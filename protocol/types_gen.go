package protocol

// GENERATED BY go run ./internal/cmd/genmarshal. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"math/big"
	"time"

	"github.com/AccumulateNetwork/accumulate/internal/encoding"
	"github.com/AccumulateNetwork/accumulate/types"
	"github.com/AccumulateNetwork/accumulate/types/state"
)

type AcmeFaucet struct {
	Url string `json:"url" form:"url" query:"url" validate:"required,acc-url"`
}

type AddCredits struct {
	Recipient string `json:"recipient" form:"recipient" query:"recipient" validate:"required"`
	Amount    uint64 `json:"amount" form:"amount" query:"amount" validate:"required"`
}

type AnonTokenAccount struct {
	state.ChainHeader
	TokenUrl      string  `json:"tokenUrl" form:"tokenUrl" query:"tokenUrl" validate:"required,acc-url"`
	Balance       big.Int `json:"balance" form:"balance" query:"balance" validate:"required"`
	TxCount       uint64  `json:"txCount" form:"txCount" query:"txCount" validate:"required"`
	Nonce         uint64  `json:"nonce" form:"nonce" query:"nonce" validate:"required"`
	CreditBalance big.Int `json:"creditBalance" form:"creditBalance" query:"creditBalance" validate:"required"`
}

type BurnTokens struct {
	Amount big.Int `json:"amount" form:"amount" query:"amount" validate:"required"`
}

type ChainParams struct {
	Data     []byte `json:"data" form:"data" query:"data" validate:"required"`
	IsUpdate bool   `json:"isUpdate" form:"isUpdate" query:"isUpdate" validate:"required"`
}

type CreateDataAccount struct {
	Url string `json:"url" form:"url" query:"url" validate:"required,acc-url"`
}

type CreateSigSpec struct {
	Url  string           `json:"url" form:"url" query:"url" validate:"required,acc-url"`
	Keys []*KeySpecParams `json:"keys" form:"keys" query:"keys" validate:"required"`
}

type CreateSigSpecGroup struct {
	Url      string     `json:"url" form:"url" query:"url" validate:"required,acc-url"`
	SigSpecs [][32]byte `json:"sigSpecs" form:"sigSpecs" query:"sigSpecs" validate:"required"`
}

type DataAccount struct {
	state.ChainHeader
	Data []byte `json:"data" form:"data" query:"data" validate:"required"`
}

type DirectoryIndexMetadata struct {
	Count uint64 `json:"count" form:"count" query:"count" validate:"required"`
}

type DirectoryQueryResult struct {
	Entries []string `json:"entries" form:"entries" query:"entries" validate:"required"`
}

type IdentityCreate struct {
	Url         string `json:"url" form:"url" query:"url" validate:"required,acc-url"`
	PublicKey   []byte `json:"publicKey" form:"publicKey" query:"publicKey" validate:"required"`
	KeyBookName string `json:"keyBookName" form:"keyBookName" query:"keyBookName"`
	KeyPageName string `json:"keyPageName" form:"keyPageName" query:"keyPageName"`
}

type IssueTokens struct {
	Recipient string  `json:"recipient" form:"recipient" query:"recipient" validate:"required,acc-url"`
	Amount    big.Int `json:"amount" form:"amount" query:"amount" validate:"required"`
}

type KeySpec struct {
	PublicKey []byte `json:"publicKey" form:"publicKey" query:"publicKey" validate:"required"`
	Nonce     uint64 `json:"nonce" form:"nonce" query:"nonce" validate:"required"`
}

type KeySpecParams struct {
	PublicKey []byte `json:"publicKey" form:"publicKey" query:"publicKey" validate:"required"`
}

type LiteDataAccount struct {
	state.ChainHeader
	Data []byte `json:"data" form:"data" query:"data" validate:"required"`
}

type MetricsRequest struct {
	Metric   string        `json:"metric" form:"metric" query:"metric" validate:"required"`
	Duration time.Duration `json:"duration" form:"duration" query:"duration" validate:"required"`
}

type MetricsResponse struct {
	Value interface{} `json:"value" form:"value" query:"value" validate:"required"`
}

type SigSpec struct {
	state.ChainHeader
	CreditBalance big.Int    `json:"creditBalance" form:"creditBalance" query:"creditBalance" validate:"required"`
	Keys          []*KeySpec `json:"keys" form:"keys" query:"keys" validate:"required"`
}

type SigSpecGroup struct {
	state.ChainHeader
	SigSpecs [][32]byte `json:"sigSpecs" form:"sigSpecs" query:"sigSpecs" validate:"required"`
}

type SyntheticBurnTokens struct {
	Amount big.Int `json:"amount" form:"amount" query:"amount" validate:"required"`
}

type SyntheticCreateChain struct {
	Cause  [32]byte      `json:"cause" form:"cause" query:"cause" validate:"required"`
	Chains []ChainParams `json:"chains" form:"chains" query:"chains" validate:"required"`
}

type SyntheticDepositCredits struct {
	Cause  [32]byte `json:"cause" form:"cause" query:"cause" validate:"required"`
	Amount uint64   `json:"amount" form:"amount" query:"amount" validate:"required"`
}

type SyntheticGenesis struct {
}

type SyntheticWriteData struct {
	Data []byte `json:"data" form:"data" query:"data" validate:"required"`
}

type TokenAccountCreate struct {
	Url        string `json:"url" form:"url" query:"url" validate:"required,acc-url"`
	TokenUrl   string `json:"tokenUrl" form:"tokenUrl" query:"tokenUrl" validate:"required,acc-url"`
	KeyBookUrl string `json:"keyBookUrl" form:"keyBookUrl" query:"keyBookUrl" validate:"required,acc-url"`
}

type TxResult struct {
	SyntheticTxs []*TxSynthRef `json:"syntheticTxs" form:"syntheticTxs" query:"syntheticTxs" validate:"required"`
}

type TxSynthRef struct {
	Type  uint64   `json:"type" form:"type" query:"type" validate:"required"`
	Hash  [32]byte `json:"hash" form:"hash" query:"hash" validate:"required"`
	Url   string   `json:"url" form:"url" query:"url" validate:"required,acc-url"`
	TxRef [32]byte `json:"txRef" form:"txRef" query:"txRef" validate:"required"`
}

type UpdateKeyPage struct {
	Operation KeyPageOperation `json:"operation" form:"operation" query:"operation" validate:"required"`
	Key       []byte           `json:"key" form:"key" query:"key" validate:"required"`
	NewKey    []byte           `json:"newKey" form:"newKey" query:"newKey" validate:"required"`
}

type WriteData struct {
	Data []byte `json:"data" form:"data" query:"data" validate:"required"`
}

type WriteDataTo struct {
	Recipient string `json:"recipient" form:"recipient" query:"recipient" validate:"required,acc-url"`
	Data      []byte `json:"data" form:"data" query:"data" validate:"required"`
}

func NewAnonTokenAccount() *AnonTokenAccount {
	v := new(AnonTokenAccount)
	v.Type = types.ChainTypeLiteTokenAccount
	return v
}

func NewDataAccount() *DataAccount {
	v := new(DataAccount)
	v.Type = types.ChainTypeDataAccount
	return v
}

func NewLiteDataAccount() *LiteDataAccount {
	v := new(LiteDataAccount)
	v.Type = types.ChainTypeLiteDataAccount
	return v
}

func NewSigSpec() *SigSpec {
	v := new(SigSpec)
	v.Type = types.ChainTypeKeyPage
	return v
}

func NewSigSpecGroup() *SigSpecGroup {
	v := new(SigSpecGroup)
	v.Type = types.ChainTypeKeyBook
	return v
}

func (*AcmeFaucet) GetType() types.TransactionType { return types.TxTypeAcmeFaucet }

func (*AddCredits) GetType() types.TransactionType { return types.TxTypeAddCredits }

func (*BurnTokens) GetType() types.TransactionType { return types.TxTypeBurnTokens }

func (*CreateDataAccount) GetType() types.TransactionType { return types.TxTypeCreateDataAccount }

func (*CreateSigSpec) GetType() types.TransactionType { return types.TxTypeCreateKeyPage }

func (*CreateSigSpecGroup) GetType() types.TransactionType { return types.TxTypeCreateKeyBook }

func (*IdentityCreate) GetType() types.TransactionType { return types.TxTypeCreateIdentity }

func (*IssueTokens) GetType() types.TransactionType { return types.TxTypeIssueTokens }

func (*SyntheticBurnTokens) GetType() types.TransactionType { return types.TxTypeSyntheticBurnTokens }

func (*SyntheticCreateChain) GetType() types.TransactionType { return types.TxTypeSyntheticCreateChain }

func (*SyntheticDepositCredits) GetType() types.TransactionType {
	return types.TxTypeSyntheticDepositCredits
}

func (*SyntheticGenesis) GetType() types.TransactionType { return types.TxTypeSyntheticGenesis }

func (*SyntheticWriteData) GetType() types.TransactionType { return types.TxTypeSyntheticWriteData }

func (*TokenAccountCreate) GetType() types.TransactionType { return types.TxTypeCreateTokenAccount }

func (*UpdateKeyPage) GetType() types.TransactionType { return types.TxTypeUpdateKeyPage }

func (*WriteData) GetType() types.TransactionType { return types.TxTypeWriteData }

func (*WriteDataTo) GetType() types.TransactionType { return types.TxTypeWriteDataTo }

func (v *AcmeFaucet) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeAcmeFaucet.ID())

	n += encoding.StringBinarySize(v.Url)

	return n
}

func (v *AddCredits) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeAddCredits.ID())

	n += encoding.StringBinarySize(v.Recipient)

	n += encoding.UvarintBinarySize(v.Amount)

	return n
}

func (v *AnonTokenAccount) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = types.ChainTypeLiteTokenAccount

	n += v.ChainHeader.GetHeaderSize()

	n += encoding.StringBinarySize(v.TokenUrl)

	n += encoding.BigintBinarySize(&v.Balance)

	n += encoding.UvarintBinarySize(v.TxCount)

	n += encoding.UvarintBinarySize(v.Nonce)

	n += encoding.BigintBinarySize(&v.CreditBalance)

	return n
}

func (v *BurnTokens) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeBurnTokens.ID())

	n += encoding.BigintBinarySize(&v.Amount)

	return n
}

func (v *ChainParams) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.Data)

	n += encoding.BoolBinarySize(v.IsUpdate)

	return n
}

func (v *CreateDataAccount) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeCreateDataAccount.ID())

	n += encoding.StringBinarySize(v.Url)

	return n
}

func (v *CreateSigSpec) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeCreateKeyPage.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.UvarintBinarySize(uint64(len(v.Keys)))

	for _, v := range v.Keys {
		n += v.BinarySize()

	}

	return n
}

func (v *CreateSigSpecGroup) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeCreateKeyBook.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.ChainSetBinarySize(v.SigSpecs)

	return n
}

func (v *DataAccount) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = types.ChainTypeDataAccount

	n += v.ChainHeader.GetHeaderSize()

	n += encoding.BytesBinarySize(v.Data)

	return n
}

func (v *DirectoryIndexMetadata) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(v.Count)

	return n
}

func (v *DirectoryQueryResult) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(uint64(len(v.Entries)))

	for _, v := range v.Entries {
		n += encoding.StringBinarySize(v)

	}

	return n
}

func (v *IdentityCreate) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeCreateIdentity.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.BytesBinarySize(v.PublicKey)

	n += encoding.StringBinarySize(v.KeyBookName)

	n += encoding.StringBinarySize(v.KeyPageName)

	return n
}

func (v *IssueTokens) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeIssueTokens.ID())

	n += encoding.StringBinarySize(v.Recipient)

	n += encoding.BigintBinarySize(&v.Amount)

	return n
}

func (v *KeySpec) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.PublicKey)

	n += encoding.UvarintBinarySize(v.Nonce)

	return n
}

func (v *KeySpecParams) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.PublicKey)

	return n
}

func (v *LiteDataAccount) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = types.ChainTypeLiteDataAccount

	n += v.ChainHeader.GetHeaderSize()

	n += encoding.BytesBinarySize(v.Data)

	return n
}

func (v *MetricsRequest) BinarySize() int {
	var n int

	n += encoding.StringBinarySize(v.Metric)

	n += encoding.DurationBinarySize(v.Duration)

	return n
}

func (v *SigSpec) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = types.ChainTypeKeyPage

	n += v.ChainHeader.GetHeaderSize()

	n += encoding.BigintBinarySize(&v.CreditBalance)

	n += encoding.UvarintBinarySize(uint64(len(v.Keys)))

	for _, v := range v.Keys {
		n += v.BinarySize()

	}

	return n
}

func (v *SigSpecGroup) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = types.ChainTypeKeyBook

	n += v.ChainHeader.GetHeaderSize()

	n += encoding.ChainSetBinarySize(v.SigSpecs)

	return n
}

func (v *SyntheticBurnTokens) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeSyntheticBurnTokens.ID())

	n += encoding.BigintBinarySize(&v.Amount)

	return n
}

func (v *SyntheticCreateChain) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeSyntheticCreateChain.ID())

	n += encoding.ChainBinarySize(&v.Cause)

	n += encoding.UvarintBinarySize(uint64(len(v.Chains)))

	for _, v := range v.Chains {
		n += v.BinarySize()

	}

	return n
}

func (v *SyntheticDepositCredits) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeSyntheticDepositCredits.ID())

	n += encoding.ChainBinarySize(&v.Cause)

	n += encoding.UvarintBinarySize(v.Amount)

	return n
}

func (v *SyntheticGenesis) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeSyntheticGenesis.ID())

	return n
}

func (v *SyntheticWriteData) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeSyntheticWriteData.ID())

	n += encoding.BytesBinarySize(v.Data)

	return n
}

func (v *TokenAccountCreate) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeCreateTokenAccount.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.StringBinarySize(v.TokenUrl)

	n += encoding.StringBinarySize(v.KeyBookUrl)

	return n
}

func (v *TxResult) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(uint64(len(v.SyntheticTxs)))

	for _, v := range v.SyntheticTxs {
		n += v.BinarySize()

	}

	return n
}

func (v *TxSynthRef) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(v.Type)

	n += encoding.ChainBinarySize(&v.Hash)

	n += encoding.StringBinarySize(v.Url)

	n += encoding.ChainBinarySize(&v.TxRef)

	return n
}

func (v *UpdateKeyPage) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeUpdateKeyPage.ID())

	n += v.Operation.BinarySize()

	n += encoding.BytesBinarySize(v.Key)

	n += encoding.BytesBinarySize(v.NewKey)

	return n
}

func (v *WriteData) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeWriteData.ID())

	n += encoding.BytesBinarySize(v.Data)

	return n
}

func (v *WriteDataTo) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeWriteDataTo.ID())

	n += encoding.StringBinarySize(v.Recipient)

	n += encoding.BytesBinarySize(v.Data)

	return n
}

func (v *AcmeFaucet) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeAcmeFaucet.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	return buffer.Bytes(), nil
}

func (v *AddCredits) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeAddCredits.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Recipient))

	buffer.Write(encoding.UvarintMarshalBinary(v.Amount))

	return buffer.Bytes(), nil
}

func (v *AnonTokenAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = types.ChainTypeLiteTokenAccount

	if b, err := v.ChainHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.StringMarshalBinary(v.TokenUrl))

	buffer.Write(encoding.BigintMarshalBinary(&v.Balance))

	buffer.Write(encoding.UvarintMarshalBinary(v.TxCount))

	buffer.Write(encoding.UvarintMarshalBinary(v.Nonce))

	buffer.Write(encoding.BigintMarshalBinary(&v.CreditBalance))

	return buffer.Bytes(), nil
}

func (v *BurnTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeBurnTokens.ID()))

	buffer.Write(encoding.BigintMarshalBinary(&v.Amount))

	return buffer.Bytes(), nil
}

func (v *ChainParams) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.Data))

	buffer.Write(encoding.BoolMarshalBinary(v.IsUpdate))

	return buffer.Bytes(), nil
}

func (v *CreateDataAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateDataAccount.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	return buffer.Bytes(), nil
}

func (v *CreateSigSpec) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateKeyPage.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Keys))))
	for i, v := range v.Keys {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Keys[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *CreateSigSpecGroup) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateKeyBook.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.ChainSetMarshalBinary(v.SigSpecs))

	return buffer.Bytes(), nil
}

func (v *DataAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = types.ChainTypeDataAccount

	if b, err := v.ChainHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.BytesMarshalBinary(v.Data))

	return buffer.Bytes(), nil
}

func (v *DirectoryIndexMetadata) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(v.Count))

	return buffer.Bytes(), nil
}

func (v *DirectoryQueryResult) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Entries))))
	for i, v := range v.Entries {
		_ = i
		buffer.Write(encoding.StringMarshalBinary(v))

	}

	return buffer.Bytes(), nil
}

func (v *IdentityCreate) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateIdentity.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))

	buffer.Write(encoding.StringMarshalBinary(v.KeyBookName))

	buffer.Write(encoding.StringMarshalBinary(v.KeyPageName))

	return buffer.Bytes(), nil
}

func (v *IssueTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeIssueTokens.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Recipient))

	buffer.Write(encoding.BigintMarshalBinary(&v.Amount))

	return buffer.Bytes(), nil
}

func (v *KeySpec) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))

	buffer.Write(encoding.UvarintMarshalBinary(v.Nonce))

	return buffer.Bytes(), nil
}

func (v *KeySpecParams) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))

	return buffer.Bytes(), nil
}

func (v *LiteDataAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = types.ChainTypeLiteDataAccount

	if b, err := v.ChainHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.BytesMarshalBinary(v.Data))

	return buffer.Bytes(), nil
}

func (v *MetricsRequest) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.StringMarshalBinary(v.Metric))

	buffer.Write(encoding.DurationMarshalBinary(v.Duration))

	return buffer.Bytes(), nil
}

func (v *SigSpec) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = types.ChainTypeKeyPage

	if b, err := v.ChainHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.BigintMarshalBinary(&v.CreditBalance))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Keys))))
	for i, v := range v.Keys {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Keys[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *SigSpecGroup) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = types.ChainTypeKeyBook

	if b, err := v.ChainHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.ChainSetMarshalBinary(v.SigSpecs))

	return buffer.Bytes(), nil
}

func (v *SyntheticBurnTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticBurnTokens.ID()))

	buffer.Write(encoding.BigintMarshalBinary(&v.Amount))

	return buffer.Bytes(), nil
}

func (v *SyntheticCreateChain) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticCreateChain.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Cause))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Chains))))
	for i, v := range v.Chains {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Chains[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *SyntheticDepositCredits) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticDepositCredits.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Cause))

	buffer.Write(encoding.UvarintMarshalBinary(v.Amount))

	return buffer.Bytes(), nil
}

func (v *SyntheticGenesis) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticGenesis.ID()))

	return buffer.Bytes(), nil
}

func (v *SyntheticWriteData) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticWriteData.ID()))

	buffer.Write(encoding.BytesMarshalBinary(v.Data))

	return buffer.Bytes(), nil
}

func (v *TokenAccountCreate) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateTokenAccount.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.StringMarshalBinary(v.TokenUrl))

	buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))

	return buffer.Bytes(), nil
}

func (v *TxResult) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.SyntheticTxs))))
	for i, v := range v.SyntheticTxs {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding SyntheticTxs[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *TxSynthRef) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(v.Type))

	buffer.Write(encoding.ChainMarshalBinary(&v.Hash))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.ChainMarshalBinary(&v.TxRef))

	return buffer.Bytes(), nil
}

func (v *UpdateKeyPage) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeUpdateKeyPage.ID()))

	if b, err := v.Operation.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Operation: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.BytesMarshalBinary(v.Key))

	buffer.Write(encoding.BytesMarshalBinary(v.NewKey))

	return buffer.Bytes(), nil
}

func (v *WriteData) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeWriteData.ID()))

	buffer.Write(encoding.BytesMarshalBinary(v.Data))

	return buffer.Bytes(), nil
}

func (v *WriteDataTo) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeWriteDataTo.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Recipient))

	buffer.Write(encoding.BytesMarshalBinary(v.Data))

	return buffer.Bytes(), nil
}

func (v *AcmeFaucet) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeAcmeFaucet
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	return nil
}

func (v *AddCredits) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeAddCredits
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Recipient: %w", err)
	} else {
		v.Recipient = x
	}
	data = data[encoding.StringBinarySize(v.Recipient):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = x
	}
	data = data[encoding.UvarintBinarySize(v.Amount):]

	return nil
}

func (v *AnonTokenAccount) UnmarshalBinary(data []byte) error {
	typ := types.ChainTypeLiteTokenAccount
	if err := v.ChainHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid chain type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TokenUrl: %w", err)
	} else {
		v.TokenUrl = x
	}
	data = data[encoding.StringBinarySize(v.TokenUrl):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Balance):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TxCount: %w", err)
	} else {
		v.TxCount = x
	}
	data = data[encoding.UvarintBinarySize(v.TxCount):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Nonce: %w", err)
	} else {
		v.Nonce = x
	}
	data = data[encoding.UvarintBinarySize(v.Nonce):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding CreditBalance: %w", err)
	} else {
		v.CreditBalance.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.CreditBalance):]

	return nil
}

func (v *BurnTokens) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeBurnTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Amount):]

	return nil
}

func (v *ChainParams) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	data = data[encoding.BytesBinarySize(v.Data):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding IsUpdate: %w", err)
	} else {
		v.IsUpdate = x
	}
	data = data[encoding.BoolBinarySize(v.IsUpdate):]

	return nil
}

func (v *CreateDataAccount) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateDataAccount
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	return nil
}

func (v *CreateSigSpec) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateKeyPage
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	var lenKeys uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Keys: %w", err)
	} else {
		lenKeys = x
	}
	data = data[encoding.UvarintBinarySize(lenKeys):]

	v.Keys = make([]*KeySpecParams, lenKeys)
	for i := range v.Keys {
		x := new(KeySpecParams)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Keys[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.Keys[i] = x
	}

	return nil
}

func (v *CreateSigSpecGroup) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateKeyBook
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.ChainSetUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SigSpecs: %w", err)
	} else {
		v.SigSpecs = x
	}
	data = data[encoding.ChainSetBinarySize(v.SigSpecs):]

	return nil
}

func (v *DataAccount) UnmarshalBinary(data []byte) error {
	typ := types.ChainTypeDataAccount
	if err := v.ChainHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid chain type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	data = data[encoding.BytesBinarySize(v.Data):]

	return nil
}

func (v *DirectoryIndexMetadata) UnmarshalBinary(data []byte) error {
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Count: %w", err)
	} else {
		v.Count = x
	}
	data = data[encoding.UvarintBinarySize(v.Count):]

	return nil
}

func (v *DirectoryQueryResult) UnmarshalBinary(data []byte) error {
	var lenEntries uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entries: %w", err)
	} else {
		lenEntries = x
	}
	data = data[encoding.UvarintBinarySize(lenEntries):]

	v.Entries = make([]string, lenEntries)
	for i := range v.Entries {
		if x, err := encoding.StringUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Entries[%d]: %w", i, err)
		} else {
			v.Entries[i] = x
		}
		data = data[encoding.StringBinarySize(v.Entries[i]):]

	}

	return nil
}

func (v *IdentityCreate) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateIdentity
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	data = data[encoding.BytesBinarySize(v.PublicKey):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyBookName: %w", err)
	} else {
		v.KeyBookName = x
	}
	data = data[encoding.StringBinarySize(v.KeyBookName):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyPageName: %w", err)
	} else {
		v.KeyPageName = x
	}
	data = data[encoding.StringBinarySize(v.KeyPageName):]

	return nil
}

func (v *IssueTokens) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeIssueTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Recipient: %w", err)
	} else {
		v.Recipient = x
	}
	data = data[encoding.StringBinarySize(v.Recipient):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Amount):]

	return nil
}

func (v *KeySpec) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	data = data[encoding.BytesBinarySize(v.PublicKey):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Nonce: %w", err)
	} else {
		v.Nonce = x
	}
	data = data[encoding.UvarintBinarySize(v.Nonce):]

	return nil
}

func (v *KeySpecParams) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	data = data[encoding.BytesBinarySize(v.PublicKey):]

	return nil
}

func (v *LiteDataAccount) UnmarshalBinary(data []byte) error {
	typ := types.ChainTypeLiteDataAccount
	if err := v.ChainHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid chain type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	data = data[encoding.BytesBinarySize(v.Data):]

	return nil
}

func (v *MetricsRequest) UnmarshalBinary(data []byte) error {
	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Metric: %w", err)
	} else {
		v.Metric = x
	}
	data = data[encoding.StringBinarySize(v.Metric):]

	if x, err := encoding.DurationUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Duration: %w", err)
	} else {
		v.Duration = x
	}
	data = data[encoding.DurationBinarySize(v.Duration):]

	return nil
}

func (v *SigSpec) UnmarshalBinary(data []byte) error {
	typ := types.ChainTypeKeyPage
	if err := v.ChainHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid chain type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding CreditBalance: %w", err)
	} else {
		v.CreditBalance.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.CreditBalance):]

	var lenKeys uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Keys: %w", err)
	} else {
		lenKeys = x
	}
	data = data[encoding.UvarintBinarySize(lenKeys):]

	v.Keys = make([]*KeySpec, lenKeys)
	for i := range v.Keys {
		x := new(KeySpec)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Keys[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.Keys[i] = x
	}

	return nil
}

func (v *SigSpecGroup) UnmarshalBinary(data []byte) error {
	typ := types.ChainTypeKeyBook
	if err := v.ChainHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid chain type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.ChainSetUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SigSpecs: %w", err)
	} else {
		v.SigSpecs = x
	}
	data = data[encoding.ChainSetBinarySize(v.SigSpecs):]

	return nil
}

func (v *SyntheticBurnTokens) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticBurnTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Amount):]

	return nil
}

func (v *SyntheticCreateChain) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticCreateChain
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	data = data[encoding.ChainBinarySize(&v.Cause):]

	var lenChains uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Chains: %w", err)
	} else {
		lenChains = x
	}
	data = data[encoding.UvarintBinarySize(lenChains):]

	v.Chains = make([]ChainParams, lenChains)
	for i := range v.Chains {
		if err := v.Chains[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Chains[%d]: %w", i, err)
		}
		data = data[v.Chains[i].BinarySize():]

	}

	return nil
}

func (v *SyntheticDepositCredits) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticDepositCredits
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	data = data[encoding.ChainBinarySize(&v.Cause):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = x
	}
	data = data[encoding.UvarintBinarySize(v.Amount):]

	return nil
}

func (v *SyntheticGenesis) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticGenesis
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	return nil
}

func (v *SyntheticWriteData) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	data = data[encoding.BytesBinarySize(v.Data):]

	return nil
}

func (v *TokenAccountCreate) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateTokenAccount
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TokenUrl: %w", err)
	} else {
		v.TokenUrl = x
	}
	data = data[encoding.StringBinarySize(v.TokenUrl):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyBookUrl: %w", err)
	} else {
		v.KeyBookUrl = x
	}
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]

	return nil
}

func (v *TxResult) UnmarshalBinary(data []byte) error {
	var lenSyntheticTxs uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SyntheticTxs: %w", err)
	} else {
		lenSyntheticTxs = x
	}
	data = data[encoding.UvarintBinarySize(lenSyntheticTxs):]

	v.SyntheticTxs = make([]*TxSynthRef, lenSyntheticTxs)
	for i := range v.SyntheticTxs {
		x := new(TxSynthRef)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding SyntheticTxs[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.SyntheticTxs[i] = x
	}

	return nil
}

func (v *TxSynthRef) UnmarshalBinary(data []byte) error {
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Type: %w", err)
	} else {
		v.Type = x
	}
	data = data[encoding.UvarintBinarySize(v.Type):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	data = data[encoding.ChainBinarySize(&v.Hash):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TxRef: %w", err)
	} else {
		v.TxRef = x
	}
	data = data[encoding.ChainBinarySize(&v.TxRef):]

	return nil
}

func (v *UpdateKeyPage) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeUpdateKeyPage
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if err := v.Operation.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Operation: %w", err)
	}
	data = data[v.Operation.BinarySize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	data = data[encoding.BytesBinarySize(v.Key):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding NewKey: %w", err)
	} else {
		v.NewKey = x
	}
	data = data[encoding.BytesBinarySize(v.NewKey):]

	return nil
}

func (v *WriteData) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	data = data[encoding.BytesBinarySize(v.Data):]

	return nil
}

func (v *WriteDataTo) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeWriteDataTo
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Recipient: %w", err)
	} else {
		v.Recipient = x
	}
	data = data[encoding.StringBinarySize(v.Recipient):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	data = data[encoding.BytesBinarySize(v.Data):]

	return nil
}

func (v *ChainParams) MarshalJSON() ([]byte, error) {
	var u struct {
		Data     string `json:"data"`
		IsUpdate bool   `json:"isUpdate"`
	}
	u.Data = encoding.BytesToJSON(v.Data)
	u.IsUpdate = v.IsUpdate
	return json.Marshal(&u)
}

func (v *CreateSigSpecGroup) MarshalJSON() ([]byte, error) {
	var u struct {
		Url      string   `json:"url"`
		SigSpecs []string `json:"sigSpecs"`
	}
	u.Url = v.Url
	u.SigSpecs = encoding.ChainSetToJSON(v.SigSpecs)
	return json.Marshal(&u)
}

func (v *DataAccount) MarshalJSON() ([]byte, error) {
	var u struct {
		state.ChainHeader
		Data string `json:"data"`
	}
	u.ChainHeader = v.ChainHeader
	u.Data = encoding.BytesToJSON(v.Data)
	return json.Marshal(&u)
}

func (v *IdentityCreate) MarshalJSON() ([]byte, error) {
	var u struct {
		Url         string `json:"url"`
		PublicKey   string `json:"publicKey"`
		KeyBookName string `json:"keyBookName"`
		KeyPageName string `json:"keyPageName"`
	}
	u.Url = v.Url
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.KeyBookName = v.KeyBookName
	u.KeyPageName = v.KeyPageName
	return json.Marshal(&u)
}

func (v *KeySpec) MarshalJSON() ([]byte, error) {
	var u struct {
		PublicKey string `json:"publicKey"`
		Nonce     uint64 `json:"nonce"`
	}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Nonce = v.Nonce
	return json.Marshal(&u)
}

func (v *KeySpecParams) MarshalJSON() ([]byte, error) {
	var u struct {
		PublicKey string `json:"publicKey"`
	}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	return json.Marshal(&u)
}

func (v *LiteDataAccount) MarshalJSON() ([]byte, error) {
	var u struct {
		state.ChainHeader
		Data string `json:"data"`
	}
	u.ChainHeader = v.ChainHeader
	u.Data = encoding.BytesToJSON(v.Data)
	return json.Marshal(&u)
}

func (v *MetricsRequest) MarshalJSON() ([]byte, error) {
	var u struct {
		Metric   string      `json:"metric"`
		Duration interface{} `json:"duration"`
	}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	return json.Marshal(&u)
}

func (v *SigSpecGroup) MarshalJSON() ([]byte, error) {
	var u struct {
		state.ChainHeader
		SigSpecs []string `json:"sigSpecs"`
	}
	u.ChainHeader = v.ChainHeader
	u.SigSpecs = encoding.ChainSetToJSON(v.SigSpecs)
	return json.Marshal(&u)
}

func (v *SyntheticCreateChain) MarshalJSON() ([]byte, error) {
	var u struct {
		Cause  string        `json:"cause"`
		Chains []ChainParams `json:"chains"`
	}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Chains = v.Chains
	return json.Marshal(&u)
}

func (v *SyntheticDepositCredits) MarshalJSON() ([]byte, error) {
	var u struct {
		Cause  string `json:"cause"`
		Amount uint64 `json:"amount"`
	}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Amount = v.Amount
	return json.Marshal(&u)
}

func (v *SyntheticWriteData) MarshalJSON() ([]byte, error) {
	var u struct {
		Data string `json:"data"`
	}
	u.Data = encoding.BytesToJSON(v.Data)
	return json.Marshal(&u)
}

func (v *TxSynthRef) MarshalJSON() ([]byte, error) {
	var u struct {
		Type  uint64 `json:"type"`
		Hash  string `json:"hash"`
		Url   string `json:"url"`
		TxRef string `json:"txRef"`
	}
	u.Type = v.Type
	u.Hash = encoding.ChainToJSON(v.Hash)
	u.Url = v.Url
	u.TxRef = encoding.ChainToJSON(v.TxRef)
	return json.Marshal(&u)
}

func (v *UpdateKeyPage) MarshalJSON() ([]byte, error) {
	var u struct {
		Operation KeyPageOperation `json:"operation"`
		Key       string           `json:"key"`
		NewKey    string           `json:"newKey"`
	}
	u.Operation = v.Operation
	u.Key = encoding.BytesToJSON(v.Key)
	u.NewKey = encoding.BytesToJSON(v.NewKey)
	return json.Marshal(&u)
}

func (v *WriteData) MarshalJSON() ([]byte, error) {
	var u struct {
		Data string `json:"data"`
	}
	u.Data = encoding.BytesToJSON(v.Data)
	return json.Marshal(&u)
}

func (v *WriteDataTo) MarshalJSON() ([]byte, error) {
	var u struct {
		Recipient string `json:"recipient"`
		Data      string `json:"data"`
	}
	u.Recipient = v.Recipient
	u.Data = encoding.BytesToJSON(v.Data)
	return json.Marshal(&u)
}

func (v *ChainParams) UnmarshalJSON(data []byte) error {
	var u struct {
		Data     string `json:"data"`
		IsUpdate bool   `json:"isUpdate"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	v.IsUpdate = u.IsUpdate
	return nil
}

func (v *CreateSigSpecGroup) UnmarshalJSON(data []byte) error {
	var u struct {
		Url      string   `json:"url"`
		SigSpecs []string `json:"sigSpecs"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.ChainSetFromJSON(u.SigSpecs); err != nil {
		return fmt.Errorf("error decoding SigSpecs: %w", err)
	} else {
		v.SigSpecs = x
	}
	return nil
}

func (v *DataAccount) UnmarshalJSON(data []byte) error {
	var u struct {
		state.ChainHeader
		Data string `json:"data"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ChainHeader = u.ChainHeader
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	return nil
}

func (v *IdentityCreate) UnmarshalJSON(data []byte) error {
	var u struct {
		Url         string `json:"url"`
		PublicKey   string `json:"publicKey"`
		KeyBookName string `json:"keyBookName"`
		KeyPageName string `json:"keyPageName"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	v.KeyBookName = u.KeyBookName
	v.KeyPageName = u.KeyPageName
	return nil
}

func (v *KeySpec) UnmarshalJSON(data []byte) error {
	var u struct {
		PublicKey string `json:"publicKey"`
		Nonce     uint64 `json:"nonce"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	v.Nonce = u.Nonce
	return nil
}

func (v *KeySpecParams) UnmarshalJSON(data []byte) error {
	var u struct {
		PublicKey string `json:"publicKey"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	return nil
}

func (v *LiteDataAccount) UnmarshalJSON(data []byte) error {
	var u struct {
		state.ChainHeader
		Data string `json:"data"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ChainHeader = u.ChainHeader
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	return nil
}

func (v *MetricsRequest) UnmarshalJSON(data []byte) error {
	var u struct {
		Metric   string      `json:"metric"`
		Duration interface{} `json:"duration"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Metric = u.Metric
	if x, err := encoding.DurationFromJSON(u.Duration); err != nil {
		return fmt.Errorf("error decoding Duration: %w", err)
	} else {
		v.Duration = x
	}
	return nil
}

func (v *SigSpecGroup) UnmarshalJSON(data []byte) error {
	var u struct {
		state.ChainHeader
		SigSpecs []string `json:"sigSpecs"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ChainHeader = u.ChainHeader
	if x, err := encoding.ChainSetFromJSON(u.SigSpecs); err != nil {
		return fmt.Errorf("error decoding SigSpecs: %w", err)
	} else {
		v.SigSpecs = x
	}
	return nil
}

func (v *SyntheticCreateChain) UnmarshalJSON(data []byte) error {
	var u struct {
		Cause  string        `json:"cause"`
		Chains []ChainParams `json:"chains"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	v.Chains = u.Chains
	return nil
}

func (v *SyntheticDepositCredits) UnmarshalJSON(data []byte) error {
	var u struct {
		Cause  string `json:"cause"`
		Amount uint64 `json:"amount"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	v.Amount = u.Amount
	return nil
}

func (v *SyntheticWriteData) UnmarshalJSON(data []byte) error {
	var u struct {
		Data string `json:"data"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	return nil
}

func (v *TxSynthRef) UnmarshalJSON(data []byte) error {
	var u struct {
		Type  uint64 `json:"type"`
		Hash  string `json:"hash"`
		Url   string `json:"url"`
		TxRef string `json:"txRef"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	v.Url = u.Url
	if x, err := encoding.ChainFromJSON(u.TxRef); err != nil {
		return fmt.Errorf("error decoding TxRef: %w", err)
	} else {
		v.TxRef = x
	}
	return nil
}

func (v *UpdateKeyPage) UnmarshalJSON(data []byte) error {
	var u struct {
		Operation KeyPageOperation `json:"operation"`
		Key       string           `json:"key"`
		NewKey    string           `json:"newKey"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Operation = u.Operation
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	if x, err := encoding.BytesFromJSON(u.NewKey); err != nil {
		return fmt.Errorf("error decoding NewKey: %w", err)
	} else {
		v.NewKey = x
	}
	return nil
}

func (v *WriteData) UnmarshalJSON(data []byte) error {
	var u struct {
		Data string `json:"data"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	return nil
}

func (v *WriteDataTo) UnmarshalJSON(data []byte) error {
	var u struct {
		Recipient string `json:"recipient"`
		Data      string `json:"data"`
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Recipient = u.Recipient
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	return nil
}
