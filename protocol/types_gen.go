// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package protocol

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"strings"
	"time"

	errors2 "gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
)

type ADI struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	extraData []byte
}

type AccountAuth struct {
	fieldsSet   []bool
	Authorities []AuthorityEntry `json:"authorities,omitempty" form:"authorities" query:"authorities" validate:"required"`
	extraData   []byte
}

type AccumulateDataEntry struct {
	fieldsSet []bool
	Data      [][]byte `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	extraData []byte
}

type AcmeFaucet struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	extraData []byte
}

type AcmeOracle struct {
	fieldsSet []bool
	Price     uint64 `json:"price,omitempty" form:"price" query:"price" validate:"required"`
	extraData []byte
}

type ActivateProtocolVersion struct {
	fieldsSet []bool
	Version   ExecutorVersion `json:"version,omitempty" form:"version" query:"version"`
	extraData []byte
}

type AddAccountAuthorityOperation struct {
	fieldsSet []bool
	// Authority is the authority to add.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	extraData []byte
}

type AddCredits struct {
	fieldsSet []bool
	Recipient *url.URL `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	Amount    big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	Oracle    uint64   `json:"oracle,omitempty" form:"oracle" query:"oracle"`
	extraData []byte
}

type AddCreditsResult struct {
	fieldsSet []bool
	Amount    big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	Credits   uint64  `json:"credits,omitempty" form:"credits" query:"credits" validate:"required"`
	Oracle    uint64  `json:"oracle,omitempty" form:"oracle" query:"oracle" validate:"required"`
	extraData []byte
}

type AddKeyOperation struct {
	fieldsSet []bool
	Entry     KeySpecParams `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData []byte
}

type AnchorLedger struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	// MinorBlockSequenceNumber is the sequence number of the last minor block.
	MinorBlockSequenceNumber uint64 `json:"minorBlockSequenceNumber,omitempty" form:"minorBlockSequenceNumber" query:"minorBlockSequenceNumber" validate:"required"`
	// MajorBlockIndex is the block index of the last major block.
	MajorBlockIndex uint64 `json:"majorBlockIndex,omitempty" form:"majorBlockIndex" query:"majorBlockIndex" validate:"required"`
	// MajorBlockTime is the timestamp of the last major block.
	MajorBlockTime time.Time `json:"majorBlockTime,omitempty" form:"majorBlockTime" query:"majorBlockTime" validate:"required"`
	// PendingMajorBlockAnchors is the list of partitions that have joined the open major block. If there is no open major block, this is unset.
	PendingMajorBlockAnchors []*url.URL `json:"pendingMajorBlockAnchors,omitempty" form:"pendingMajorBlockAnchors" query:"pendingMajorBlockAnchors" validate:"required"`
	// Sequence tracks sent and received anchors.
	Sequence  []*PartitionSyntheticLedger `json:"sequence,omitempty" form:"sequence" query:"sequence" validate:"required"`
	extraData []byte
}

type AnchorMetadata struct {
	fieldsSet []bool
	ChainMetadata
	Account     *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Index       uint64   `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	SourceIndex uint64   `json:"sourceIndex,omitempty" form:"sourceIndex" query:"sourceIndex" validate:"required"`
	SourceBlock uint64   `json:"sourceBlock,omitempty" form:"sourceBlock" query:"sourceBlock" validate:"required"`
	Entry       []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData   []byte
}

// AnnotatedReceipt is a [merkle.Receipt] annotated with the account and chain it originates from.
type AnnotatedReceipt struct {
	fieldsSet []bool
	Receipt   *merkle.Receipt `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	Anchor    *AnchorMetadata `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	extraData []byte
}

type AuthorityEntry struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	// Disabled disables auth checks for this authority, allowing anyone to sign for it.
	Disabled  bool `json:"disabled,omitempty" form:"disabled" query:"disabled" validate:"required"`
	extraData []byte
}

// AuthoritySignature is a signature produced by an authority.
type AuthoritySignature struct {
	fieldsSet []bool
	// Signer is the signer that produced this signature.
	Signer *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	// Authority is the authority that produced this signature.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	// Vote is the authority's vote.
	Vote VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
	// TxID is the ID of the transaction this was produced for.
	TxID      *url.TxID  `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Delegator []*url.URL `json:"delegator,omitempty" form:"delegator" query:"delegator" validate:"required"`
	extraData []byte
}

type BTCLegacySignature struct {
	fieldsSet       []bool
	PublicKey       []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature       []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer          *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion   uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Timestamp       uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp"`
	Vote            VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	extraData       []byte
}

type BTCSignature struct {
	fieldsSet       []bool
	PublicKey       []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature       []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer          *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion   uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Timestamp       uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp"`
	Vote            VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	extraData       []byte
}

type BlockEntry struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Chain     string   `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	Index     uint64   `json:"index" form:"index" query:"index" validate:"required"`
	extraData []byte
}

type BlockLedger struct {
	fieldsSet []bool
	Url       *url.URL      `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Index     uint64        `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Time      time.Time     `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	Entries   []*BlockEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type BlockValidatorAnchor struct {
	fieldsSet []bool
	PartitionAnchor
	// AcmeBurnt is the amount of acme tokens burnt in the transaction.
	AcmeBurnt big.Int `json:"acmeBurnt,omitempty" form:"acmeBurnt" query:"acmeBurnt" validate:"required"`
	extraData []byte
}

type BurnTokens struct {
	fieldsSet []bool
	Amount    big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	extraData []byte
}

type ChainMetadata struct {
	fieldsSet []bool
	Name      string    `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	extraData []byte
}

type ChainParams struct {
	fieldsSet []bool
	Data      []byte `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	IsUpdate  bool   `json:"isUpdate,omitempty" form:"isUpdate" query:"isUpdate" validate:"required"`
	extraData []byte
}

type CreateDataAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	// Authorities is a list of authorities to add to the authority set.
	Authorities []*url.URL `json:"authorities,omitempty" form:"authorities" query:"authorities"`
	extraData   []byte
}

type CreateIdentity struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	KeyHash   []byte   `json:"keyHash,omitempty" form:"keyHash" query:"keyHash"`
	// KeyBookUrl creates a new key book.
	KeyBookUrl *url.URL `json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl"`
	// Authorities is a list of authorities to add to the authority set, in addition to the new key book.
	Authorities []*url.URL `json:"authorities,omitempty" form:"authorities" query:"authorities"`
	extraData   []byte
}

type CreateKeyBook struct {
	fieldsSet     []bool
	Url           *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	PublicKeyHash []byte   `json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	// Authorities is a list of authorities to add to the authority set, in addition to the key book itself.
	Authorities []*url.URL `json:"authorities,omitempty" form:"authorities" query:"authorities"`
	extraData   []byte
}

type CreateKeyPage struct {
	fieldsSet []bool
	Keys      []*KeySpecParams `json:"keys,omitempty" form:"keys" query:"keys" validate:"required"`
	extraData []byte
}

type CreateLiteTokenAccount struct {
	fieldsSet []bool
	extraData []byte
}

type CreateToken struct {
	fieldsSet   []bool
	Url         *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Symbol      string   `json:"symbol,omitempty" form:"symbol" query:"symbol" validate:"required"`
	Precision   uint64   `json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	Properties  *url.URL `json:"properties,omitempty" form:"properties" query:"properties"`
	SupplyLimit *big.Int `json:"supplyLimit,omitempty" form:"supplyLimit" query:"supplyLimit"`
	// Authorities is a list of authorities to add to the authority set.
	Authorities []*url.URL `json:"authorities,omitempty" form:"authorities" query:"authorities"`
	extraData   []byte
}

type CreateTokenAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	TokenUrl  *url.URL `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required"`
	// Authorities is a list of authorities to add to the authority set.
	Authorities []*url.URL        `json:"authorities,omitempty" form:"authorities" query:"authorities"`
	Proof       *TokenIssuerProof `json:"proof,omitempty" form:"proof" query:"proof"`
	extraData   []byte
}

type DataAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry"`
	extraData []byte
}

// DelegatedSignature is used when signing a transaction on behalf of another authority.
type DelegatedSignature struct {
	fieldsSet []bool
	Signature Signature `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	// Delegator is the authority that delegated its authority to the signer.
	Delegator *url.URL `json:"delegator,omitempty" form:"delegator" query:"delegator" validate:"required"`
	extraData []byte
}

type DirectoryAnchor struct {
	fieldsSet []bool
	PartitionAnchor
	// Updates are synchronization updates for network accounts.
	Updates []NetworkAccountUpdate `json:"updates,omitempty" form:"updates" query:"updates" validate:"required"`
	// Receipts are receipts for anchors from other partitions that were included in the block.
	Receipts []*PartitionAnchorReceipt `json:"receipts,omitempty" form:"receipts" query:"receipts" validate:"required"`
	// MakeMajorBlock notifies the partition that the DN has opened a major block.
	MakeMajorBlock uint64 `json:"makeMajorBlock,omitempty" form:"makeMajorBlock" query:"makeMajorBlock" validate:"required"`
	// MakeMajorBlockTime holds the time when the major block was opened.
	MakeMajorBlockTime time.Time `json:"makeMajorBlockTime,omitempty" form:"makeMajorBlockTime" query:"makeMajorBlockTime" validate:"required"`
	extraData          []byte
}

type DisableAccountAuthOperation struct {
	fieldsSet []bool
	// Authority is the authority to enable authorization for.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	extraData []byte
}

type ED25519Signature struct {
	fieldsSet       []bool
	PublicKey       []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature       []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer          *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion   uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Timestamp       uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp"`
	Vote            VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	extraData       []byte
}

type ETHSignature struct {
	fieldsSet       []bool
	PublicKey       []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature       []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer          *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion   uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Timestamp       uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp"`
	Vote            VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	extraData       []byte
}

type EmptyResult struct {
	fieldsSet []bool
	extraData []byte
}

type EnableAccountAuthOperation struct {
	fieldsSet []bool
	// Authority is the authority to enable authorization for.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	extraData []byte
}

type FactomDataEntry struct {
	AccountId [32]byte `json:"accountId,omitempty" form:"accountId" query:"accountId" validate:"required"`
	Data      []byte   `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	ExtIds    [][]byte `json:"extIds,omitempty" form:"extIds" query:"extIds" validate:"required"`
}

type FactomDataEntryWrapper struct {
	fieldsSet []bool
	FactomDataEntry
	extraData []byte
}

type FeeSchedule struct {
	fieldsSet []bool
	// CreateIdentitySliding is the sliding fee schedule for creating an ADI. The first entry is the cost of a one-character ADI, the second is the cost of a two-character ADI, etc.
	CreateIdentitySliding []Fee `json:"createIdentitySliding,omitempty" form:"createIdentitySliding" query:"createIdentitySliding" validate:"required"`
	extraData             []byte
}

// IndexEntry represents an entry in an index chain.
type IndexEntry struct {
	fieldsSet []bool
	// Source is the index of the chain from which an anchor was taken.
	Source uint64 `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	// Anchor is the index of the chain into which the anchor was added. Omit when indexing the root anchor chain.
	Anchor uint64 `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	// BlockIndex is the index of the block. Only include when indexing the root anchor chain.
	BlockIndex uint64 `json:"blockIndex,omitempty" form:"blockIndex" query:"blockIndex" validate:"required"`
	// BlockTime is the start time of the block. Only include when indexing the root anchor chain.
	BlockTime *time.Time `json:"blockTime,omitempty" form:"blockTime" query:"blockTime" validate:"required"`
	// RootIndexIndex is the index of the root anchor index chain entry. Only include when indexing the anchor ledger for a major block.
	RootIndexIndex uint64 `json:"rootIndexIndex,omitempty" form:"rootIndexIndex" query:"rootIndexIndex" validate:"required"`
	extraData      []byte
}

// InternalSignature is used for internally produced transactions.
type InternalSignature struct {
	fieldsSet []bool
	// Cause is the hash of the transaction that produced the signed transaction.
	Cause           [32]byte `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash" validate:"required"`
	extraData       []byte
}

type IssueTokens struct {
	fieldsSet []bool
	Recipient *url.URL          `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	Amount    big.Int           `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	To        []*TokenRecipient `json:"to,omitempty" form:"to" query:"to" validate:"required"`
	extraData []byte
}

type KeyBook struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	BookType  BookType `json:"bookType,omitempty" form:"bookType" query:"bookType" validate:"required"`
	AccountAuth
	PageCount uint64 `json:"pageCount,omitempty" form:"pageCount" query:"pageCount" validate:"required"`
	extraData []byte
}

type KeyPage struct {
	fieldsSet     []bool
	Url           *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	CreditBalance uint64   `json:"creditBalance,omitempty" form:"creditBalance" query:"creditBalance" validate:"required"`
	// AcceptThreshold is the number of acceptances required to accept a transaction.
	AcceptThreshold uint64 `json:"acceptThreshold,omitempty" form:"acceptThreshold" query:"acceptThreshold" validate:"required"`
	// RejectThreshold is the number of rejections required to reject a transaction.
	RejectThreshold uint64 `json:"rejectThreshold,omitempty" form:"rejectThreshold" query:"rejectThreshold" validate:"required"`
	// ResponseThreshold is the number of responses that must be received before a transaction will be processed.
	ResponseThreshold uint64 `json:"responseThreshold,omitempty" form:"responseThreshold" query:"responseThreshold" validate:"required"`
	// BlockThreshold is the number of minor blocks that must elapse before a transaction will be processed.
	BlockThreshold       uint64               `json:"blockThreshold,omitempty" form:"blockThreshold" query:"blockThreshold" validate:"required"`
	Version              uint64               `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Keys                 []*KeySpec           `json:"keys,omitempty" form:"keys" query:"keys" validate:"required"`
	TransactionBlacklist *AllowedTransactions `json:"transactionBlacklist,omitempty" form:"transactionBlacklist" query:"transactionBlacklist"`
	extraData            []byte
}

type KeySpec struct {
	fieldsSet     []bool
	PublicKeyHash []byte   `json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	LastUsedOn    uint64   `json:"lastUsedOn,omitempty" form:"lastUsedOn" query:"lastUsedOn" validate:"required"`
	Delegate      *url.URL `json:"delegate,omitempty" form:"delegate" query:"delegate" validate:"required"`
	extraData     []byte
}

type KeySpecParams struct {
	fieldsSet []bool
	KeyHash   []byte   `json:"keyHash,omitempty" form:"keyHash" query:"keyHash" validate:"required"`
	Delegate  *url.URL `json:"delegate,omitempty" form:"delegate" query:"delegate"`
	extraData []byte
}

type LegacyED25519Signature struct {
	fieldsSet       []bool
	Timestamp       uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	PublicKey       []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature       []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer          *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion   uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Vote            VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	extraData       []byte
}

type LiteDataAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	extraData []byte
}

type LiteIdentity struct {
	fieldsSet     []bool
	Url           *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	CreditBalance uint64   `json:"creditBalance,omitempty" form:"creditBalance" query:"creditBalance" validate:"required"`
	LastUsedOn    uint64   `json:"lastUsedOn,omitempty" form:"lastUsedOn" query:"lastUsedOn" validate:"required"`
	extraData     []byte
}

type LiteTokenAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	TokenUrl  *url.URL `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required"`
	Balance   big.Int  `json:"balance,omitempty" form:"balance" query:"balance" validate:"required"`
	// LockHeight is the major block height after which the balance can be transferred out of this account.
	LockHeight uint64 `json:"lockHeight,omitempty" form:"lockHeight" query:"lockHeight" validate:"required"`
	extraData  []byte
}

type LockAccount struct {
	fieldsSet []bool
	// Height is the major block height when the account will be released.
	Height    uint64 `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	extraData []byte
}

type MetricsRequest struct {
	fieldsSet []bool
	Metric    string        `json:"metric,omitempty" form:"metric" query:"metric" validate:"required"`
	Duration  time.Duration `json:"duration,omitempty" form:"duration" query:"duration" validate:"required"`
	extraData []byte
}

type MetricsResponse struct {
	Value interface{} `json:"value,omitempty" form:"value" query:"value" validate:"required"`
}

type NetworkAccountUpdate struct {
	fieldsSet []bool
	Name      string          `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Body      TransactionBody `json:"body,omitempty" form:"body" query:"body" validate:"required"`
	extraData []byte
}

type NetworkDefinition struct {
	fieldsSet   []bool
	NetworkName string           `json:"networkName,omitempty" form:"networkName" query:"networkName" validate:"required"`
	Version     uint64           `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Partitions  []*PartitionInfo `json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required"`
	Validators  []*ValidatorInfo `json:"validators,omitempty" form:"validators" query:"validators" validate:"required"`
	extraData   []byte
}

type NetworkGlobals struct {
	fieldsSet                []bool
	OperatorAcceptThreshold  Rational `json:"operatorAcceptThreshold,omitempty" form:"operatorAcceptThreshold" query:"operatorAcceptThreshold" validate:"required"`
	ValidatorAcceptThreshold Rational `json:"validatorAcceptThreshold,omitempty" form:"validatorAcceptThreshold" query:"validatorAcceptThreshold" validate:"required"`
	// MajorBlockSchedule a cron expression defining the (approximate) major blocks interval.
	MajorBlockSchedule string `json:"majorBlockSchedule,omitempty" form:"majorBlockSchedule" query:"majorBlockSchedule" validate:"required"`
	// AnchorEmptyBlocks controls whether an anchor is sent for a block if the block contains no transactions other than a directory anchor.
	AnchorEmptyBlocks bool           `json:"anchorEmptyBlocks,omitempty" form:"anchorEmptyBlocks" query:"anchorEmptyBlocks" validate:"required"`
	FeeSchedule       *FeeSchedule   `json:"feeSchedule,omitempty" form:"feeSchedule" query:"feeSchedule" validate:"required"`
	Limits            *NetworkLimits `json:"limits,omitempty" form:"limits" query:"limits" validate:"required"`
	extraData         []byte
}

type NetworkLimits struct {
	fieldsSet []bool
	// DataEntryParts is the maximum number of parts a data entry can have.
	DataEntryParts uint64 `json:"dataEntryParts,omitempty" form:"dataEntryParts" query:"dataEntryParts" validate:"required"`
	// AccountAuthorities is the maximum number of authorities an account can have.
	AccountAuthorities uint64 `json:"accountAuthorities,omitempty" form:"accountAuthorities" query:"accountAuthorities" validate:"required"`
	// BookPages is the maximum number of pages a book can have.
	BookPages uint64 `json:"bookPages,omitempty" form:"bookPages" query:"bookPages" validate:"required"`
	// PageEntries is the maximum number of entries a page can have.
	PageEntries uint64 `json:"pageEntries,omitempty" form:"pageEntries" query:"pageEntries" validate:"required"`
	// IdentityAccounts is the maximum number of accounts an identity can have (excluding accounts of sub ADIs).
	IdentityAccounts uint64 `json:"identityAccounts,omitempty" form:"identityAccounts" query:"identityAccounts" validate:"required"`
	extraData        []byte
}

type Object struct {
	fieldsSet []bool
	// Type is the object's type.
	Type ObjectType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	// Chains lists the account's chains.
	Chains []ChainMetadata `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
	// Pending lists the account's pending transactions.
	Pending   TxIdSet `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	extraData []byte
}

type PartitionAnchor struct {
	fieldsSet []bool
	// Source is the principal of the transaction that produced this transaction.
	Source *url.URL `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	// MajorBlockIndex is the major block index, or zero.
	MajorBlockIndex uint64 `json:"majorBlockIndex,omitempty" form:"majorBlockIndex" query:"majorBlockIndex" validate:"required"`
	// MinorBlockIndex is the minor block index.
	MinorBlockIndex uint64 `json:"minorBlockIndex,omitempty" form:"minorBlockIndex" query:"minorBlockIndex" validate:"required"`
	// RootChainIndex is the index of the last root chain entry.
	RootChainIndex uint64 `json:"rootChainIndex,omitempty" form:"rootChainIndex" query:"rootChainIndex" validate:"required"`
	// RootChainAnchor is the anchor of the root chain.
	RootChainAnchor [32]byte `json:"rootChainAnchor,omitempty" form:"rootChainAnchor" query:"rootChainAnchor" validate:"required"`
	// StateTreeAnchor is the root of the source's state tree (BPT).
	StateTreeAnchor [32]byte `json:"stateTreeAnchor,omitempty" form:"stateTreeAnchor" query:"stateTreeAnchor" validate:"required"`
	extraData       []byte
}

type PartitionAnchorReceipt struct {
	fieldsSet []bool
	Anchor    *PartitionAnchor `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	// RootChainReceipt is a receipt for the anchored root chain entry.
	RootChainReceipt *merkle.Receipt `json:"rootChainReceipt,omitempty" form:"rootChainReceipt" query:"rootChainReceipt" validate:"required"`
	extraData        []byte
}

type PartitionInfo struct {
	fieldsSet []bool
	ID        string        `json:"id,omitempty" form:"id" query:"id" validate:"required"`
	Type      PartitionType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	extraData []byte
}

// PartitionSignature is used to initiate transactions between BVNs.
type PartitionSignature struct {
	fieldsSet []bool
	// SourceNetwork is the network that produced the transaction.
	SourceNetwork *url.URL `json:"sourceNetwork,omitempty" form:"sourceNetwork" query:"sourceNetwork" validate:"required"`
	// DestinationNetwork is the network that the transaction is sent to.
	DestinationNetwork *url.URL `json:"destinationNetwork,omitempty" form:"destinationNetwork" query:"destinationNetwork" validate:"required"`
	// SequenceNumber is the sequence number of the transaction.
	SequenceNumber  uint64   `json:"sequenceNumber,omitempty" form:"sequenceNumber" query:"sequenceNumber" validate:"required"`
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	extraData       []byte
}

type PartitionSyntheticLedger struct {
	fieldsSet []bool
	// Url is the URL of the partition.
	Url *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	// Produced is the maximum sequence number of transactions produced for the partition.
	Produced uint64 `json:"produced,omitempty" form:"produced" query:"produced" validate:"required"`
	// Received is the maximum sequence number of transactions received from the partition.
	Received uint64 `json:"received,omitempty" form:"received" query:"received" validate:"required"`
	// Delivered is the maximum sequence number of delivered transactions received from the partition.
	Delivered uint64 `json:"delivered,omitempty" form:"delivered" query:"delivered" validate:"required"`
	// Pending is the transaction hashes of transactions received out of order.
	Pending   []*url.TxID `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	extraData []byte
}

// PlaceholderTransaction is a placeholder for some observable change in V2 logic.
type PlaceholderTransaction struct {
	fieldsSet []bool
	extraData []byte
}

type RCD1Signature struct {
	fieldsSet       []bool
	PublicKey       []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature       []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer          *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion   uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Timestamp       uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp"`
	Vote            VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	extraData       []byte
}

type Rational struct {
	fieldsSet   []bool
	Numerator   uint64 `json:"numerator,omitempty" form:"numerator" query:"numerator" validate:"required"`
	Denominator uint64 `json:"denominator,omitempty" form:"denominator" query:"denominator" validate:"required"`
	extraData   []byte
}

type ReceiptSignature struct {
	fieldsSet []bool
	// SourceNetwork is the network that produced the transaction.
	SourceNetwork   *url.URL       `json:"sourceNetwork,omitempty" form:"sourceNetwork" query:"sourceNetwork" validate:"required"`
	Proof           merkle.Receipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	TransactionHash [32]byte       `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	extraData       []byte
}

// RemoteSignature is used when forwarding a signature from one partition to another.
type RemoteSignature struct {
	fieldsSet   []bool
	Destination *url.URL   `json:"destination,omitempty" form:"destination" query:"destination" validate:"required"`
	Signature   Signature  `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Cause       [][32]byte `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	extraData   []byte
}

type RemoteTransaction struct {
	fieldsSet []bool
	Hash      [32]byte `json:"hash,omitempty" form:"hash" query:"hash"`
	extraData []byte
}

type RemoveAccountAuthorityOperation struct {
	fieldsSet []bool
	// Authority is the authority to add.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	extraData []byte
}

type RemoveKeyOperation struct {
	fieldsSet []bool
	Entry     KeySpecParams `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData []byte
}

type Route struct {
	fieldsSet []bool
	// Length is the prefix length.
	Length uint64 `json:"length,omitempty" form:"length" query:"length" validate:"required"`
	// Value is the prefix value.
	Value     uint64 `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	extraData []byte
}

type RouteOverride struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Partition string   `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	extraData []byte
}

type RoutingTable struct {
	fieldsSet []bool
	Overrides []RouteOverride `json:"overrides,omitempty" form:"overrides" query:"overrides" validate:"required"`
	Routes    []Route         `json:"routes,omitempty" form:"routes" query:"routes" validate:"required"`
	extraData []byte
}

type SendTokens struct {
	fieldsSet []bool
	Hash      [32]byte          `json:"hash,omitempty" form:"hash" query:"hash"`
	Meta      json.RawMessage   `json:"meta,omitempty" form:"meta" query:"meta"`
	To        []*TokenRecipient `json:"to,omitempty" form:"to" query:"to" validate:"required"`
	extraData []byte
}

type SetThresholdKeyPageOperation struct {
	fieldsSet []bool
	Threshold uint64 `json:"threshold,omitempty" form:"threshold" query:"threshold" validate:"required"`
	extraData []byte
}

// SignatureSet is used when forwarding a set of signatures.
type SignatureSet struct {
	fieldsSet       []bool
	Vote            VoteType    `json:"vote,omitempty" form:"vote" query:"vote"`
	Signer          *url.URL    `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	TransactionHash [32]byte    `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	Signatures      []Signature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	Authority       *url.URL    `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	extraData       []byte
}

type SyntheticBurnTokens struct {
	fieldsSet []bool
	SyntheticOrigin
	Amount    big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	IsRefund  bool    `json:"isRefund,omitempty" form:"isRefund" query:"isRefund" validate:"required"`
	extraData []byte
}

type SyntheticCreateIdentity struct {
	fieldsSet []bool
	SyntheticOrigin
	Accounts  []Account `json:"accounts,omitempty" form:"accounts" query:"accounts" validate:"required"`
	extraData []byte
}

type SyntheticDepositCredits struct {
	fieldsSet []bool
	SyntheticOrigin
	Amount uint64 `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	// AcmeRefundAmount is the amount of ACME that will be refunded if the deposit fails.
	AcmeRefundAmount *big.Int `json:"acmeRefundAmount,omitempty" form:"acmeRefundAmount" query:"acmeRefundAmount" validate:"required"`
	IsRefund         bool     `json:"isRefund,omitempty" form:"isRefund" query:"isRefund" validate:"required"`
	extraData        []byte
}

type SyntheticDepositTokens struct {
	fieldsSet []bool
	SyntheticOrigin
	Token     *url.URL `json:"token,omitempty" form:"token" query:"token" validate:"required"`
	Amount    big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	IsIssuer  bool     `json:"isIssuer,omitempty" form:"isIssuer" query:"isIssuer" validate:"required"`
	IsRefund  bool     `json:"isRefund,omitempty" form:"isRefund" query:"isRefund" validate:"required"`
	extraData []byte
}

type SyntheticForwardTransaction struct {
	fieldsSet   []bool
	Signatures  []RemoteSignature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	Transaction *Transaction      `json:"transaction,omitempty" form:"transaction" query:"transaction"`
	extraData   []byte
}

type SyntheticLedger struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	// Sequence tracks sent and received synthetic transactions.
	Sequence  []*PartitionSyntheticLedger `json:"sequence,omitempty" form:"sequence" query:"sequence" validate:"required"`
	extraData []byte
}

type SyntheticOrigin struct {
	fieldsSet []bool
	// Cause is the ID of the transaction that produced this transaction.
	Cause *url.TxID `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	// Initiator is the initiator of the cause.
	Initiator *url.URL `json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	// FeeRefund is portion of the cause's fee that will be refunded if this transaction fails.
	FeeRefund uint64 `json:"feeRefund,omitempty" form:"feeRefund" query:"feeRefund" validate:"required"`
	extraData []byte
}

type SyntheticWriteData struct {
	fieldsSet []bool
	SyntheticOrigin
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData []byte
}

type SystemGenesis struct {
	fieldsSet []bool
	extraData []byte
}

type SystemLedger struct {
	fieldsSet      []bool
	Url            *url.URL               `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Index          uint64                 `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Timestamp      time.Time              `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	AcmeBurnt      big.Int                `json:"acmeBurnt,omitempty" form:"acmeBurnt" query:"acmeBurnt" validate:"required"`
	PendingUpdates []NetworkAccountUpdate `json:"pendingUpdates,omitempty" form:"pendingUpdates" query:"pendingUpdates" validate:"required"`
	// Anchor is the block anchor that should be sent for the last block.
	Anchor AnchorBody `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	// ExecutorVersion is the active executor version.
	ExecutorVersion ExecutorVersion `json:"executorVersion,omitempty" form:"executorVersion" query:"executorVersion"`
	extraData       []byte
}

type SystemWriteData struct {
	fieldsSet []bool
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	// WriteToState writes the data entry to the account state.
	WriteToState bool `json:"writeToState,omitempty" form:"writeToState" query:"writeToState"`
	extraData    []byte
}

type TokenAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	TokenUrl  *url.URL `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required"`
	Balance   big.Int  `json:"balance,omitempty" form:"balance" query:"balance" validate:"required"`
	extraData []byte
}

type TokenIssuer struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	Symbol      string   `json:"symbol,omitempty" form:"symbol" query:"symbol" validate:"required"`
	Precision   uint64   `json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	Properties  *url.URL `json:"properties,omitempty" form:"properties" query:"properties" validate:"required"`
	Issued      big.Int  `json:"issued,omitempty" form:"issued" query:"issued" validate:"required"`
	SupplyLimit *big.Int `json:"supplyLimit,omitempty" form:"supplyLimit" query:"supplyLimit"`
	extraData   []byte
}

type TokenIssuerProof struct {
	fieldsSet   []bool
	Transaction *CreateToken    `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Receipt     *merkle.Receipt `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	extraData   []byte
}

type TokenRecipient struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Amount    big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	extraData []byte
}

type Transaction struct {
	fieldsSet []bool
	Header    TransactionHeader `json:"header,omitempty" form:"header" query:"header" validate:"required"`
	Body      TransactionBody   `json:"body,omitempty" form:"body" query:"body" validate:"required"`
	hash      []byte
	extraData []byte
}

type TransactionHeader struct {
	fieldsSet []bool
	Principal *url.URL `json:"principal,omitempty" form:"principal" query:"principal" validate:"required"`
	Initiator [32]byte `json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	Memo      string   `json:"memo,omitempty" form:"memo" query:"memo"`
	Metadata  []byte   `json:"metadata,omitempty" form:"metadata" query:"metadata"`
	extraData []byte
}

type TransactionResultSet struct {
	fieldsSet []bool
	Results   []*TransactionStatus `json:"results,omitempty" form:"results" query:"results" validate:"required"`
	extraData []byte
}

type TransactionStatus struct {
	fieldsSet []bool
	TxID      *url.TxID         `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Code      errors2.Status    `json:"code,omitempty" form:"code" query:"code" validate:"required"`
	Error     *errors2.Error    `json:"error,omitempty" form:"error" query:"error" validate:"required"`
	Result    TransactionResult `json:"result,omitempty" form:"result" query:"result" validate:"required"`
	// Received is the block when the transaction was first received.
	Received uint64 `json:"received,omitempty" form:"received" query:"received" validate:"required"`
	// Initiator is the signer that initiated the transaction.
	Initiator *url.URL `json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	// Signers lists accounts that have signed the transaction.
	Signers []Signer `json:"signers,omitempty" form:"signers" query:"signers" validate:"required"`
	// SourceNetwork is the network that produced the transaction.
	SourceNetwork *url.URL `json:"sourceNetwork,omitempty" form:"sourceNetwork" query:"sourceNetwork" validate:"required"`
	// DestinationNetwork is the network that the transaction is sent to.
	DestinationNetwork *url.URL `json:"destinationNetwork,omitempty" form:"destinationNetwork" query:"destinationNetwork" validate:"required"`
	// SequenceNumber is the sequence number of the transaction.
	SequenceNumber uint64 `json:"sequenceNumber,omitempty" form:"sequenceNumber" query:"sequenceNumber" validate:"required"`
	// GotDirectoryReceipt indicates if a receipt has been received from the DN.
	GotDirectoryReceipt bool `json:"gotDirectoryReceipt,omitempty" form:"gotDirectoryReceipt" query:"gotDirectoryReceipt" validate:"required"`
	// Proof is the proof of the transaction.
	Proof *merkle.Receipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	// AnchorSigners is the list of validators that have signed the anchor.
	AnchorSigners [][]byte `json:"anchorSigners,omitempty" form:"anchorSigners" query:"anchorSigners" validate:"required"`
	extraData     []byte
}

type TxIdSet struct {
	fieldsSet []bool
	Entries   []*url.TxID `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type UnknownAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	extraData []byte
}

type UnknownSigner struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Version   uint64   `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	extraData []byte
}

type UpdateAccountAuth struct {
	fieldsSet  []bool
	Operations []AccountAuthOperation `json:"operations,omitempty" form:"operations" query:"operations" validate:"required"`
	extraData  []byte
}

type UpdateAllowedKeyPageOperation struct {
	fieldsSet []bool
	Allow     []TransactionType `json:"allow,omitempty" form:"allow" query:"allow"`
	Deny      []TransactionType `json:"deny,omitempty" form:"deny" query:"deny"`
	extraData []byte
}

type UpdateKey struct {
	fieldsSet  []bool
	NewKeyHash []byte `json:"newKeyHash,omitempty" form:"newKeyHash" query:"newKeyHash" validate:"required"`
	extraData  []byte
}

type UpdateKeyOperation struct {
	fieldsSet []bool
	OldEntry  KeySpecParams `json:"oldEntry,omitempty" form:"oldEntry" query:"oldEntry" validate:"required"`
	NewEntry  KeySpecParams `json:"newEntry,omitempty" form:"newEntry" query:"newEntry" validate:"required"`
	extraData []byte
}

type UpdateKeyPage struct {
	fieldsSet []bool
	Operation []KeyPageOperation `json:"operation,omitempty" form:"operation" query:"operation" validate:"required"`
	extraData []byte
}

type ValidatorInfo struct {
	fieldsSet     []bool
	PublicKey     []byte                    `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	PublicKeyHash [32]byte                  `json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	Operator      *url.URL                  `json:"operator,omitempty" form:"operator" query:"operator" validate:"required"`
	Partitions    []*ValidatorPartitionInfo `json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required"`
	extraData     []byte
}

type ValidatorPartitionInfo struct {
	fieldsSet []bool
	ID        string `json:"id,omitempty" form:"id" query:"id" validate:"required"`
	Active    bool   `json:"active" form:"active" query:"active" validate:"required"`
	extraData []byte
}

type WriteData struct {
	fieldsSet []bool
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	Scratch   bool      `json:"scratch,omitempty" form:"scratch" query:"scratch"`
	// WriteToState writes the data entry to the account state.
	WriteToState bool `json:"writeToState,omitempty" form:"writeToState" query:"writeToState"`
	extraData    []byte
}

type WriteDataResult struct {
	fieldsSet  []bool
	EntryHash  [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	AccountUrl *url.URL `json:"accountUrl,omitempty" form:"accountUrl" query:"accountUrl" validate:"required"`
	AccountID  []byte   `json:"accountID,omitempty" form:"accountID" query:"accountID" validate:"required"`
	extraData  []byte
}

type WriteDataTo struct {
	fieldsSet []bool
	Recipient *url.URL  `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData []byte
}

func (*ADI) Type() AccountType { return AccountTypeIdentity }

func (*AccumulateDataEntry) Type() DataEntryType { return DataEntryTypeAccumulate }

func (*AcmeFaucet) Type() TransactionType { return TransactionTypeAcmeFaucet }

func (*ActivateProtocolVersion) Type() TransactionType { return TransactionTypeActivateProtocolVersion }

func (*AddAccountAuthorityOperation) Type() AccountAuthOperationType {
	return AccountAuthOperationTypeAddAuthority
}

func (*AddCredits) Type() TransactionType { return TransactionTypeAddCredits }

func (*AddCreditsResult) Type() TransactionType { return TransactionTypeAddCredits }

func (*AddKeyOperation) Type() KeyPageOperationType { return KeyPageOperationTypeAdd }

func (*AnchorLedger) Type() AccountType { return AccountTypeAnchorLedger }

func (*AuthoritySignature) Type() SignatureType { return SignatureTypeAuthority }

func (*BTCLegacySignature) Type() SignatureType { return SignatureTypeBTCLegacy }

func (*BTCSignature) Type() SignatureType { return SignatureTypeBTC }

func (*BlockLedger) Type() AccountType { return AccountTypeBlockLedger }

func (*BlockValidatorAnchor) Type() TransactionType { return TransactionTypeBlockValidatorAnchor }

func (*BurnTokens) Type() TransactionType { return TransactionTypeBurnTokens }

func (*CreateDataAccount) Type() TransactionType { return TransactionTypeCreateDataAccount }

func (*CreateIdentity) Type() TransactionType { return TransactionTypeCreateIdentity }

func (*CreateKeyBook) Type() TransactionType { return TransactionTypeCreateKeyBook }

func (*CreateKeyPage) Type() TransactionType { return TransactionTypeCreateKeyPage }

func (*CreateLiteTokenAccount) Type() TransactionType { return TransactionTypeCreateLiteTokenAccount }

func (*CreateToken) Type() TransactionType { return TransactionTypeCreateToken }

func (*CreateTokenAccount) Type() TransactionType { return TransactionTypeCreateTokenAccount }

func (*DataAccount) Type() AccountType { return AccountTypeDataAccount }

func (*DelegatedSignature) Type() SignatureType { return SignatureTypeDelegated }

func (*DirectoryAnchor) Type() TransactionType { return TransactionTypeDirectoryAnchor }

func (*DisableAccountAuthOperation) Type() AccountAuthOperationType {
	return AccountAuthOperationTypeDisable
}

func (*ED25519Signature) Type() SignatureType { return SignatureTypeED25519 }

func (*ETHSignature) Type() SignatureType { return SignatureTypeETH }

func (*EmptyResult) Type() TransactionType { return TransactionTypeUnknown }

func (*EnableAccountAuthOperation) Type() AccountAuthOperationType {
	return AccountAuthOperationTypeEnable
}

func (*FactomDataEntryWrapper) Type() DataEntryType { return DataEntryTypeFactom }

func (*InternalSignature) Type() SignatureType { return SignatureTypeInternal }

func (*IssueTokens) Type() TransactionType { return TransactionTypeIssueTokens }

func (*KeyBook) Type() AccountType { return AccountTypeKeyBook }

func (*KeyPage) Type() AccountType { return AccountTypeKeyPage }

func (*LegacyED25519Signature) Type() SignatureType { return SignatureTypeLegacyED25519 }

func (*LiteDataAccount) Type() AccountType { return AccountTypeLiteDataAccount }

func (*LiteIdentity) Type() AccountType { return AccountTypeLiteIdentity }

func (*LiteTokenAccount) Type() AccountType { return AccountTypeLiteTokenAccount }

func (*LockAccount) Type() TransactionType { return TransactionTypeLockAccount }

func (*PartitionSignature) Type() SignatureType { return SignatureTypePartition }

func (*PlaceholderTransaction) Type() TransactionType { return TransactionTypePlaceholder }

func (*RCD1Signature) Type() SignatureType { return SignatureTypeRCD1 }

func (*ReceiptSignature) Type() SignatureType { return SignatureTypeReceipt }

func (*RemoteSignature) Type() SignatureType { return SignatureTypeRemote }

func (*RemoteTransaction) Type() TransactionType { return TransactionTypeRemote }

func (*RemoveAccountAuthorityOperation) Type() AccountAuthOperationType {
	return AccountAuthOperationTypeRemoveAuthority
}

func (*RemoveKeyOperation) Type() KeyPageOperationType { return KeyPageOperationTypeRemove }

func (*SendTokens) Type() TransactionType { return TransactionTypeSendTokens }

func (*SetThresholdKeyPageOperation) Type() KeyPageOperationType {
	return KeyPageOperationTypeSetThreshold
}

func (*SignatureSet) Type() SignatureType { return SignatureTypeSet }

func (*SyntheticBurnTokens) Type() TransactionType { return TransactionTypeSyntheticBurnTokens }

func (*SyntheticCreateIdentity) Type() TransactionType { return TransactionTypeSyntheticCreateIdentity }

func (*SyntheticDepositCredits) Type() TransactionType { return TransactionTypeSyntheticDepositCredits }

func (*SyntheticDepositTokens) Type() TransactionType { return TransactionTypeSyntheticDepositTokens }

func (*SyntheticForwardTransaction) Type() TransactionType {
	return TransactionTypeSyntheticForwardTransaction
}

func (*SyntheticLedger) Type() AccountType { return AccountTypeSyntheticLedger }

func (*SyntheticWriteData) Type() TransactionType { return TransactionTypeSyntheticWriteData }

func (*SystemGenesis) Type() TransactionType { return TransactionTypeSystemGenesis }

func (*SystemLedger) Type() AccountType { return AccountTypeSystemLedger }

func (*SystemWriteData) Type() TransactionType { return TransactionTypeSystemWriteData }

func (*TokenAccount) Type() AccountType { return AccountTypeTokenAccount }

func (*TokenIssuer) Type() AccountType { return AccountTypeTokenIssuer }

func (*UnknownAccount) Type() AccountType { return AccountTypeUnknown }

func (*UnknownSigner) Type() AccountType { return AccountTypeUnknownSigner }

func (*UpdateAccountAuth) Type() TransactionType { return TransactionTypeUpdateAccountAuth }

func (*UpdateAllowedKeyPageOperation) Type() KeyPageOperationType {
	return KeyPageOperationTypeUpdateAllowed
}

func (*UpdateKey) Type() TransactionType { return TransactionTypeUpdateKey }

func (*UpdateKeyOperation) Type() KeyPageOperationType { return KeyPageOperationTypeUpdate }

func (*UpdateKeyPage) Type() TransactionType { return TransactionTypeUpdateKeyPage }

func (*WriteData) Type() TransactionType { return TransactionTypeWriteData }

func (*WriteDataResult) Type() TransactionType { return TransactionTypeWriteData }

func (*WriteDataTo) Type() TransactionType { return TransactionTypeWriteDataTo }

func (v *ADI) Copy() *ADI {
	u := new(ADI)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.AccountAuth = *v.AccountAuth.Copy()

	return u
}

func (v *ADI) CopyAsInterface() interface{} { return v.Copy() }

func (v *AccountAuth) Copy() *AccountAuth {
	u := new(AccountAuth)

	u.Authorities = make([]AuthorityEntry, len(v.Authorities))
	for i, v := range v.Authorities {
		u.Authorities[i] = *(&v).Copy()
	}

	return u
}

func (v *AccountAuth) CopyAsInterface() interface{} { return v.Copy() }

func (v *AccumulateDataEntry) Copy() *AccumulateDataEntry {
	u := new(AccumulateDataEntry)

	u.Data = make([][]byte, len(v.Data))
	for i, v := range v.Data {
		u.Data[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *AccumulateDataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *AcmeFaucet) Copy() *AcmeFaucet {
	u := new(AcmeFaucet)

	if v.Url != nil {
		u.Url = v.Url
	}

	return u
}

func (v *AcmeFaucet) CopyAsInterface() interface{} { return v.Copy() }

func (v *AcmeOracle) Copy() *AcmeOracle {
	u := new(AcmeOracle)

	u.Price = v.Price

	return u
}

func (v *AcmeOracle) CopyAsInterface() interface{} { return v.Copy() }

func (v *ActivateProtocolVersion) Copy() *ActivateProtocolVersion {
	u := new(ActivateProtocolVersion)

	u.Version = v.Version

	return u
}

func (v *ActivateProtocolVersion) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddAccountAuthorityOperation) Copy() *AddAccountAuthorityOperation {
	u := new(AddAccountAuthorityOperation)

	if v.Authority != nil {
		u.Authority = v.Authority
	}

	return u
}

func (v *AddAccountAuthorityOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddCredits) Copy() *AddCredits {
	u := new(AddCredits)

	if v.Recipient != nil {
		u.Recipient = v.Recipient
	}
	u.Amount = *encoding.BigintCopy(&v.Amount)
	u.Oracle = v.Oracle

	return u
}

func (v *AddCredits) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddCreditsResult) Copy() *AddCreditsResult {
	u := new(AddCreditsResult)

	u.Amount = *encoding.BigintCopy(&v.Amount)
	u.Credits = v.Credits
	u.Oracle = v.Oracle

	return u
}

func (v *AddCreditsResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddKeyOperation) Copy() *AddKeyOperation {
	u := new(AddKeyOperation)

	u.Entry = *(&v.Entry).Copy()

	return u
}

func (v *AddKeyOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *AnchorLedger) Copy() *AnchorLedger {
	u := new(AnchorLedger)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.MinorBlockSequenceNumber = v.MinorBlockSequenceNumber
	u.MajorBlockIndex = v.MajorBlockIndex
	u.MajorBlockTime = v.MajorBlockTime
	u.PendingMajorBlockAnchors = make([]*url.URL, len(v.PendingMajorBlockAnchors))
	for i, v := range v.PendingMajorBlockAnchors {
		if v != nil {
			u.PendingMajorBlockAnchors[i] = v
		}
	}
	u.Sequence = make([]*PartitionSyntheticLedger, len(v.Sequence))
	for i, v := range v.Sequence {
		if v != nil {
			u.Sequence[i] = (v).Copy()
		}
	}

	return u
}

func (v *AnchorLedger) CopyAsInterface() interface{} { return v.Copy() }

func (v *AnchorMetadata) Copy() *AnchorMetadata {
	u := new(AnchorMetadata)

	u.ChainMetadata = *v.ChainMetadata.Copy()
	if v.Account != nil {
		u.Account = v.Account
	}
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesCopy(v.Entry)

	return u
}

func (v *AnchorMetadata) CopyAsInterface() interface{} { return v.Copy() }

func (v *AnnotatedReceipt) Copy() *AnnotatedReceipt {
	u := new(AnnotatedReceipt)

	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}
	if v.Anchor != nil {
		u.Anchor = (v.Anchor).Copy()
	}

	return u
}

func (v *AnnotatedReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *AuthorityEntry) Copy() *AuthorityEntry {
	u := new(AuthorityEntry)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Disabled = v.Disabled

	return u
}

func (v *AuthorityEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *AuthoritySignature) Copy() *AuthoritySignature {
	u := new(AuthoritySignature)

	if v.Signer != nil {
		u.Signer = v.Signer
	}
	if v.Authority != nil {
		u.Authority = v.Authority
	}
	u.Vote = v.Vote
	if v.TxID != nil {
		u.TxID = v.TxID
	}
	u.Delegator = make([]*url.URL, len(v.Delegator))
	for i, v := range v.Delegator {
		if v != nil {
			u.Delegator[i] = v
		}
	}

	return u
}

func (v *AuthoritySignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *BTCLegacySignature) Copy() *BTCLegacySignature {
	u := new(BTCLegacySignature)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *BTCLegacySignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *BTCSignature) Copy() *BTCSignature {
	u := new(BTCSignature)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *BTCSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockEntry) Copy() *BlockEntry {
	u := new(BlockEntry)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Chain = v.Chain
	u.Index = v.Index

	return u
}

func (v *BlockEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockLedger) Copy() *BlockLedger {
	u := new(BlockLedger)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Index = v.Index
	u.Time = v.Time
	u.Entries = make([]*BlockEntry, len(v.Entries))
	for i, v := range v.Entries {
		if v != nil {
			u.Entries[i] = (v).Copy()
		}
	}

	return u
}

func (v *BlockLedger) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockValidatorAnchor) Copy() *BlockValidatorAnchor {
	u := new(BlockValidatorAnchor)

	u.PartitionAnchor = *v.PartitionAnchor.Copy()
	u.AcmeBurnt = *encoding.BigintCopy(&v.AcmeBurnt)

	return u
}

func (v *BlockValidatorAnchor) CopyAsInterface() interface{} { return v.Copy() }

func (v *BurnTokens) Copy() *BurnTokens {
	u := new(BurnTokens)

	u.Amount = *encoding.BigintCopy(&v.Amount)

	return u
}

func (v *BurnTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainMetadata) Copy() *ChainMetadata {
	u := new(ChainMetadata)

	u.Name = v.Name
	u.Type = v.Type

	return u
}

func (v *ChainMetadata) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainParams) Copy() *ChainParams {
	u := new(ChainParams)

	u.Data = encoding.BytesCopy(v.Data)
	u.IsUpdate = v.IsUpdate

	return u
}

func (v *ChainParams) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateDataAccount) Copy() *CreateDataAccount {
	u := new(CreateDataAccount)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Authorities = make([]*url.URL, len(v.Authorities))
	for i, v := range v.Authorities {
		if v != nil {
			u.Authorities[i] = v
		}
	}

	return u
}

func (v *CreateDataAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateIdentity) Copy() *CreateIdentity {
	u := new(CreateIdentity)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.KeyHash = encoding.BytesCopy(v.KeyHash)
	if v.KeyBookUrl != nil {
		u.KeyBookUrl = v.KeyBookUrl
	}
	u.Authorities = make([]*url.URL, len(v.Authorities))
	for i, v := range v.Authorities {
		if v != nil {
			u.Authorities[i] = v
		}
	}

	return u
}

func (v *CreateIdentity) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateKeyBook) Copy() *CreateKeyBook {
	u := new(CreateKeyBook)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.PublicKeyHash = encoding.BytesCopy(v.PublicKeyHash)
	u.Authorities = make([]*url.URL, len(v.Authorities))
	for i, v := range v.Authorities {
		if v != nil {
			u.Authorities[i] = v
		}
	}

	return u
}

func (v *CreateKeyBook) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateKeyPage) Copy() *CreateKeyPage {
	u := new(CreateKeyPage)

	u.Keys = make([]*KeySpecParams, len(v.Keys))
	for i, v := range v.Keys {
		if v != nil {
			u.Keys[i] = (v).Copy()
		}
	}

	return u
}

func (v *CreateKeyPage) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateLiteTokenAccount) Copy() *CreateLiteTokenAccount {
	u := new(CreateLiteTokenAccount)

	return u
}

func (v *CreateLiteTokenAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateToken) Copy() *CreateToken {
	u := new(CreateToken)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	if v.Properties != nil {
		u.Properties = v.Properties
	}
	if v.SupplyLimit != nil {
		u.SupplyLimit = encoding.BigintCopy(v.SupplyLimit)
	}
	u.Authorities = make([]*url.URL, len(v.Authorities))
	for i, v := range v.Authorities {
		if v != nil {
			u.Authorities[i] = v
		}
	}

	return u
}

func (v *CreateToken) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateTokenAccount) Copy() *CreateTokenAccount {
	u := new(CreateTokenAccount)

	if v.Url != nil {
		u.Url = v.Url
	}
	if v.TokenUrl != nil {
		u.TokenUrl = v.TokenUrl
	}
	u.Authorities = make([]*url.URL, len(v.Authorities))
	for i, v := range v.Authorities {
		if v != nil {
			u.Authorities[i] = v
		}
	}
	if v.Proof != nil {
		u.Proof = (v.Proof).Copy()
	}

	return u
}

func (v *CreateTokenAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *DataAccount) Copy() *DataAccount {
	u := new(DataAccount)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	if v.Entry != nil {
		u.Entry = CopyDataEntry(v.Entry)
	}

	return u
}

func (v *DataAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *DelegatedSignature) Copy() *DelegatedSignature {
	u := new(DelegatedSignature)

	if v.Signature != nil {
		u.Signature = CopySignature(v.Signature)
	}
	if v.Delegator != nil {
		u.Delegator = v.Delegator
	}

	return u
}

func (v *DelegatedSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *DirectoryAnchor) Copy() *DirectoryAnchor {
	u := new(DirectoryAnchor)

	u.PartitionAnchor = *v.PartitionAnchor.Copy()
	u.Updates = make([]NetworkAccountUpdate, len(v.Updates))
	for i, v := range v.Updates {
		u.Updates[i] = *(&v).Copy()
	}
	u.Receipts = make([]*PartitionAnchorReceipt, len(v.Receipts))
	for i, v := range v.Receipts {
		if v != nil {
			u.Receipts[i] = (v).Copy()
		}
	}
	u.MakeMajorBlock = v.MakeMajorBlock
	u.MakeMajorBlockTime = v.MakeMajorBlockTime

	return u
}

func (v *DirectoryAnchor) CopyAsInterface() interface{} { return v.Copy() }

func (v *DisableAccountAuthOperation) Copy() *DisableAccountAuthOperation {
	u := new(DisableAccountAuthOperation)

	if v.Authority != nil {
		u.Authority = v.Authority
	}

	return u
}

func (v *DisableAccountAuthOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *ED25519Signature) Copy() *ED25519Signature {
	u := new(ED25519Signature)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *ED25519Signature) CopyAsInterface() interface{} { return v.Copy() }

func (v *ETHSignature) Copy() *ETHSignature {
	u := new(ETHSignature)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *ETHSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *EmptyResult) Copy() *EmptyResult {
	u := new(EmptyResult)

	return u
}

func (v *EmptyResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *EnableAccountAuthOperation) Copy() *EnableAccountAuthOperation {
	u := new(EnableAccountAuthOperation)

	if v.Authority != nil {
		u.Authority = v.Authority
	}

	return u
}

func (v *EnableAccountAuthOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *FactomDataEntry) Copy() *FactomDataEntry {
	u := new(FactomDataEntry)

	u.AccountId = v.AccountId
	u.Data = encoding.BytesCopy(v.Data)
	u.ExtIds = make([][]byte, len(v.ExtIds))
	for i, v := range v.ExtIds {
		u.ExtIds[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *FactomDataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *FactomDataEntryWrapper) Copy() *FactomDataEntryWrapper {
	u := new(FactomDataEntryWrapper)

	u.FactomDataEntry = *v.FactomDataEntry.Copy()

	return u
}

func (v *FactomDataEntryWrapper) CopyAsInterface() interface{} { return v.Copy() }

func (v *FeeSchedule) Copy() *FeeSchedule {
	u := new(FeeSchedule)

	u.CreateIdentitySliding = make([]Fee, len(v.CreateIdentitySliding))
	for i, v := range v.CreateIdentitySliding {
		u.CreateIdentitySliding[i] = v
	}

	return u
}

func (v *FeeSchedule) CopyAsInterface() interface{} { return v.Copy() }

func (v *IndexEntry) Copy() *IndexEntry {
	u := new(IndexEntry)

	u.Source = v.Source
	u.Anchor = v.Anchor
	u.BlockIndex = v.BlockIndex
	if v.BlockTime != nil {
		u.BlockTime = new(time.Time)
		*u.BlockTime = *v.BlockTime
	}
	u.RootIndexIndex = v.RootIndexIndex

	return u
}

func (v *IndexEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *InternalSignature) Copy() *InternalSignature {
	u := new(InternalSignature)

	u.Cause = v.Cause
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *InternalSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *IssueTokens) Copy() *IssueTokens {
	u := new(IssueTokens)

	if v.Recipient != nil {
		u.Recipient = v.Recipient
	}
	u.Amount = *encoding.BigintCopy(&v.Amount)
	u.To = make([]*TokenRecipient, len(v.To))
	for i, v := range v.To {
		if v != nil {
			u.To[i] = (v).Copy()
		}
	}

	return u
}

func (v *IssueTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeyBook) Copy() *KeyBook {
	u := new(KeyBook)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.BookType = v.BookType
	u.AccountAuth = *v.AccountAuth.Copy()
	u.PageCount = v.PageCount

	return u
}

func (v *KeyBook) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeyPage) Copy() *KeyPage {
	u := new(KeyPage)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.CreditBalance = v.CreditBalance
	u.AcceptThreshold = v.AcceptThreshold
	u.RejectThreshold = v.RejectThreshold
	u.ResponseThreshold = v.ResponseThreshold
	u.BlockThreshold = v.BlockThreshold
	u.Version = v.Version
	u.Keys = make([]*KeySpec, len(v.Keys))
	for i, v := range v.Keys {
		if v != nil {
			u.Keys[i] = (v).Copy()
		}
	}
	if v.TransactionBlacklist != nil {
		u.TransactionBlacklist = new(AllowedTransactions)
		*u.TransactionBlacklist = *v.TransactionBlacklist
	}

	return u
}

func (v *KeyPage) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeySpec) Copy() *KeySpec {
	u := new(KeySpec)

	u.PublicKeyHash = encoding.BytesCopy(v.PublicKeyHash)
	u.LastUsedOn = v.LastUsedOn
	if v.Delegate != nil {
		u.Delegate = v.Delegate
	}

	return u
}

func (v *KeySpec) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeySpecParams) Copy() *KeySpecParams {
	u := new(KeySpecParams)

	u.KeyHash = encoding.BytesCopy(v.KeyHash)
	if v.Delegate != nil {
		u.Delegate = v.Delegate
	}

	return u
}

func (v *KeySpecParams) CopyAsInterface() interface{} { return v.Copy() }

func (v *LegacyED25519Signature) Copy() *LegacyED25519Signature {
	u := new(LegacyED25519Signature)

	u.Timestamp = v.Timestamp
	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.SignerVersion = v.SignerVersion
	u.Vote = v.Vote
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *LegacyED25519Signature) CopyAsInterface() interface{} { return v.Copy() }

func (v *LiteDataAccount) Copy() *LiteDataAccount {
	u := new(LiteDataAccount)

	if v.Url != nil {
		u.Url = v.Url
	}

	return u
}

func (v *LiteDataAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *LiteIdentity) Copy() *LiteIdentity {
	u := new(LiteIdentity)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.CreditBalance = v.CreditBalance
	u.LastUsedOn = v.LastUsedOn

	return u
}

func (v *LiteIdentity) CopyAsInterface() interface{} { return v.Copy() }

func (v *LiteTokenAccount) Copy() *LiteTokenAccount {
	u := new(LiteTokenAccount)

	if v.Url != nil {
		u.Url = v.Url
	}
	if v.TokenUrl != nil {
		u.TokenUrl = v.TokenUrl
	}
	u.Balance = *encoding.BigintCopy(&v.Balance)
	u.LockHeight = v.LockHeight

	return u
}

func (v *LiteTokenAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *LockAccount) Copy() *LockAccount {
	u := new(LockAccount)

	u.Height = v.Height

	return u
}

func (v *LockAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *MetricsRequest) Copy() *MetricsRequest {
	u := new(MetricsRequest)

	u.Metric = v.Metric
	u.Duration = v.Duration

	return u
}

func (v *MetricsRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkAccountUpdate) Copy() *NetworkAccountUpdate {
	u := new(NetworkAccountUpdate)

	u.Name = v.Name
	if v.Body != nil {
		u.Body = CopyTransactionBody(v.Body)
	}

	return u
}

func (v *NetworkAccountUpdate) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkDefinition) Copy() *NetworkDefinition {
	u := new(NetworkDefinition)

	u.NetworkName = v.NetworkName
	u.Version = v.Version
	u.Partitions = make([]*PartitionInfo, len(v.Partitions))
	for i, v := range v.Partitions {
		if v != nil {
			u.Partitions[i] = (v).Copy()
		}
	}
	u.Validators = make([]*ValidatorInfo, len(v.Validators))
	for i, v := range v.Validators {
		if v != nil {
			u.Validators[i] = (v).Copy()
		}
	}

	return u
}

func (v *NetworkDefinition) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkGlobals) Copy() *NetworkGlobals {
	u := new(NetworkGlobals)

	u.OperatorAcceptThreshold = *(&v.OperatorAcceptThreshold).Copy()
	u.ValidatorAcceptThreshold = *(&v.ValidatorAcceptThreshold).Copy()
	u.MajorBlockSchedule = v.MajorBlockSchedule
	u.AnchorEmptyBlocks = v.AnchorEmptyBlocks
	if v.FeeSchedule != nil {
		u.FeeSchedule = (v.FeeSchedule).Copy()
	}
	if v.Limits != nil {
		u.Limits = (v.Limits).Copy()
	}

	return u
}

func (v *NetworkGlobals) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkLimits) Copy() *NetworkLimits {
	u := new(NetworkLimits)

	u.DataEntryParts = v.DataEntryParts
	u.AccountAuthorities = v.AccountAuthorities
	u.BookPages = v.BookPages
	u.PageEntries = v.PageEntries
	u.IdentityAccounts = v.IdentityAccounts

	return u
}

func (v *NetworkLimits) CopyAsInterface() interface{} { return v.Copy() }

func (v *Object) Copy() *Object {
	u := new(Object)

	u.Type = v.Type
	u.Chains = make([]ChainMetadata, len(v.Chains))
	for i, v := range v.Chains {
		u.Chains[i] = *(&v).Copy()
	}
	u.Pending = *(&v.Pending).Copy()

	return u
}

func (v *Object) CopyAsInterface() interface{} { return v.Copy() }

func (v *PartitionAnchor) Copy() *PartitionAnchor {
	u := new(PartitionAnchor)

	if v.Source != nil {
		u.Source = v.Source
	}
	u.MajorBlockIndex = v.MajorBlockIndex
	u.MinorBlockIndex = v.MinorBlockIndex
	u.RootChainIndex = v.RootChainIndex
	u.RootChainAnchor = v.RootChainAnchor
	u.StateTreeAnchor = v.StateTreeAnchor

	return u
}

func (v *PartitionAnchor) CopyAsInterface() interface{} { return v.Copy() }

func (v *PartitionAnchorReceipt) Copy() *PartitionAnchorReceipt {
	u := new(PartitionAnchorReceipt)

	if v.Anchor != nil {
		u.Anchor = (v.Anchor).Copy()
	}
	if v.RootChainReceipt != nil {
		u.RootChainReceipt = (v.RootChainReceipt).Copy()
	}

	return u
}

func (v *PartitionAnchorReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *PartitionInfo) Copy() *PartitionInfo {
	u := new(PartitionInfo)

	u.ID = v.ID
	u.Type = v.Type

	return u
}

func (v *PartitionInfo) CopyAsInterface() interface{} { return v.Copy() }

func (v *PartitionSignature) Copy() *PartitionSignature {
	u := new(PartitionSignature)

	if v.SourceNetwork != nil {
		u.SourceNetwork = v.SourceNetwork
	}
	if v.DestinationNetwork != nil {
		u.DestinationNetwork = v.DestinationNetwork
	}
	u.SequenceNumber = v.SequenceNumber
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *PartitionSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *PartitionSyntheticLedger) Copy() *PartitionSyntheticLedger {
	u := new(PartitionSyntheticLedger)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Produced = v.Produced
	u.Received = v.Received
	u.Delivered = v.Delivered
	u.Pending = make([]*url.TxID, len(v.Pending))
	for i, v := range v.Pending {
		if v != nil {
			u.Pending[i] = v
		}
	}

	return u
}

func (v *PartitionSyntheticLedger) CopyAsInterface() interface{} { return v.Copy() }

func (v *PlaceholderTransaction) Copy() *PlaceholderTransaction {
	u := new(PlaceholderTransaction)

	return u
}

func (v *PlaceholderTransaction) CopyAsInterface() interface{} { return v.Copy() }

func (v *RCD1Signature) Copy() *RCD1Signature {
	u := new(RCD1Signature)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *RCD1Signature) CopyAsInterface() interface{} { return v.Copy() }

func (v *Rational) Copy() *Rational {
	u := new(Rational)

	u.Numerator = v.Numerator
	u.Denominator = v.Denominator

	return u
}

func (v *Rational) CopyAsInterface() interface{} { return v.Copy() }

func (v *ReceiptSignature) Copy() *ReceiptSignature {
	u := new(ReceiptSignature)

	if v.SourceNetwork != nil {
		u.SourceNetwork = v.SourceNetwork
	}
	u.Proof = *(&v.Proof).Copy()
	u.TransactionHash = v.TransactionHash

	return u
}

func (v *ReceiptSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *RemoteSignature) Copy() *RemoteSignature {
	u := new(RemoteSignature)

	if v.Destination != nil {
		u.Destination = v.Destination
	}
	if v.Signature != nil {
		u.Signature = CopySignature(v.Signature)
	}
	u.Cause = make([][32]byte, len(v.Cause))
	for i, v := range v.Cause {
		u.Cause[i] = v
	}

	return u
}

func (v *RemoteSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *RemoteTransaction) Copy() *RemoteTransaction {
	u := new(RemoteTransaction)

	u.Hash = v.Hash

	return u
}

func (v *RemoteTransaction) CopyAsInterface() interface{} { return v.Copy() }

func (v *RemoveAccountAuthorityOperation) Copy() *RemoveAccountAuthorityOperation {
	u := new(RemoveAccountAuthorityOperation)

	if v.Authority != nil {
		u.Authority = v.Authority
	}

	return u
}

func (v *RemoveAccountAuthorityOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *RemoveKeyOperation) Copy() *RemoveKeyOperation {
	u := new(RemoveKeyOperation)

	u.Entry = *(&v.Entry).Copy()

	return u
}

func (v *RemoveKeyOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *Route) Copy() *Route {
	u := new(Route)

	u.Length = v.Length
	u.Value = v.Value
	u.Partition = v.Partition

	return u
}

func (v *Route) CopyAsInterface() interface{} { return v.Copy() }

func (v *RouteOverride) Copy() *RouteOverride {
	u := new(RouteOverride)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Partition = v.Partition

	return u
}

func (v *RouteOverride) CopyAsInterface() interface{} { return v.Copy() }

func (v *RoutingTable) Copy() *RoutingTable {
	u := new(RoutingTable)

	u.Overrides = make([]RouteOverride, len(v.Overrides))
	for i, v := range v.Overrides {
		u.Overrides[i] = *(&v).Copy()
	}
	u.Routes = make([]Route, len(v.Routes))
	for i, v := range v.Routes {
		u.Routes[i] = *(&v).Copy()
	}

	return u
}

func (v *RoutingTable) CopyAsInterface() interface{} { return v.Copy() }

func (v *SendTokens) Copy() *SendTokens {
	u := new(SendTokens)

	u.Hash = v.Hash
	u.Meta = encoding.BytesCopy(v.Meta)
	u.To = make([]*TokenRecipient, len(v.To))
	for i, v := range v.To {
		if v != nil {
			u.To[i] = (v).Copy()
		}
	}

	return u
}

func (v *SendTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *SetThresholdKeyPageOperation) Copy() *SetThresholdKeyPageOperation {
	u := new(SetThresholdKeyPageOperation)

	u.Threshold = v.Threshold

	return u
}

func (v *SetThresholdKeyPageOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureSet) Copy() *SignatureSet {
	u := new(SignatureSet)

	u.Vote = v.Vote
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.TransactionHash = v.TransactionHash
	u.Signatures = make([]Signature, len(v.Signatures))
	for i, v := range v.Signatures {
		if v != nil {
			u.Signatures[i] = CopySignature(v)
		}
	}
	if v.Authority != nil {
		u.Authority = v.Authority
	}

	return u
}

func (v *SignatureSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticBurnTokens) Copy() *SyntheticBurnTokens {
	u := new(SyntheticBurnTokens)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	u.Amount = *encoding.BigintCopy(&v.Amount)
	u.IsRefund = v.IsRefund

	return u
}

func (v *SyntheticBurnTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticCreateIdentity) Copy() *SyntheticCreateIdentity {
	u := new(SyntheticCreateIdentity)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	u.Accounts = make([]Account, len(v.Accounts))
	for i, v := range v.Accounts {
		if v != nil {
			u.Accounts[i] = CopyAccount(v)
		}
	}

	return u
}

func (v *SyntheticCreateIdentity) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticDepositCredits) Copy() *SyntheticDepositCredits {
	u := new(SyntheticDepositCredits)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	u.Amount = v.Amount
	if v.AcmeRefundAmount != nil {
		u.AcmeRefundAmount = encoding.BigintCopy(v.AcmeRefundAmount)
	}
	u.IsRefund = v.IsRefund

	return u
}

func (v *SyntheticDepositCredits) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticDepositTokens) Copy() *SyntheticDepositTokens {
	u := new(SyntheticDepositTokens)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	if v.Token != nil {
		u.Token = v.Token
	}
	u.Amount = *encoding.BigintCopy(&v.Amount)
	u.IsIssuer = v.IsIssuer
	u.IsRefund = v.IsRefund

	return u
}

func (v *SyntheticDepositTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticForwardTransaction) Copy() *SyntheticForwardTransaction {
	u := new(SyntheticForwardTransaction)

	u.Signatures = make([]RemoteSignature, len(v.Signatures))
	for i, v := range v.Signatures {
		u.Signatures[i] = *(&v).Copy()
	}
	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}

	return u
}

func (v *SyntheticForwardTransaction) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticLedger) Copy() *SyntheticLedger {
	u := new(SyntheticLedger)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Sequence = make([]*PartitionSyntheticLedger, len(v.Sequence))
	for i, v := range v.Sequence {
		if v != nil {
			u.Sequence[i] = (v).Copy()
		}
	}

	return u
}

func (v *SyntheticLedger) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticOrigin) Copy() *SyntheticOrigin {
	u := new(SyntheticOrigin)

	if v.Cause != nil {
		u.Cause = v.Cause
	}
	if v.Initiator != nil {
		u.Initiator = v.Initiator
	}
	u.FeeRefund = v.FeeRefund

	return u
}

func (v *SyntheticOrigin) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticWriteData) Copy() *SyntheticWriteData {
	u := new(SyntheticWriteData)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	if v.Entry != nil {
		u.Entry = CopyDataEntry(v.Entry)
	}

	return u
}

func (v *SyntheticWriteData) CopyAsInterface() interface{} { return v.Copy() }

func (v *SystemGenesis) Copy() *SystemGenesis {
	u := new(SystemGenesis)

	return u
}

func (v *SystemGenesis) CopyAsInterface() interface{} { return v.Copy() }

func (v *SystemLedger) Copy() *SystemLedger {
	u := new(SystemLedger)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Index = v.Index
	u.Timestamp = v.Timestamp
	u.AcmeBurnt = *encoding.BigintCopy(&v.AcmeBurnt)
	u.PendingUpdates = make([]NetworkAccountUpdate, len(v.PendingUpdates))
	for i, v := range v.PendingUpdates {
		u.PendingUpdates[i] = *(&v).Copy()
	}
	if v.Anchor != nil {
		u.Anchor = CopyAnchorBody(v.Anchor)
	}
	u.ExecutorVersion = v.ExecutorVersion

	return u
}

func (v *SystemLedger) CopyAsInterface() interface{} { return v.Copy() }

func (v *SystemWriteData) Copy() *SystemWriteData {
	u := new(SystemWriteData)

	if v.Entry != nil {
		u.Entry = CopyDataEntry(v.Entry)
	}
	u.WriteToState = v.WriteToState

	return u
}

func (v *SystemWriteData) CopyAsInterface() interface{} { return v.Copy() }

func (v *TokenAccount) Copy() *TokenAccount {
	u := new(TokenAccount)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	if v.TokenUrl != nil {
		u.TokenUrl = v.TokenUrl
	}
	u.Balance = *encoding.BigintCopy(&v.Balance)

	return u
}

func (v *TokenAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *TokenIssuer) Copy() *TokenIssuer {
	u := new(TokenIssuer)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	if v.Properties != nil {
		u.Properties = v.Properties
	}
	u.Issued = *encoding.BigintCopy(&v.Issued)
	if v.SupplyLimit != nil {
		u.SupplyLimit = encoding.BigintCopy(v.SupplyLimit)
	}

	return u
}

func (v *TokenIssuer) CopyAsInterface() interface{} { return v.Copy() }

func (v *TokenIssuerProof) Copy() *TokenIssuerProof {
	u := new(TokenIssuerProof)

	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *TokenIssuerProof) CopyAsInterface() interface{} { return v.Copy() }

func (v *TokenRecipient) Copy() *TokenRecipient {
	u := new(TokenRecipient)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Amount = *encoding.BigintCopy(&v.Amount)

	return u
}

func (v *TokenRecipient) CopyAsInterface() interface{} { return v.Copy() }

func (v *Transaction) Copy() *Transaction {
	u := new(Transaction)

	u.Header = *(&v.Header).Copy()
	if v.Body != nil {
		u.Body = CopyTransactionBody(v.Body)
	}

	return u
}

func (v *Transaction) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionHeader) Copy() *TransactionHeader {
	u := new(TransactionHeader)

	if v.Principal != nil {
		u.Principal = v.Principal
	}
	u.Initiator = v.Initiator
	u.Memo = v.Memo
	u.Metadata = encoding.BytesCopy(v.Metadata)

	return u
}

func (v *TransactionHeader) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionResultSet) Copy() *TransactionResultSet {
	u := new(TransactionResultSet)

	u.Results = make([]*TransactionStatus, len(v.Results))
	for i, v := range v.Results {
		if v != nil {
			u.Results[i] = (v).Copy()
		}
	}

	return u
}

func (v *TransactionResultSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionStatus) Copy() *TransactionStatus {
	u := new(TransactionStatus)

	if v.TxID != nil {
		u.TxID = v.TxID
	}
	u.Code = v.Code
	if v.Error != nil {
		u.Error = (v.Error).Copy()
	}
	if v.Result != nil {
		u.Result = CopyTransactionResult(v.Result)
	}
	u.Received = v.Received
	if v.Initiator != nil {
		u.Initiator = v.Initiator
	}
	u.Signers = make([]Signer, len(v.Signers))
	for i, v := range v.Signers {
		if v != nil {
			u.Signers[i] = CopySigner(v)
		}
	}
	if v.SourceNetwork != nil {
		u.SourceNetwork = v.SourceNetwork
	}
	if v.DestinationNetwork != nil {
		u.DestinationNetwork = v.DestinationNetwork
	}
	u.SequenceNumber = v.SequenceNumber
	u.GotDirectoryReceipt = v.GotDirectoryReceipt
	if v.Proof != nil {
		u.Proof = (v.Proof).Copy()
	}
	u.AnchorSigners = make([][]byte, len(v.AnchorSigners))
	for i, v := range v.AnchorSigners {
		u.AnchorSigners[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *TransactionStatus) CopyAsInterface() interface{} { return v.Copy() }

func (v *TxIdSet) Copy() *TxIdSet {
	u := new(TxIdSet)

	u.Entries = make([]*url.TxID, len(v.Entries))
	for i, v := range v.Entries {
		if v != nil {
			u.Entries[i] = v
		}
	}

	return u
}

func (v *TxIdSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *UnknownAccount) Copy() *UnknownAccount {
	u := new(UnknownAccount)

	if v.Url != nil {
		u.Url = v.Url
	}

	return u
}

func (v *UnknownAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *UnknownSigner) Copy() *UnknownSigner {
	u := new(UnknownSigner)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Version = v.Version

	return u
}

func (v *UnknownSigner) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateAccountAuth) Copy() *UpdateAccountAuth {
	u := new(UpdateAccountAuth)

	u.Operations = make([]AccountAuthOperation, len(v.Operations))
	for i, v := range v.Operations {
		if v != nil {
			u.Operations[i] = CopyAccountAuthOperation(v)
		}
	}

	return u
}

func (v *UpdateAccountAuth) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateAllowedKeyPageOperation) Copy() *UpdateAllowedKeyPageOperation {
	u := new(UpdateAllowedKeyPageOperation)

	u.Allow = make([]TransactionType, len(v.Allow))
	for i, v := range v.Allow {
		u.Allow[i] = v
	}
	u.Deny = make([]TransactionType, len(v.Deny))
	for i, v := range v.Deny {
		u.Deny[i] = v
	}

	return u
}

func (v *UpdateAllowedKeyPageOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateKey) Copy() *UpdateKey {
	u := new(UpdateKey)

	u.NewKeyHash = encoding.BytesCopy(v.NewKeyHash)

	return u
}

func (v *UpdateKey) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateKeyOperation) Copy() *UpdateKeyOperation {
	u := new(UpdateKeyOperation)

	u.OldEntry = *(&v.OldEntry).Copy()
	u.NewEntry = *(&v.NewEntry).Copy()

	return u
}

func (v *UpdateKeyOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateKeyPage) Copy() *UpdateKeyPage {
	u := new(UpdateKeyPage)

	u.Operation = make([]KeyPageOperation, len(v.Operation))
	for i, v := range v.Operation {
		if v != nil {
			u.Operation[i] = CopyKeyPageOperation(v)
		}
	}

	return u
}

func (v *UpdateKeyPage) CopyAsInterface() interface{} { return v.Copy() }

func (v *ValidatorInfo) Copy() *ValidatorInfo {
	u := new(ValidatorInfo)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.PublicKeyHash = v.PublicKeyHash
	if v.Operator != nil {
		u.Operator = v.Operator
	}
	u.Partitions = make([]*ValidatorPartitionInfo, len(v.Partitions))
	for i, v := range v.Partitions {
		if v != nil {
			u.Partitions[i] = (v).Copy()
		}
	}

	return u
}

func (v *ValidatorInfo) CopyAsInterface() interface{} { return v.Copy() }

func (v *ValidatorPartitionInfo) Copy() *ValidatorPartitionInfo {
	u := new(ValidatorPartitionInfo)

	u.ID = v.ID
	u.Active = v.Active

	return u
}

func (v *ValidatorPartitionInfo) CopyAsInterface() interface{} { return v.Copy() }

func (v *WriteData) Copy() *WriteData {
	u := new(WriteData)

	if v.Entry != nil {
		u.Entry = CopyDataEntry(v.Entry)
	}
	u.Scratch = v.Scratch
	u.WriteToState = v.WriteToState

	return u
}

func (v *WriteData) CopyAsInterface() interface{} { return v.Copy() }

func (v *WriteDataResult) Copy() *WriteDataResult {
	u := new(WriteDataResult)

	u.EntryHash = v.EntryHash
	if v.AccountUrl != nil {
		u.AccountUrl = v.AccountUrl
	}
	u.AccountID = encoding.BytesCopy(v.AccountID)

	return u
}

func (v *WriteDataResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *WriteDataTo) Copy() *WriteDataTo {
	u := new(WriteDataTo)

	if v.Recipient != nil {
		u.Recipient = v.Recipient
	}
	if v.Entry != nil {
		u.Entry = CopyDataEntry(v.Entry)
	}

	return u
}

func (v *WriteDataTo) CopyAsInterface() interface{} { return v.Copy() }

func (v *ADI) Equal(u *ADI) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}

	return true
}

func (v *AccountAuth) Equal(u *AccountAuth) bool {
	if len(v.Authorities) != len(u.Authorities) {
		return false
	}
	for i := range v.Authorities {
		if !((&v.Authorities[i]).Equal(&u.Authorities[i])) {
			return false
		}
	}

	return true
}

func (v *AccumulateDataEntry) Equal(u *AccumulateDataEntry) bool {
	if len(v.Data) != len(u.Data) {
		return false
	}
	for i := range v.Data {
		if !(bytes.Equal(v.Data[i], u.Data[i])) {
			return false
		}
	}

	return true
}

func (v *AcmeFaucet) Equal(u *AcmeFaucet) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}

	return true
}

func (v *AcmeOracle) Equal(u *AcmeOracle) bool {
	if !(v.Price == u.Price) {
		return false
	}

	return true
}

func (v *ActivateProtocolVersion) Equal(u *ActivateProtocolVersion) bool {
	if !(v.Version == u.Version) {
		return false
	}

	return true
}

func (v *AddAccountAuthorityOperation) Equal(u *AddAccountAuthorityOperation) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *AddCredits) Equal(u *AddCredits) bool {
	switch {
	case v.Recipient == u.Recipient:
		// equal
	case v.Recipient == nil || u.Recipient == nil:
		return false
	case !((v.Recipient).Equal(u.Recipient)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}
	if !(v.Oracle == u.Oracle) {
		return false
	}

	return true
}

func (v *AddCreditsResult) Equal(u *AddCreditsResult) bool {
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}
	if !(v.Credits == u.Credits) {
		return false
	}
	if !(v.Oracle == u.Oracle) {
		return false
	}

	return true
}

func (v *AddKeyOperation) Equal(u *AddKeyOperation) bool {
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *AnchorLedger) Equal(u *AnchorLedger) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.MinorBlockSequenceNumber == u.MinorBlockSequenceNumber) {
		return false
	}
	if !(v.MajorBlockIndex == u.MajorBlockIndex) {
		return false
	}
	if !((v.MajorBlockTime).Equal(u.MajorBlockTime)) {
		return false
	}
	if len(v.PendingMajorBlockAnchors) != len(u.PendingMajorBlockAnchors) {
		return false
	}
	for i := range v.PendingMajorBlockAnchors {
		if !((v.PendingMajorBlockAnchors[i]).Equal(u.PendingMajorBlockAnchors[i])) {
			return false
		}
	}
	if len(v.Sequence) != len(u.Sequence) {
		return false
	}
	for i := range v.Sequence {
		if !((v.Sequence[i]).Equal(u.Sequence[i])) {
			return false
		}
	}

	return true
}

func (v *AnchorMetadata) Equal(u *AnchorMetadata) bool {
	if !v.ChainMetadata.Equal(&u.ChainMetadata) {
		return false
	}
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !(v.SourceIndex == u.SourceIndex) {
		return false
	}
	if !(v.SourceBlock == u.SourceBlock) {
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}

	return true
}

func (v *AnnotatedReceipt) Equal(u *AnnotatedReceipt) bool {
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}
	switch {
	case v.Anchor == u.Anchor:
		// equal
	case v.Anchor == nil || u.Anchor == nil:
		return false
	case !((v.Anchor).Equal(u.Anchor)):
		return false
	}

	return true
}

func (v *AuthorityEntry) Equal(u *AuthorityEntry) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Disabled == u.Disabled) {
		return false
	}

	return true
}

func (v *AuthoritySignature) Equal(u *AuthoritySignature) bool {
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	if len(v.Delegator) != len(u.Delegator) {
		return false
	}
	for i := range v.Delegator {
		if !((v.Delegator[i]).Equal(u.Delegator[i])) {
			return false
		}
	}

	return true
}

func (v *BTCLegacySignature) Equal(u *BTCLegacySignature) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *BTCSignature) Equal(u *BTCSignature) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *BlockEntry) Equal(u *BlockEntry) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}

	return true
}

func (v *BlockLedger) Equal(u *BlockLedger) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !((v.Time).Equal(u.Time)) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((v.Entries[i]).Equal(u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *BlockValidatorAnchor) Equal(u *BlockValidatorAnchor) bool {
	if !v.PartitionAnchor.Equal(&u.PartitionAnchor) {
		return false
	}
	if !((&v.AcmeBurnt).Cmp(&u.AcmeBurnt) == 0) {
		return false
	}

	return true
}

func (v *BurnTokens) Equal(u *BurnTokens) bool {
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *ChainMetadata) Equal(u *ChainMetadata) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *ChainParams) Equal(u *ChainParams) bool {
	if !(bytes.Equal(v.Data, u.Data)) {
		return false
	}
	if !(v.IsUpdate == u.IsUpdate) {
		return false
	}

	return true
}

func (v *CreateDataAccount) Equal(u *CreateDataAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if len(v.Authorities) != len(u.Authorities) {
		return false
	}
	for i := range v.Authorities {
		if !((v.Authorities[i]).Equal(u.Authorities[i])) {
			return false
		}
	}

	return true
}

func (v *CreateIdentity) Equal(u *CreateIdentity) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(bytes.Equal(v.KeyHash, u.KeyHash)) {
		return false
	}
	switch {
	case v.KeyBookUrl == u.KeyBookUrl:
		// equal
	case v.KeyBookUrl == nil || u.KeyBookUrl == nil:
		return false
	case !((v.KeyBookUrl).Equal(u.KeyBookUrl)):
		return false
	}
	if len(v.Authorities) != len(u.Authorities) {
		return false
	}
	for i := range v.Authorities {
		if !((v.Authorities[i]).Equal(u.Authorities[i])) {
			return false
		}
	}

	return true
}

func (v *CreateKeyBook) Equal(u *CreateKeyBook) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(bytes.Equal(v.PublicKeyHash, u.PublicKeyHash)) {
		return false
	}
	if len(v.Authorities) != len(u.Authorities) {
		return false
	}
	for i := range v.Authorities {
		if !((v.Authorities[i]).Equal(u.Authorities[i])) {
			return false
		}
	}

	return true
}

func (v *CreateKeyPage) Equal(u *CreateKeyPage) bool {
	if len(v.Keys) != len(u.Keys) {
		return false
	}
	for i := range v.Keys {
		if !((v.Keys[i]).Equal(u.Keys[i])) {
			return false
		}
	}

	return true
}

func (v *CreateLiteTokenAccount) Equal(u *CreateLiteTokenAccount) bool {

	return true
}

func (v *CreateToken) Equal(u *CreateToken) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Symbol == u.Symbol) {
		return false
	}
	if !(v.Precision == u.Precision) {
		return false
	}
	switch {
	case v.Properties == u.Properties:
		// equal
	case v.Properties == nil || u.Properties == nil:
		return false
	case !((v.Properties).Equal(u.Properties)):
		return false
	}
	switch {
	case v.SupplyLimit == u.SupplyLimit:
		// equal
	case v.SupplyLimit == nil || u.SupplyLimit == nil:
		return false
	case !((v.SupplyLimit).Cmp(u.SupplyLimit) == 0):
		return false
	}
	if len(v.Authorities) != len(u.Authorities) {
		return false
	}
	for i := range v.Authorities {
		if !((v.Authorities[i]).Equal(u.Authorities[i])) {
			return false
		}
	}

	return true
}

func (v *CreateTokenAccount) Equal(u *CreateTokenAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	switch {
	case v.TokenUrl == u.TokenUrl:
		// equal
	case v.TokenUrl == nil || u.TokenUrl == nil:
		return false
	case !((v.TokenUrl).Equal(u.TokenUrl)):
		return false
	}
	if len(v.Authorities) != len(u.Authorities) {
		return false
	}
	for i := range v.Authorities {
		if !((v.Authorities[i]).Equal(u.Authorities[i])) {
			return false
		}
	}
	switch {
	case v.Proof == u.Proof:
		// equal
	case v.Proof == nil || u.Proof == nil:
		return false
	case !((v.Proof).Equal(u.Proof)):
		return false
	}

	return true
}

func (v *DataAccount) Equal(u *DataAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	if !(EqualDataEntry(v.Entry, u.Entry)) {
		return false
	}

	return true
}

func (v *DelegatedSignature) Equal(u *DelegatedSignature) bool {
	if !(EqualSignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Delegator == u.Delegator:
		// equal
	case v.Delegator == nil || u.Delegator == nil:
		return false
	case !((v.Delegator).Equal(u.Delegator)):
		return false
	}

	return true
}

func (v *DirectoryAnchor) Equal(u *DirectoryAnchor) bool {
	if !v.PartitionAnchor.Equal(&u.PartitionAnchor) {
		return false
	}
	if len(v.Updates) != len(u.Updates) {
		return false
	}
	for i := range v.Updates {
		if !((&v.Updates[i]).Equal(&u.Updates[i])) {
			return false
		}
	}
	if len(v.Receipts) != len(u.Receipts) {
		return false
	}
	for i := range v.Receipts {
		if !((v.Receipts[i]).Equal(u.Receipts[i])) {
			return false
		}
	}
	if !(v.MakeMajorBlock == u.MakeMajorBlock) {
		return false
	}
	if !((v.MakeMajorBlockTime).Equal(u.MakeMajorBlockTime)) {
		return false
	}

	return true
}

func (v *DisableAccountAuthOperation) Equal(u *DisableAccountAuthOperation) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *ED25519Signature) Equal(u *ED25519Signature) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *ETHSignature) Equal(u *ETHSignature) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *EmptyResult) Equal(u *EmptyResult) bool {

	return true
}

func (v *EnableAccountAuthOperation) Equal(u *EnableAccountAuthOperation) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *FactomDataEntry) Equal(u *FactomDataEntry) bool {
	if !(v.AccountId == u.AccountId) {
		return false
	}
	if !(bytes.Equal(v.Data, u.Data)) {
		return false
	}
	if len(v.ExtIds) != len(u.ExtIds) {
		return false
	}
	for i := range v.ExtIds {
		if !(bytes.Equal(v.ExtIds[i], u.ExtIds[i])) {
			return false
		}
	}

	return true
}

func (v *FactomDataEntryWrapper) Equal(u *FactomDataEntryWrapper) bool {
	if !v.FactomDataEntry.Equal(&u.FactomDataEntry) {
		return false
	}

	return true
}

func (v *FeeSchedule) Equal(u *FeeSchedule) bool {
	if len(v.CreateIdentitySliding) != len(u.CreateIdentitySliding) {
		return false
	}
	for i := range v.CreateIdentitySliding {
		if !(v.CreateIdentitySliding[i] == u.CreateIdentitySliding[i]) {
			return false
		}
	}

	return true
}

func (v *IndexEntry) Equal(u *IndexEntry) bool {
	if !(v.Source == u.Source) {
		return false
	}
	if !(v.Anchor == u.Anchor) {
		return false
	}
	if !(v.BlockIndex == u.BlockIndex) {
		return false
	}
	switch {
	case v.BlockTime == u.BlockTime:
		// equal
	case v.BlockTime == nil || u.BlockTime == nil:
		return false
	case !((*v.BlockTime).Equal(*u.BlockTime)):
		return false
	}
	if !(v.RootIndexIndex == u.RootIndexIndex) {
		return false
	}

	return true
}

func (v *InternalSignature) Equal(u *InternalSignature) bool {
	if !(v.Cause == u.Cause) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *IssueTokens) Equal(u *IssueTokens) bool {
	switch {
	case v.Recipient == u.Recipient:
		// equal
	case v.Recipient == nil || u.Recipient == nil:
		return false
	case !((v.Recipient).Equal(u.Recipient)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}
	if len(v.To) != len(u.To) {
		return false
	}
	for i := range v.To {
		if !((v.To[i]).Equal(u.To[i])) {
			return false
		}
	}

	return true
}

func (v *KeyBook) Equal(u *KeyBook) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.BookType == u.BookType) {
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	if !(v.PageCount == u.PageCount) {
		return false
	}

	return true
}

func (v *KeyPage) Equal(u *KeyPage) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.CreditBalance == u.CreditBalance) {
		return false
	}
	if !(v.AcceptThreshold == u.AcceptThreshold) {
		return false
	}
	if !(v.RejectThreshold == u.RejectThreshold) {
		return false
	}
	if !(v.ResponseThreshold == u.ResponseThreshold) {
		return false
	}
	if !(v.BlockThreshold == u.BlockThreshold) {
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if len(v.Keys) != len(u.Keys) {
		return false
	}
	for i := range v.Keys {
		if !((v.Keys[i]).Equal(u.Keys[i])) {
			return false
		}
	}
	switch {
	case v.TransactionBlacklist == u.TransactionBlacklist:
		// equal
	case v.TransactionBlacklist == nil || u.TransactionBlacklist == nil:
		return false
	case !(*v.TransactionBlacklist == *u.TransactionBlacklist):
		return false
	}

	return true
}

func (v *KeySpec) Equal(u *KeySpec) bool {
	if !(bytes.Equal(v.PublicKeyHash, u.PublicKeyHash)) {
		return false
	}
	if !(v.LastUsedOn == u.LastUsedOn) {
		return false
	}
	switch {
	case v.Delegate == u.Delegate:
		// equal
	case v.Delegate == nil || u.Delegate == nil:
		return false
	case !((v.Delegate).Equal(u.Delegate)):
		return false
	}

	return true
}

func (v *KeySpecParams) Equal(u *KeySpecParams) bool {
	if !(bytes.Equal(v.KeyHash, u.KeyHash)) {
		return false
	}
	switch {
	case v.Delegate == u.Delegate:
		// equal
	case v.Delegate == nil || u.Delegate == nil:
		return false
	case !((v.Delegate).Equal(u.Delegate)):
		return false
	}

	return true
}

func (v *LegacyED25519Signature) Equal(u *LegacyED25519Signature) bool {
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *LiteDataAccount) Equal(u *LiteDataAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}

	return true
}

func (v *LiteIdentity) Equal(u *LiteIdentity) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.CreditBalance == u.CreditBalance) {
		return false
	}
	if !(v.LastUsedOn == u.LastUsedOn) {
		return false
	}

	return true
}

func (v *LiteTokenAccount) Equal(u *LiteTokenAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	switch {
	case v.TokenUrl == u.TokenUrl:
		// equal
	case v.TokenUrl == nil || u.TokenUrl == nil:
		return false
	case !((v.TokenUrl).Equal(u.TokenUrl)):
		return false
	}
	if !((&v.Balance).Cmp(&u.Balance) == 0) {
		return false
	}
	if !(v.LockHeight == u.LockHeight) {
		return false
	}

	return true
}

func (v *LockAccount) Equal(u *LockAccount) bool {
	if !(v.Height == u.Height) {
		return false
	}

	return true
}

func (v *MetricsRequest) Equal(u *MetricsRequest) bool {
	if !(v.Metric == u.Metric) {
		return false
	}
	if !(v.Duration == u.Duration) {
		return false
	}

	return true
}

func (v *NetworkAccountUpdate) Equal(u *NetworkAccountUpdate) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(EqualTransactionBody(v.Body, u.Body)) {
		return false
	}

	return true
}

func (v *NetworkDefinition) Equal(u *NetworkDefinition) bool {
	if !(v.NetworkName == u.NetworkName) {
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if len(v.Partitions) != len(u.Partitions) {
		return false
	}
	for i := range v.Partitions {
		if !((v.Partitions[i]).Equal(u.Partitions[i])) {
			return false
		}
	}
	if len(v.Validators) != len(u.Validators) {
		return false
	}
	for i := range v.Validators {
		if !((v.Validators[i]).Equal(u.Validators[i])) {
			return false
		}
	}

	return true
}

func (v *NetworkGlobals) Equal(u *NetworkGlobals) bool {
	if !((&v.OperatorAcceptThreshold).Equal(&u.OperatorAcceptThreshold)) {
		return false
	}
	if !((&v.ValidatorAcceptThreshold).Equal(&u.ValidatorAcceptThreshold)) {
		return false
	}
	if !(v.MajorBlockSchedule == u.MajorBlockSchedule) {
		return false
	}
	if !(v.AnchorEmptyBlocks == u.AnchorEmptyBlocks) {
		return false
	}
	switch {
	case v.FeeSchedule == u.FeeSchedule:
		// equal
	case v.FeeSchedule == nil || u.FeeSchedule == nil:
		return false
	case !((v.FeeSchedule).Equal(u.FeeSchedule)):
		return false
	}
	switch {
	case v.Limits == u.Limits:
		// equal
	case v.Limits == nil || u.Limits == nil:
		return false
	case !((v.Limits).Equal(u.Limits)):
		return false
	}

	return true
}

func (v *NetworkLimits) Equal(u *NetworkLimits) bool {
	if !(v.DataEntryParts == u.DataEntryParts) {
		return false
	}
	if !(v.AccountAuthorities == u.AccountAuthorities) {
		return false
	}
	if !(v.BookPages == u.BookPages) {
		return false
	}
	if !(v.PageEntries == u.PageEntries) {
		return false
	}
	if !(v.IdentityAccounts == u.IdentityAccounts) {
		return false
	}

	return true
}

func (v *Object) Equal(u *Object) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if len(v.Chains) != len(u.Chains) {
		return false
	}
	for i := range v.Chains {
		if !((&v.Chains[i]).Equal(&u.Chains[i])) {
			return false
		}
	}
	if !((&v.Pending).Equal(&u.Pending)) {
		return false
	}

	return true
}

func (v *PartitionAnchor) Equal(u *PartitionAnchor) bool {
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	if !(v.MajorBlockIndex == u.MajorBlockIndex) {
		return false
	}
	if !(v.MinorBlockIndex == u.MinorBlockIndex) {
		return false
	}
	if !(v.RootChainIndex == u.RootChainIndex) {
		return false
	}
	if !(v.RootChainAnchor == u.RootChainAnchor) {
		return false
	}
	if !(v.StateTreeAnchor == u.StateTreeAnchor) {
		return false
	}

	return true
}

func (v *PartitionAnchorReceipt) Equal(u *PartitionAnchorReceipt) bool {
	switch {
	case v.Anchor == u.Anchor:
		// equal
	case v.Anchor == nil || u.Anchor == nil:
		return false
	case !((v.Anchor).Equal(u.Anchor)):
		return false
	}
	switch {
	case v.RootChainReceipt == u.RootChainReceipt:
		// equal
	case v.RootChainReceipt == nil || u.RootChainReceipt == nil:
		return false
	case !((v.RootChainReceipt).Equal(u.RootChainReceipt)):
		return false
	}

	return true
}

func (v *PartitionInfo) Equal(u *PartitionInfo) bool {
	if !(v.ID == u.ID) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *PartitionSignature) Equal(u *PartitionSignature) bool {
	switch {
	case v.SourceNetwork == u.SourceNetwork:
		// equal
	case v.SourceNetwork == nil || u.SourceNetwork == nil:
		return false
	case !((v.SourceNetwork).Equal(u.SourceNetwork)):
		return false
	}
	switch {
	case v.DestinationNetwork == u.DestinationNetwork:
		// equal
	case v.DestinationNetwork == nil || u.DestinationNetwork == nil:
		return false
	case !((v.DestinationNetwork).Equal(u.DestinationNetwork)):
		return false
	}
	if !(v.SequenceNumber == u.SequenceNumber) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *PartitionSyntheticLedger) Equal(u *PartitionSyntheticLedger) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Produced == u.Produced) {
		return false
	}
	if !(v.Received == u.Received) {
		return false
	}
	if !(v.Delivered == u.Delivered) {
		return false
	}
	if len(v.Pending) != len(u.Pending) {
		return false
	}
	for i := range v.Pending {
		if !((v.Pending[i]).Equal(u.Pending[i])) {
			return false
		}
	}

	return true
}

func (v *PlaceholderTransaction) Equal(u *PlaceholderTransaction) bool {

	return true
}

func (v *RCD1Signature) Equal(u *RCD1Signature) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *Rational) Equal(u *Rational) bool {
	if !(v.Numerator == u.Numerator) {
		return false
	}
	if !(v.Denominator == u.Denominator) {
		return false
	}

	return true
}

func (v *ReceiptSignature) Equal(u *ReceiptSignature) bool {
	switch {
	case v.SourceNetwork == u.SourceNetwork:
		// equal
	case v.SourceNetwork == nil || u.SourceNetwork == nil:
		return false
	case !((v.SourceNetwork).Equal(u.SourceNetwork)):
		return false
	}
	if !((&v.Proof).Equal(&u.Proof)) {
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}

	return true
}

func (v *RemoteSignature) Equal(u *RemoteSignature) bool {
	switch {
	case v.Destination == u.Destination:
		// equal
	case v.Destination == nil || u.Destination == nil:
		return false
	case !((v.Destination).Equal(u.Destination)):
		return false
	}
	if !(EqualSignature(v.Signature, u.Signature)) {
		return false
	}
	if len(v.Cause) != len(u.Cause) {
		return false
	}
	for i := range v.Cause {
		if !(v.Cause[i] == u.Cause[i]) {
			return false
		}
	}

	return true
}

func (v *RemoteTransaction) Equal(u *RemoteTransaction) bool {
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *RemoveAccountAuthorityOperation) Equal(u *RemoveAccountAuthorityOperation) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *RemoveKeyOperation) Equal(u *RemoveKeyOperation) bool {
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *Route) Equal(u *Route) bool {
	if !(v.Length == u.Length) {
		return false
	}
	if !(v.Value == u.Value) {
		return false
	}
	if !(v.Partition == u.Partition) {
		return false
	}

	return true
}

func (v *RouteOverride) Equal(u *RouteOverride) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Partition == u.Partition) {
		return false
	}

	return true
}

func (v *RoutingTable) Equal(u *RoutingTable) bool {
	if len(v.Overrides) != len(u.Overrides) {
		return false
	}
	for i := range v.Overrides {
		if !((&v.Overrides[i]).Equal(&u.Overrides[i])) {
			return false
		}
	}
	if len(v.Routes) != len(u.Routes) {
		return false
	}
	for i := range v.Routes {
		if !((&v.Routes[i]).Equal(&u.Routes[i])) {
			return false
		}
	}

	return true
}

func (v *SendTokens) Equal(u *SendTokens) bool {
	if !(v.Hash == u.Hash) {
		return false
	}
	if !(bytes.Equal(v.Meta, u.Meta)) {
		return false
	}
	if len(v.To) != len(u.To) {
		return false
	}
	for i := range v.To {
		if !((v.To[i]).Equal(u.To[i])) {
			return false
		}
	}

	return true
}

func (v *SetThresholdKeyPageOperation) Equal(u *SetThresholdKeyPageOperation) bool {
	if !(v.Threshold == u.Threshold) {
		return false
	}

	return true
}

func (v *SignatureSet) Equal(u *SignatureSet) bool {
	if !(v.Vote == u.Vote) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(EqualSignature(v.Signatures[i], u.Signatures[i])) {
			return false
		}
	}
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *SyntheticBurnTokens) Equal(u *SyntheticBurnTokens) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}
	if !(v.IsRefund == u.IsRefund) {
		return false
	}

	return true
}

func (v *SyntheticCreateIdentity) Equal(u *SyntheticCreateIdentity) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if len(v.Accounts) != len(u.Accounts) {
		return false
	}
	for i := range v.Accounts {
		if !(EqualAccount(v.Accounts[i], u.Accounts[i])) {
			return false
		}
	}

	return true
}

func (v *SyntheticDepositCredits) Equal(u *SyntheticDepositCredits) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if !(v.Amount == u.Amount) {
		return false
	}
	switch {
	case v.AcmeRefundAmount == u.AcmeRefundAmount:
		// equal
	case v.AcmeRefundAmount == nil || u.AcmeRefundAmount == nil:
		return false
	case !((v.AcmeRefundAmount).Cmp(u.AcmeRefundAmount) == 0):
		return false
	}
	if !(v.IsRefund == u.IsRefund) {
		return false
	}

	return true
}

func (v *SyntheticDepositTokens) Equal(u *SyntheticDepositTokens) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	switch {
	case v.Token == u.Token:
		// equal
	case v.Token == nil || u.Token == nil:
		return false
	case !((v.Token).Equal(u.Token)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}
	if !(v.IsIssuer == u.IsIssuer) {
		return false
	}
	if !(v.IsRefund == u.IsRefund) {
		return false
	}

	return true
}

func (v *SyntheticForwardTransaction) Equal(u *SyntheticForwardTransaction) bool {
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !((&v.Signatures[i]).Equal(&u.Signatures[i])) {
			return false
		}
	}
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}

	return true
}

func (v *SyntheticLedger) Equal(u *SyntheticLedger) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if len(v.Sequence) != len(u.Sequence) {
		return false
	}
	for i := range v.Sequence {
		if !((v.Sequence[i]).Equal(u.Sequence[i])) {
			return false
		}
	}

	return true
}

func (v *SyntheticOrigin) Equal(u *SyntheticOrigin) bool {
	switch {
	case v.Cause == u.Cause:
		// equal
	case v.Cause == nil || u.Cause == nil:
		return false
	case !((v.Cause).Equal(u.Cause)):
		return false
	}
	switch {
	case v.Initiator == u.Initiator:
		// equal
	case v.Initiator == nil || u.Initiator == nil:
		return false
	case !((v.Initiator).Equal(u.Initiator)):
		return false
	}
	if !(v.FeeRefund == u.FeeRefund) {
		return false
	}

	return true
}

func (v *SyntheticWriteData) Equal(u *SyntheticWriteData) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if !(EqualDataEntry(v.Entry, u.Entry)) {
		return false
	}

	return true
}

func (v *SystemGenesis) Equal(u *SystemGenesis) bool {

	return true
}

func (v *SystemLedger) Equal(u *SystemLedger) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !((v.Timestamp).Equal(u.Timestamp)) {
		return false
	}
	if !((&v.AcmeBurnt).Cmp(&u.AcmeBurnt) == 0) {
		return false
	}
	if len(v.PendingUpdates) != len(u.PendingUpdates) {
		return false
	}
	for i := range v.PendingUpdates {
		if !((&v.PendingUpdates[i]).Equal(&u.PendingUpdates[i])) {
			return false
		}
	}
	if !(EqualAnchorBody(v.Anchor, u.Anchor)) {
		return false
	}
	if !(v.ExecutorVersion == u.ExecutorVersion) {
		return false
	}

	return true
}

func (v *SystemWriteData) Equal(u *SystemWriteData) bool {
	if !(EqualDataEntry(v.Entry, u.Entry)) {
		return false
	}
	if !(v.WriteToState == u.WriteToState) {
		return false
	}

	return true
}

func (v *TokenAccount) Equal(u *TokenAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	switch {
	case v.TokenUrl == u.TokenUrl:
		// equal
	case v.TokenUrl == nil || u.TokenUrl == nil:
		return false
	case !((v.TokenUrl).Equal(u.TokenUrl)):
		return false
	}
	if !((&v.Balance).Cmp(&u.Balance) == 0) {
		return false
	}

	return true
}

func (v *TokenIssuer) Equal(u *TokenIssuer) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	if !(v.Symbol == u.Symbol) {
		return false
	}
	if !(v.Precision == u.Precision) {
		return false
	}
	switch {
	case v.Properties == u.Properties:
		// equal
	case v.Properties == nil || u.Properties == nil:
		return false
	case !((v.Properties).Equal(u.Properties)):
		return false
	}
	if !((&v.Issued).Cmp(&u.Issued) == 0) {
		return false
	}
	switch {
	case v.SupplyLimit == u.SupplyLimit:
		// equal
	case v.SupplyLimit == nil || u.SupplyLimit == nil:
		return false
	case !((v.SupplyLimit).Cmp(u.SupplyLimit) == 0):
		return false
	}

	return true
}

func (v *TokenIssuerProof) Equal(u *TokenIssuerProof) bool {
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

func (v *TokenRecipient) Equal(u *TokenRecipient) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *Transaction) Equal(u *Transaction) bool {
	if !((&v.Header).Equal(&u.Header)) {
		return false
	}
	if !(EqualTransactionBody(v.Body, u.Body)) {
		return false
	}

	return true
}

func (v *TransactionHeader) Equal(u *TransactionHeader) bool {
	switch {
	case v.Principal == u.Principal:
		// equal
	case v.Principal == nil || u.Principal == nil:
		return false
	case !((v.Principal).Equal(u.Principal)):
		return false
	}
	if !(v.Initiator == u.Initiator) {
		return false
	}
	if !(v.Memo == u.Memo) {
		return false
	}
	if !(bytes.Equal(v.Metadata, u.Metadata)) {
		return false
	}

	return true
}

func (v *TransactionResultSet) Equal(u *TransactionResultSet) bool {
	if len(v.Results) != len(u.Results) {
		return false
	}
	for i := range v.Results {
		if !((v.Results[i]).Equal(u.Results[i])) {
			return false
		}
	}

	return true
}

func (v *TransactionStatus) Equal(u *TransactionStatus) bool {
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	if !(v.Code == u.Code) {
		return false
	}
	switch {
	case v.Error == u.Error:
		// equal
	case v.Error == nil || u.Error == nil:
		return false
	case !((v.Error).Equal(u.Error)):
		return false
	}
	if !(EqualTransactionResult(v.Result, u.Result)) {
		return false
	}
	if !(v.Received == u.Received) {
		return false
	}
	switch {
	case v.Initiator == u.Initiator:
		// equal
	case v.Initiator == nil || u.Initiator == nil:
		return false
	case !((v.Initiator).Equal(u.Initiator)):
		return false
	}
	if len(v.Signers) != len(u.Signers) {
		return false
	}
	for i := range v.Signers {
		if !(EqualSigner(v.Signers[i], u.Signers[i])) {
			return false
		}
	}
	switch {
	case v.SourceNetwork == u.SourceNetwork:
		// equal
	case v.SourceNetwork == nil || u.SourceNetwork == nil:
		return false
	case !((v.SourceNetwork).Equal(u.SourceNetwork)):
		return false
	}
	switch {
	case v.DestinationNetwork == u.DestinationNetwork:
		// equal
	case v.DestinationNetwork == nil || u.DestinationNetwork == nil:
		return false
	case !((v.DestinationNetwork).Equal(u.DestinationNetwork)):
		return false
	}
	if !(v.SequenceNumber == u.SequenceNumber) {
		return false
	}
	if !(v.GotDirectoryReceipt == u.GotDirectoryReceipt) {
		return false
	}
	switch {
	case v.Proof == u.Proof:
		// equal
	case v.Proof == nil || u.Proof == nil:
		return false
	case !((v.Proof).Equal(u.Proof)):
		return false
	}
	if len(v.AnchorSigners) != len(u.AnchorSigners) {
		return false
	}
	for i := range v.AnchorSigners {
		if !(bytes.Equal(v.AnchorSigners[i], u.AnchorSigners[i])) {
			return false
		}
	}

	return true
}

func (v *TxIdSet) Equal(u *TxIdSet) bool {
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((v.Entries[i]).Equal(u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *UnknownAccount) Equal(u *UnknownAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}

	return true
}

func (v *UnknownSigner) Equal(u *UnknownSigner) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}

	return true
}

func (v *UpdateAccountAuth) Equal(u *UpdateAccountAuth) bool {
	if len(v.Operations) != len(u.Operations) {
		return false
	}
	for i := range v.Operations {
		if !(EqualAccountAuthOperation(v.Operations[i], u.Operations[i])) {
			return false
		}
	}

	return true
}

func (v *UpdateAllowedKeyPageOperation) Equal(u *UpdateAllowedKeyPageOperation) bool {
	if len(v.Allow) != len(u.Allow) {
		return false
	}
	for i := range v.Allow {
		if !(v.Allow[i] == u.Allow[i]) {
			return false
		}
	}
	if len(v.Deny) != len(u.Deny) {
		return false
	}
	for i := range v.Deny {
		if !(v.Deny[i] == u.Deny[i]) {
			return false
		}
	}

	return true
}

func (v *UpdateKey) Equal(u *UpdateKey) bool {
	if !(bytes.Equal(v.NewKeyHash, u.NewKeyHash)) {
		return false
	}

	return true
}

func (v *UpdateKeyOperation) Equal(u *UpdateKeyOperation) bool {
	if !((&v.OldEntry).Equal(&u.OldEntry)) {
		return false
	}
	if !((&v.NewEntry).Equal(&u.NewEntry)) {
		return false
	}

	return true
}

func (v *UpdateKeyPage) Equal(u *UpdateKeyPage) bool {
	if len(v.Operation) != len(u.Operation) {
		return false
	}
	for i := range v.Operation {
		if !(EqualKeyPageOperation(v.Operation[i], u.Operation[i])) {
			return false
		}
	}

	return true
}

func (v *ValidatorInfo) Equal(u *ValidatorInfo) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(v.PublicKeyHash == u.PublicKeyHash) {
		return false
	}
	switch {
	case v.Operator == u.Operator:
		// equal
	case v.Operator == nil || u.Operator == nil:
		return false
	case !((v.Operator).Equal(u.Operator)):
		return false
	}
	if len(v.Partitions) != len(u.Partitions) {
		return false
	}
	for i := range v.Partitions {
		if !((v.Partitions[i]).Equal(u.Partitions[i])) {
			return false
		}
	}

	return true
}

func (v *ValidatorPartitionInfo) Equal(u *ValidatorPartitionInfo) bool {
	if !(v.ID == u.ID) {
		return false
	}
	if !(v.Active == u.Active) {
		return false
	}

	return true
}

func (v *WriteData) Equal(u *WriteData) bool {
	if !(EqualDataEntry(v.Entry, u.Entry)) {
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}
	if !(v.WriteToState == u.WriteToState) {
		return false
	}

	return true
}

func (v *WriteDataResult) Equal(u *WriteDataResult) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}
	switch {
	case v.AccountUrl == u.AccountUrl:
		// equal
	case v.AccountUrl == nil || u.AccountUrl == nil:
		return false
	case !((v.AccountUrl).Equal(u.AccountUrl)):
		return false
	}
	if !(bytes.Equal(v.AccountID, u.AccountID)) {
		return false
	}

	return true
}

func (v *WriteDataTo) Equal(u *WriteDataTo) bool {
	switch {
	case v.Recipient == u.Recipient:
		// equal
	case v.Recipient == nil || u.Recipient == nil:
		return false
	case !((v.Recipient).Equal(u.Recipient)):
		return false
	}
	if !(EqualDataEntry(v.Entry, u.Entry)) {
		return false
	}

	return true
}

var fieldNames_ADI = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
}

func (v *ADI) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, v.AccountAuth.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_ADI)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ADI) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AccountAuth = []string{
	1: "Authorities",
}

func (v *AccountAuth) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Authorities) == 0) {
		for _, v := range v.Authorities {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_AccountAuth)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AccountAuth) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Authorities is missing")
	} else if len(v.Authorities) == 0 {
		errs = append(errs, "field Authorities is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AccumulateDataEntry = []string{
	1: "Type",
	2: "Data",
}

func (v *AccumulateDataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Data) == 0) {
		for _, v := range v.Data {
			writer.WriteBytes(2, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_AccumulateDataEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AccumulateDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Data is missing")
	} else if len(v.Data) == 0 {
		errs = append(errs, "field Data is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AcmeFaucet = []string{
	1: "Type",
	2: "Url",
}

func (v *AcmeFaucet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}

	_, _, err := writer.Reset(fieldNames_AcmeFaucet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AcmeFaucet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AcmeOracle = []string{
	1: "Price",
}

func (v *AcmeOracle) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Price == 0) {
		writer.WriteUint(1, v.Price)
	}

	_, _, err := writer.Reset(fieldNames_AcmeOracle)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AcmeOracle) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Price is missing")
	} else if v.Price == 0 {
		errs = append(errs, "field Price is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ActivateProtocolVersion = []string{
	1: "Type",
	2: "Version",
}

func (v *ActivateProtocolVersion) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Version == 0) {
		writer.WriteEnum(2, v.Version)
	}

	_, _, err := writer.Reset(fieldNames_ActivateProtocolVersion)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ActivateProtocolVersion) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddAccountAuthorityOperation = []string{
	1: "Type",
	2: "Authority",
}

func (v *AddAccountAuthorityOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_AddAccountAuthorityOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AddAccountAuthorityOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddCredits = []string{
	1: "Type",
	2: "Recipient",
	3: "Amount",
	4: "Oracle",
}

func (v *AddCredits) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Recipient == nil) {
		writer.WriteUrl(2, v.Recipient)
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(3, &v.Amount)
	}
	if !(v.Oracle == 0) {
		writer.WriteUint(4, v.Oracle)
	}

	_, _, err := writer.Reset(fieldNames_AddCredits)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AddCredits) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Recipient is missing")
	} else if v.Recipient == nil {
		errs = append(errs, "field Recipient is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddCreditsResult = []string{
	1: "Type",
	2: "Amount",
	3: "Credits",
	4: "Oracle",
}

func (v *AddCreditsResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(2, &v.Amount)
	}
	if !(v.Credits == 0) {
		writer.WriteUint(3, v.Credits)
	}
	if !(v.Oracle == 0) {
		writer.WriteUint(4, v.Oracle)
	}

	_, _, err := writer.Reset(fieldNames_AddCreditsResult)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AddCreditsResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Credits is missing")
	} else if v.Credits == 0 {
		errs = append(errs, "field Credits is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Oracle is missing")
	} else if v.Oracle == 0 {
		errs = append(errs, "field Oracle is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddKeyOperation = []string{
	1: "Type",
	2: "Entry",
}

func (v *AddKeyOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Entry).Equal(new(KeySpecParams))) {
		writer.WriteValue(2, v.Entry.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_AddKeyOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AddKeyOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(KeySpecParams)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AnchorLedger = []string{
	1: "Type",
	2: "Url",
	3: "MinorBlockSequenceNumber",
	4: "MajorBlockIndex",
	5: "MajorBlockTime",
	6: "PendingMajorBlockAnchors",
	7: "Sequence",
}

func (v *AnchorLedger) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.MinorBlockSequenceNumber == 0) {
		writer.WriteUint(3, v.MinorBlockSequenceNumber)
	}
	if !(v.MajorBlockIndex == 0) {
		writer.WriteUint(4, v.MajorBlockIndex)
	}
	if !(v.MajorBlockTime == (time.Time{})) {
		writer.WriteTime(5, v.MajorBlockTime)
	}
	if !(len(v.PendingMajorBlockAnchors) == 0) {
		for _, v := range v.PendingMajorBlockAnchors {
			writer.WriteUrl(6, v)
		}
	}
	if !(len(v.Sequence) == 0) {
		for _, v := range v.Sequence {
			writer.WriteValue(7, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_AnchorLedger)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AnchorLedger) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field MinorBlockSequenceNumber is missing")
	} else if v.MinorBlockSequenceNumber == 0 {
		errs = append(errs, "field MinorBlockSequenceNumber is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field MajorBlockIndex is missing")
	} else if v.MajorBlockIndex == 0 {
		errs = append(errs, "field MajorBlockIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field MajorBlockTime is missing")
	} else if v.MajorBlockTime == (time.Time{}) {
		errs = append(errs, "field MajorBlockTime is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field PendingMajorBlockAnchors is missing")
	} else if len(v.PendingMajorBlockAnchors) == 0 {
		errs = append(errs, "field PendingMajorBlockAnchors is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Sequence is missing")
	} else if len(v.Sequence) == 0 {
		errs = append(errs, "field Sequence is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AnchorMetadata = []string{
	1: "ChainMetadata",
	2: "Account",
	3: "Index",
	4: "SourceIndex",
	5: "SourceBlock",
	6: "Entry",
}

func (v *AnchorMetadata) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, v.ChainMetadata.MarshalBinary)
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(v.Index == 0) {
		writer.WriteUint(3, v.Index)
	}
	if !(v.SourceIndex == 0) {
		writer.WriteUint(4, v.SourceIndex)
	}
	if !(v.SourceBlock == 0) {
		writer.WriteUint(5, v.SourceBlock)
	}
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(6, v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_AnchorMetadata)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AnchorMetadata) IsValid() error {
	var errs []string

	if err := v.ChainMetadata.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field SourceIndex is missing")
	} else if v.SourceIndex == 0 {
		errs = append(errs, "field SourceIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SourceBlock is missing")
	} else if v.SourceBlock == 0 {
		errs = append(errs, "field SourceBlock is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entry is missing")
	} else if len(v.Entry) == 0 {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AnnotatedReceipt = []string{
	1: "Receipt",
	2: "Anchor",
}

func (v *AnnotatedReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Receipt == nil) {
		writer.WriteValue(1, v.Receipt.MarshalBinary)
	}
	if !(v.Anchor == nil) {
		writer.WriteValue(2, v.Anchor.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_AnnotatedReceipt)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AnnotatedReceipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Receipt is missing")
	} else if v.Receipt == nil {
		errs = append(errs, "field Receipt is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Anchor is missing")
	} else if v.Anchor == nil {
		errs = append(errs, "field Anchor is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AuthorityEntry = []string{
	1: "Url",
	2: "Disabled",
}

func (v *AuthorityEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(!v.Disabled) {
		writer.WriteBool(2, v.Disabled)
	}

	_, _, err := writer.Reset(fieldNames_AuthorityEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AuthorityEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Disabled is missing")
	} else if !v.Disabled {
		errs = append(errs, "field Disabled is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AuthoritySignature = []string{
	1: "Type",
	2: "Signer",
	3: "Authority",
	4: "Vote",
	5: "TxID",
	6: "Delegator",
}

func (v *AuthoritySignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Signer == nil) {
		writer.WriteUrl(2, v.Signer)
	}
	if !(v.Authority == nil) {
		writer.WriteUrl(3, v.Authority)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(4, v.Vote)
	}
	if !(v.TxID == nil) {
		writer.WriteTxid(5, v.TxID)
	}
	if !(len(v.Delegator) == 0) {
		for _, v := range v.Delegator {
			writer.WriteUrl(6, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_AuthoritySignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AuthoritySignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Delegator is missing")
	} else if len(v.Delegator) == 0 {
		errs = append(errs, "field Delegator is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BTCLegacySignature = []string{
	1: "Type",
	2: "PublicKey",
	3: "Signature",
	4: "Signer",
	5: "SignerVersion",
	6: "Timestamp",
	7: "Vote",
	8: "TransactionHash",
}

func (v *BTCLegacySignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(3, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(4, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(5, v.SignerVersion)
	}
	if !(v.Timestamp == 0) {
		writer.WriteUint(6, v.Timestamp)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(8, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_BTCLegacySignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BTCLegacySignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BTCSignature = []string{
	1: "Type",
	2: "PublicKey",
	3: "Signature",
	4: "Signer",
	5: "SignerVersion",
	6: "Timestamp",
	7: "Vote",
	8: "TransactionHash",
}

func (v *BTCSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(3, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(4, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(5, v.SignerVersion)
	}
	if !(v.Timestamp == 0) {
		writer.WriteUint(6, v.Timestamp)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(8, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_BTCSignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BTCSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockEntry = []string{
	1: "Account",
	2: "Chain",
	3: "Index",
}

func (v *BlockEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(2, v.Chain)
	}
	writer.WriteUint(3, v.Index)

	_, _, err := writer.Reset(fieldNames_BlockEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Index is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockLedger = []string{
	1: "Type",
	2: "Url",
	3: "Index",
	4: "Time",
	5: "Entries",
}

func (v *BlockLedger) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.Index == 0) {
		writer.WriteUint(3, v.Index)
	}
	if !(v.Time == (time.Time{})) {
		writer.WriteTime(4, v.Time)
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(5, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_BlockLedger)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockLedger) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == (time.Time{}) {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockValidatorAnchor = []string{
	1: "Type",
	2: "PartitionAnchor",
	3: "AcmeBurnt",
}

func (v *BlockValidatorAnchor) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.PartitionAnchor.MarshalBinary)
	if !((v.AcmeBurnt).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(3, &v.AcmeBurnt)
	}

	_, _, err := writer.Reset(fieldNames_BlockValidatorAnchor)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockValidatorAnchor) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.PartitionAnchor.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field AcmeBurnt is missing")
	} else if (v.AcmeBurnt).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field AcmeBurnt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BurnTokens = []string{
	1: "Type",
	2: "Amount",
}

func (v *BurnTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(2, &v.Amount)
	}

	_, _, err := writer.Reset(fieldNames_BurnTokens)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BurnTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainMetadata = []string{
	1: "Name",
	2: "Type",
}

func (v *ChainMetadata) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}

	_, _, err := writer.Reset(fieldNames_ChainMetadata)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainMetadata) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainParams = []string{
	1: "Data",
	2: "IsUpdate",
}

func (v *ChainParams) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Data) == 0) {
		writer.WriteBytes(1, v.Data)
	}
	if !(!v.IsUpdate) {
		writer.WriteBool(2, v.IsUpdate)
	}

	_, _, err := writer.Reset(fieldNames_ChainParams)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainParams) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Data is missing")
	} else if len(v.Data) == 0 {
		errs = append(errs, "field Data is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field IsUpdate is missing")
	} else if !v.IsUpdate {
		errs = append(errs, "field IsUpdate is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateDataAccount = []string{
	1: "Type",
	2: "Url",
	3: "Authorities",
}

func (v *CreateDataAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.Authorities) == 0) {
		for _, v := range v.Authorities {
			writer.WriteUrl(3, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_CreateDataAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CreateDataAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateIdentity = []string{
	1: "Type",
	2: "Url",
	3: "KeyHash",
	4: "KeyBookUrl",
	6: "Authorities",
}

func (v *CreateIdentity) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.KeyHash) == 0) {
		writer.WriteBytes(3, v.KeyHash)
	}
	if !(v.KeyBookUrl == nil) {
		writer.WriteUrl(4, v.KeyBookUrl)
	}
	if !(len(v.Authorities) == 0) {
		for _, v := range v.Authorities {
			writer.WriteUrl(6, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_CreateIdentity)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CreateIdentity) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateKeyBook = []string{
	1: "Type",
	2: "Url",
	3: "PublicKeyHash",
	5: "Authorities",
}

func (v *CreateKeyBook) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.PublicKeyHash) == 0) {
		writer.WriteBytes(3, v.PublicKeyHash)
	}
	if !(len(v.Authorities) == 0) {
		for _, v := range v.Authorities {
			writer.WriteUrl(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_CreateKeyBook)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CreateKeyBook) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field PublicKeyHash is missing")
	} else if len(v.PublicKeyHash) == 0 {
		errs = append(errs, "field PublicKeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateKeyPage = []string{
	1: "Type",
	2: "Keys",
}

func (v *CreateKeyPage) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Keys) == 0) {
		for _, v := range v.Keys {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_CreateKeyPage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CreateKeyPage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Keys is missing")
	} else if len(v.Keys) == 0 {
		errs = append(errs, "field Keys is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateLiteTokenAccount = []string{
	1: "Type",
}

func (v *CreateLiteTokenAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_CreateLiteTokenAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CreateLiteTokenAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateToken = []string{
	1: "Type",
	2: "Url",
	4: "Symbol",
	5: "Precision",
	6: "Properties",
	7: "SupplyLimit",
	9: "Authorities",
}

func (v *CreateToken) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.Symbol) == 0) {
		writer.WriteString(4, v.Symbol)
	}
	if !(v.Precision == 0) {
		writer.WriteUint(5, v.Precision)
	}
	if !(v.Properties == nil) {
		writer.WriteUrl(6, v.Properties)
	}
	if !(v.SupplyLimit == nil) {
		writer.WriteBigInt(7, v.SupplyLimit)
	}
	if !(len(v.Authorities) == 0) {
		for _, v := range v.Authorities {
			writer.WriteUrl(9, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_CreateToken)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CreateToken) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Symbol is missing")
	} else if len(v.Symbol) == 0 {
		errs = append(errs, "field Symbol is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Precision is missing")
	} else if v.Precision == 0 {
		errs = append(errs, "field Precision is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateTokenAccount = []string{
	1: "Type",
	2: "Url",
	3: "TokenUrl",
	7: "Authorities",
	8: "Proof",
}

func (v *CreateTokenAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.TokenUrl == nil) {
		writer.WriteUrl(3, v.TokenUrl)
	}
	if !(len(v.Authorities) == 0) {
		for _, v := range v.Authorities {
			writer.WriteUrl(7, v)
		}
	}
	if !(v.Proof == nil) {
		writer.WriteValue(8, v.Proof.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_CreateTokenAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CreateTokenAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TokenUrl is missing")
	} else if v.TokenUrl == nil {
		errs = append(errs, "field TokenUrl is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DataAccount = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "Entry",
}

func (v *DataAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, v.AccountAuth.MarshalBinary)
	if !(EqualDataEntry(v.Entry, nil)) {
		writer.WriteValue(4, v.Entry.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_DataAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DataAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DelegatedSignature = []string{
	1: "Type",
	2: "Signature",
	3: "Delegator",
}

func (v *DelegatedSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(EqualSignature(v.Signature, nil)) {
		writer.WriteValue(2, v.Signature.MarshalBinary)
	}
	if !(v.Delegator == nil) {
		writer.WriteUrl(3, v.Delegator)
	}

	_, _, err := writer.Reset(fieldNames_DelegatedSignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DelegatedSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signature is missing")
	} else if EqualSignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Delegator is missing")
	} else if v.Delegator == nil {
		errs = append(errs, "field Delegator is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DirectoryAnchor = []string{
	1: "Type",
	2: "PartitionAnchor",
	3: "Updates",
	4: "Receipts",
	5: "MakeMajorBlock",
	6: "MakeMajorBlockTime",
}

func (v *DirectoryAnchor) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.PartitionAnchor.MarshalBinary)
	if !(len(v.Updates) == 0) {
		for _, v := range v.Updates {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}
	if !(len(v.Receipts) == 0) {
		for _, v := range v.Receipts {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}
	if !(v.MakeMajorBlock == 0) {
		writer.WriteUint(5, v.MakeMajorBlock)
	}
	if !(v.MakeMajorBlockTime == (time.Time{})) {
		writer.WriteTime(6, v.MakeMajorBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_DirectoryAnchor)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DirectoryAnchor) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.PartitionAnchor.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Updates is missing")
	} else if len(v.Updates) == 0 {
		errs = append(errs, "field Updates is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Receipts is missing")
	} else if len(v.Receipts) == 0 {
		errs = append(errs, "field Receipts is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field MakeMajorBlock is missing")
	} else if v.MakeMajorBlock == 0 {
		errs = append(errs, "field MakeMajorBlock is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field MakeMajorBlockTime is missing")
	} else if v.MakeMajorBlockTime == (time.Time{}) {
		errs = append(errs, "field MakeMajorBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DisableAccountAuthOperation = []string{
	1: "Type",
	2: "Authority",
}

func (v *DisableAccountAuthOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_DisableAccountAuthOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DisableAccountAuthOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ED25519Signature = []string{
	1: "Type",
	2: "PublicKey",
	3: "Signature",
	4: "Signer",
	5: "SignerVersion",
	6: "Timestamp",
	7: "Vote",
	8: "TransactionHash",
}

func (v *ED25519Signature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(3, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(4, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(5, v.SignerVersion)
	}
	if !(v.Timestamp == 0) {
		writer.WriteUint(6, v.Timestamp)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(8, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_ED25519Signature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ED25519Signature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ETHSignature = []string{
	1: "Type",
	2: "PublicKey",
	3: "Signature",
	4: "Signer",
	5: "SignerVersion",
	6: "Timestamp",
	7: "Vote",
	8: "TransactionHash",
}

func (v *ETHSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(3, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(4, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(5, v.SignerVersion)
	}
	if !(v.Timestamp == 0) {
		writer.WriteUint(6, v.Timestamp)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(8, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_ETHSignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ETHSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_EmptyResult = []string{
	1: "Type",
}

func (v *EmptyResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_EmptyResult)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *EmptyResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_EnableAccountAuthOperation = []string{
	1: "Type",
	2: "Authority",
}

func (v *EnableAccountAuthOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_EnableAccountAuthOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *EnableAccountAuthOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FactomDataEntryWrapper = []string{
	1: "Type",
	2: "FactomDataEntry",
}

func (v *FactomDataEntryWrapper) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.FactomDataEntry.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_FactomDataEntryWrapper)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FactomDataEntryWrapper) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.FactomDataEntry.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FeeSchedule = []string{
	1: "CreateIdentitySliding",
}

func (v *FeeSchedule) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.CreateIdentitySliding) == 0) {
		for _, v := range v.CreateIdentitySliding {
			writer.WriteEnum(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_FeeSchedule)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FeeSchedule) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field CreateIdentitySliding is missing")
	} else if len(v.CreateIdentitySliding) == 0 {
		errs = append(errs, "field CreateIdentitySliding is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_IndexEntry = []string{
	1: "Source",
	2: "Anchor",
	3: "BlockIndex",
	4: "BlockTime",
	5: "RootIndexIndex",
}

func (v *IndexEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Source == 0) {
		writer.WriteUint(1, v.Source)
	}
	if !(v.Anchor == 0) {
		writer.WriteUint(2, v.Anchor)
	}
	if !(v.BlockIndex == 0) {
		writer.WriteUint(3, v.BlockIndex)
	}
	if !(v.BlockTime == nil) {
		writer.WriteTime(4, *v.BlockTime)
	}
	if !(v.RootIndexIndex == 0) {
		writer.WriteUint(5, v.RootIndexIndex)
	}

	_, _, err := writer.Reset(fieldNames_IndexEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *IndexEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Source is missing")
	} else if v.Source == 0 {
		errs = append(errs, "field Source is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Anchor is missing")
	} else if v.Anchor == 0 {
		errs = append(errs, "field Anchor is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field BlockIndex is missing")
	} else if v.BlockIndex == 0 {
		errs = append(errs, "field BlockIndex is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field BlockTime is missing")
	} else if v.BlockTime == nil {
		errs = append(errs, "field BlockTime is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field RootIndexIndex is missing")
	} else if v.RootIndexIndex == 0 {
		errs = append(errs, "field RootIndexIndex is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InternalSignature = []string{
	1: "Type",
	2: "Cause",
	3: "TransactionHash",
}

func (v *InternalSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Cause == ([32]byte{})) {
		writer.WriteHash(2, &v.Cause)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(3, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_InternalSignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *InternalSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Cause is missing")
	} else if v.Cause == ([32]byte{}) {
		errs = append(errs, "field Cause is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TransactionHash is missing")
	} else if v.TransactionHash == ([32]byte{}) {
		errs = append(errs, "field TransactionHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_IssueTokens = []string{
	1: "Type",
	2: "Recipient",
	3: "Amount",
	4: "To",
}

func (v *IssueTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Recipient == nil) {
		writer.WriteUrl(2, v.Recipient)
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(3, &v.Amount)
	}
	if !(len(v.To) == 0) {
		for _, v := range v.To {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_IssueTokens)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *IssueTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Recipient is missing")
	} else if v.Recipient == nil {
		errs = append(errs, "field Recipient is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field To is missing")
	} else if len(v.To) == 0 {
		errs = append(errs, "field To is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeyBook = []string{
	1: "Type",
	2: "Url",
	3: "BookType",
	4: "AccountAuth",
	5: "PageCount",
}

func (v *KeyBook) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.BookType == 0) {
		writer.WriteEnum(3, v.BookType)
	}
	writer.WriteValue(4, v.AccountAuth.MarshalBinary)
	if !(v.PageCount == 0) {
		writer.WriteUint(5, v.PageCount)
	}

	_, _, err := writer.Reset(fieldNames_KeyBook)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *KeyBook) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field BookType is missing")
	} else if v.BookType == 0 {
		errs = append(errs, "field BookType is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field PageCount is missing")
	} else if v.PageCount == 0 {
		errs = append(errs, "field PageCount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeyPage = []string{
	1:  "Type",
	2:  "Url",
	3:  "CreditBalance",
	4:  "AcceptThreshold",
	5:  "RejectThreshold",
	6:  "ResponseThreshold",
	7:  "BlockThreshold",
	8:  "Version",
	9:  "Keys",
	10: "TransactionBlacklist",
}

func (v *KeyPage) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.CreditBalance == 0) {
		writer.WriteUint(3, v.CreditBalance)
	}
	if !(v.AcceptThreshold == 0) {
		writer.WriteUint(4, v.AcceptThreshold)
	}
	if !(v.RejectThreshold == 0) {
		writer.WriteUint(5, v.RejectThreshold)
	}
	if !(v.ResponseThreshold == 0) {
		writer.WriteUint(6, v.ResponseThreshold)
	}
	if !(v.BlockThreshold == 0) {
		writer.WriteUint(7, v.BlockThreshold)
	}
	if !(v.Version == 0) {
		writer.WriteUint(8, v.Version)
	}
	if !(len(v.Keys) == 0) {
		for _, v := range v.Keys {
			writer.WriteValue(9, v.MarshalBinary)
		}
	}
	if !(v.TransactionBlacklist == nil) {
		writer.WriteEnum(10, *v.TransactionBlacklist)
	}

	_, _, err := writer.Reset(fieldNames_KeyPage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *KeyPage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field CreditBalance is missing")
	} else if v.CreditBalance == 0 {
		errs = append(errs, "field CreditBalance is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field AcceptThreshold is missing")
	} else if v.AcceptThreshold == 0 {
		errs = append(errs, "field AcceptThreshold is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field RejectThreshold is missing")
	} else if v.RejectThreshold == 0 {
		errs = append(errs, "field RejectThreshold is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field ResponseThreshold is missing")
	} else if v.ResponseThreshold == 0 {
		errs = append(errs, "field ResponseThreshold is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field BlockThreshold is missing")
	} else if v.BlockThreshold == 0 {
		errs = append(errs, "field BlockThreshold is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field Keys is missing")
	} else if len(v.Keys) == 0 {
		errs = append(errs, "field Keys is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeySpec = []string{
	1: "PublicKeyHash",
	2: "LastUsedOn",
	3: "Delegate",
}

func (v *KeySpec) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.PublicKeyHash) == 0) {
		writer.WriteBytes(1, v.PublicKeyHash)
	}
	if !(v.LastUsedOn == 0) {
		writer.WriteUint(2, v.LastUsedOn)
	}
	if !(v.Delegate == nil) {
		writer.WriteUrl(3, v.Delegate)
	}

	_, _, err := writer.Reset(fieldNames_KeySpec)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *KeySpec) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field PublicKeyHash is missing")
	} else if len(v.PublicKeyHash) == 0 {
		errs = append(errs, "field PublicKeyHash is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field LastUsedOn is missing")
	} else if v.LastUsedOn == 0 {
		errs = append(errs, "field LastUsedOn is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Delegate is missing")
	} else if v.Delegate == nil {
		errs = append(errs, "field Delegate is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeySpecParams = []string{
	1: "KeyHash",
	2: "Delegate",
}

func (v *KeySpecParams) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.KeyHash) == 0) {
		writer.WriteBytes(1, v.KeyHash)
	}
	if !(v.Delegate == nil) {
		writer.WriteUrl(2, v.Delegate)
	}

	_, _, err := writer.Reset(fieldNames_KeySpecParams)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *KeySpecParams) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field KeyHash is missing")
	} else if len(v.KeyHash) == 0 {
		errs = append(errs, "field KeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LegacyED25519Signature = []string{
	1: "Type",
	2: "Timestamp",
	3: "PublicKey",
	4: "Signature",
	5: "Signer",
	6: "SignerVersion",
	7: "Vote",
	8: "TransactionHash",
}

func (v *LegacyED25519Signature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Timestamp == 0) {
		writer.WriteUint(2, v.Timestamp)
	}
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(3, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(4, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(5, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(6, v.SignerVersion)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(8, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_LegacyED25519Signature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LegacyED25519Signature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Timestamp is missing")
	} else if v.Timestamp == 0 {
		errs = append(errs, "field Timestamp is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LiteDataAccount = []string{
	1: "Type",
	2: "Url",
}

func (v *LiteDataAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}

	_, _, err := writer.Reset(fieldNames_LiteDataAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LiteDataAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LiteIdentity = []string{
	1: "Type",
	2: "Url",
	3: "CreditBalance",
	4: "LastUsedOn",
}

func (v *LiteIdentity) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.CreditBalance == 0) {
		writer.WriteUint(3, v.CreditBalance)
	}
	if !(v.LastUsedOn == 0) {
		writer.WriteUint(4, v.LastUsedOn)
	}

	_, _, err := writer.Reset(fieldNames_LiteIdentity)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LiteIdentity) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field CreditBalance is missing")
	} else if v.CreditBalance == 0 {
		errs = append(errs, "field CreditBalance is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field LastUsedOn is missing")
	} else if v.LastUsedOn == 0 {
		errs = append(errs, "field LastUsedOn is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LiteTokenAccount = []string{
	1: "Type",
	2: "Url",
	3: "TokenUrl",
	4: "Balance",
	5: "LockHeight",
}

func (v *LiteTokenAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.TokenUrl == nil) {
		writer.WriteUrl(3, v.TokenUrl)
	}
	if !((v.Balance).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(4, &v.Balance)
	}
	if !(v.LockHeight == 0) {
		writer.WriteUint(5, v.LockHeight)
	}

	_, _, err := writer.Reset(fieldNames_LiteTokenAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LiteTokenAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TokenUrl is missing")
	} else if v.TokenUrl == nil {
		errs = append(errs, "field TokenUrl is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Balance is missing")
	} else if (v.Balance).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Balance is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field LockHeight is missing")
	} else if v.LockHeight == 0 {
		errs = append(errs, "field LockHeight is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LockAccount = []string{
	1: "Type",
	2: "Height",
}

func (v *LockAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Height == 0) {
		writer.WriteUint(2, v.Height)
	}

	_, _, err := writer.Reset(fieldNames_LockAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LockAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MetricsRequest = []string{
	1: "Metric",
	2: "Duration",
}

func (v *MetricsRequest) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Metric) == 0) {
		writer.WriteString(1, v.Metric)
	}
	if !(v.Duration == 0) {
		writer.WriteDuration(2, v.Duration)
	}

	_, _, err := writer.Reset(fieldNames_MetricsRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MetricsRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Metric is missing")
	} else if len(v.Metric) == 0 {
		errs = append(errs, "field Metric is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Duration is missing")
	} else if v.Duration == 0 {
		errs = append(errs, "field Duration is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkAccountUpdate = []string{
	1: "Name",
	2: "Body",
}

func (v *NetworkAccountUpdate) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(EqualTransactionBody(v.Body, nil)) {
		writer.WriteValue(2, v.Body.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_NetworkAccountUpdate)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkAccountUpdate) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Body is missing")
	} else if EqualTransactionBody(v.Body, nil) {
		errs = append(errs, "field Body is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkDefinition = []string{
	1: "NetworkName",
	2: "Version",
	3: "Partitions",
	4: "Validators",
}

func (v *NetworkDefinition) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.NetworkName) == 0) {
		writer.WriteString(1, v.NetworkName)
	}
	if !(v.Version == 0) {
		writer.WriteUint(2, v.Version)
	}
	if !(len(v.Partitions) == 0) {
		for _, v := range v.Partitions {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}
	if !(len(v.Validators) == 0) {
		for _, v := range v.Validators {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_NetworkDefinition)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkDefinition) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field NetworkName is missing")
	} else if len(v.NetworkName) == 0 {
		errs = append(errs, "field NetworkName is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Partitions is missing")
	} else if len(v.Partitions) == 0 {
		errs = append(errs, "field Partitions is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Validators is missing")
	} else if len(v.Validators) == 0 {
		errs = append(errs, "field Validators is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkGlobals = []string{
	1: "OperatorAcceptThreshold",
	2: "ValidatorAcceptThreshold",
	3: "MajorBlockSchedule",
	4: "AnchorEmptyBlocks",
	5: "FeeSchedule",
	6: "Limits",
}

func (v *NetworkGlobals) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !((v.OperatorAcceptThreshold).Equal(new(Rational))) {
		writer.WriteValue(1, v.OperatorAcceptThreshold.MarshalBinary)
	}
	if !((v.ValidatorAcceptThreshold).Equal(new(Rational))) {
		writer.WriteValue(2, v.ValidatorAcceptThreshold.MarshalBinary)
	}
	if !(len(v.MajorBlockSchedule) == 0) {
		writer.WriteString(3, v.MajorBlockSchedule)
	}
	if !(!v.AnchorEmptyBlocks) {
		writer.WriteBool(4, v.AnchorEmptyBlocks)
	}
	if !(v.FeeSchedule == nil) {
		writer.WriteValue(5, v.FeeSchedule.MarshalBinary)
	}
	if !(v.Limits == nil) {
		writer.WriteValue(6, v.Limits.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_NetworkGlobals)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkGlobals) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field OperatorAcceptThreshold is missing")
	} else if (v.OperatorAcceptThreshold).Equal(new(Rational)) {
		errs = append(errs, "field OperatorAcceptThreshold is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field ValidatorAcceptThreshold is missing")
	} else if (v.ValidatorAcceptThreshold).Equal(new(Rational)) {
		errs = append(errs, "field ValidatorAcceptThreshold is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field MajorBlockSchedule is missing")
	} else if len(v.MajorBlockSchedule) == 0 {
		errs = append(errs, "field MajorBlockSchedule is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field AnchorEmptyBlocks is missing")
	} else if !v.AnchorEmptyBlocks {
		errs = append(errs, "field AnchorEmptyBlocks is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field FeeSchedule is missing")
	} else if v.FeeSchedule == nil {
		errs = append(errs, "field FeeSchedule is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Limits is missing")
	} else if v.Limits == nil {
		errs = append(errs, "field Limits is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkLimits = []string{
	1: "DataEntryParts",
	2: "AccountAuthorities",
	3: "BookPages",
	4: "PageEntries",
	5: "IdentityAccounts",
}

func (v *NetworkLimits) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.DataEntryParts == 0) {
		writer.WriteUint(1, v.DataEntryParts)
	}
	if !(v.AccountAuthorities == 0) {
		writer.WriteUint(2, v.AccountAuthorities)
	}
	if !(v.BookPages == 0) {
		writer.WriteUint(3, v.BookPages)
	}
	if !(v.PageEntries == 0) {
		writer.WriteUint(4, v.PageEntries)
	}
	if !(v.IdentityAccounts == 0) {
		writer.WriteUint(5, v.IdentityAccounts)
	}

	_, _, err := writer.Reset(fieldNames_NetworkLimits)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkLimits) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field DataEntryParts is missing")
	} else if v.DataEntryParts == 0 {
		errs = append(errs, "field DataEntryParts is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field AccountAuthorities is missing")
	} else if v.AccountAuthorities == 0 {
		errs = append(errs, "field AccountAuthorities is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field BookPages is missing")
	} else if v.BookPages == 0 {
		errs = append(errs, "field BookPages is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field PageEntries is missing")
	} else if v.PageEntries == 0 {
		errs = append(errs, "field PageEntries is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field IdentityAccounts is missing")
	} else if v.IdentityAccounts == 0 {
		errs = append(errs, "field IdentityAccounts is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Object = []string{
	1: "Type",
	2: "Chains",
	3: "Pending",
}

func (v *Object) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	if !(len(v.Chains) == 0) {
		for _, v := range v.Chains {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	if !((v.Pending).Equal(new(TxIdSet))) {
		writer.WriteValue(3, v.Pending.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_Object)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Object) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Chains is missing")
	} else if len(v.Chains) == 0 {
		errs = append(errs, "field Chains is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Pending is missing")
	} else if (v.Pending).Equal(new(TxIdSet)) {
		errs = append(errs, "field Pending is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PartitionAnchor = []string{
	1: "Source",
	2: "MajorBlockIndex",
	3: "MinorBlockIndex",
	4: "RootChainIndex",
	5: "RootChainAnchor",
	6: "StateTreeAnchor",
}

func (v *PartitionAnchor) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Source == nil) {
		writer.WriteUrl(1, v.Source)
	}
	if !(v.MajorBlockIndex == 0) {
		writer.WriteUint(2, v.MajorBlockIndex)
	}
	if !(v.MinorBlockIndex == 0) {
		writer.WriteUint(3, v.MinorBlockIndex)
	}
	if !(v.RootChainIndex == 0) {
		writer.WriteUint(4, v.RootChainIndex)
	}
	if !(v.RootChainAnchor == ([32]byte{})) {
		writer.WriteHash(5, &v.RootChainAnchor)
	}
	if !(v.StateTreeAnchor == ([32]byte{})) {
		writer.WriteHash(6, &v.StateTreeAnchor)
	}

	_, _, err := writer.Reset(fieldNames_PartitionAnchor)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PartitionAnchor) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Source is missing")
	} else if v.Source == nil {
		errs = append(errs, "field Source is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field MajorBlockIndex is missing")
	} else if v.MajorBlockIndex == 0 {
		errs = append(errs, "field MajorBlockIndex is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field MinorBlockIndex is missing")
	} else if v.MinorBlockIndex == 0 {
		errs = append(errs, "field MinorBlockIndex is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field RootChainIndex is missing")
	} else if v.RootChainIndex == 0 {
		errs = append(errs, "field RootChainIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field RootChainAnchor is missing")
	} else if v.RootChainAnchor == ([32]byte{}) {
		errs = append(errs, "field RootChainAnchor is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field StateTreeAnchor is missing")
	} else if v.StateTreeAnchor == ([32]byte{}) {
		errs = append(errs, "field StateTreeAnchor is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PartitionAnchorReceipt = []string{
	1: "Anchor",
	2: "RootChainReceipt",
}

func (v *PartitionAnchorReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Anchor == nil) {
		writer.WriteValue(1, v.Anchor.MarshalBinary)
	}
	if !(v.RootChainReceipt == nil) {
		writer.WriteValue(2, v.RootChainReceipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_PartitionAnchorReceipt)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PartitionAnchorReceipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Anchor is missing")
	} else if v.Anchor == nil {
		errs = append(errs, "field Anchor is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RootChainReceipt is missing")
	} else if v.RootChainReceipt == nil {
		errs = append(errs, "field RootChainReceipt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PartitionInfo = []string{
	1: "ID",
	2: "Type",
}

func (v *PartitionInfo) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.ID) == 0) {
		writer.WriteString(1, v.ID)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}

	_, _, err := writer.Reset(fieldNames_PartitionInfo)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PartitionInfo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field ID is missing")
	} else if len(v.ID) == 0 {
		errs = append(errs, "field ID is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PartitionSignature = []string{
	1: "Type",
	2: "SourceNetwork",
	3: "DestinationNetwork",
	4: "SequenceNumber",
	5: "TransactionHash",
}

func (v *PartitionSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.SourceNetwork == nil) {
		writer.WriteUrl(2, v.SourceNetwork)
	}
	if !(v.DestinationNetwork == nil) {
		writer.WriteUrl(3, v.DestinationNetwork)
	}
	if !(v.SequenceNumber == 0) {
		writer.WriteUint(4, v.SequenceNumber)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(5, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_PartitionSignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PartitionSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field SourceNetwork is missing")
	} else if v.SourceNetwork == nil {
		errs = append(errs, "field SourceNetwork is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field DestinationNetwork is missing")
	} else if v.DestinationNetwork == nil {
		errs = append(errs, "field DestinationNetwork is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field SequenceNumber is missing")
	} else if v.SequenceNumber == 0 {
		errs = append(errs, "field SequenceNumber is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PartitionSyntheticLedger = []string{
	1: "Url",
	2: "Produced",
	3: "Received",
	4: "Delivered",
	5: "Pending",
}

func (v *PartitionSyntheticLedger) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(v.Produced == 0) {
		writer.WriteUint(2, v.Produced)
	}
	if !(v.Received == 0) {
		writer.WriteUint(3, v.Received)
	}
	if !(v.Delivered == 0) {
		writer.WriteUint(4, v.Delivered)
	}
	if !(len(v.Pending) == 0) {
		for _, v := range v.Pending {
			writer.WriteTxid(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_PartitionSyntheticLedger)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PartitionSyntheticLedger) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Produced is missing")
	} else if v.Produced == 0 {
		errs = append(errs, "field Produced is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Received is missing")
	} else if v.Received == 0 {
		errs = append(errs, "field Received is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Delivered is missing")
	} else if v.Delivered == 0 {
		errs = append(errs, "field Delivered is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Pending is missing")
	} else if len(v.Pending) == 0 {
		errs = append(errs, "field Pending is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PlaceholderTransaction = []string{
	1: "Type",
}

func (v *PlaceholderTransaction) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_PlaceholderTransaction)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PlaceholderTransaction) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RCD1Signature = []string{
	1: "Type",
	2: "PublicKey",
	3: "Signature",
	4: "Signer",
	5: "SignerVersion",
	6: "Timestamp",
	7: "Vote",
	8: "TransactionHash",
}

func (v *RCD1Signature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(3, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(4, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(5, v.SignerVersion)
	}
	if !(v.Timestamp == 0) {
		writer.WriteUint(6, v.Timestamp)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(8, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_RCD1Signature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RCD1Signature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Rational = []string{
	1: "Numerator",
	2: "Denominator",
}

func (v *Rational) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Numerator == 0) {
		writer.WriteUint(1, v.Numerator)
	}
	if !(v.Denominator == 0) {
		writer.WriteUint(2, v.Denominator)
	}

	_, _, err := writer.Reset(fieldNames_Rational)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Rational) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Numerator is missing")
	} else if v.Numerator == 0 {
		errs = append(errs, "field Numerator is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Denominator is missing")
	} else if v.Denominator == 0 {
		errs = append(errs, "field Denominator is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ReceiptSignature = []string{
	1: "Type",
	2: "SourceNetwork",
	3: "Proof",
	4: "TransactionHash",
}

func (v *ReceiptSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.SourceNetwork == nil) {
		writer.WriteUrl(2, v.SourceNetwork)
	}
	if !((v.Proof).Equal(new(merkle.Receipt))) {
		writer.WriteValue(3, v.Proof.MarshalBinary)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(4, &v.TransactionHash)
	}

	_, _, err := writer.Reset(fieldNames_ReceiptSignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ReceiptSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field SourceNetwork is missing")
	} else if v.SourceNetwork == nil {
		errs = append(errs, "field SourceNetwork is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Proof is missing")
	} else if (v.Proof).Equal(new(merkle.Receipt)) {
		errs = append(errs, "field Proof is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RemoteSignature = []string{
	1: "Type",
	2: "Destination",
	3: "Signature",
	4: "Cause",
}

func (v *RemoteSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Destination == nil) {
		writer.WriteUrl(2, v.Destination)
	}
	if !(EqualSignature(v.Signature, nil)) {
		writer.WriteValue(3, v.Signature.MarshalBinary)
	}
	if !(len(v.Cause) == 0) {
		for _, v := range v.Cause {
			writer.WriteHash(4, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_RemoteSignature)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RemoteSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Destination is missing")
	} else if v.Destination == nil {
		errs = append(errs, "field Destination is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if EqualSignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Cause is missing")
	} else if len(v.Cause) == 0 {
		errs = append(errs, "field Cause is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RemoteTransaction = []string{
	1: "Type",
	2: "Hash",
}

func (v *RemoteTransaction) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(2, &v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_RemoteTransaction)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RemoteTransaction) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RemoveAccountAuthorityOperation = []string{
	1: "Type",
	2: "Authority",
}

func (v *RemoveAccountAuthorityOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_RemoveAccountAuthorityOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RemoveAccountAuthorityOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RemoveKeyOperation = []string{
	1: "Type",
	2: "Entry",
}

func (v *RemoveKeyOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Entry).Equal(new(KeySpecParams))) {
		writer.WriteValue(2, v.Entry.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_RemoveKeyOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RemoveKeyOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(KeySpecParams)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Route = []string{
	1: "Length",
	2: "Value",
	3: "Partition",
}

func (v *Route) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Length == 0) {
		writer.WriteUint(1, v.Length)
	}
	if !(v.Value == 0) {
		writer.WriteUint(2, v.Value)
	}
	if !(len(v.Partition) == 0) {
		writer.WriteString(3, v.Partition)
	}

	_, _, err := writer.Reset(fieldNames_Route)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Route) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Length is missing")
	} else if v.Length == 0 {
		errs = append(errs, "field Length is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == 0 {
		errs = append(errs, "field Value is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Partition is missing")
	} else if len(v.Partition) == 0 {
		errs = append(errs, "field Partition is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RouteOverride = []string{
	1: "Account",
	2: "Partition",
}

func (v *RouteOverride) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Partition) == 0) {
		writer.WriteString(2, v.Partition)
	}

	_, _, err := writer.Reset(fieldNames_RouteOverride)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RouteOverride) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Partition is missing")
	} else if len(v.Partition) == 0 {
		errs = append(errs, "field Partition is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RoutingTable = []string{
	1: "Overrides",
	2: "Routes",
}

func (v *RoutingTable) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Overrides) == 0) {
		for _, v := range v.Overrides {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}
	if !(len(v.Routes) == 0) {
		for _, v := range v.Routes {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_RoutingTable)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RoutingTable) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Overrides is missing")
	} else if len(v.Overrides) == 0 {
		errs = append(errs, "field Overrides is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Routes is missing")
	} else if len(v.Routes) == 0 {
		errs = append(errs, "field Routes is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SendTokens = []string{
	1: "Type",
	2: "Hash",
	3: "Meta",
	4: "To",
}

func (v *SendTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(2, &v.Hash)
	}
	if !(len(v.Meta) == 0) {
		writer.WriteBytes(3, v.Meta)
	}
	if !(len(v.To) == 0) {
		for _, v := range v.To {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_SendTokens)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SendTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field To is missing")
	} else if len(v.To) == 0 {
		errs = append(errs, "field To is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SetThresholdKeyPageOperation = []string{
	1: "Type",
	2: "Threshold",
}

func (v *SetThresholdKeyPageOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Threshold == 0) {
		writer.WriteUint(2, v.Threshold)
	}

	_, _, err := writer.Reset(fieldNames_SetThresholdKeyPageOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SetThresholdKeyPageOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Threshold is missing")
	} else if v.Threshold == 0 {
		errs = append(errs, "field Threshold is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SignatureSet = []string{
	1: "Type",
	2: "Vote",
	3: "Signer",
	4: "TransactionHash",
	5: "Signatures",
	6: "Authority",
}

func (v *SignatureSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Vote == 0) {
		writer.WriteEnum(2, v.Vote)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(3, v.Signer)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(4, &v.TransactionHash)
	}
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(5, v.MarshalBinary)
		}
	}
	if !(v.Authority == nil) {
		writer.WriteUrl(6, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_SignatureSet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SignatureSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticBurnTokens = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Amount",
	4: "IsRefund",
}

func (v *SyntheticBurnTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.SyntheticOrigin.MarshalBinary)
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(3, &v.Amount)
	}
	if !(!v.IsRefund) {
		writer.WriteBool(4, v.IsRefund)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticBurnTokens)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticBurnTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field IsRefund is missing")
	} else if !v.IsRefund {
		errs = append(errs, "field IsRefund is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticCreateIdentity = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Accounts",
}

func (v *SyntheticCreateIdentity) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.SyntheticOrigin.MarshalBinary)
	if !(len(v.Accounts) == 0) {
		for _, v := range v.Accounts {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_SyntheticCreateIdentity)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticCreateIdentity) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Accounts is missing")
	} else if len(v.Accounts) == 0 {
		errs = append(errs, "field Accounts is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticDepositCredits = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Amount",
	4: "AcmeRefundAmount",
	5: "IsRefund",
}

func (v *SyntheticDepositCredits) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.SyntheticOrigin.MarshalBinary)
	if !(v.Amount == 0) {
		writer.WriteUint(3, v.Amount)
	}
	if !(v.AcmeRefundAmount == nil) {
		writer.WriteBigInt(4, v.AcmeRefundAmount)
	}
	if !(!v.IsRefund) {
		writer.WriteBool(5, v.IsRefund)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticDepositCredits)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticDepositCredits) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Amount is missing")
	} else if v.Amount == 0 {
		errs = append(errs, "field Amount is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field AcmeRefundAmount is missing")
	} else if v.AcmeRefundAmount == nil {
		errs = append(errs, "field AcmeRefundAmount is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field IsRefund is missing")
	} else if !v.IsRefund {
		errs = append(errs, "field IsRefund is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticDepositTokens = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Token",
	4: "Amount",
	5: "IsIssuer",
	6: "IsRefund",
}

func (v *SyntheticDepositTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.SyntheticOrigin.MarshalBinary)
	if !(v.Token == nil) {
		writer.WriteUrl(3, v.Token)
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(4, &v.Amount)
	}
	if !(!v.IsIssuer) {
		writer.WriteBool(5, v.IsIssuer)
	}
	if !(!v.IsRefund) {
		writer.WriteBool(6, v.IsRefund)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticDepositTokens)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticDepositTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Token is missing")
	} else if v.Token == nil {
		errs = append(errs, "field Token is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field IsIssuer is missing")
	} else if !v.IsIssuer {
		errs = append(errs, "field IsIssuer is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field IsRefund is missing")
	} else if !v.IsRefund {
		errs = append(errs, "field IsRefund is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticForwardTransaction = []string{
	1: "Type",
	2: "Signatures",
	3: "Transaction",
}

func (v *SyntheticForwardTransaction) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	if !(v.Transaction == nil) {
		writer.WriteValue(3, v.Transaction.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticForwardTransaction)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticForwardTransaction) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticLedger = []string{
	1: "Type",
	2: "Url",
	3: "Sequence",
}

func (v *SyntheticLedger) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.Sequence) == 0) {
		for _, v := range v.Sequence {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_SyntheticLedger)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticLedger) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Sequence is missing")
	} else if len(v.Sequence) == 0 {
		errs = append(errs, "field Sequence is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticOrigin = []string{
	1: "Cause",
	3: "Initiator",
	4: "FeeRefund",
}

func (v *SyntheticOrigin) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Cause == nil) {
		writer.WriteTxid(1, v.Cause)
	}
	if !(v.Initiator == nil) {
		writer.WriteUrl(3, v.Initiator)
	}
	if !(v.FeeRefund == 0) {
		writer.WriteUint(4, v.FeeRefund)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticOrigin)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticOrigin) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Cause is missing")
	} else if v.Cause == nil {
		errs = append(errs, "field Cause is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Initiator is missing")
	} else if v.Initiator == nil {
		errs = append(errs, "field Initiator is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field FeeRefund is missing")
	} else if v.FeeRefund == 0 {
		errs = append(errs, "field FeeRefund is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticWriteData = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Entry",
}

func (v *SyntheticWriteData) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.SyntheticOrigin.MarshalBinary)
	if !(EqualDataEntry(v.Entry, nil)) {
		writer.WriteValue(3, v.Entry.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticWriteData)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticWriteData) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if EqualDataEntry(v.Entry, nil) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SystemGenesis = []string{
	1: "Type",
}

func (v *SystemGenesis) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_SystemGenesis)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SystemGenesis) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SystemLedger = []string{
	1: "Type",
	2: "Url",
	3: "Index",
	4: "Timestamp",
	5: "AcmeBurnt",
	6: "PendingUpdates",
	7: "Anchor",
	8: "ExecutorVersion",
}

func (v *SystemLedger) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.Index == 0) {
		writer.WriteUint(3, v.Index)
	}
	if !(v.Timestamp == (time.Time{})) {
		writer.WriteTime(4, v.Timestamp)
	}
	if !((v.AcmeBurnt).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(5, &v.AcmeBurnt)
	}
	if !(len(v.PendingUpdates) == 0) {
		for _, v := range v.PendingUpdates {
			writer.WriteValue(6, v.MarshalBinary)
		}
	}
	if !(EqualAnchorBody(v.Anchor, nil)) {
		writer.WriteValue(7, v.Anchor.MarshalBinary)
	}
	if !(v.ExecutorVersion == 0) {
		writer.WriteEnum(8, v.ExecutorVersion)
	}

	_, _, err := writer.Reset(fieldNames_SystemLedger)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SystemLedger) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Timestamp is missing")
	} else if v.Timestamp == (time.Time{}) {
		errs = append(errs, "field Timestamp is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field AcmeBurnt is missing")
	} else if (v.AcmeBurnt).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field AcmeBurnt is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field PendingUpdates is missing")
	} else if len(v.PendingUpdates) == 0 {
		errs = append(errs, "field PendingUpdates is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Anchor is missing")
	} else if EqualAnchorBody(v.Anchor, nil) {
		errs = append(errs, "field Anchor is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SystemWriteData = []string{
	1: "Type",
	2: "Entry",
	3: "WriteToState",
}

func (v *SystemWriteData) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(EqualDataEntry(v.Entry, nil)) {
		writer.WriteValue(2, v.Entry.MarshalBinary)
	}
	if !(!v.WriteToState) {
		writer.WriteBool(3, v.WriteToState)
	}

	_, _, err := writer.Reset(fieldNames_SystemWriteData)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SystemWriteData) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Entry is missing")
	} else if EqualDataEntry(v.Entry, nil) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TokenAccount = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "TokenUrl",
	5: "Balance",
}

func (v *TokenAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, v.AccountAuth.MarshalBinary)
	if !(v.TokenUrl == nil) {
		writer.WriteUrl(4, v.TokenUrl)
	}
	if !((v.Balance).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(5, &v.Balance)
	}

	_, _, err := writer.Reset(fieldNames_TokenAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TokenAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field TokenUrl is missing")
	} else if v.TokenUrl == nil {
		errs = append(errs, "field TokenUrl is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Balance is missing")
	} else if (v.Balance).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Balance is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TokenIssuer = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "Symbol",
	5: "Precision",
	6: "Properties",
	7: "Issued",
	8: "SupplyLimit",
}

func (v *TokenIssuer) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, v.AccountAuth.MarshalBinary)
	if !(len(v.Symbol) == 0) {
		writer.WriteString(4, v.Symbol)
	}
	if !(v.Precision == 0) {
		writer.WriteUint(5, v.Precision)
	}
	if !(v.Properties == nil) {
		writer.WriteUrl(6, v.Properties)
	}
	if !((v.Issued).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(7, &v.Issued)
	}
	if !(v.SupplyLimit == nil) {
		writer.WriteBigInt(8, v.SupplyLimit)
	}

	_, _, err := writer.Reset(fieldNames_TokenIssuer)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TokenIssuer) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Symbol is missing")
	} else if len(v.Symbol) == 0 {
		errs = append(errs, "field Symbol is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Precision is missing")
	} else if v.Precision == 0 {
		errs = append(errs, "field Precision is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Properties is missing")
	} else if v.Properties == nil {
		errs = append(errs, "field Properties is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Issued is missing")
	} else if (v.Issued).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Issued is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TokenIssuerProof = []string{
	1: "Transaction",
	2: "Receipt",
}

func (v *TokenIssuerProof) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Transaction == nil) {
		writer.WriteValue(1, v.Transaction.MarshalBinary)
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(2, v.Receipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_TokenIssuerProof)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TokenIssuerProof) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == nil {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Receipt is missing")
	} else if v.Receipt == nil {
		errs = append(errs, "field Receipt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TokenRecipient = []string{
	1: "Url",
	2: "Amount",
}

func (v *TokenRecipient) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(2, &v.Amount)
	}

	_, _, err := writer.Reset(fieldNames_TokenRecipient)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TokenRecipient) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Transaction = []string{
	1: "Header",
	2: "Body",
}

func (v *Transaction) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !((v.Header).Equal(new(TransactionHeader))) {
		writer.WriteValue(1, v.Header.MarshalBinary)
	}
	if !(EqualTransactionBody(v.Body, nil)) {
		writer.WriteValue(2, v.Body.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_Transaction)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Transaction) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Header is missing")
	} else if (v.Header).Equal(new(TransactionHeader)) {
		errs = append(errs, "field Header is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Body is missing")
	} else if EqualTransactionBody(v.Body, nil) {
		errs = append(errs, "field Body is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionHeader = []string{
	1: "Principal",
	2: "Initiator",
	3: "Memo",
	4: "Metadata",
}

func (v *TransactionHeader) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Principal == nil) {
		writer.WriteUrl(1, v.Principal)
	}
	if !(v.Initiator == ([32]byte{})) {
		writer.WriteHash(2, &v.Initiator)
	}
	if !(len(v.Memo) == 0) {
		writer.WriteString(3, v.Memo)
	}
	if !(len(v.Metadata) == 0) {
		writer.WriteBytes(4, v.Metadata)
	}

	_, _, err := writer.Reset(fieldNames_TransactionHeader)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TransactionHeader) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Principal is missing")
	} else if v.Principal == nil {
		errs = append(errs, "field Principal is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Initiator is missing")
	} else if v.Initiator == ([32]byte{}) {
		errs = append(errs, "field Initiator is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionResultSet = []string{
	1: "Results",
}

func (v *TransactionResultSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Results) == 0) {
		for _, v := range v.Results {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_TransactionResultSet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TransactionResultSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Results is missing")
	} else if len(v.Results) == 0 {
		errs = append(errs, "field Results is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionStatus = []string{
	1:  "TxID",
	2:  "Code",
	3:  "Error",
	4:  "Result",
	5:  "Received",
	6:  "Initiator",
	7:  "Signers",
	8:  "SourceNetwork",
	9:  "DestinationNetwork",
	10: "SequenceNumber",
	11: "GotDirectoryReceipt",
	12: "Proof",
	13: "AnchorSigners",
}

func (v *TransactionStatus) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.TxID == nil) {
		writer.WriteTxid(1, v.TxID)
	}
	if !(v.Code == 0) {
		writer.WriteEnum(2, v.Code)
	}
	if !(v.Error == nil) {
		writer.WriteValue(3, v.Error.MarshalBinary)
	}
	if !(EqualTransactionResult(v.Result, nil)) {
		writer.WriteValue(4, v.Result.MarshalBinary)
	}
	if !(v.Received == 0) {
		writer.WriteUint(5, v.Received)
	}
	if !(v.Initiator == nil) {
		writer.WriteUrl(6, v.Initiator)
	}
	if !(len(v.Signers) == 0) {
		for _, v := range v.Signers {
			writer.WriteValue(7, v.MarshalBinary)
		}
	}
	if !(v.SourceNetwork == nil) {
		writer.WriteUrl(8, v.SourceNetwork)
	}
	if !(v.DestinationNetwork == nil) {
		writer.WriteUrl(9, v.DestinationNetwork)
	}
	if !(v.SequenceNumber == 0) {
		writer.WriteUint(10, v.SequenceNumber)
	}
	if !(!v.GotDirectoryReceipt) {
		writer.WriteBool(11, v.GotDirectoryReceipt)
	}
	if !(v.Proof == nil) {
		writer.WriteValue(12, v.Proof.MarshalBinary)
	}
	if !(len(v.AnchorSigners) == 0) {
		for _, v := range v.AnchorSigners {
			writer.WriteBytes(13, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_TransactionStatus)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TransactionStatus) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Code is missing")
	} else if v.Code == 0 {
		errs = append(errs, "field Code is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Error is missing")
	} else if v.Error == nil {
		errs = append(errs, "field Error is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Result is missing")
	} else if EqualTransactionResult(v.Result, nil) {
		errs = append(errs, "field Result is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Received is missing")
	} else if v.Received == 0 {
		errs = append(errs, "field Received is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Initiator is missing")
	} else if v.Initiator == nil {
		errs = append(errs, "field Initiator is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Signers is missing")
	} else if len(v.Signers) == 0 {
		errs = append(errs, "field Signers is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field SourceNetwork is missing")
	} else if v.SourceNetwork == nil {
		errs = append(errs, "field SourceNetwork is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field DestinationNetwork is missing")
	} else if v.DestinationNetwork == nil {
		errs = append(errs, "field DestinationNetwork is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field SequenceNumber is missing")
	} else if v.SequenceNumber == 0 {
		errs = append(errs, "field SequenceNumber is not set")
	}
	if len(v.fieldsSet) > 10 && !v.fieldsSet[10] {
		errs = append(errs, "field GotDirectoryReceipt is missing")
	} else if !v.GotDirectoryReceipt {
		errs = append(errs, "field GotDirectoryReceipt is not set")
	}
	if len(v.fieldsSet) > 11 && !v.fieldsSet[11] {
		errs = append(errs, "field Proof is missing")
	} else if v.Proof == nil {
		errs = append(errs, "field Proof is not set")
	}
	if len(v.fieldsSet) > 12 && !v.fieldsSet[12] {
		errs = append(errs, "field AnchorSigners is missing")
	} else if len(v.AnchorSigners) == 0 {
		errs = append(errs, "field AnchorSigners is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TxIdSet = []string{
	1: "Entries",
}

func (v *TxIdSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteTxid(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_TxIdSet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TxIdSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UnknownAccount = []string{
	1: "Type",
	2: "Url",
}

func (v *UnknownAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}

	_, _, err := writer.Reset(fieldNames_UnknownAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UnknownAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UnknownSigner = []string{
	1: "Type",
	2: "Url",
	3: "Version",
}

func (v *UnknownSigner) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.Version == 0) {
		writer.WriteUint(3, v.Version)
	}

	_, _, err := writer.Reset(fieldNames_UnknownSigner)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UnknownSigner) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateAccountAuth = []string{
	1: "Type",
	2: "Operations",
}

func (v *UpdateAccountAuth) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Operations) == 0) {
		for _, v := range v.Operations {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_UpdateAccountAuth)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UpdateAccountAuth) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Operations is missing")
	} else if len(v.Operations) == 0 {
		errs = append(errs, "field Operations is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateAllowedKeyPageOperation = []string{
	1: "Type",
	2: "Allow",
	3: "Deny",
}

func (v *UpdateAllowedKeyPageOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Allow) == 0) {
		for _, v := range v.Allow {
			writer.WriteEnum(2, v)
		}
	}
	if !(len(v.Deny) == 0) {
		for _, v := range v.Deny {
			writer.WriteEnum(3, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_UpdateAllowedKeyPageOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UpdateAllowedKeyPageOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateKey = []string{
	1: "Type",
	2: "NewKeyHash",
}

func (v *UpdateKey) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.NewKeyHash) == 0) {
		writer.WriteBytes(2, v.NewKeyHash)
	}

	_, _, err := writer.Reset(fieldNames_UpdateKey)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UpdateKey) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field NewKeyHash is missing")
	} else if len(v.NewKeyHash) == 0 {
		errs = append(errs, "field NewKeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateKeyOperation = []string{
	1: "Type",
	2: "OldEntry",
	3: "NewEntry",
}

func (v *UpdateKeyOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.OldEntry).Equal(new(KeySpecParams))) {
		writer.WriteValue(2, v.OldEntry.MarshalBinary)
	}
	if !((v.NewEntry).Equal(new(KeySpecParams))) {
		writer.WriteValue(3, v.NewEntry.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_UpdateKeyOperation)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UpdateKeyOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field OldEntry is missing")
	} else if (v.OldEntry).Equal(new(KeySpecParams)) {
		errs = append(errs, "field OldEntry is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field NewEntry is missing")
	} else if (v.NewEntry).Equal(new(KeySpecParams)) {
		errs = append(errs, "field NewEntry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateKeyPage = []string{
	1: "Type",
	2: "Operation",
}

func (v *UpdateKeyPage) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Operation) == 0) {
		for _, v := range v.Operation {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_UpdateKeyPage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UpdateKeyPage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Operation is missing")
	} else if len(v.Operation) == 0 {
		errs = append(errs, "field Operation is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ValidatorInfo = []string{
	1: "PublicKey",
	2: "PublicKeyHash",
	3: "Operator",
	4: "Partitions",
}

func (v *ValidatorInfo) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(1, v.PublicKey)
	}
	if !(v.PublicKeyHash == ([32]byte{})) {
		writer.WriteHash(2, &v.PublicKeyHash)
	}
	if !(v.Operator == nil) {
		writer.WriteUrl(3, v.Operator)
	}
	if !(len(v.Partitions) == 0) {
		for _, v := range v.Partitions {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_ValidatorInfo)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ValidatorInfo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKeyHash is missing")
	} else if v.PublicKeyHash == ([32]byte{}) {
		errs = append(errs, "field PublicKeyHash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Operator is missing")
	} else if v.Operator == nil {
		errs = append(errs, "field Operator is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Partitions is missing")
	} else if len(v.Partitions) == 0 {
		errs = append(errs, "field Partitions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ValidatorPartitionInfo = []string{
	1: "ID",
	2: "Active",
}

func (v *ValidatorPartitionInfo) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.ID) == 0) {
		writer.WriteString(1, v.ID)
	}
	writer.WriteBool(2, v.Active)

	_, _, err := writer.Reset(fieldNames_ValidatorPartitionInfo)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ValidatorPartitionInfo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field ID is missing")
	} else if len(v.ID) == 0 {
		errs = append(errs, "field ID is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Active is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_WriteData = []string{
	1: "Type",
	2: "Entry",
	3: "Scratch",
	4: "WriteToState",
}

func (v *WriteData) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(EqualDataEntry(v.Entry, nil)) {
		writer.WriteValue(2, v.Entry.MarshalBinary)
	}
	if !(!v.Scratch) {
		writer.WriteBool(3, v.Scratch)
	}
	if !(!v.WriteToState) {
		writer.WriteBool(4, v.WriteToState)
	}

	_, _, err := writer.Reset(fieldNames_WriteData)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *WriteData) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Entry is missing")
	} else if EqualDataEntry(v.Entry, nil) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_WriteDataResult = []string{
	1: "Type",
	2: "EntryHash",
	3: "AccountUrl",
	4: "AccountID",
}

func (v *WriteDataResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(2, &v.EntryHash)
	}
	if !(v.AccountUrl == nil) {
		writer.WriteUrl(3, v.AccountUrl)
	}
	if !(len(v.AccountID) == 0) {
		writer.WriteBytes(4, v.AccountID)
	}

	_, _, err := writer.Reset(fieldNames_WriteDataResult)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *WriteDataResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field AccountUrl is missing")
	} else if v.AccountUrl == nil {
		errs = append(errs, "field AccountUrl is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field AccountID is missing")
	} else if len(v.AccountID) == 0 {
		errs = append(errs, "field AccountID is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_WriteDataTo = []string{
	1: "Type",
	2: "Recipient",
	3: "Entry",
}

func (v *WriteDataTo) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Recipient == nil) {
		writer.WriteUrl(2, v.Recipient)
	}
	if !(EqualDataEntry(v.Entry, nil)) {
		writer.WriteValue(3, v.Entry.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_WriteDataTo)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *WriteDataTo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Recipient is missing")
	} else if v.Recipient == nil {
		errs = append(errs, "field Recipient is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if EqualDataEntry(v.Entry, nil) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *ADI) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ADI) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ADI) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_ADI)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AccountAuth) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AccountAuth) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(AuthorityEntry); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
			v.Authorities = append(v.Authorities, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_AccountAuth)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AccumulateDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AccumulateDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType DataEntryType
	if x := new(DataEntryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AccumulateDataEntry) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		if x, ok := reader.ReadBytes(2); ok {
			v.Data = append(v.Data, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_AccumulateDataEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AcmeFaucet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AcmeFaucet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AcmeFaucet) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}

	seen, err := reader.Reset(fieldNames_AcmeFaucet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AcmeOracle) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AcmeOracle) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Price = x
	}

	seen, err := reader.Reset(fieldNames_AcmeOracle)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ActivateProtocolVersion) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ActivateProtocolVersion) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ActivateProtocolVersion) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(ExecutorVersion); reader.ReadEnum(2, x) {
		v.Version = *x
	}

	seen, err := reader.Reset(fieldNames_ActivateProtocolVersion)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AddAccountAuthorityOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddAccountAuthorityOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountAuthOperationType
	if x := new(AccountAuthOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AddAccountAuthorityOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_AddAccountAuthorityOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AddCredits) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddCredits) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AddCredits) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Recipient = x
	}
	if x, ok := reader.ReadBigInt(3); ok {
		v.Amount = *x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Oracle = x
	}

	seen, err := reader.Reset(fieldNames_AddCredits)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AddCreditsResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddCreditsResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AddCreditsResult) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBigInt(2); ok {
		v.Amount = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Credits = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Oracle = x
	}

	seen, err := reader.Reset(fieldNames_AddCreditsResult)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AddKeyOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddKeyOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AddKeyOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(KeySpecParams); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_AddKeyOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AnchorLedger) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AnchorLedger) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AnchorLedger) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.MinorBlockSequenceNumber = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.MajorBlockIndex = x
	}
	if x, ok := reader.ReadTime(5); ok {
		v.MajorBlockTime = x
	}
	for {
		if x, ok := reader.ReadUrl(6); ok {
			v.PendingMajorBlockAnchors = append(v.PendingMajorBlockAnchors, x)
		} else {
			break
		}
	}
	for {
		if x := new(PartitionSyntheticLedger); reader.ReadValue(7, x.UnmarshalBinaryFrom) {
			v.Sequence = append(v.Sequence, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_AnchorLedger)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AnchorMetadata) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AnchorMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.ChainMetadata.UnmarshalBinaryFrom)
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.SourceIndex = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SourceBlock = x
	}
	if x, ok := reader.ReadBytes(6); ok {
		v.Entry = x
	}

	seen, err := reader.Reset(fieldNames_AnchorMetadata)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AnnotatedReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AnnotatedReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(merkle.Receipt); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Receipt = x
	}
	if x := new(AnchorMetadata); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Anchor = x
	}

	seen, err := reader.Reset(fieldNames_AnnotatedReceipt)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AuthorityEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AuthorityEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.Disabled = x
	}

	seen, err := reader.Reset(fieldNames_AuthorityEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AuthoritySignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AuthoritySignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AuthoritySignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Authority = x
	}
	if x := new(VoteType); reader.ReadEnum(4, x) {
		v.Vote = *x
	}
	if x, ok := reader.ReadTxid(5); ok {
		v.TxID = x
	}
	for {
		if x, ok := reader.ReadUrl(6); ok {
			v.Delegator = append(v.Delegator, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_AuthoritySignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BTCLegacySignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BTCLegacySignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BTCLegacySignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SignerVersion = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.Timestamp = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}
	if x, ok := reader.ReadHash(8); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_BTCLegacySignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BTCSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BTCSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BTCSignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SignerVersion = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.Timestamp = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}
	if x, ok := reader.ReadHash(8); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_BTCSignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Chain = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}

	seen, err := reader.Reset(fieldNames_BlockEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockLedger) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockLedger) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BlockLedger) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(4); ok {
		v.Time = x
	}
	for {
		if x := new(BlockEntry); reader.ReadValue(5, x.UnmarshalBinaryFrom) {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_BlockLedger)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockValidatorAnchor) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockValidatorAnchor) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BlockValidatorAnchor) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.PartitionAnchor.UnmarshalBinaryFrom)
	if x, ok := reader.ReadBigInt(3); ok {
		v.AcmeBurnt = *x
	}

	seen, err := reader.Reset(fieldNames_BlockValidatorAnchor)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BurnTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BurnTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BurnTokens) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBigInt(2); ok {
		v.Amount = *x
	}

	seen, err := reader.Reset(fieldNames_BurnTokens)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainMetadata) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x := new(ChainType); reader.ReadEnum(2, x) {
		v.Type = *x
	}

	seen, err := reader.Reset(fieldNames_ChainMetadata)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainParams) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainParams) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.Data = x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.IsUpdate = x
	}

	seen, err := reader.Reset(fieldNames_ChainParams)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CreateDataAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateDataAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *CreateDataAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	for {
		if x, ok := reader.ReadUrl(3); ok {
			v.Authorities = append(v.Authorities, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_CreateDataAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CreateIdentity) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateIdentity) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *CreateIdentity) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.KeyHash = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.KeyBookUrl = x
	}
	for {
		if x, ok := reader.ReadUrl(6); ok {
			v.Authorities = append(v.Authorities, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_CreateIdentity)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CreateKeyBook) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateKeyBook) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *CreateKeyBook) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.PublicKeyHash = x
	}
	for {
		if x, ok := reader.ReadUrl(5); ok {
			v.Authorities = append(v.Authorities, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_CreateKeyBook)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CreateKeyPage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateKeyPage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *CreateKeyPage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		if x := new(KeySpecParams); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Keys = append(v.Keys, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_CreateKeyPage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CreateLiteTokenAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateLiteTokenAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *CreateLiteTokenAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_CreateLiteTokenAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CreateToken) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateToken) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *CreateToken) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadString(4); ok {
		v.Symbol = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Precision = x
	}
	if x, ok := reader.ReadUrl(6); ok {
		v.Properties = x
	}
	if x, ok := reader.ReadBigInt(7); ok {
		v.SupplyLimit = x
	}
	for {
		if x, ok := reader.ReadUrl(9); ok {
			v.Authorities = append(v.Authorities, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_CreateToken)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CreateTokenAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateTokenAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *CreateTokenAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.TokenUrl = x
	}
	for {
		if x, ok := reader.ReadUrl(7); ok {
			v.Authorities = append(v.Authorities, x)
		} else {
			break
		}
	}
	if x := new(TokenIssuerProof); reader.ReadValue(8, x.UnmarshalBinaryFrom) {
		v.Proof = x
	}

	seen, err := reader.Reset(fieldNames_CreateTokenAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DataAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *DataAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinaryFrom)
	reader.ReadValue(4, func(r io.Reader) error {
		x, err := UnmarshalDataEntryFrom(r)
		if err == nil {
			v.Entry = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_DataAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DelegatedSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DelegatedSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *DelegatedSignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalSignatureFrom(r)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	if x, ok := reader.ReadUrl(3); ok {
		v.Delegator = x
	}

	seen, err := reader.Reset(fieldNames_DelegatedSignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DirectoryAnchor) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DirectoryAnchor) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *DirectoryAnchor) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.PartitionAnchor.UnmarshalBinaryFrom)
	for {
		if x := new(NetworkAccountUpdate); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
			v.Updates = append(v.Updates, *x)
		} else {
			break
		}
	}
	for {
		if x := new(PartitionAnchorReceipt); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
			v.Receipts = append(v.Receipts, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(5); ok {
		v.MakeMajorBlock = x
	}
	if x, ok := reader.ReadTime(6); ok {
		v.MakeMajorBlockTime = x
	}

	seen, err := reader.Reset(fieldNames_DirectoryAnchor)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DisableAccountAuthOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DisableAccountAuthOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountAuthOperationType
	if x := new(AccountAuthOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *DisableAccountAuthOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_DisableAccountAuthOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ED25519Signature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ED25519Signature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ED25519Signature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SignerVersion = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.Timestamp = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}
	if x, ok := reader.ReadHash(8); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_ED25519Signature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ETHSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ETHSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ETHSignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SignerVersion = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.Timestamp = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}
	if x, ok := reader.ReadHash(8); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_ETHSignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *EmptyResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *EmptyResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *EmptyResult) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_EmptyResult)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *EnableAccountAuthOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *EnableAccountAuthOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountAuthOperationType
	if x := new(AccountAuthOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *EnableAccountAuthOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_EnableAccountAuthOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FactomDataEntryWrapper) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FactomDataEntryWrapper) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType DataEntryType
	if x := new(DataEntryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *FactomDataEntryWrapper) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.FactomDataEntry.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_FactomDataEntryWrapper)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FeeSchedule) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FeeSchedule) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(Fee); reader.ReadEnum(1, x) {
			v.CreateIdentitySliding = append(v.CreateIdentitySliding, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_FeeSchedule)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *IndexEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *IndexEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Source = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Anchor = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.BlockIndex = x
	}
	if x, ok := reader.ReadTime(4); ok {
		v.BlockTime = &x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.RootIndexIndex = x
	}

	seen, err := reader.Reset(fieldNames_IndexEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *InternalSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InternalSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *InternalSignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadHash(2); ok {
		v.Cause = *x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_InternalSignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *IssueTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *IssueTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *IssueTokens) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Recipient = x
	}
	if x, ok := reader.ReadBigInt(3); ok {
		v.Amount = *x
	}
	for {
		if x := new(TokenRecipient); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
			v.To = append(v.To, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_IssueTokens)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *KeyBook) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeyBook) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *KeyBook) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x := new(BookType); reader.ReadEnum(3, x) {
		v.BookType = *x
	}
	reader.ReadValue(4, v.AccountAuth.UnmarshalBinaryFrom)
	if x, ok := reader.ReadUint(5); ok {
		v.PageCount = x
	}

	seen, err := reader.Reset(fieldNames_KeyBook)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *KeyPage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeyPage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *KeyPage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.CreditBalance = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.AcceptThreshold = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.RejectThreshold = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.ResponseThreshold = x
	}
	if x, ok := reader.ReadUint(7); ok {
		v.BlockThreshold = x
	}
	if x, ok := reader.ReadUint(8); ok {
		v.Version = x
	}
	for {
		if x := new(KeySpec); reader.ReadValue(9, x.UnmarshalBinaryFrom) {
			v.Keys = append(v.Keys, x)
		} else {
			break
		}
	}
	if x := new(AllowedTransactions); reader.ReadEnum(10, x) {
		v.TransactionBlacklist = x
	}

	seen, err := reader.Reset(fieldNames_KeyPage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *KeySpec) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeySpec) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.PublicKeyHash = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.LastUsedOn = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Delegate = x
	}

	seen, err := reader.Reset(fieldNames_KeySpec)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *KeySpecParams) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeySpecParams) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.KeyHash = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Delegate = x
	}

	seen, err := reader.Reset(fieldNames_KeySpecParams)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LegacyED25519Signature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LegacyED25519Signature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *LegacyED25519Signature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUint(2); ok {
		v.Timestamp = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(5); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.SignerVersion = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}
	if x, ok := reader.ReadHash(8); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_LegacyED25519Signature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LiteDataAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LiteDataAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *LiteDataAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}

	seen, err := reader.Reset(fieldNames_LiteDataAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LiteIdentity) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LiteIdentity) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *LiteIdentity) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.CreditBalance = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.LastUsedOn = x
	}

	seen, err := reader.Reset(fieldNames_LiteIdentity)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LiteTokenAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LiteTokenAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *LiteTokenAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.TokenUrl = x
	}
	if x, ok := reader.ReadBigInt(4); ok {
		v.Balance = *x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.LockHeight = x
	}

	seen, err := reader.Reset(fieldNames_LiteTokenAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LockAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LockAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *LockAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUint(2); ok {
		v.Height = x
	}

	seen, err := reader.Reset(fieldNames_LockAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MetricsRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MetricsRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Metric = x
	}
	if x, ok := reader.ReadDuration(2); ok {
		v.Duration = x
	}

	seen, err := reader.Reset(fieldNames_MetricsRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkAccountUpdate) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkAccountUpdate) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalTransactionBodyFrom(r)
		if err == nil {
			v.Body = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_NetworkAccountUpdate)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkDefinition) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkDefinition) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.NetworkName = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Version = x
	}
	for {
		if x := new(PartitionInfo); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
			v.Partitions = append(v.Partitions, x)
		} else {
			break
		}
	}
	for {
		if x := new(ValidatorInfo); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
			v.Validators = append(v.Validators, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_NetworkDefinition)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkGlobals) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkGlobals) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(Rational); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.OperatorAcceptThreshold = *x
	}
	if x := new(Rational); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.ValidatorAcceptThreshold = *x
	}
	if x, ok := reader.ReadString(3); ok {
		v.MajorBlockSchedule = x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.AnchorEmptyBlocks = x
	}
	if x := new(FeeSchedule); reader.ReadValue(5, x.UnmarshalBinaryFrom) {
		v.FeeSchedule = x
	}
	if x := new(NetworkLimits); reader.ReadValue(6, x.UnmarshalBinaryFrom) {
		v.Limits = x
	}

	seen, err := reader.Reset(fieldNames_NetworkGlobals)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkLimits) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkLimits) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.DataEntryParts = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.AccountAuthorities = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.BookPages = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.PageEntries = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.IdentityAccounts = x
	}

	seen, err := reader.Reset(fieldNames_NetworkLimits)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Object) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Object) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(ObjectType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	for {
		if x := new(ChainMetadata); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Chains = append(v.Chains, *x)
		} else {
			break
		}
	}
	if x := new(TxIdSet); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.Pending = *x
	}

	seen, err := reader.Reset(fieldNames_Object)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PartitionAnchor) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PartitionAnchor) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Source = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.MajorBlockIndex = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.MinorBlockIndex = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.RootChainIndex = x
	}
	if x, ok := reader.ReadHash(5); ok {
		v.RootChainAnchor = *x
	}
	if x, ok := reader.ReadHash(6); ok {
		v.StateTreeAnchor = *x
	}

	seen, err := reader.Reset(fieldNames_PartitionAnchor)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PartitionAnchorReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PartitionAnchorReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(PartitionAnchor); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Anchor = x
	}
	if x := new(merkle.Receipt); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.RootChainReceipt = x
	}

	seen, err := reader.Reset(fieldNames_PartitionAnchorReceipt)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PartitionInfo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PartitionInfo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.ID = x
	}
	if x := new(PartitionType); reader.ReadEnum(2, x) {
		v.Type = *x
	}

	seen, err := reader.Reset(fieldNames_PartitionInfo)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PartitionSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PartitionSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *PartitionSignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.SourceNetwork = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.DestinationNetwork = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.SequenceNumber = x
	}
	if x, ok := reader.ReadHash(5); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_PartitionSignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PartitionSyntheticLedger) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PartitionSyntheticLedger) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Produced = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Received = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Delivered = x
	}
	for {
		if x, ok := reader.ReadTxid(5); ok {
			v.Pending = append(v.Pending, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_PartitionSyntheticLedger)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PlaceholderTransaction) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PlaceholderTransaction) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *PlaceholderTransaction) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_PlaceholderTransaction)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RCD1Signature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RCD1Signature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *RCD1Signature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SignerVersion = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.Timestamp = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}
	if x, ok := reader.ReadHash(8); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_RCD1Signature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Rational) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Rational) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Numerator = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Denominator = x
	}

	seen, err := reader.Reset(fieldNames_Rational)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ReceiptSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ReceiptSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ReceiptSignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.SourceNetwork = x
	}
	if x := new(merkle.Receipt); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.Proof = *x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.TransactionHash = *x
	}

	seen, err := reader.Reset(fieldNames_ReceiptSignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RemoteSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RemoteSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *RemoteSignature) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Destination = x
	}
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := UnmarshalSignatureFrom(r)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	for {
		if x, ok := reader.ReadHash(4); ok {
			v.Cause = append(v.Cause, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_RemoteSignature)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RemoteTransaction) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RemoteTransaction) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *RemoteTransaction) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadHash(2); ok {
		v.Hash = *x
	}

	seen, err := reader.Reset(fieldNames_RemoteTransaction)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RemoveAccountAuthorityOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RemoveAccountAuthorityOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountAuthOperationType
	if x := new(AccountAuthOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *RemoveAccountAuthorityOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_RemoveAccountAuthorityOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RemoveKeyOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RemoveKeyOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *RemoveKeyOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(KeySpecParams); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_RemoveKeyOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Route) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Route) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Length = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Value = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Partition = x
	}

	seen, err := reader.Reset(fieldNames_Route)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RouteOverride) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RouteOverride) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Partition = x
	}

	seen, err := reader.Reset(fieldNames_RouteOverride)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RoutingTable) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RoutingTable) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(RouteOverride); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
			v.Overrides = append(v.Overrides, *x)
		} else {
			break
		}
	}
	for {
		if x := new(Route); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Routes = append(v.Routes, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_RoutingTable)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SendTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SendTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SendTokens) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadHash(2); ok {
		v.Hash = *x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Meta = x
	}
	for {
		if x := new(TokenRecipient); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
			v.To = append(v.To, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SendTokens)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SetThresholdKeyPageOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SetThresholdKeyPageOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SetThresholdKeyPageOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUint(2); ok {
		v.Threshold = x
	}

	seen, err := reader.Reset(fieldNames_SetThresholdKeyPageOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SignatureSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SignatureSet) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(VoteType); reader.ReadEnum(2, x) {
		v.Vote = *x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.TransactionHash = *x
	}
	for {
		ok := reader.ReadValue(5, func(r io.Reader) error {
			x, err := UnmarshalSignatureFrom(r)
			if err == nil {
				v.Signatures = append(v.Signatures, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadUrl(6); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_SignatureSet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticBurnTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticBurnTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SyntheticBurnTokens) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinaryFrom)
	if x, ok := reader.ReadBigInt(3); ok {
		v.Amount = *x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.IsRefund = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticBurnTokens)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticCreateIdentity) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticCreateIdentity) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SyntheticCreateIdentity) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinaryFrom)
	for {
		ok := reader.ReadValue(3, func(r io.Reader) error {
			x, err := UnmarshalAccountFrom(r)
			if err == nil {
				v.Accounts = append(v.Accounts, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SyntheticCreateIdentity)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticDepositCredits) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticDepositCredits) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SyntheticDepositCredits) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinaryFrom)
	if x, ok := reader.ReadUint(3); ok {
		v.Amount = x
	}
	if x, ok := reader.ReadBigInt(4); ok {
		v.AcmeRefundAmount = x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.IsRefund = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticDepositCredits)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticDepositTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticDepositTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SyntheticDepositTokens) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinaryFrom)
	if x, ok := reader.ReadUrl(3); ok {
		v.Token = x
	}
	if x, ok := reader.ReadBigInt(4); ok {
		v.Amount = *x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.IsIssuer = x
	}
	if x, ok := reader.ReadBool(6); ok {
		v.IsRefund = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticDepositTokens)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticForwardTransaction) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticForwardTransaction) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SyntheticForwardTransaction) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		if x := new(RemoteSignature); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Signatures = append(v.Signatures, *x)
		} else {
			break
		}
	}
	if x := new(Transaction); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.Transaction = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticForwardTransaction)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticLedger) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticLedger) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SyntheticLedger) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	for {
		if x := new(PartitionSyntheticLedger); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
			v.Sequence = append(v.Sequence, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SyntheticLedger)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticOrigin) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticOrigin) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadTxid(1); ok {
		v.Cause = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Initiator = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.FeeRefund = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticOrigin)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticWriteData) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticWriteData) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SyntheticWriteData) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinaryFrom)
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := UnmarshalDataEntryFrom(r)
		if err == nil {
			v.Entry = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_SyntheticWriteData)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SystemGenesis) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SystemGenesis) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SystemGenesis) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_SystemGenesis)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SystemLedger) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SystemLedger) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SystemLedger) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(4); ok {
		v.Timestamp = x
	}
	if x, ok := reader.ReadBigInt(5); ok {
		v.AcmeBurnt = *x
	}
	for {
		if x := new(NetworkAccountUpdate); reader.ReadValue(6, x.UnmarshalBinaryFrom) {
			v.PendingUpdates = append(v.PendingUpdates, *x)
		} else {
			break
		}
	}
	reader.ReadValue(7, func(r io.Reader) error {
		x, err := UnmarshalAnchorBodyFrom(r)
		if err == nil {
			v.Anchor = x
		}
		return err
	})
	if x := new(ExecutorVersion); reader.ReadEnum(8, x) {
		v.ExecutorVersion = *x
	}

	seen, err := reader.Reset(fieldNames_SystemLedger)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SystemWriteData) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SystemWriteData) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SystemWriteData) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalDataEntryFrom(r)
		if err == nil {
			v.Entry = x
		}
		return err
	})
	if x, ok := reader.ReadBool(3); ok {
		v.WriteToState = x
	}

	seen, err := reader.Reset(fieldNames_SystemWriteData)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TokenAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TokenAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *TokenAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinaryFrom)
	if x, ok := reader.ReadUrl(4); ok {
		v.TokenUrl = x
	}
	if x, ok := reader.ReadBigInt(5); ok {
		v.Balance = *x
	}

	seen, err := reader.Reset(fieldNames_TokenAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TokenIssuer) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TokenIssuer) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *TokenIssuer) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinaryFrom)
	if x, ok := reader.ReadString(4); ok {
		v.Symbol = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Precision = x
	}
	if x, ok := reader.ReadUrl(6); ok {
		v.Properties = x
	}
	if x, ok := reader.ReadBigInt(7); ok {
		v.Issued = *x
	}
	if x, ok := reader.ReadBigInt(8); ok {
		v.SupplyLimit = x
	}

	seen, err := reader.Reset(fieldNames_TokenIssuer)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TokenIssuerProof) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TokenIssuerProof) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(CreateToken); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Transaction = x
	}
	if x := new(merkle.Receipt); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_TokenIssuerProof)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TokenRecipient) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TokenRecipient) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBigInt(2); ok {
		v.Amount = *x
	}

	seen, err := reader.Reset(fieldNames_TokenRecipient)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Transaction) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Transaction) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(TransactionHeader); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Header = *x
	}
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalTransactionBodyFrom(r)
		if err == nil {
			v.Body = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_Transaction)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TransactionHeader) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionHeader) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Principal = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.Initiator = *x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Memo = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.Metadata = x
	}

	seen, err := reader.Reset(fieldNames_TransactionHeader)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TransactionResultSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionResultSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(TransactionStatus); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
			v.Results = append(v.Results, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_TransactionResultSet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TransactionStatus) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionStatus) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadTxid(1); ok {
		v.TxID = x
	}
	if x := new(errors2.Status); reader.ReadEnum(2, x) {
		v.Code = *x
	}
	if x := new(errors2.Error); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.Error = x
	}
	reader.ReadValue(4, func(r io.Reader) error {
		x, err := UnmarshalTransactionResultFrom(r)
		if err == nil {
			v.Result = x
		}
		return err
	})
	if x, ok := reader.ReadUint(5); ok {
		v.Received = x
	}
	if x, ok := reader.ReadUrl(6); ok {
		v.Initiator = x
	}
	for {
		ok := reader.ReadValue(7, func(r io.Reader) error {
			x, err := UnmarshalSignerFrom(r)
			if err == nil {
				v.Signers = append(v.Signers, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadUrl(8); ok {
		v.SourceNetwork = x
	}
	if x, ok := reader.ReadUrl(9); ok {
		v.DestinationNetwork = x
	}
	if x, ok := reader.ReadUint(10); ok {
		v.SequenceNumber = x
	}
	if x, ok := reader.ReadBool(11); ok {
		v.GotDirectoryReceipt = x
	}
	if x := new(merkle.Receipt); reader.ReadValue(12, x.UnmarshalBinaryFrom) {
		v.Proof = x
	}
	for {
		if x, ok := reader.ReadBytes(13); ok {
			v.AnchorSigners = append(v.AnchorSigners, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_TransactionStatus)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TxIdSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TxIdSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadTxid(1); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_TxIdSet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UnknownAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UnknownAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *UnknownAccount) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}

	seen, err := reader.Reset(fieldNames_UnknownAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UnknownSigner) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UnknownSigner) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *UnknownSigner) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Version = x
	}

	seen, err := reader.Reset(fieldNames_UnknownSigner)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UpdateAccountAuth) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateAccountAuth) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *UpdateAccountAuth) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		ok := reader.ReadValue(2, func(r io.Reader) error {
			x, err := UnmarshalAccountAuthOperationFrom(r)
			if err == nil {
				v.Operations = append(v.Operations, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_UpdateAccountAuth)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UpdateAllowedKeyPageOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateAllowedKeyPageOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *UpdateAllowedKeyPageOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		if x := new(TransactionType); reader.ReadEnum(2, x) {
			v.Allow = append(v.Allow, *x)
		} else {
			break
		}
	}
	for {
		if x := new(TransactionType); reader.ReadEnum(3, x) {
			v.Deny = append(v.Deny, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_UpdateAllowedKeyPageOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UpdateKey) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateKey) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *UpdateKey) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.NewKeyHash = x
	}

	seen, err := reader.Reset(fieldNames_UpdateKey)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UpdateKeyOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateKeyOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *UpdateKeyOperation) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(KeySpecParams); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.OldEntry = *x
	}
	if x := new(KeySpecParams); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.NewEntry = *x
	}

	seen, err := reader.Reset(fieldNames_UpdateKeyOperation)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UpdateKeyPage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateKeyPage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *UpdateKeyPage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		ok := reader.ReadValue(2, func(r io.Reader) error {
			x, err := UnmarshalKeyPageOperationFrom(r)
			if err == nil {
				v.Operation = append(v.Operation, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_UpdateKeyPage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ValidatorInfo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ValidatorInfo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.PublicKeyHash = *x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Operator = x
	}
	for {
		if x := new(ValidatorPartitionInfo); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
			v.Partitions = append(v.Partitions, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ValidatorInfo)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ValidatorPartitionInfo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ValidatorPartitionInfo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.ID = x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.Active = x
	}

	seen, err := reader.Reset(fieldNames_ValidatorPartitionInfo)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *WriteData) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *WriteData) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *WriteData) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalDataEntryFrom(r)
		if err == nil {
			v.Entry = x
		}
		return err
	})
	if x, ok := reader.ReadBool(3); ok {
		v.Scratch = x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.WriteToState = x
	}

	seen, err := reader.Reset(fieldNames_WriteData)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *WriteDataResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *WriteDataResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *WriteDataResult) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadHash(2); ok {
		v.EntryHash = *x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.AccountUrl = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.AccountID = x
	}

	seen, err := reader.Reset(fieldNames_WriteDataResult)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *WriteDataTo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *WriteDataTo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *WriteDataTo) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Recipient = x
	}
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := UnmarshalDataEntryFrom(r)
		if err == nil {
			v.Entry = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_WriteDataTo)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ADI) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        AccountType                       `json:"type"`
		Url         *url.URL                          `json:"url,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.AccountAuth.Authorities) == 0) {

		u.Authorities = v.AccountAuth.Authorities
	}
	return json.Marshal(&u)
}

func (v *AccountAuth) MarshalJSON() ([]byte, error) {
	u := struct {
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
	}{}
	if !(len(v.Authorities) == 0) {
		u.Authorities = v.Authorities
	}
	return json.Marshal(&u)
}

func (v *AccumulateDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type DataEntryType              `json:"type"`
		Data encoding.JsonList[*string] `json:"data,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Data) == 0) {
		u.Data = make(encoding.JsonList[*string], len(v.Data))
		for i, x := range v.Data {
			u.Data[i] = encoding.BytesToJSON(x)
		}
	}
	return json.Marshal(&u)
}

func (v *AcmeFaucet) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
		Url  *url.URL        `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	return json.Marshal(&u)
}

func (v *ActivateProtocolVersion) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    TransactionType `json:"type"`
		Version ExecutorVersion `json:"version,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Version == 0) {
		u.Version = v.Version
	}
	return json.Marshal(&u)
}

func (v *AddAccountAuthorityOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	return json.Marshal(&u)
}

func (v *AddCredits) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType `json:"type"`
		Recipient *url.URL        `json:"recipient,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
		Oracle    uint64          `json:"oracle,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Recipient == nil) {
		u.Recipient = v.Recipient
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		u.Amount = encoding.BigintToJSON(&v.Amount)
	}
	if !(v.Oracle == 0) {
		u.Oracle = v.Oracle
	}
	return json.Marshal(&u)
}

func (v *AddCreditsResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    TransactionType `json:"type"`
		Amount  *string         `json:"amount,omitempty"`
		Credits uint64          `json:"credits,omitempty"`
		Oracle  uint64          `json:"oracle,omitempty"`
	}{}
	u.Type = v.Type()
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		u.Amount = encoding.BigintToJSON(&v.Amount)
	}
	if !(v.Credits == 0) {
		u.Credits = v.Credits
	}
	if !(v.Oracle == 0) {
		u.Oracle = v.Oracle
	}
	return json.Marshal(&u)
}

func (v *AddKeyOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Entry KeySpecParams        `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	if !((v.Entry).Equal(new(KeySpecParams))) {
		u.Entry = v.Entry
	}
	return json.Marshal(&u)
}

func (v *AnchorLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Type                     AccountType                                  `json:"type"`
		Url                      *url.URL                                     `json:"url,omitempty"`
		MinorBlockSequenceNumber uint64                                       `json:"minorBlockSequenceNumber,omitempty"`
		MajorBlockIndex          uint64                                       `json:"majorBlockIndex,omitempty"`
		MajorBlockTime           time.Time                                    `json:"majorBlockTime,omitempty"`
		PendingMajorBlockAnchors encoding.JsonList[*url.URL]                  `json:"pendingMajorBlockAnchors,omitempty"`
		Sequence                 encoding.JsonList[*PartitionSyntheticLedger] `json:"sequence,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.MinorBlockSequenceNumber == 0) {
		u.MinorBlockSequenceNumber = v.MinorBlockSequenceNumber
	}
	if !(v.MajorBlockIndex == 0) {
		u.MajorBlockIndex = v.MajorBlockIndex
	}
	if !(v.MajorBlockTime == (time.Time{})) {
		u.MajorBlockTime = v.MajorBlockTime
	}
	if !(len(v.PendingMajorBlockAnchors) == 0) {
		u.PendingMajorBlockAnchors = v.PendingMajorBlockAnchors
	}
	if !(len(v.Sequence) == 0) {
		u.Sequence = v.Sequence
	}
	return json.Marshal(&u)
}

func (v *AnchorMetadata) MarshalJSON() ([]byte, error) {
	u := struct {
		Name        string    `json:"name,omitempty"`
		Type        ChainType `json:"type,omitempty"`
		Account     *url.URL  `json:"account,omitempty"`
		Index       uint64    `json:"index,omitempty"`
		SourceIndex uint64    `json:"sourceIndex,omitempty"`
		SourceBlock uint64    `json:"sourceBlock,omitempty"`
		Entry       *string   `json:"entry,omitempty"`
	}{}
	if !(len(v.ChainMetadata.Name) == 0) {

		u.Name = v.ChainMetadata.Name
	}
	if !(v.ChainMetadata.Type == 0) {

		u.Type = v.ChainMetadata.Type
	}
	if !(v.Account == nil) {
		u.Account = v.Account
	}
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.SourceIndex == 0) {
		u.SourceIndex = v.SourceIndex
	}
	if !(v.SourceBlock == 0) {
		u.SourceBlock = v.SourceBlock
	}
	if !(len(v.Entry) == 0) {
		u.Entry = encoding.BytesToJSON(v.Entry)
	}
	return json.Marshal(&u)
}

func (v *AuthoritySignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      SignatureType               `json:"type"`
		Signer    *url.URL                    `json:"signer,omitempty"`
		Authority *url.URL                    `json:"authority,omitempty"`
		Vote      VoteType                    `json:"vote,omitempty"`
		TxID      *url.TxID                   `json:"txID,omitempty"`
		Delegator encoding.JsonList[*url.URL] `json:"delegator,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	if !(v.Vote == 0) {
		u.Vote = v.Vote
	}
	if !(v.TxID == nil) {
		u.TxID = v.TxID
	}
	if !(len(v.Delegator) == 0) {
		u.Delegator = v.Delegator
	}
	return json.Marshal(&u)
}

func (v *BTCLegacySignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		u.Signature = encoding.BytesToJSON(v.Signature)
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.SignerVersion == 0) {
		u.SignerVersion = v.SignerVersion
	}
	if !(v.Timestamp == 0) {
		u.Timestamp = v.Timestamp
	}
	if !(v.Vote == 0) {
		u.Vote = v.Vote
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *BTCSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		u.Signature = encoding.BytesToJSON(v.Signature)
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.SignerVersion == 0) {
		u.SignerVersion = v.SignerVersion
	}
	if !(v.Timestamp == 0) {
		u.Timestamp = v.Timestamp
	}
	if !(v.Vote == 0) {
		u.Vote = v.Vote
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *BlockLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    AccountType                    `json:"type"`
		Url     *url.URL                       `json:"url,omitempty"`
		Index   uint64                         `json:"index,omitempty"`
		Time    time.Time                      `json:"time,omitempty"`
		Entries encoding.JsonList[*BlockEntry] `json:"entries,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.Time == (time.Time{})) {
		u.Time = v.Time
	}
	if !(len(v.Entries) == 0) {
		u.Entries = v.Entries
	}
	return json.Marshal(&u)
}

func (v *BlockValidatorAnchor) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            TransactionType `json:"type"`
		Source          *url.URL        `json:"source,omitempty"`
		MajorBlockIndex uint64          `json:"majorBlockIndex,omitempty"`
		MinorBlockIndex uint64          `json:"minorBlockIndex,omitempty"`
		RootChainIndex  uint64          `json:"rootChainIndex,omitempty"`
		RootChainAnchor string          `json:"rootChainAnchor,omitempty"`
		StateTreeAnchor string          `json:"stateTreeAnchor,omitempty"`
		AcmeBurnt       *string         `json:"acmeBurnt,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.PartitionAnchor.Source == nil) {

		u.Source = v.PartitionAnchor.Source
	}
	if !(v.PartitionAnchor.MajorBlockIndex == 0) {

		u.MajorBlockIndex = v.PartitionAnchor.MajorBlockIndex
	}
	if !(v.PartitionAnchor.MinorBlockIndex == 0) {

		u.MinorBlockIndex = v.PartitionAnchor.MinorBlockIndex
	}
	if !(v.PartitionAnchor.RootChainIndex == 0) {

		u.RootChainIndex = v.PartitionAnchor.RootChainIndex
	}
	if !(v.PartitionAnchor.RootChainAnchor == ([32]byte{})) {

		u.RootChainAnchor = encoding.ChainToJSON(v.PartitionAnchor.RootChainAnchor)
	}
	if !(v.PartitionAnchor.StateTreeAnchor == ([32]byte{})) {

		u.StateTreeAnchor = encoding.ChainToJSON(v.PartitionAnchor.StateTreeAnchor)
	}
	if !((v.AcmeBurnt).Cmp(new(big.Int)) == 0) {
		u.AcmeBurnt = encoding.BigintToJSON(&v.AcmeBurnt)
	}
	return json.Marshal(&u)
}

func (v *BurnTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   TransactionType `json:"type"`
		Amount *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		u.Amount = encoding.BigintToJSON(&v.Amount)
	}
	return json.Marshal(&u)
}

func (v *ChainParams) MarshalJSON() ([]byte, error) {
	u := struct {
		Data     *string `json:"data,omitempty"`
		IsUpdate bool    `json:"isUpdate,omitempty"`
	}{}
	if !(len(v.Data) == 0) {
		u.Data = encoding.BytesToJSON(v.Data)
	}
	if !(!v.IsUpdate) {
		u.IsUpdate = v.IsUpdate
	}
	return json.Marshal(&u)
}

func (v *CreateDataAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        TransactionType             `json:"type"`
		Url         *url.URL                    `json:"url,omitempty"`
		Authorities encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.Authorities) == 0) {
		u.Authorities = v.Authorities
	}
	return json.Marshal(&u)
}

func (v *CreateIdentity) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        TransactionType             `json:"type"`
		Url         *url.URL                    `json:"url,omitempty"`
		KeyHash     *string                     `json:"keyHash,omitempty"`
		KeyBookUrl  *url.URL                    `json:"keyBookUrl,omitempty"`
		Authorities encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.KeyHash) == 0) {
		u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	}
	if !(v.KeyBookUrl == nil) {
		u.KeyBookUrl = v.KeyBookUrl
	}
	if !(len(v.Authorities) == 0) {
		u.Authorities = v.Authorities
	}
	return json.Marshal(&u)
}

func (v *CreateKeyBook) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          TransactionType             `json:"type"`
		Url           *url.URL                    `json:"url,omitempty"`
		PublicKeyHash *string                     `json:"publicKeyHash,omitempty"`
		Authorities   encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.PublicKeyHash) == 0) {
		u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	}
	if !(len(v.Authorities) == 0) {
		u.Authorities = v.Authorities
	}
	return json.Marshal(&u)
}

func (v *CreateKeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType                   `json:"type"`
		Keys encoding.JsonList[*KeySpecParams] `json:"keys,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Keys) == 0) {
		u.Keys = v.Keys
	}
	return json.Marshal(&u)
}

func (v *CreateLiteTokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *CreateToken) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        TransactionType             `json:"type"`
		Url         *url.URL                    `json:"url,omitempty"`
		Symbol      string                      `json:"symbol,omitempty"`
		Precision   uint64                      `json:"precision,omitempty"`
		Properties  *url.URL                    `json:"properties,omitempty"`
		SupplyLimit *string                     `json:"supplyLimit,omitempty"`
		Authorities encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.Symbol) == 0) {
		u.Symbol = v.Symbol
	}
	if !(v.Precision == 0) {
		u.Precision = v.Precision
	}
	if !(v.Properties == nil) {
		u.Properties = v.Properties
	}
	if !(v.SupplyLimit == nil) {
		u.SupplyLimit = encoding.BigintToJSON(v.SupplyLimit)
	}
	if !(len(v.Authorities) == 0) {
		u.Authorities = v.Authorities
	}
	return json.Marshal(&u)
}

func (v *CreateTokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        TransactionType             `json:"type"`
		Url         *url.URL                    `json:"url,omitempty"`
		TokenUrl    *url.URL                    `json:"tokenUrl,omitempty"`
		Authorities encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
		Proof       *TokenIssuerProof           `json:"proof,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.TokenUrl == nil) {
		u.TokenUrl = v.TokenUrl
	}
	if !(len(v.Authorities) == 0) {
		u.Authorities = v.Authorities
	}
	if !(v.Proof == nil) {
		u.Proof = v.Proof
	}
	return json.Marshal(&u)
}

func (v *DataAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        AccountType                            `json:"type"`
		Url         *url.URL                               `json:"url,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry]      `json:"authorities,omitempty"`
		Entry       *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.AccountAuth.Authorities) == 0) {

		u.Authorities = v.AccountAuth.Authorities
	}
	if !(EqualDataEntry(v.Entry, nil)) {
		u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	}
	return json.Marshal(&u)
}

func (v *DelegatedSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      SignatureType                          `json:"type"`
		Signature *encoding.JsonUnmarshalWith[Signature] `json:"signature,omitempty"`
		Delegator *url.URL                               `json:"delegator,omitempty"`
	}{}
	u.Type = v.Type()
	if !(EqualSignature(v.Signature, nil)) {
		u.Signature = &encoding.JsonUnmarshalWith[Signature]{Value: v.Signature, Func: UnmarshalSignatureJSON}
	}
	if !(v.Delegator == nil) {
		u.Delegator = v.Delegator
	}
	return json.Marshal(&u)
}

func (v *DirectoryAnchor) MarshalJSON() ([]byte, error) {
	u := struct {
		Type               TransactionType                            `json:"type"`
		Source             *url.URL                                   `json:"source,omitempty"`
		MajorBlockIndex    uint64                                     `json:"majorBlockIndex,omitempty"`
		MinorBlockIndex    uint64                                     `json:"minorBlockIndex,omitempty"`
		RootChainIndex     uint64                                     `json:"rootChainIndex,omitempty"`
		RootChainAnchor    string                                     `json:"rootChainAnchor,omitempty"`
		StateTreeAnchor    string                                     `json:"stateTreeAnchor,omitempty"`
		Updates            encoding.JsonList[NetworkAccountUpdate]    `json:"updates,omitempty"`
		Receipts           encoding.JsonList[*PartitionAnchorReceipt] `json:"receipts,omitempty"`
		MakeMajorBlock     uint64                                     `json:"makeMajorBlock,omitempty"`
		MakeMajorBlockTime time.Time                                  `json:"makeMajorBlockTime,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.PartitionAnchor.Source == nil) {

		u.Source = v.PartitionAnchor.Source
	}
	if !(v.PartitionAnchor.MajorBlockIndex == 0) {

		u.MajorBlockIndex = v.PartitionAnchor.MajorBlockIndex
	}
	if !(v.PartitionAnchor.MinorBlockIndex == 0) {

		u.MinorBlockIndex = v.PartitionAnchor.MinorBlockIndex
	}
	if !(v.PartitionAnchor.RootChainIndex == 0) {

		u.RootChainIndex = v.PartitionAnchor.RootChainIndex
	}
	if !(v.PartitionAnchor.RootChainAnchor == ([32]byte{})) {

		u.RootChainAnchor = encoding.ChainToJSON(v.PartitionAnchor.RootChainAnchor)
	}
	if !(v.PartitionAnchor.StateTreeAnchor == ([32]byte{})) {

		u.StateTreeAnchor = encoding.ChainToJSON(v.PartitionAnchor.StateTreeAnchor)
	}
	if !(len(v.Updates) == 0) {
		u.Updates = v.Updates
	}
	if !(len(v.Receipts) == 0) {
		u.Receipts = v.Receipts
	}
	if !(v.MakeMajorBlock == 0) {
		u.MakeMajorBlock = v.MakeMajorBlock
	}
	if !(v.MakeMajorBlockTime == (time.Time{})) {
		u.MakeMajorBlockTime = v.MakeMajorBlockTime
	}
	return json.Marshal(&u)
}

func (v *DisableAccountAuthOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	return json.Marshal(&u)
}

func (v *ED25519Signature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		u.Signature = encoding.BytesToJSON(v.Signature)
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.SignerVersion == 0) {
		u.SignerVersion = v.SignerVersion
	}
	if !(v.Timestamp == 0) {
		u.Timestamp = v.Timestamp
	}
	if !(v.Vote == 0) {
		u.Vote = v.Vote
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *ETHSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		u.Signature = encoding.BytesToJSON(v.Signature)
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.SignerVersion == 0) {
		u.SignerVersion = v.SignerVersion
	}
	if !(v.Timestamp == 0) {
		u.Timestamp = v.Timestamp
	}
	if !(v.Vote == 0) {
		u.Vote = v.Vote
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *EmptyResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *EnableAccountAuthOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	return json.Marshal(&u)
}

func (v *FactomDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		AccountId string                     `json:"accountId,omitempty"`
		Data      *string                    `json:"data,omitempty"`
		ExtIds    encoding.JsonList[*string] `json:"extIds,omitempty"`
	}{}
	if !(v.AccountId == ([32]byte{})) {
		u.AccountId = encoding.ChainToJSON(v.AccountId)
	}
	if !(len(v.Data) == 0) {
		u.Data = encoding.BytesToJSON(v.Data)
	}
	if !(len(v.ExtIds) == 0) {
		u.ExtIds = make(encoding.JsonList[*string], len(v.ExtIds))
		for i, x := range v.ExtIds {
			u.ExtIds[i] = encoding.BytesToJSON(x)
		}
	}
	return json.Marshal(&u)
}

func (v *FactomDataEntryWrapper) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      DataEntryType              `json:"type"`
		AccountId string                     `json:"accountId,omitempty"`
		Data      *string                    `json:"data,omitempty"`
		ExtIds    encoding.JsonList[*string] `json:"extIds,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.FactomDataEntry.AccountId == ([32]byte{})) {

		u.AccountId = encoding.ChainToJSON(v.FactomDataEntry.AccountId)
	}
	if !(len(v.FactomDataEntry.Data) == 0) {

		u.Data = encoding.BytesToJSON(v.FactomDataEntry.Data)
	}
	if !(len(v.FactomDataEntry.ExtIds) == 0) {

		u.ExtIds = make(encoding.JsonList[*string], len(v.FactomDataEntry.ExtIds))
		for i, x := range v.FactomDataEntry.ExtIds {
			u.ExtIds[i] = encoding.BytesToJSON(x)
		}
	}
	return json.Marshal(&u)
}

func (v *FeeSchedule) MarshalJSON() ([]byte, error) {
	u := struct {
		CreateIdentitySliding encoding.JsonList[Fee] `json:"createIdentitySliding,omitempty"`
	}{}
	if !(len(v.CreateIdentitySliding) == 0) {
		u.CreateIdentitySliding = v.CreateIdentitySliding
	}
	return json.Marshal(&u)
}

func (v *InternalSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType `json:"type"`
		Cause           string        `json:"cause,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Cause == ([32]byte{})) {
		u.Cause = encoding.ChainToJSON(v.Cause)
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *IssueTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType                    `json:"type"`
		Recipient *url.URL                           `json:"recipient,omitempty"`
		Amount    *string                            `json:"amount,omitempty"`
		To        encoding.JsonList[*TokenRecipient] `json:"to,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Recipient == nil) {
		u.Recipient = v.Recipient
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		u.Amount = encoding.BigintToJSON(&v.Amount)
	}
	if !(len(v.To) == 0) {
		u.To = v.To
	}
	return json.Marshal(&u)
}

func (v *KeyBook) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        AccountType                       `json:"type"`
		Url         *url.URL                          `json:"url,omitempty"`
		BookType    BookType                          `json:"bookType,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
		PageCount   uint64                            `json:"pageCount,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.BookType == 0) {
		u.BookType = v.BookType
	}
	if !(len(v.AccountAuth.Authorities) == 0) {

		u.Authorities = v.AccountAuth.Authorities
	}
	if !(v.PageCount == 0) {
		u.PageCount = v.PageCount
	}
	return json.Marshal(&u)
}

func (v *KeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type                 AccountType                 `json:"type"`
		KeyBook              *url.URL                    `json:"keyBook,omitempty"`
		Url                  *url.URL                    `json:"url,omitempty"`
		CreditBalance        uint64                      `json:"creditBalance,omitempty"`
		AcceptThreshold      uint64                      `json:"acceptThreshold,omitempty"`
		Threshold            uint64                      `json:"threshold,omitempty"`
		RejectThreshold      uint64                      `json:"rejectThreshold,omitempty"`
		ResponseThreshold    uint64                      `json:"responseThreshold,omitempty"`
		BlockThreshold       uint64                      `json:"blockThreshold,omitempty"`
		Version              uint64                      `json:"version,omitempty"`
		Keys                 encoding.JsonList[*KeySpec] `json:"keys,omitempty"`
		TransactionBlacklist *AllowedTransactions        `json:"transactionBlacklist,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.KeyBook() == nil) {
		u.KeyBook = v.KeyBook()
	}
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.CreditBalance == 0) {
		u.CreditBalance = v.CreditBalance
	}
	if !(v.AcceptThreshold == 0) {
		u.AcceptThreshold = v.AcceptThreshold
		u.Threshold = v.AcceptThreshold
	}
	if !(v.RejectThreshold == 0) {
		u.RejectThreshold = v.RejectThreshold
	}
	if !(v.ResponseThreshold == 0) {
		u.ResponseThreshold = v.ResponseThreshold
	}
	if !(v.BlockThreshold == 0) {
		u.BlockThreshold = v.BlockThreshold
	}
	if !(v.Version == 0) {
		u.Version = v.Version
	}
	if !(len(v.Keys) == 0) {
		u.Keys = v.Keys
	}
	if !(v.TransactionBlacklist == nil) {
		u.TransactionBlacklist = v.TransactionBlacklist
	}
	return json.Marshal(&u)
}

func (v *KeySpec) MarshalJSON() ([]byte, error) {
	u := struct {
		PublicKeyHash *string  `json:"publicKeyHash,omitempty"`
		PublicKey     *string  `json:"publicKey,omitempty"`
		LastUsedOn    uint64   `json:"lastUsedOn,omitempty"`
		Delegate      *url.URL `json:"delegate,omitempty"`
	}{}
	if !(len(v.PublicKeyHash) == 0) {
		u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
		u.PublicKey = encoding.BytesToJSON(v.PublicKeyHash)
	}
	if !(v.LastUsedOn == 0) {
		u.LastUsedOn = v.LastUsedOn
	}
	if !(v.Delegate == nil) {
		u.Delegate = v.Delegate
	}
	return json.Marshal(&u)
}

func (v *KeySpecParams) MarshalJSON() ([]byte, error) {
	u := struct {
		KeyHash  *string  `json:"keyHash,omitempty"`
		Delegate *url.URL `json:"delegate,omitempty"`
	}{}
	if !(len(v.KeyHash) == 0) {
		u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	}
	if !(v.Delegate == nil) {
		u.Delegate = v.Delegate
	}
	return json.Marshal(&u)
}

func (v *LegacyED25519Signature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType `json:"type"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Timestamp == 0) {
		u.Timestamp = v.Timestamp
	}
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		u.Signature = encoding.BytesToJSON(v.Signature)
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.SignerVersion == 0) {
		u.SignerVersion = v.SignerVersion
	}
	if !(v.Vote == 0) {
		u.Vote = v.Vote
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *LiteDataAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	return json.Marshal(&u)
}

func (v *LiteIdentity) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          AccountType `json:"type"`
		Url           *url.URL    `json:"url,omitempty"`
		CreditBalance uint64      `json:"creditBalance,omitempty"`
		LastUsedOn    uint64      `json:"lastUsedOn,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.CreditBalance == 0) {
		u.CreditBalance = v.CreditBalance
	}
	if !(v.LastUsedOn == 0) {
		u.LastUsedOn = v.LastUsedOn
	}
	return json.Marshal(&u)
}

func (v *LiteTokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       AccountType `json:"type"`
		Url        *url.URL    `json:"url,omitempty"`
		TokenUrl   *url.URL    `json:"tokenUrl,omitempty"`
		Balance    *string     `json:"balance,omitempty"`
		LockHeight uint64      `json:"lockHeight,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.TokenUrl == nil) {
		u.TokenUrl = v.TokenUrl
	}
	if !((v.Balance).Cmp(new(big.Int)) == 0) {
		u.Balance = encoding.BigintToJSON(&v.Balance)
	}
	if !(v.LockHeight == 0) {
		u.LockHeight = v.LockHeight
	}
	return json.Marshal(&u)
}

func (v *LockAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   TransactionType `json:"type"`
		Height uint64          `json:"height,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Height == 0) {
		u.Height = v.Height
	}
	return json.Marshal(&u)
}

func (v *MetricsRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	if !(len(v.Metric) == 0) {
		u.Metric = v.Metric
	}
	if !(v.Duration == 0) {
		u.Duration = encoding.DurationToJSON(v.Duration)
	}
	return json.Marshal(&u)
}

func (v *MetricsResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	if !(v.Value == nil) {
		u.Value = encoding.AnyToJSON(v.Value)
	}
	return json.Marshal(&u)
}

func (v *NetworkAccountUpdate) MarshalJSON() ([]byte, error) {
	u := struct {
		Name string                                       `json:"name,omitempty"`
		Body *encoding.JsonUnmarshalWith[TransactionBody] `json:"body,omitempty"`
	}{}
	if !(len(v.Name) == 0) {
		u.Name = v.Name
	}
	if !(EqualTransactionBody(v.Body, nil)) {
		u.Body = &encoding.JsonUnmarshalWith[TransactionBody]{Value: v.Body, Func: UnmarshalTransactionBodyJSON}
	}
	return json.Marshal(&u)
}

func (v *NetworkDefinition) MarshalJSON() ([]byte, error) {
	u := struct {
		NetworkName string                            `json:"networkName,omitempty"`
		Version     uint64                            `json:"version,omitempty"`
		Partitions  encoding.JsonList[*PartitionInfo] `json:"partitions,omitempty"`
		Validators  encoding.JsonList[*ValidatorInfo] `json:"validators,omitempty"`
	}{}
	if !(len(v.NetworkName) == 0) {
		u.NetworkName = v.NetworkName
	}
	if !(v.Version == 0) {
		u.Version = v.Version
	}
	if !(len(v.Partitions) == 0) {
		u.Partitions = v.Partitions
	}
	if !(len(v.Validators) == 0) {
		u.Validators = v.Validators
	}
	return json.Marshal(&u)
}

func (v *Object) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    ObjectType                       `json:"type,omitempty"`
		Chains  encoding.JsonList[ChainMetadata] `json:"chains,omitempty"`
		Pending TxIdSet                          `json:"pending,omitempty"`
	}{}
	if !(v.Type == 0) {
		u.Type = v.Type
	}
	if !(len(v.Chains) == 0) {
		u.Chains = v.Chains
	}
	if !((v.Pending).Equal(new(TxIdSet))) {
		u.Pending = v.Pending
	}
	return json.Marshal(&u)
}

func (v *PartitionAnchor) MarshalJSON() ([]byte, error) {
	u := struct {
		Source          *url.URL `json:"source,omitempty"`
		MajorBlockIndex uint64   `json:"majorBlockIndex,omitempty"`
		MinorBlockIndex uint64   `json:"minorBlockIndex,omitempty"`
		RootChainIndex  uint64   `json:"rootChainIndex,omitempty"`
		RootChainAnchor string   `json:"rootChainAnchor,omitempty"`
		StateTreeAnchor string   `json:"stateTreeAnchor,omitempty"`
	}{}
	if !(v.Source == nil) {
		u.Source = v.Source
	}
	if !(v.MajorBlockIndex == 0) {
		u.MajorBlockIndex = v.MajorBlockIndex
	}
	if !(v.MinorBlockIndex == 0) {
		u.MinorBlockIndex = v.MinorBlockIndex
	}
	if !(v.RootChainIndex == 0) {
		u.RootChainIndex = v.RootChainIndex
	}
	if !(v.RootChainAnchor == ([32]byte{})) {
		u.RootChainAnchor = encoding.ChainToJSON(v.RootChainAnchor)
	}
	if !(v.StateTreeAnchor == ([32]byte{})) {
		u.StateTreeAnchor = encoding.ChainToJSON(v.StateTreeAnchor)
	}
	return json.Marshal(&u)
}

func (v *PartitionSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type               SignatureType `json:"type"`
		SourceNetwork      *url.URL      `json:"sourceNetwork,omitempty"`
		DestinationNetwork *url.URL      `json:"destinationNetwork,omitempty"`
		SequenceNumber     uint64        `json:"sequenceNumber,omitempty"`
		TransactionHash    string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.SourceNetwork == nil) {
		u.SourceNetwork = v.SourceNetwork
	}
	if !(v.DestinationNetwork == nil) {
		u.DestinationNetwork = v.DestinationNetwork
	}
	if !(v.SequenceNumber == 0) {
		u.SequenceNumber = v.SequenceNumber
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *PartitionSyntheticLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Url       *url.URL                     `json:"url,omitempty"`
		Produced  uint64                       `json:"produced,omitempty"`
		Received  uint64                       `json:"received,omitempty"`
		Delivered uint64                       `json:"delivered,omitempty"`
		Pending   encoding.JsonList[*url.TxID] `json:"pending,omitempty"`
	}{}
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.Produced == 0) {
		u.Produced = v.Produced
	}
	if !(v.Received == 0) {
		u.Received = v.Received
	}
	if !(v.Delivered == 0) {
		u.Delivered = v.Delivered
	}
	if !(len(v.Pending) == 0) {
		u.Pending = v.Pending
	}
	return json.Marshal(&u)
}

func (v *PlaceholderTransaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *RCD1Signature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		u.Signature = encoding.BytesToJSON(v.Signature)
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.SignerVersion == 0) {
		u.SignerVersion = v.SignerVersion
	}
	if !(v.Timestamp == 0) {
		u.Timestamp = v.Timestamp
	}
	if !(v.Vote == 0) {
		u.Vote = v.Vote
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *ReceiptSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType  `json:"type"`
		SourceNetwork   *url.URL       `json:"sourceNetwork,omitempty"`
		Proof           merkle.Receipt `json:"proof,omitempty"`
		TransactionHash string         `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.SourceNetwork == nil) {
		u.SourceNetwork = v.SourceNetwork
	}
	if !((v.Proof).Equal(new(merkle.Receipt))) {
		u.Proof = v.Proof
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	return json.Marshal(&u)
}

func (v *RemoteSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        SignatureType                          `json:"type"`
		Destination *url.URL                               `json:"destination,omitempty"`
		Signature   *encoding.JsonUnmarshalWith[Signature] `json:"signature,omitempty"`
		Cause       encoding.JsonList[string]              `json:"cause,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Destination == nil) {
		u.Destination = v.Destination
	}
	if !(EqualSignature(v.Signature, nil)) {
		u.Signature = &encoding.JsonUnmarshalWith[Signature]{Value: v.Signature, Func: UnmarshalSignatureJSON}
	}
	if !(len(v.Cause) == 0) {
		u.Cause = make(encoding.JsonList[string], len(v.Cause))
		for i, x := range v.Cause {
			u.Cause[i] = encoding.ChainToJSON(x)
		}
	}
	return json.Marshal(&u)
}

func (v *RemoteTransaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
		Hash string          `json:"hash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(v.Hash)
	}
	return json.Marshal(&u)
}

func (v *RemoveAccountAuthorityOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	return json.Marshal(&u)
}

func (v *RemoveKeyOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Entry KeySpecParams        `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	if !((v.Entry).Equal(new(KeySpecParams))) {
		u.Entry = v.Entry
	}
	return json.Marshal(&u)
}

func (v *RoutingTable) MarshalJSON() ([]byte, error) {
	u := struct {
		Overrides encoding.JsonList[RouteOverride] `json:"overrides,omitempty"`
		Routes    encoding.JsonList[Route]         `json:"routes,omitempty"`
	}{}
	if !(len(v.Overrides) == 0) {
		u.Overrides = v.Overrides
	}
	if !(len(v.Routes) == 0) {
		u.Routes = v.Routes
	}
	return json.Marshal(&u)
}

func (v *SendTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType                    `json:"type"`
		Hash string                             `json:"hash,omitempty"`
		Meta json.RawMessage                    `json:"meta,omitempty"`
		To   encoding.JsonList[*TokenRecipient] `json:"to,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(v.Hash)
	}
	if !(len(v.Meta) == 0) {
		u.Meta = v.Meta
	}
	if !(len(v.To) == 0) {
		u.To = v.To
	}
	return json.Marshal(&u)
}

func (v *SetThresholdKeyPageOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      KeyPageOperationType `json:"type"`
		Threshold uint64               `json:"threshold,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Threshold == 0) {
		u.Threshold = v.Threshold
	}
	return json.Marshal(&u)
}

func (v *SignatureSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            SignatureType                              `json:"type"`
		Vote            VoteType                                   `json:"vote,omitempty"`
		Signer          *url.URL                                   `json:"signer,omitempty"`
		TransactionHash string                                     `json:"transactionHash,omitempty"`
		Signatures      *encoding.JsonUnmarshalListWith[Signature] `json:"signatures,omitempty"`
		Authority       *url.URL                                   `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Vote == 0) {
		u.Vote = v.Vote
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.TransactionHash == ([32]byte{})) {
		u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	}
	if !(len(v.Signatures) == 0) {
		u.Signatures = &encoding.JsonUnmarshalListWith[Signature]{Value: v.Signatures, Func: UnmarshalSignatureJSON}
	}
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	return json.Marshal(&u)
}

func (v *SyntheticBurnTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType `json:"type"`
		Cause     *url.TxID       `json:"cause,omitempty"`
		Source    *url.URL        `json:"source,omitempty"`
		Initiator *url.URL        `json:"initiator,omitempty"`
		FeeRefund uint64          `json:"feeRefund,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
		IsRefund  bool            `json:"isRefund,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.SyntheticOrigin.Cause == nil) {

		u.Cause = v.SyntheticOrigin.Cause
	}
	if !(v.SyntheticOrigin.Source() == nil) {

		u.Source = v.SyntheticOrigin.Source()
	}
	if !(v.SyntheticOrigin.Initiator == nil) {

		u.Initiator = v.SyntheticOrigin.Initiator
	}
	if !(v.SyntheticOrigin.FeeRefund == 0) {

		u.FeeRefund = v.SyntheticOrigin.FeeRefund
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		u.Amount = encoding.BigintToJSON(&v.Amount)
	}
	if !(!v.IsRefund) {
		u.IsRefund = v.IsRefund
	}
	return json.Marshal(&u)
}

func (v *SyntheticCreateIdentity) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType                          `json:"type"`
		Cause     *url.TxID                                `json:"cause,omitempty"`
		Source    *url.URL                                 `json:"source,omitempty"`
		Initiator *url.URL                                 `json:"initiator,omitempty"`
		FeeRefund uint64                                   `json:"feeRefund,omitempty"`
		Accounts  *encoding.JsonUnmarshalListWith[Account] `json:"accounts,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.SyntheticOrigin.Cause == nil) {

		u.Cause = v.SyntheticOrigin.Cause
	}
	if !(v.SyntheticOrigin.Source() == nil) {

		u.Source = v.SyntheticOrigin.Source()
	}
	if !(v.SyntheticOrigin.Initiator == nil) {

		u.Initiator = v.SyntheticOrigin.Initiator
	}
	if !(v.SyntheticOrigin.FeeRefund == 0) {

		u.FeeRefund = v.SyntheticOrigin.FeeRefund
	}
	if !(len(v.Accounts) == 0) {
		u.Accounts = &encoding.JsonUnmarshalListWith[Account]{Value: v.Accounts, Func: UnmarshalAccountJSON}
	}
	return json.Marshal(&u)
}

func (v *SyntheticDepositCredits) MarshalJSON() ([]byte, error) {
	u := struct {
		Type             TransactionType `json:"type"`
		Cause            *url.TxID       `json:"cause,omitempty"`
		Source           *url.URL        `json:"source,omitempty"`
		Initiator        *url.URL        `json:"initiator,omitempty"`
		FeeRefund        uint64          `json:"feeRefund,omitempty"`
		Amount           uint64          `json:"amount,omitempty"`
		AcmeRefundAmount *string         `json:"acmeRefundAmount,omitempty"`
		IsRefund         bool            `json:"isRefund,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.SyntheticOrigin.Cause == nil) {

		u.Cause = v.SyntheticOrigin.Cause
	}
	if !(v.SyntheticOrigin.Source() == nil) {

		u.Source = v.SyntheticOrigin.Source()
	}
	if !(v.SyntheticOrigin.Initiator == nil) {

		u.Initiator = v.SyntheticOrigin.Initiator
	}
	if !(v.SyntheticOrigin.FeeRefund == 0) {

		u.FeeRefund = v.SyntheticOrigin.FeeRefund
	}
	if !(v.Amount == 0) {
		u.Amount = v.Amount
	}
	if !(v.AcmeRefundAmount == nil) {
		u.AcmeRefundAmount = encoding.BigintToJSON(v.AcmeRefundAmount)
	}
	if !(!v.IsRefund) {
		u.IsRefund = v.IsRefund
	}
	return json.Marshal(&u)
}

func (v *SyntheticDepositTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType `json:"type"`
		Cause     *url.TxID       `json:"cause,omitempty"`
		Source    *url.URL        `json:"source,omitempty"`
		Initiator *url.URL        `json:"initiator,omitempty"`
		FeeRefund uint64          `json:"feeRefund,omitempty"`
		Token     *url.URL        `json:"token,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
		IsIssuer  bool            `json:"isIssuer,omitempty"`
		IsRefund  bool            `json:"isRefund,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.SyntheticOrigin.Cause == nil) {

		u.Cause = v.SyntheticOrigin.Cause
	}
	if !(v.SyntheticOrigin.Source() == nil) {

		u.Source = v.SyntheticOrigin.Source()
	}
	if !(v.SyntheticOrigin.Initiator == nil) {

		u.Initiator = v.SyntheticOrigin.Initiator
	}
	if !(v.SyntheticOrigin.FeeRefund == 0) {

		u.FeeRefund = v.SyntheticOrigin.FeeRefund
	}
	if !(v.Token == nil) {
		u.Token = v.Token
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		u.Amount = encoding.BigintToJSON(&v.Amount)
	}
	if !(!v.IsIssuer) {
		u.IsIssuer = v.IsIssuer
	}
	if !(!v.IsRefund) {
		u.IsRefund = v.IsRefund
	}
	return json.Marshal(&u)
}

func (v *SyntheticForwardTransaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        TransactionType                    `json:"type"`
		Signatures  encoding.JsonList[RemoteSignature] `json:"signatures,omitempty"`
		Transaction *Transaction                       `json:"transaction,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Signatures) == 0) {
		u.Signatures = v.Signatures
	}
	if !(v.Transaction == nil) {
		u.Transaction = v.Transaction
	}
	return json.Marshal(&u)
}

func (v *SyntheticLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Type     AccountType                                  `json:"type"`
		Url      *url.URL                                     `json:"url,omitempty"`
		Sequence encoding.JsonList[*PartitionSyntheticLedger] `json:"sequence,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.Sequence) == 0) {
		u.Sequence = v.Sequence
	}
	return json.Marshal(&u)
}

func (v *SyntheticWriteData) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType                        `json:"type"`
		Cause     *url.TxID                              `json:"cause,omitempty"`
		Source    *url.URL                               `json:"source,omitempty"`
		Initiator *url.URL                               `json:"initiator,omitempty"`
		FeeRefund uint64                                 `json:"feeRefund,omitempty"`
		Entry     *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.SyntheticOrigin.Cause == nil) {

		u.Cause = v.SyntheticOrigin.Cause
	}
	if !(v.SyntheticOrigin.Source() == nil) {

		u.Source = v.SyntheticOrigin.Source()
	}
	if !(v.SyntheticOrigin.Initiator == nil) {

		u.Initiator = v.SyntheticOrigin.Initiator
	}
	if !(v.SyntheticOrigin.FeeRefund == 0) {

		u.FeeRefund = v.SyntheticOrigin.FeeRefund
	}
	if !(EqualDataEntry(v.Entry, nil)) {
		u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	}
	return json.Marshal(&u)
}

func (v *SystemGenesis) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *SystemLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            AccountType                             `json:"type"`
		Url             *url.URL                                `json:"url,omitempty"`
		Index           uint64                                  `json:"index,omitempty"`
		Timestamp       time.Time                               `json:"timestamp,omitempty"`
		AcmeBurnt       *string                                 `json:"acmeBurnt,omitempty"`
		PendingUpdates  encoding.JsonList[NetworkAccountUpdate] `json:"pendingUpdates,omitempty"`
		Anchor          *encoding.JsonUnmarshalWith[AnchorBody] `json:"anchor,omitempty"`
		ExecutorVersion ExecutorVersion                         `json:"executorVersion,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.Timestamp == (time.Time{})) {
		u.Timestamp = v.Timestamp
	}
	if !((v.AcmeBurnt).Cmp(new(big.Int)) == 0) {
		u.AcmeBurnt = encoding.BigintToJSON(&v.AcmeBurnt)
	}
	if !(len(v.PendingUpdates) == 0) {
		u.PendingUpdates = v.PendingUpdates
	}
	if !(EqualAnchorBody(v.Anchor, nil)) {
		u.Anchor = &encoding.JsonUnmarshalWith[AnchorBody]{Value: v.Anchor, Func: UnmarshalAnchorBodyJSON}
	}
	if !(v.ExecutorVersion == 0) {
		u.ExecutorVersion = v.ExecutorVersion
	}
	return json.Marshal(&u)
}

func (v *SystemWriteData) MarshalJSON() ([]byte, error) {
	u := struct {
		Type         TransactionType                        `json:"type"`
		Entry        *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
		WriteToState bool                                   `json:"writeToState,omitempty"`
	}{}
	u.Type = v.Type()
	if !(EqualDataEntry(v.Entry, nil)) {
		u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	}
	if !(!v.WriteToState) {
		u.WriteToState = v.WriteToState
	}
	return json.Marshal(&u)
}

func (v *TokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        AccountType                       `json:"type"`
		Url         *url.URL                          `json:"url,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
		TokenUrl    *url.URL                          `json:"tokenUrl,omitempty"`
		Balance     *string                           `json:"balance,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.AccountAuth.Authorities) == 0) {

		u.Authorities = v.AccountAuth.Authorities
	}
	if !(v.TokenUrl == nil) {
		u.TokenUrl = v.TokenUrl
	}
	if !((v.Balance).Cmp(new(big.Int)) == 0) {
		u.Balance = encoding.BigintToJSON(&v.Balance)
	}
	return json.Marshal(&u)
}

func (v *TokenIssuer) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        AccountType                       `json:"type"`
		Url         *url.URL                          `json:"url,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
		Symbol      string                            `json:"symbol,omitempty"`
		Precision   uint64                            `json:"precision,omitempty"`
		Properties  *url.URL                          `json:"properties,omitempty"`
		Issued      *string                           `json:"issued,omitempty"`
		SupplyLimit *string                           `json:"supplyLimit,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(len(v.AccountAuth.Authorities) == 0) {

		u.Authorities = v.AccountAuth.Authorities
	}
	if !(len(v.Symbol) == 0) {
		u.Symbol = v.Symbol
	}
	if !(v.Precision == 0) {
		u.Precision = v.Precision
	}
	if !(v.Properties == nil) {
		u.Properties = v.Properties
	}
	if !((v.Issued).Cmp(new(big.Int)) == 0) {
		u.Issued = encoding.BigintToJSON(&v.Issued)
	}
	if !(v.SupplyLimit == nil) {
		u.SupplyLimit = encoding.BigintToJSON(v.SupplyLimit)
	}
	return json.Marshal(&u)
}

func (v *TokenRecipient) MarshalJSON() ([]byte, error) {
	u := struct {
		Url    *url.URL `json:"url,omitempty"`
		Amount *string  `json:"amount,omitempty"`
	}{}
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		u.Amount = encoding.BigintToJSON(&v.Amount)
	}
	return json.Marshal(&u)
}

func (v *Transaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Header TransactionHeader                            `json:"header,omitempty"`
		Body   *encoding.JsonUnmarshalWith[TransactionBody] `json:"body,omitempty"`
	}{}
	if !((v.Header).Equal(new(TransactionHeader))) {
		u.Header = v.Header
	}
	if !(EqualTransactionBody(v.Body, nil)) {
		u.Body = &encoding.JsonUnmarshalWith[TransactionBody]{Value: v.Body, Func: UnmarshalTransactionBodyJSON}
	}
	if !(len(v.hash) == 0) {
	}
	return json.Marshal(&u)
}

func (v *TransactionHeader) MarshalJSON() ([]byte, error) {
	u := struct {
		Principal *url.URL `json:"principal,omitempty"`
		Initiator string   `json:"initiator,omitempty"`
		Memo      string   `json:"memo,omitempty"`
		Metadata  *string  `json:"metadata,omitempty"`
	}{}
	if !(v.Principal == nil) {
		u.Principal = v.Principal
	}
	if !(v.Initiator == ([32]byte{})) {
		u.Initiator = encoding.ChainToJSON(v.Initiator)
	}
	if !(len(v.Memo) == 0) {
		u.Memo = v.Memo
	}
	if !(len(v.Metadata) == 0) {
		u.Metadata = encoding.BytesToJSON(v.Metadata)
	}
	return json.Marshal(&u)
}

func (v *TransactionResultSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Results encoding.JsonList[*TransactionStatus] `json:"results,omitempty"`
	}{}
	if !(len(v.Results) == 0) {
		u.Results = v.Results
	}
	return json.Marshal(&u)
}

func (v *TransactionStatus) MarshalJSON() ([]byte, error) {
	u := struct {
		TxID                *url.TxID                                      `json:"txID,omitempty"`
		Code                errors2.Status                                 `json:"code,omitempty"`
		Remote              bool                                           `json:"remote,omitempty"`
		Delivered           bool                                           `json:"delivered,omitempty"`
		Pending             bool                                           `json:"pending,omitempty"`
		Failed              bool                                           `json:"failed,omitempty"`
		CodeNum             uint64                                         `json:"codeNum,omitempty"`
		Error               *errors2.Error                                 `json:"error,omitempty"`
		Result              *encoding.JsonUnmarshalWith[TransactionResult] `json:"result,omitempty"`
		Received            uint64                                         `json:"received,omitempty"`
		Initiator           *url.URL                                       `json:"initiator,omitempty"`
		Signers             *encoding.JsonUnmarshalListWith[Signer]        `json:"signers,omitempty"`
		SourceNetwork       *url.URL                                       `json:"sourceNetwork,omitempty"`
		DestinationNetwork  *url.URL                                       `json:"destinationNetwork,omitempty"`
		SequenceNumber      uint64                                         `json:"sequenceNumber,omitempty"`
		GotDirectoryReceipt bool                                           `json:"gotDirectoryReceipt,omitempty"`
		Proof               *merkle.Receipt                                `json:"proof,omitempty"`
		AnchorSigners       encoding.JsonList[*string]                     `json:"anchorSigners,omitempty"`
	}{}
	if !(v.TxID == nil) {
		u.TxID = v.TxID
	}
	if !(v.Code == 0) {
		u.Code = v.Code
	}
	if !(!v.Remote()) {
		u.Remote = v.Remote()
	}
	if !(!v.Delivered()) {
		u.Delivered = v.Delivered()
	}
	if !(!v.Pending()) {
		u.Pending = v.Pending()
	}
	if !(!v.Failed()) {
		u.Failed = v.Failed()
	}
	if !(v.CodeNum() == 0) {
		u.CodeNum = v.CodeNum()
	}
	if !(v.Error == nil) {
		u.Error = v.Error
	}
	if !(EqualTransactionResult(v.Result, nil)) {
		u.Result = &encoding.JsonUnmarshalWith[TransactionResult]{Value: v.Result, Func: UnmarshalTransactionResultJSON}
	}
	if !(v.Received == 0) {
		u.Received = v.Received
	}
	if !(v.Initiator == nil) {
		u.Initiator = v.Initiator
	}
	if !(len(v.Signers) == 0) {
		u.Signers = &encoding.JsonUnmarshalListWith[Signer]{Value: v.Signers, Func: UnmarshalSignerJSON}
	}
	if !(v.SourceNetwork == nil) {
		u.SourceNetwork = v.SourceNetwork
	}
	if !(v.DestinationNetwork == nil) {
		u.DestinationNetwork = v.DestinationNetwork
	}
	if !(v.SequenceNumber == 0) {
		u.SequenceNumber = v.SequenceNumber
	}
	if !(!v.GotDirectoryReceipt) {
		u.GotDirectoryReceipt = v.GotDirectoryReceipt
	}
	if !(v.Proof == nil) {
		u.Proof = v.Proof
	}
	if !(len(v.AnchorSigners) == 0) {
		u.AnchorSigners = make(encoding.JsonList[*string], len(v.AnchorSigners))
		for i, x := range v.AnchorSigners {
			u.AnchorSigners[i] = encoding.BytesToJSON(x)
		}
	}
	return json.Marshal(&u)
}

func (v *TxIdSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Entries encoding.JsonList[*url.TxID] `json:"entries,omitempty"`
	}{}
	if !(len(v.Entries) == 0) {
		u.Entries = v.Entries
	}
	return json.Marshal(&u)
}

func (v *UnknownAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	return json.Marshal(&u)
}

func (v *UnknownSigner) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    AccountType `json:"type"`
		Url     *url.URL    `json:"url,omitempty"`
		Version uint64      `json:"version,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.Version == 0) {
		u.Version = v.Version
	}
	return json.Marshal(&u)
}

func (v *UpdateAccountAuth) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType                                       `json:"type"`
		Operations *encoding.JsonUnmarshalListWith[AccountAuthOperation] `json:"operations,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Operations) == 0) {
		u.Operations = &encoding.JsonUnmarshalListWith[AccountAuthOperation]{Value: v.Operations, Func: UnmarshalAccountAuthOperationJSON}
	}
	return json.Marshal(&u)
}

func (v *UpdateAllowedKeyPageOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  KeyPageOperationType               `json:"type"`
		Allow encoding.JsonList[TransactionType] `json:"allow,omitempty"`
		Deny  encoding.JsonList[TransactionType] `json:"deny,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Allow) == 0) {
		u.Allow = v.Allow
	}
	if !(len(v.Deny) == 0) {
		u.Deny = v.Deny
	}
	return json.Marshal(&u)
}

func (v *UpdateKey) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType `json:"type"`
		NewKeyHash *string         `json:"newKeyHash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.NewKeyHash) == 0) {
		u.NewKeyHash = encoding.BytesToJSON(v.NewKeyHash)
	}
	return json.Marshal(&u)
}

func (v *UpdateKeyOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type     KeyPageOperationType `json:"type"`
		OldEntry KeySpecParams        `json:"oldEntry,omitempty"`
		NewEntry KeySpecParams        `json:"newEntry,omitempty"`
	}{}
	u.Type = v.Type()
	if !((v.OldEntry).Equal(new(KeySpecParams))) {
		u.OldEntry = v.OldEntry
	}
	if !((v.NewEntry).Equal(new(KeySpecParams))) {
		u.NewEntry = v.NewEntry
	}
	return json.Marshal(&u)
}

func (v *UpdateKeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType                                   `json:"type"`
		Operation *encoding.JsonUnmarshalListWith[KeyPageOperation] `json:"operation,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Operation) == 0) {
		u.Operation = &encoding.JsonUnmarshalListWith[KeyPageOperation]{Value: v.Operation, Func: UnmarshalKeyPageOperationJSON}
	}
	return json.Marshal(&u)
}

func (v *ValidatorInfo) MarshalJSON() ([]byte, error) {
	u := struct {
		PublicKey     *string                                    `json:"publicKey,omitempty"`
		PublicKeyHash string                                     `json:"publicKeyHash,omitempty"`
		Operator      *url.URL                                   `json:"operator,omitempty"`
		Partitions    encoding.JsonList[*ValidatorPartitionInfo] `json:"partitions,omitempty"`
	}{}
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(v.PublicKeyHash == ([32]byte{})) {
		u.PublicKeyHash = encoding.ChainToJSON(v.PublicKeyHash)
	}
	if !(v.Operator == nil) {
		u.Operator = v.Operator
	}
	if !(len(v.Partitions) == 0) {
		u.Partitions = v.Partitions
	}
	return json.Marshal(&u)
}

func (v *WriteData) MarshalJSON() ([]byte, error) {
	u := struct {
		Type         TransactionType                        `json:"type"`
		Entry        *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
		Scratch      bool                                   `json:"scratch,omitempty"`
		WriteToState bool                                   `json:"writeToState,omitempty"`
	}{}
	u.Type = v.Type()
	if !(EqualDataEntry(v.Entry, nil)) {
		u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	}
	if !(!v.Scratch) {
		u.Scratch = v.Scratch
	}
	if !(!v.WriteToState) {
		u.WriteToState = v.WriteToState
	}
	return json.Marshal(&u)
}

func (v *WriteDataResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType `json:"type"`
		EntryHash  string          `json:"entryHash,omitempty"`
		AccountUrl *url.URL        `json:"accountUrl,omitempty"`
		AccountID  *string         `json:"accountID,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.EntryHash == ([32]byte{})) {
		u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	}
	if !(v.AccountUrl == nil) {
		u.AccountUrl = v.AccountUrl
	}
	if !(len(v.AccountID) == 0) {
		u.AccountID = encoding.BytesToJSON(v.AccountID)
	}
	return json.Marshal(&u)
}

func (v *WriteDataTo) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType                        `json:"type"`
		Recipient *url.URL                               `json:"recipient,omitempty"`
		Entry     *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Recipient == nil) {
		u.Recipient = v.Recipient
	}
	if !(EqualDataEntry(v.Entry, nil)) {
		u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	}
	return json.Marshal(&u)
}

func (v *ADI) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        AccountType                       `json:"type"`
		Url         *url.URL                          `json:"url,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	return nil
}

func (v *AccountAuth) UnmarshalJSON(data []byte) error {
	u := struct {
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
	}{}
	u.Authorities = v.Authorities
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Authorities = u.Authorities
	return nil
}

func (v *AccumulateDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type DataEntryType              `json:"type"`
		Data encoding.JsonList[*string] `json:"data,omitempty"`
	}{}
	u.Type = v.Type()
	u.Data = make(encoding.JsonList[*string], len(v.Data))
	for i, x := range v.Data {
		u.Data[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Data = make([][]byte, len(u.Data))
	for i, x := range u.Data {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Data: %w", err)
		} else {
			v.Data[i] = x
		}
	}
	return nil
}

func (v *AcmeFaucet) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
		Url  *url.URL        `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	return nil
}

func (v *ActivateProtocolVersion) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    TransactionType `json:"type"`
		Version ExecutorVersion `json:"version,omitempty"`
	}{}
	u.Type = v.Type()
	u.Version = v.Version
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Version = u.Version
	return nil
}

func (v *AddAccountAuthorityOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	return nil
}

func (v *AddCredits) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType `json:"type"`
		Recipient *url.URL        `json:"recipient,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
		Oracle    uint64          `json:"oracle,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Oracle = v.Oracle
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Recipient = u.Recipient
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	v.Oracle = u.Oracle
	return nil
}

func (v *AddCreditsResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    TransactionType `json:"type"`
		Amount  *string         `json:"amount,omitempty"`
		Credits uint64          `json:"credits,omitempty"`
		Oracle  uint64          `json:"oracle,omitempty"`
	}{}
	u.Type = v.Type()
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Credits = v.Credits
	u.Oracle = v.Oracle
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	v.Credits = u.Credits
	v.Oracle = u.Oracle
	return nil
}

func (v *AddKeyOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Entry KeySpecParams        `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Entry = u.Entry
	return nil
}

func (v *AnchorLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Type                     AccountType                                  `json:"type"`
		Url                      *url.URL                                     `json:"url,omitempty"`
		MinorBlockSequenceNumber uint64                                       `json:"minorBlockSequenceNumber,omitempty"`
		MajorBlockIndex          uint64                                       `json:"majorBlockIndex,omitempty"`
		MajorBlockTime           time.Time                                    `json:"majorBlockTime,omitempty"`
		PendingMajorBlockAnchors encoding.JsonList[*url.URL]                  `json:"pendingMajorBlockAnchors,omitempty"`
		Sequence                 encoding.JsonList[*PartitionSyntheticLedger] `json:"sequence,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.MinorBlockSequenceNumber = v.MinorBlockSequenceNumber
	u.MajorBlockIndex = v.MajorBlockIndex
	u.MajorBlockTime = v.MajorBlockTime
	u.PendingMajorBlockAnchors = v.PendingMajorBlockAnchors
	u.Sequence = v.Sequence
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.MinorBlockSequenceNumber = u.MinorBlockSequenceNumber
	v.MajorBlockIndex = u.MajorBlockIndex
	v.MajorBlockTime = u.MajorBlockTime
	v.PendingMajorBlockAnchors = u.PendingMajorBlockAnchors
	v.Sequence = u.Sequence
	return nil
}

func (v *AnchorMetadata) UnmarshalJSON(data []byte) error {
	u := struct {
		Name        string    `json:"name,omitempty"`
		Type        ChainType `json:"type,omitempty"`
		Account     *url.URL  `json:"account,omitempty"`
		Index       uint64    `json:"index,omitempty"`
		SourceIndex uint64    `json:"sourceIndex,omitempty"`
		SourceBlock uint64    `json:"sourceBlock,omitempty"`
		Entry       *string   `json:"entry,omitempty"`
	}{}
	u.Name = v.ChainMetadata.Name
	u.Type = v.ChainMetadata.Type
	u.Account = v.Account
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesToJSON(v.Entry)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ChainMetadata.Name = u.Name
	v.ChainMetadata.Type = u.Type
	v.Account = u.Account
	v.Index = u.Index
	v.SourceIndex = u.SourceIndex
	v.SourceBlock = u.SourceBlock
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	return nil
}

func (v *AuthoritySignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      SignatureType               `json:"type"`
		Signer    *url.URL                    `json:"signer,omitempty"`
		Authority *url.URL                    `json:"authority,omitempty"`
		Vote      VoteType                    `json:"vote,omitempty"`
		TxID      *url.TxID                   `json:"txID,omitempty"`
		Delegator encoding.JsonList[*url.URL] `json:"delegator,omitempty"`
	}{}
	u.Type = v.Type()
	u.Signer = v.Signer
	u.Authority = v.Authority
	u.Vote = v.Vote
	u.TxID = v.TxID
	u.Delegator = v.Delegator
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Signer = u.Signer
	v.Authority = u.Authority
	v.Vote = u.Vote
	v.TxID = u.TxID
	v.Delegator = u.Delegator
	return nil
}

func (v *BTCLegacySignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Timestamp = u.Timestamp
	v.Vote = u.Vote
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *BTCSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Timestamp = u.Timestamp
	v.Vote = u.Vote
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *BlockLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    AccountType                    `json:"type"`
		Url     *url.URL                       `json:"url,omitempty"`
		Index   uint64                         `json:"index,omitempty"`
		Time    time.Time                      `json:"time,omitempty"`
		Entries encoding.JsonList[*BlockEntry] `json:"entries,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Index = v.Index
	u.Time = v.Time
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Index = u.Index
	v.Time = u.Time
	v.Entries = u.Entries
	return nil
}

func (v *BlockValidatorAnchor) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            TransactionType `json:"type"`
		Source          *url.URL        `json:"source,omitempty"`
		MajorBlockIndex uint64          `json:"majorBlockIndex,omitempty"`
		MinorBlockIndex uint64          `json:"minorBlockIndex,omitempty"`
		RootChainIndex  uint64          `json:"rootChainIndex,omitempty"`
		RootChainAnchor string          `json:"rootChainAnchor,omitempty"`
		StateTreeAnchor string          `json:"stateTreeAnchor,omitempty"`
		AcmeBurnt       *string         `json:"acmeBurnt,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.PartitionAnchor.Source
	u.MajorBlockIndex = v.PartitionAnchor.MajorBlockIndex
	u.MinorBlockIndex = v.PartitionAnchor.MinorBlockIndex
	u.RootChainIndex = v.PartitionAnchor.RootChainIndex
	u.RootChainAnchor = encoding.ChainToJSON(v.PartitionAnchor.RootChainAnchor)
	u.StateTreeAnchor = encoding.ChainToJSON(v.PartitionAnchor.StateTreeAnchor)
	u.AcmeBurnt = encoding.BigintToJSON(&v.AcmeBurnt)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.PartitionAnchor.Source = u.Source
	v.PartitionAnchor.MajorBlockIndex = u.MajorBlockIndex
	v.PartitionAnchor.MinorBlockIndex = u.MinorBlockIndex
	v.PartitionAnchor.RootChainIndex = u.RootChainIndex
	if x, err := encoding.ChainFromJSON(u.RootChainAnchor); err != nil {
		return fmt.Errorf("error decoding RootChainAnchor: %w", err)
	} else {
		v.PartitionAnchor.RootChainAnchor = x
	}
	if x, err := encoding.ChainFromJSON(u.StateTreeAnchor); err != nil {
		return fmt.Errorf("error decoding StateTreeAnchor: %w", err)
	} else {
		v.PartitionAnchor.StateTreeAnchor = x
	}
	if x, err := encoding.BigintFromJSON(u.AcmeBurnt); err != nil {
		return fmt.Errorf("error decoding AcmeBurnt: %w", err)
	} else {
		v.AcmeBurnt = *x
	}
	return nil
}

func (v *BurnTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   TransactionType `json:"type"`
		Amount *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *ChainParams) UnmarshalJSON(data []byte) error {
	u := struct {
		Data     *string `json:"data,omitempty"`
		IsUpdate bool    `json:"isUpdate,omitempty"`
	}{}
	u.Data = encoding.BytesToJSON(v.Data)
	u.IsUpdate = v.IsUpdate
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	v.IsUpdate = u.IsUpdate
	return nil
}

func (v *CreateDataAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        TransactionType             `json:"type"`
		Url         *url.URL                    `json:"url,omitempty"`
		Authorities encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.Authorities
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Authorities = u.Authorities
	return nil
}

func (v *CreateIdentity) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        TransactionType             `json:"type"`
		Url         *url.URL                    `json:"url,omitempty"`
		KeyHash     *string                     `json:"keyHash,omitempty"`
		KeyBookUrl  *url.URL                    `json:"keyBookUrl,omitempty"`
		Authorities encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	u.KeyBookUrl = v.KeyBookUrl
	u.Authorities = v.Authorities
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.KeyHash); err != nil {
		return fmt.Errorf("error decoding KeyHash: %w", err)
	} else {
		v.KeyHash = x
	}
	v.KeyBookUrl = u.KeyBookUrl
	v.Authorities = u.Authorities
	return nil
}

func (v *CreateKeyBook) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          TransactionType             `json:"type"`
		Url           *url.URL                    `json:"url,omitempty"`
		PublicKeyHash *string                     `json:"publicKeyHash,omitempty"`
		Authorities   encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	u.Authorities = v.Authorities
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.PublicKeyHash); err != nil {
		return fmt.Errorf("error decoding PublicKeyHash: %w", err)
	} else {
		v.PublicKeyHash = x
	}
	v.Authorities = u.Authorities
	return nil
}

func (v *CreateKeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType                   `json:"type"`
		Keys encoding.JsonList[*KeySpecParams] `json:"keys,omitempty"`
	}{}
	u.Type = v.Type()
	u.Keys = v.Keys
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Keys = u.Keys
	return nil
}

func (v *CreateLiteTokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *CreateToken) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        TransactionType             `json:"type"`
		Url         *url.URL                    `json:"url,omitempty"`
		Symbol      string                      `json:"symbol,omitempty"`
		Precision   uint64                      `json:"precision,omitempty"`
		Properties  *url.URL                    `json:"properties,omitempty"`
		SupplyLimit *string                     `json:"supplyLimit,omitempty"`
		Authorities encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.SupplyLimit = encoding.BigintToJSON(v.SupplyLimit)
	u.Authorities = v.Authorities
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Symbol = u.Symbol
	v.Precision = u.Precision
	v.Properties = u.Properties
	if x, err := encoding.BigintFromJSON(u.SupplyLimit); err != nil {
		return fmt.Errorf("error decoding SupplyLimit: %w", err)
	} else {
		v.SupplyLimit = x
	}
	v.Authorities = u.Authorities
	return nil
}

func (v *CreateTokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        TransactionType             `json:"type"`
		Url         *url.URL                    `json:"url,omitempty"`
		TokenUrl    *url.URL                    `json:"tokenUrl,omitempty"`
		Authorities encoding.JsonList[*url.URL] `json:"authorities,omitempty"`
		Proof       *TokenIssuerProof           `json:"proof,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.TokenUrl = v.TokenUrl
	u.Authorities = v.Authorities
	u.Proof = v.Proof
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.TokenUrl = u.TokenUrl
	v.Authorities = u.Authorities
	v.Proof = u.Proof
	return nil
}

func (v *DataAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        AccountType                            `json:"type"`
		Url         *url.URL                               `json:"url,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry]      `json:"authorities,omitempty"`
		Entry       *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	if u.Entry != nil {
		v.Entry = u.Entry.Value
	}

	return nil
}

func (v *DelegatedSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      SignatureType                          `json:"type"`
		Signature *encoding.JsonUnmarshalWith[Signature] `json:"signature,omitempty"`
		Delegator *url.URL                               `json:"delegator,omitempty"`
	}{}
	u.Type = v.Type()
	u.Signature = &encoding.JsonUnmarshalWith[Signature]{Value: v.Signature, Func: UnmarshalSignatureJSON}
	u.Delegator = v.Delegator
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Signature != nil {
		v.Signature = u.Signature.Value
	}

	v.Delegator = u.Delegator
	return nil
}

func (v *DirectoryAnchor) UnmarshalJSON(data []byte) error {
	u := struct {
		Type               TransactionType                            `json:"type"`
		Source             *url.URL                                   `json:"source,omitempty"`
		MajorBlockIndex    uint64                                     `json:"majorBlockIndex,omitempty"`
		MinorBlockIndex    uint64                                     `json:"minorBlockIndex,omitempty"`
		RootChainIndex     uint64                                     `json:"rootChainIndex,omitempty"`
		RootChainAnchor    string                                     `json:"rootChainAnchor,omitempty"`
		StateTreeAnchor    string                                     `json:"stateTreeAnchor,omitempty"`
		Updates            encoding.JsonList[NetworkAccountUpdate]    `json:"updates,omitempty"`
		Receipts           encoding.JsonList[*PartitionAnchorReceipt] `json:"receipts,omitempty"`
		MakeMajorBlock     uint64                                     `json:"makeMajorBlock,omitempty"`
		MakeMajorBlockTime time.Time                                  `json:"makeMajorBlockTime,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.PartitionAnchor.Source
	u.MajorBlockIndex = v.PartitionAnchor.MajorBlockIndex
	u.MinorBlockIndex = v.PartitionAnchor.MinorBlockIndex
	u.RootChainIndex = v.PartitionAnchor.RootChainIndex
	u.RootChainAnchor = encoding.ChainToJSON(v.PartitionAnchor.RootChainAnchor)
	u.StateTreeAnchor = encoding.ChainToJSON(v.PartitionAnchor.StateTreeAnchor)
	u.Updates = v.Updates
	u.Receipts = v.Receipts
	u.MakeMajorBlock = v.MakeMajorBlock
	u.MakeMajorBlockTime = v.MakeMajorBlockTime
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.PartitionAnchor.Source = u.Source
	v.PartitionAnchor.MajorBlockIndex = u.MajorBlockIndex
	v.PartitionAnchor.MinorBlockIndex = u.MinorBlockIndex
	v.PartitionAnchor.RootChainIndex = u.RootChainIndex
	if x, err := encoding.ChainFromJSON(u.RootChainAnchor); err != nil {
		return fmt.Errorf("error decoding RootChainAnchor: %w", err)
	} else {
		v.PartitionAnchor.RootChainAnchor = x
	}
	if x, err := encoding.ChainFromJSON(u.StateTreeAnchor); err != nil {
		return fmt.Errorf("error decoding StateTreeAnchor: %w", err)
	} else {
		v.PartitionAnchor.StateTreeAnchor = x
	}
	v.Updates = u.Updates
	v.Receipts = u.Receipts
	v.MakeMajorBlock = u.MakeMajorBlock
	v.MakeMajorBlockTime = u.MakeMajorBlockTime
	return nil
}

func (v *DisableAccountAuthOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	return nil
}

func (v *ED25519Signature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Timestamp = u.Timestamp
	v.Vote = u.Vote
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *ETHSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Timestamp = u.Timestamp
	v.Vote = u.Vote
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *EmptyResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *EnableAccountAuthOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	return nil
}

func (v *FactomDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		AccountId string                     `json:"accountId,omitempty"`
		Data      *string                    `json:"data,omitempty"`
		ExtIds    encoding.JsonList[*string] `json:"extIds,omitempty"`
	}{}
	u.AccountId = encoding.ChainToJSON(v.AccountId)
	u.Data = encoding.BytesToJSON(v.Data)
	u.ExtIds = make(encoding.JsonList[*string], len(v.ExtIds))
	for i, x := range v.ExtIds {
		u.ExtIds[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.AccountId); err != nil {
		return fmt.Errorf("error decoding AccountId: %w", err)
	} else {
		v.AccountId = x
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	v.ExtIds = make([][]byte, len(u.ExtIds))
	for i, x := range u.ExtIds {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding ExtIds: %w", err)
		} else {
			v.ExtIds[i] = x
		}
	}
	return nil
}

func (v *FactomDataEntryWrapper) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      DataEntryType              `json:"type"`
		AccountId string                     `json:"accountId,omitempty"`
		Data      *string                    `json:"data,omitempty"`
		ExtIds    encoding.JsonList[*string] `json:"extIds,omitempty"`
	}{}
	u.Type = v.Type()
	u.AccountId = encoding.ChainToJSON(v.FactomDataEntry.AccountId)
	u.Data = encoding.BytesToJSON(v.FactomDataEntry.Data)
	u.ExtIds = make(encoding.JsonList[*string], len(v.FactomDataEntry.ExtIds))
	for i, x := range v.FactomDataEntry.ExtIds {
		u.ExtIds[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.AccountId); err != nil {
		return fmt.Errorf("error decoding AccountId: %w", err)
	} else {
		v.FactomDataEntry.AccountId = x
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.FactomDataEntry.Data = x
	}
	v.FactomDataEntry.ExtIds = make([][]byte, len(u.ExtIds))
	for i, x := range u.ExtIds {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding ExtIds: %w", err)
		} else {
			v.FactomDataEntry.ExtIds[i] = x
		}
	}
	return nil
}

func (v *FeeSchedule) UnmarshalJSON(data []byte) error {
	u := struct {
		CreateIdentitySliding encoding.JsonList[Fee] `json:"createIdentitySliding,omitempty"`
	}{}
	u.CreateIdentitySliding = v.CreateIdentitySliding
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.CreateIdentitySliding = u.CreateIdentitySliding
	return nil
}

func (v *InternalSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType `json:"type"`
		Cause           string        `json:"cause,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *IssueTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType                    `json:"type"`
		Recipient *url.URL                           `json:"recipient,omitempty"`
		Amount    *string                            `json:"amount,omitempty"`
		To        encoding.JsonList[*TokenRecipient] `json:"to,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.To = v.To
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Recipient = u.Recipient
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	v.To = u.To
	return nil
}

func (v *KeyBook) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        AccountType                       `json:"type"`
		Url         *url.URL                          `json:"url,omitempty"`
		BookType    BookType                          `json:"bookType,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
		PageCount   uint64                            `json:"pageCount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.BookType = v.BookType
	u.Authorities = v.AccountAuth.Authorities
	u.PageCount = v.PageCount
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.BookType = u.BookType
	v.AccountAuth.Authorities = u.Authorities
	v.PageCount = u.PageCount
	return nil
}

func (v *KeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type                 AccountType                 `json:"type"`
		KeyBook              *url.URL                    `json:"keyBook,omitempty"`
		Url                  *url.URL                    `json:"url,omitempty"`
		CreditBalance        uint64                      `json:"creditBalance,omitempty"`
		AcceptThreshold      uint64                      `json:"acceptThreshold,omitempty"`
		Threshold            uint64                      `json:"threshold,omitempty"`
		RejectThreshold      uint64                      `json:"rejectThreshold,omitempty"`
		ResponseThreshold    uint64                      `json:"responseThreshold,omitempty"`
		BlockThreshold       uint64                      `json:"blockThreshold,omitempty"`
		Version              uint64                      `json:"version,omitempty"`
		Keys                 encoding.JsonList[*KeySpec] `json:"keys,omitempty"`
		TransactionBlacklist *AllowedTransactions        `json:"transactionBlacklist,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.Url = v.Url
	u.CreditBalance = v.CreditBalance
	u.AcceptThreshold = v.AcceptThreshold
	u.Threshold = v.AcceptThreshold
	u.RejectThreshold = v.RejectThreshold
	u.ResponseThreshold = v.ResponseThreshold
	u.BlockThreshold = v.BlockThreshold
	u.Version = v.Version
	u.Keys = v.Keys
	u.TransactionBlacklist = v.TransactionBlacklist
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.CreditBalance = u.CreditBalance
	if !(u.AcceptThreshold == 0) {
		v.AcceptThreshold = u.AcceptThreshold
	} else {
		v.AcceptThreshold = u.Threshold
	}
	v.RejectThreshold = u.RejectThreshold
	v.ResponseThreshold = u.ResponseThreshold
	v.BlockThreshold = u.BlockThreshold
	v.Version = u.Version
	v.Keys = u.Keys
	v.TransactionBlacklist = u.TransactionBlacklist
	return nil
}

func (v *KeySpec) UnmarshalJSON(data []byte) error {
	u := struct {
		PublicKeyHash *string  `json:"publicKeyHash,omitempty"`
		PublicKey     *string  `json:"publicKey,omitempty"`
		LastUsedOn    uint64   `json:"lastUsedOn,omitempty"`
		Delegate      *url.URL `json:"delegate,omitempty"`
	}{}
	u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	u.PublicKey = encoding.BytesToJSON(v.PublicKeyHash)
	u.LastUsedOn = v.LastUsedOn
	u.Delegate = v.Delegate
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(u.PublicKeyHash == nil) {
		if x, err := encoding.BytesFromJSON(u.PublicKeyHash); err != nil {
			return fmt.Errorf("error decoding PublicKeyHash: %w", err)
		} else {
			v.PublicKeyHash = x
		}
	} else {
		if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
			return fmt.Errorf("error decoding PublicKeyHash: %w", err)
		} else {
			v.PublicKeyHash = x
		}
	}
	v.LastUsedOn = u.LastUsedOn
	v.Delegate = u.Delegate
	return nil
}

func (v *KeySpecParams) UnmarshalJSON(data []byte) error {
	u := struct {
		KeyHash  *string  `json:"keyHash,omitempty"`
		Delegate *url.URL `json:"delegate,omitempty"`
	}{}
	u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	u.Delegate = v.Delegate
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.KeyHash); err != nil {
		return fmt.Errorf("error decoding KeyHash: %w", err)
	} else {
		v.KeyHash = x
	}
	v.Delegate = u.Delegate
	return nil
}

func (v *LegacyED25519Signature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType `json:"type"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Timestamp = v.Timestamp
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Vote = v.Vote
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Timestamp = u.Timestamp
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Vote = u.Vote
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *LiteDataAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	return nil
}

func (v *LiteIdentity) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          AccountType `json:"type"`
		Url           *url.URL    `json:"url,omitempty"`
		CreditBalance uint64      `json:"creditBalance,omitempty"`
		LastUsedOn    uint64      `json:"lastUsedOn,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.CreditBalance = v.CreditBalance
	u.LastUsedOn = v.LastUsedOn
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.CreditBalance = u.CreditBalance
	v.LastUsedOn = u.LastUsedOn
	return nil
}

func (v *LiteTokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       AccountType `json:"type"`
		Url        *url.URL    `json:"url,omitempty"`
		TokenUrl   *url.URL    `json:"tokenUrl,omitempty"`
		Balance    *string     `json:"balance,omitempty"`
		LockHeight uint64      `json:"lockHeight,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.LockHeight = v.LockHeight
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.TokenUrl = u.TokenUrl
	if x, err := encoding.BigintFromJSON(u.Balance); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance = *x
	}
	v.LockHeight = u.LockHeight
	return nil
}

func (v *LockAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   TransactionType `json:"type"`
		Height uint64          `json:"height,omitempty"`
	}{}
	u.Type = v.Type()
	u.Height = v.Height
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Height = u.Height
	return nil
}

func (v *MetricsRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Metric = u.Metric
	if x, err := encoding.DurationFromJSON(u.Duration); err != nil {
		return fmt.Errorf("error decoding Duration: %w", err)
	} else {
		v.Duration = x
	}
	return nil
}

func (v *MetricsResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	u.Value = encoding.AnyToJSON(v.Value)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.AnyFromJSON(u.Value); err != nil {
		return fmt.Errorf("error decoding Value: %w", err)
	} else {
		v.Value = x
	}
	return nil
}

func (v *NetworkAccountUpdate) UnmarshalJSON(data []byte) error {
	u := struct {
		Name string                                       `json:"name,omitempty"`
		Body *encoding.JsonUnmarshalWith[TransactionBody] `json:"body,omitempty"`
	}{}
	u.Name = v.Name
	u.Body = &encoding.JsonUnmarshalWith[TransactionBody]{Value: v.Body, Func: UnmarshalTransactionBodyJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Name = u.Name
	if u.Body != nil {
		v.Body = u.Body.Value
	}

	return nil
}

func (v *NetworkDefinition) UnmarshalJSON(data []byte) error {
	u := struct {
		NetworkName string                            `json:"networkName,omitempty"`
		Version     uint64                            `json:"version,omitempty"`
		Partitions  encoding.JsonList[*PartitionInfo] `json:"partitions,omitempty"`
		Validators  encoding.JsonList[*ValidatorInfo] `json:"validators,omitempty"`
	}{}
	u.NetworkName = v.NetworkName
	u.Version = v.Version
	u.Partitions = v.Partitions
	u.Validators = v.Validators
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.NetworkName = u.NetworkName
	v.Version = u.Version
	v.Partitions = u.Partitions
	v.Validators = u.Validators
	return nil
}

func (v *Object) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    ObjectType                       `json:"type,omitempty"`
		Chains  encoding.JsonList[ChainMetadata] `json:"chains,omitempty"`
		Pending TxIdSet                          `json:"pending,omitempty"`
	}{}
	u.Type = v.Type
	u.Chains = v.Chains
	u.Pending = v.Pending
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.Chains = u.Chains
	v.Pending = u.Pending
	return nil
}

func (v *PartitionAnchor) UnmarshalJSON(data []byte) error {
	u := struct {
		Source          *url.URL `json:"source,omitempty"`
		MajorBlockIndex uint64   `json:"majorBlockIndex,omitempty"`
		MinorBlockIndex uint64   `json:"minorBlockIndex,omitempty"`
		RootChainIndex  uint64   `json:"rootChainIndex,omitempty"`
		RootChainAnchor string   `json:"rootChainAnchor,omitempty"`
		StateTreeAnchor string   `json:"stateTreeAnchor,omitempty"`
	}{}
	u.Source = v.Source
	u.MajorBlockIndex = v.MajorBlockIndex
	u.MinorBlockIndex = v.MinorBlockIndex
	u.RootChainIndex = v.RootChainIndex
	u.RootChainAnchor = encoding.ChainToJSON(v.RootChainAnchor)
	u.StateTreeAnchor = encoding.ChainToJSON(v.StateTreeAnchor)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Source = u.Source
	v.MajorBlockIndex = u.MajorBlockIndex
	v.MinorBlockIndex = u.MinorBlockIndex
	v.RootChainIndex = u.RootChainIndex
	if x, err := encoding.ChainFromJSON(u.RootChainAnchor); err != nil {
		return fmt.Errorf("error decoding RootChainAnchor: %w", err)
	} else {
		v.RootChainAnchor = x
	}
	if x, err := encoding.ChainFromJSON(u.StateTreeAnchor); err != nil {
		return fmt.Errorf("error decoding StateTreeAnchor: %w", err)
	} else {
		v.StateTreeAnchor = x
	}
	return nil
}

func (v *PartitionSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type               SignatureType `json:"type"`
		SourceNetwork      *url.URL      `json:"sourceNetwork,omitempty"`
		DestinationNetwork *url.URL      `json:"destinationNetwork,omitempty"`
		SequenceNumber     uint64        `json:"sequenceNumber,omitempty"`
		TransactionHash    string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.SourceNetwork = v.SourceNetwork
	u.DestinationNetwork = v.DestinationNetwork
	u.SequenceNumber = v.SequenceNumber
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SourceNetwork = u.SourceNetwork
	v.DestinationNetwork = u.DestinationNetwork
	v.SequenceNumber = u.SequenceNumber
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *PartitionSyntheticLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Url       *url.URL                     `json:"url,omitempty"`
		Produced  uint64                       `json:"produced,omitempty"`
		Received  uint64                       `json:"received,omitempty"`
		Delivered uint64                       `json:"delivered,omitempty"`
		Pending   encoding.JsonList[*url.TxID] `json:"pending,omitempty"`
	}{}
	u.Url = v.Url
	u.Produced = v.Produced
	u.Received = v.Received
	u.Delivered = v.Delivered
	u.Pending = v.Pending
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	v.Produced = u.Produced
	v.Received = u.Received
	v.Delivered = u.Delivered
	v.Pending = u.Pending
	return nil
}

func (v *PlaceholderTransaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *RCD1Signature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType `json:"type"`
		PublicKey       *string       `json:"publicKey,omitempty"`
		Signature       *string       `json:"signature,omitempty"`
		Signer          *url.URL      `json:"signer,omitempty"`
		SignerVersion   uint64        `json:"signerVersion,omitempty"`
		Timestamp       uint64        `json:"timestamp,omitempty"`
		Vote            VoteType      `json:"vote,omitempty"`
		TransactionHash string        `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Timestamp = u.Timestamp
	v.Vote = u.Vote
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *ReceiptSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType  `json:"type"`
		SourceNetwork   *url.URL       `json:"sourceNetwork,omitempty"`
		Proof           merkle.Receipt `json:"proof,omitempty"`
		TransactionHash string         `json:"transactionHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.SourceNetwork = v.SourceNetwork
	u.Proof = v.Proof
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SourceNetwork = u.SourceNetwork
	v.Proof = u.Proof
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *RemoteSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        SignatureType                          `json:"type"`
		Destination *url.URL                               `json:"destination,omitempty"`
		Signature   *encoding.JsonUnmarshalWith[Signature] `json:"signature,omitempty"`
		Cause       encoding.JsonList[string]              `json:"cause,omitempty"`
	}{}
	u.Type = v.Type()
	u.Destination = v.Destination
	u.Signature = &encoding.JsonUnmarshalWith[Signature]{Value: v.Signature, Func: UnmarshalSignatureJSON}
	u.Cause = make(encoding.JsonList[string], len(v.Cause))
	for i, x := range v.Cause {
		u.Cause[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Destination = u.Destination
	if u.Signature != nil {
		v.Signature = u.Signature.Value
	}

	v.Cause = make([][32]byte, len(u.Cause))
	for i, x := range u.Cause {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Cause: %w", err)
		} else {
			v.Cause[i] = x
		}
	}
	return nil
}

func (v *RemoteTransaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
		Hash string          `json:"hash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Hash = encoding.ChainToJSON(v.Hash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	return nil
}

func (v *RemoveAccountAuthorityOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	return nil
}

func (v *RemoveKeyOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Entry KeySpecParams        `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Entry = u.Entry
	return nil
}

func (v *RoutingTable) UnmarshalJSON(data []byte) error {
	u := struct {
		Overrides encoding.JsonList[RouteOverride] `json:"overrides,omitempty"`
		Routes    encoding.JsonList[Route]         `json:"routes,omitempty"`
	}{}
	u.Overrides = v.Overrides
	u.Routes = v.Routes
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Overrides = u.Overrides
	v.Routes = u.Routes
	return nil
}

func (v *SendTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType                    `json:"type"`
		Hash string                             `json:"hash,omitempty"`
		Meta json.RawMessage                    `json:"meta,omitempty"`
		To   encoding.JsonList[*TokenRecipient] `json:"to,omitempty"`
	}{}
	u.Type = v.Type()
	u.Hash = encoding.ChainToJSON(v.Hash)
	u.Meta = v.Meta
	u.To = v.To
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	v.Meta = u.Meta
	v.To = u.To
	return nil
}

func (v *SetThresholdKeyPageOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      KeyPageOperationType `json:"type"`
		Threshold uint64               `json:"threshold,omitempty"`
	}{}
	u.Type = v.Type()
	u.Threshold = v.Threshold
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Threshold = u.Threshold
	return nil
}

func (v *SignatureSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            SignatureType                              `json:"type"`
		Vote            VoteType                                   `json:"vote,omitempty"`
		Signer          *url.URL                                   `json:"signer,omitempty"`
		TransactionHash string                                     `json:"transactionHash,omitempty"`
		Signatures      *encoding.JsonUnmarshalListWith[Signature] `json:"signatures,omitempty"`
		Authority       *url.URL                                   `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Vote = v.Vote
	u.Signer = v.Signer
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	u.Signatures = &encoding.JsonUnmarshalListWith[Signature]{Value: v.Signatures, Func: UnmarshalSignatureJSON}
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Vote = u.Vote
	v.Signer = u.Signer
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	if u.Signatures != nil {
		v.Signatures = make([]Signature, len(u.Signatures.Value))
		for i, x := range u.Signatures.Value {
			v.Signatures[i] = x
		}
	}
	v.Authority = u.Authority
	return nil
}

func (v *SyntheticBurnTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType `json:"type"`
		Cause     *url.TxID       `json:"cause,omitempty"`
		Source    *url.URL        `json:"source,omitempty"`
		Initiator *url.URL        `json:"initiator,omitempty"`
		FeeRefund uint64          `json:"feeRefund,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
		IsRefund  bool            `json:"isRefund,omitempty"`
	}{}
	u.Type = v.Type()
	u.Cause = v.SyntheticOrigin.Cause
	u.Source = v.SyntheticOrigin.Source()
	u.Initiator = v.SyntheticOrigin.Initiator
	u.FeeRefund = v.SyntheticOrigin.FeeRefund
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.IsRefund = v.IsRefund
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Cause = u.Cause
	v.SyntheticOrigin.Initiator = u.Initiator
	v.SyntheticOrigin.FeeRefund = u.FeeRefund
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	v.IsRefund = u.IsRefund
	return nil
}

func (v *SyntheticCreateIdentity) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType                          `json:"type"`
		Cause     *url.TxID                                `json:"cause,omitempty"`
		Source    *url.URL                                 `json:"source,omitempty"`
		Initiator *url.URL                                 `json:"initiator,omitempty"`
		FeeRefund uint64                                   `json:"feeRefund,omitempty"`
		Accounts  *encoding.JsonUnmarshalListWith[Account] `json:"accounts,omitempty"`
	}{}
	u.Type = v.Type()
	u.Cause = v.SyntheticOrigin.Cause
	u.Source = v.SyntheticOrigin.Source()
	u.Initiator = v.SyntheticOrigin.Initiator
	u.FeeRefund = v.SyntheticOrigin.FeeRefund
	u.Accounts = &encoding.JsonUnmarshalListWith[Account]{Value: v.Accounts, Func: UnmarshalAccountJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Cause = u.Cause
	v.SyntheticOrigin.Initiator = u.Initiator
	v.SyntheticOrigin.FeeRefund = u.FeeRefund
	if u.Accounts != nil {
		v.Accounts = make([]Account, len(u.Accounts.Value))
		for i, x := range u.Accounts.Value {
			v.Accounts[i] = x
		}
	}
	return nil
}

func (v *SyntheticDepositCredits) UnmarshalJSON(data []byte) error {
	u := struct {
		Type             TransactionType `json:"type"`
		Cause            *url.TxID       `json:"cause,omitempty"`
		Source           *url.URL        `json:"source,omitempty"`
		Initiator        *url.URL        `json:"initiator,omitempty"`
		FeeRefund        uint64          `json:"feeRefund,omitempty"`
		Amount           uint64          `json:"amount,omitempty"`
		AcmeRefundAmount *string         `json:"acmeRefundAmount,omitempty"`
		IsRefund         bool            `json:"isRefund,omitempty"`
	}{}
	u.Type = v.Type()
	u.Cause = v.SyntheticOrigin.Cause
	u.Source = v.SyntheticOrigin.Source()
	u.Initiator = v.SyntheticOrigin.Initiator
	u.FeeRefund = v.SyntheticOrigin.FeeRefund
	u.Amount = v.Amount
	u.AcmeRefundAmount = encoding.BigintToJSON(v.AcmeRefundAmount)
	u.IsRefund = v.IsRefund
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Cause = u.Cause
	v.SyntheticOrigin.Initiator = u.Initiator
	v.SyntheticOrigin.FeeRefund = u.FeeRefund
	v.Amount = u.Amount
	if x, err := encoding.BigintFromJSON(u.AcmeRefundAmount); err != nil {
		return fmt.Errorf("error decoding AcmeRefundAmount: %w", err)
	} else {
		v.AcmeRefundAmount = x
	}
	v.IsRefund = u.IsRefund
	return nil
}

func (v *SyntheticDepositTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType `json:"type"`
		Cause     *url.TxID       `json:"cause,omitempty"`
		Source    *url.URL        `json:"source,omitempty"`
		Initiator *url.URL        `json:"initiator,omitempty"`
		FeeRefund uint64          `json:"feeRefund,omitempty"`
		Token     *url.URL        `json:"token,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
		IsIssuer  bool            `json:"isIssuer,omitempty"`
		IsRefund  bool            `json:"isRefund,omitempty"`
	}{}
	u.Type = v.Type()
	u.Cause = v.SyntheticOrigin.Cause
	u.Source = v.SyntheticOrigin.Source()
	u.Initiator = v.SyntheticOrigin.Initiator
	u.FeeRefund = v.SyntheticOrigin.FeeRefund
	u.Token = v.Token
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.IsIssuer = v.IsIssuer
	u.IsRefund = v.IsRefund
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Cause = u.Cause
	v.SyntheticOrigin.Initiator = u.Initiator
	v.SyntheticOrigin.FeeRefund = u.FeeRefund
	v.Token = u.Token
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	v.IsIssuer = u.IsIssuer
	v.IsRefund = u.IsRefund
	return nil
}

func (v *SyntheticForwardTransaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        TransactionType                    `json:"type"`
		Signatures  encoding.JsonList[RemoteSignature] `json:"signatures,omitempty"`
		Transaction *Transaction                       `json:"transaction,omitempty"`
	}{}
	u.Type = v.Type()
	u.Signatures = v.Signatures
	u.Transaction = v.Transaction
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Signatures = u.Signatures
	v.Transaction = u.Transaction
	return nil
}

func (v *SyntheticLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Type     AccountType                                  `json:"type"`
		Url      *url.URL                                     `json:"url,omitempty"`
		Sequence encoding.JsonList[*PartitionSyntheticLedger] `json:"sequence,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Sequence = v.Sequence
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Sequence = u.Sequence
	return nil
}

func (v *SyntheticWriteData) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType                        `json:"type"`
		Cause     *url.TxID                              `json:"cause,omitempty"`
		Source    *url.URL                               `json:"source,omitempty"`
		Initiator *url.URL                               `json:"initiator,omitempty"`
		FeeRefund uint64                                 `json:"feeRefund,omitempty"`
		Entry     *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Cause = v.SyntheticOrigin.Cause
	u.Source = v.SyntheticOrigin.Source()
	u.Initiator = v.SyntheticOrigin.Initiator
	u.FeeRefund = v.SyntheticOrigin.FeeRefund
	u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Cause = u.Cause
	v.SyntheticOrigin.Initiator = u.Initiator
	v.SyntheticOrigin.FeeRefund = u.FeeRefund
	if u.Entry != nil {
		v.Entry = u.Entry.Value
	}

	return nil
}

func (v *SystemGenesis) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *SystemLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            AccountType                             `json:"type"`
		Url             *url.URL                                `json:"url,omitempty"`
		Index           uint64                                  `json:"index,omitempty"`
		Timestamp       time.Time                               `json:"timestamp,omitempty"`
		AcmeBurnt       *string                                 `json:"acmeBurnt,omitempty"`
		PendingUpdates  encoding.JsonList[NetworkAccountUpdate] `json:"pendingUpdates,omitempty"`
		Anchor          *encoding.JsonUnmarshalWith[AnchorBody] `json:"anchor,omitempty"`
		ExecutorVersion ExecutorVersion                         `json:"executorVersion,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Index = v.Index
	u.Timestamp = v.Timestamp
	u.AcmeBurnt = encoding.BigintToJSON(&v.AcmeBurnt)
	u.PendingUpdates = v.PendingUpdates
	u.Anchor = &encoding.JsonUnmarshalWith[AnchorBody]{Value: v.Anchor, Func: UnmarshalAnchorBodyJSON}
	u.ExecutorVersion = v.ExecutorVersion
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Index = u.Index
	v.Timestamp = u.Timestamp
	if x, err := encoding.BigintFromJSON(u.AcmeBurnt); err != nil {
		return fmt.Errorf("error decoding AcmeBurnt: %w", err)
	} else {
		v.AcmeBurnt = *x
	}
	v.PendingUpdates = u.PendingUpdates
	if u.Anchor != nil {
		v.Anchor = u.Anchor.Value
	}

	v.ExecutorVersion = u.ExecutorVersion
	return nil
}

func (v *SystemWriteData) UnmarshalJSON(data []byte) error {
	u := struct {
		Type         TransactionType                        `json:"type"`
		Entry        *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
		WriteToState bool                                   `json:"writeToState,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	u.WriteToState = v.WriteToState
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Entry != nil {
		v.Entry = u.Entry.Value
	}

	v.WriteToState = u.WriteToState
	return nil
}

func (v *TokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        AccountType                       `json:"type"`
		Url         *url.URL                          `json:"url,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
		TokenUrl    *url.URL                          `json:"tokenUrl,omitempty"`
		Balance     *string                           `json:"balance,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	v.TokenUrl = u.TokenUrl
	if x, err := encoding.BigintFromJSON(u.Balance); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance = *x
	}
	return nil
}

func (v *TokenIssuer) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        AccountType                       `json:"type"`
		Url         *url.URL                          `json:"url,omitempty"`
		Authorities encoding.JsonList[AuthorityEntry] `json:"authorities,omitempty"`
		Symbol      string                            `json:"symbol,omitempty"`
		Precision   uint64                            `json:"precision,omitempty"`
		Properties  *url.URL                          `json:"properties,omitempty"`
		Issued      *string                           `json:"issued,omitempty"`
		SupplyLimit *string                           `json:"supplyLimit,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.Issued = encoding.BigintToJSON(&v.Issued)
	u.SupplyLimit = encoding.BigintToJSON(v.SupplyLimit)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	v.Symbol = u.Symbol
	v.Precision = u.Precision
	v.Properties = u.Properties
	if x, err := encoding.BigintFromJSON(u.Issued); err != nil {
		return fmt.Errorf("error decoding Issued: %w", err)
	} else {
		v.Issued = *x
	}
	if x, err := encoding.BigintFromJSON(u.SupplyLimit); err != nil {
		return fmt.Errorf("error decoding SupplyLimit: %w", err)
	} else {
		v.SupplyLimit = x
	}
	return nil
}

func (v *TokenRecipient) UnmarshalJSON(data []byte) error {
	u := struct {
		Url    *url.URL `json:"url,omitempty"`
		Amount *string  `json:"amount,omitempty"`
	}{}
	u.Url = v.Url
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *Transaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Header TransactionHeader                            `json:"header,omitempty"`
		Body   *encoding.JsonUnmarshalWith[TransactionBody] `json:"body,omitempty"`
	}{}
	u.Header = v.Header
	u.Body = &encoding.JsonUnmarshalWith[TransactionBody]{Value: v.Body, Func: UnmarshalTransactionBodyJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Header = u.Header
	if u.Body != nil {
		v.Body = u.Body.Value
	}

	return nil
}

func (v *TransactionHeader) UnmarshalJSON(data []byte) error {
	u := struct {
		Principal *url.URL `json:"principal,omitempty"`
		Initiator string   `json:"initiator,omitempty"`
		Memo      string   `json:"memo,omitempty"`
		Metadata  *string  `json:"metadata,omitempty"`
	}{}
	u.Principal = v.Principal
	u.Initiator = encoding.ChainToJSON(v.Initiator)
	u.Memo = v.Memo
	u.Metadata = encoding.BytesToJSON(v.Metadata)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Principal = u.Principal
	if x, err := encoding.ChainFromJSON(u.Initiator); err != nil {
		return fmt.Errorf("error decoding Initiator: %w", err)
	} else {
		v.Initiator = x
	}
	v.Memo = u.Memo
	if x, err := encoding.BytesFromJSON(u.Metadata); err != nil {
		return fmt.Errorf("error decoding Metadata: %w", err)
	} else {
		v.Metadata = x
	}
	return nil
}

func (v *TransactionResultSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Results encoding.JsonList[*TransactionStatus] `json:"results,omitempty"`
	}{}
	u.Results = v.Results
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Results = u.Results
	return nil
}

func (v *TransactionStatus) UnmarshalJSON(data []byte) error {
	u := struct {
		TxID                *url.TxID                                      `json:"txID,omitempty"`
		Code                errors2.Status                                 `json:"code,omitempty"`
		Remote              bool                                           `json:"remote,omitempty"`
		Delivered           bool                                           `json:"delivered,omitempty"`
		Pending             bool                                           `json:"pending,omitempty"`
		Failed              bool                                           `json:"failed,omitempty"`
		CodeNum             uint64                                         `json:"codeNum,omitempty"`
		Error               *errors2.Error                                 `json:"error,omitempty"`
		Result              *encoding.JsonUnmarshalWith[TransactionResult] `json:"result,omitempty"`
		Received            uint64                                         `json:"received,omitempty"`
		Initiator           *url.URL                                       `json:"initiator,omitempty"`
		Signers             *encoding.JsonUnmarshalListWith[Signer]        `json:"signers,omitempty"`
		SourceNetwork       *url.URL                                       `json:"sourceNetwork,omitempty"`
		DestinationNetwork  *url.URL                                       `json:"destinationNetwork,omitempty"`
		SequenceNumber      uint64                                         `json:"sequenceNumber,omitempty"`
		GotDirectoryReceipt bool                                           `json:"gotDirectoryReceipt,omitempty"`
		Proof               *merkle.Receipt                                `json:"proof,omitempty"`
		AnchorSigners       encoding.JsonList[*string]                     `json:"anchorSigners,omitempty"`
	}{}
	u.TxID = v.TxID
	u.Code = v.Code
	u.Remote = v.Remote()
	u.Delivered = v.Delivered()
	u.Pending = v.Pending()
	u.Failed = v.Failed()
	u.CodeNum = v.CodeNum()
	u.Error = v.Error
	u.Result = &encoding.JsonUnmarshalWith[TransactionResult]{Value: v.Result, Func: UnmarshalTransactionResultJSON}
	u.Received = v.Received
	u.Initiator = v.Initiator
	u.Signers = &encoding.JsonUnmarshalListWith[Signer]{Value: v.Signers, Func: UnmarshalSignerJSON}
	u.SourceNetwork = v.SourceNetwork
	u.DestinationNetwork = v.DestinationNetwork
	u.SequenceNumber = v.SequenceNumber
	u.GotDirectoryReceipt = v.GotDirectoryReceipt
	u.Proof = v.Proof
	u.AnchorSigners = make(encoding.JsonList[*string], len(v.AnchorSigners))
	for i, x := range v.AnchorSigners {
		u.AnchorSigners[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.TxID = u.TxID
	v.Code = u.Code
	v.Error = u.Error
	if u.Result != nil {
		v.Result = u.Result.Value
	}

	v.Received = u.Received
	v.Initiator = u.Initiator
	if u.Signers != nil {
		v.Signers = make([]Signer, len(u.Signers.Value))
		for i, x := range u.Signers.Value {
			v.Signers[i] = x
		}
	}
	v.SourceNetwork = u.SourceNetwork
	v.DestinationNetwork = u.DestinationNetwork
	v.SequenceNumber = u.SequenceNumber
	v.GotDirectoryReceipt = u.GotDirectoryReceipt
	v.Proof = u.Proof
	v.AnchorSigners = make([][]byte, len(u.AnchorSigners))
	for i, x := range u.AnchorSigners {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding AnchorSigners: %w", err)
		} else {
			v.AnchorSigners[i] = x
		}
	}
	return nil
}

func (v *TxIdSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Entries encoding.JsonList[*url.TxID] `json:"entries,omitempty"`
	}{}
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Entries = u.Entries
	return nil
}

func (v *UnknownAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	return nil
}

func (v *UnknownSigner) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    AccountType `json:"type"`
		Url     *url.URL    `json:"url,omitempty"`
		Version uint64      `json:"version,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Version = v.Version
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Version = u.Version
	return nil
}

func (v *UpdateAccountAuth) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType                                       `json:"type"`
		Operations *encoding.JsonUnmarshalListWith[AccountAuthOperation] `json:"operations,omitempty"`
	}{}
	u.Type = v.Type()
	u.Operations = &encoding.JsonUnmarshalListWith[AccountAuthOperation]{Value: v.Operations, Func: UnmarshalAccountAuthOperationJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Operations != nil {
		v.Operations = make([]AccountAuthOperation, len(u.Operations.Value))
		for i, x := range u.Operations.Value {
			v.Operations[i] = x
		}
	}
	return nil
}

func (v *UpdateAllowedKeyPageOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  KeyPageOperationType               `json:"type"`
		Allow encoding.JsonList[TransactionType] `json:"allow,omitempty"`
		Deny  encoding.JsonList[TransactionType] `json:"deny,omitempty"`
	}{}
	u.Type = v.Type()
	u.Allow = v.Allow
	u.Deny = v.Deny
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Allow = u.Allow
	v.Deny = u.Deny
	return nil
}

func (v *UpdateKey) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType `json:"type"`
		NewKeyHash *string         `json:"newKeyHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.NewKeyHash = encoding.BytesToJSON(v.NewKeyHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.NewKeyHash); err != nil {
		return fmt.Errorf("error decoding NewKeyHash: %w", err)
	} else {
		v.NewKeyHash = x
	}
	return nil
}

func (v *UpdateKeyOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type     KeyPageOperationType `json:"type"`
		OldEntry KeySpecParams        `json:"oldEntry,omitempty"`
		NewEntry KeySpecParams        `json:"newEntry,omitempty"`
	}{}
	u.Type = v.Type()
	u.OldEntry = v.OldEntry
	u.NewEntry = v.NewEntry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.OldEntry = u.OldEntry
	v.NewEntry = u.NewEntry
	return nil
}

func (v *UpdateKeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType                                   `json:"type"`
		Operation *encoding.JsonUnmarshalListWith[KeyPageOperation] `json:"operation,omitempty"`
	}{}
	u.Type = v.Type()
	u.Operation = &encoding.JsonUnmarshalListWith[KeyPageOperation]{Value: v.Operation, Func: UnmarshalKeyPageOperationJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Operation != nil {
		v.Operation = make([]KeyPageOperation, len(u.Operation.Value))
		for i, x := range u.Operation.Value {
			v.Operation[i] = x
		}
	}
	return nil
}

func (v *ValidatorInfo) UnmarshalJSON(data []byte) error {
	u := struct {
		PublicKey     *string                                    `json:"publicKey,omitempty"`
		PublicKeyHash string                                     `json:"publicKeyHash,omitempty"`
		Operator      *url.URL                                   `json:"operator,omitempty"`
		Partitions    encoding.JsonList[*ValidatorPartitionInfo] `json:"partitions,omitempty"`
	}{}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.PublicKeyHash = encoding.ChainToJSON(v.PublicKeyHash)
	u.Operator = v.Operator
	u.Partitions = v.Partitions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.ChainFromJSON(u.PublicKeyHash); err != nil {
		return fmt.Errorf("error decoding PublicKeyHash: %w", err)
	} else {
		v.PublicKeyHash = x
	}
	v.Operator = u.Operator
	v.Partitions = u.Partitions
	return nil
}

func (v *WriteData) UnmarshalJSON(data []byte) error {
	u := struct {
		Type         TransactionType                        `json:"type"`
		Entry        *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
		Scratch      bool                                   `json:"scratch,omitempty"`
		WriteToState bool                                   `json:"writeToState,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	u.Scratch = v.Scratch
	u.WriteToState = v.WriteToState
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Entry != nil {
		v.Entry = u.Entry.Value
	}

	v.Scratch = u.Scratch
	v.WriteToState = u.WriteToState
	return nil
}

func (v *WriteDataResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType `json:"type"`
		EntryHash  string          `json:"entryHash,omitempty"`
		AccountUrl *url.URL        `json:"accountUrl,omitempty"`
		AccountID  *string         `json:"accountID,omitempty"`
	}{}
	u.Type = v.Type()
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.AccountUrl = v.AccountUrl
	u.AccountID = encoding.BytesToJSON(v.AccountID)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	v.AccountUrl = u.AccountUrl
	if x, err := encoding.BytesFromJSON(u.AccountID); err != nil {
		return fmt.Errorf("error decoding AccountID: %w", err)
	} else {
		v.AccountID = x
	}
	return nil
}

func (v *WriteDataTo) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType                        `json:"type"`
		Recipient *url.URL                               `json:"recipient,omitempty"`
		Entry     *encoding.JsonUnmarshalWith[DataEntry] `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Entry = &encoding.JsonUnmarshalWith[DataEntry]{Value: v.Entry, Func: UnmarshalDataEntryJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Recipient = u.Recipient
	if u.Entry != nil {
		v.Entry = u.Entry.Value
	}

	return nil
}
