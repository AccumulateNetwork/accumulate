package protocol

// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"math/big"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
)

type ADI struct {
	AccountHeader
}

type AccountHeader struct {
	Type           AccountType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Url            string      `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	KeyBook        string      `json:"keyBook,omitempty" form:"keyBook" query:"keyBook" validate:"required"`
	ManagerKeyBook string      `json:"managerKeyBook,omitempty" form:"managerKeyBook" query:"managerKeyBook" validate:"required"`
	url            *url.URL
}

type AcmeFaucet struct {
	Url string `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
}

type AddCredits struct {
	Recipient string `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	Amount    uint64 `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type Anchor struct {
	AccountHeader
}

type AnchorMetadata struct {
	ChainMetadata
	Account     *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Index       uint64   `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	SourceIndex uint64   `json:"sourceIndex,omitempty" form:"sourceIndex" query:"sourceIndex" validate:"required"`
	SourceBlock uint64   `json:"sourceBlock,omitempty" form:"sourceBlock" query:"sourceBlock" validate:"required"`
	Entry       []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type AnchoredRecord struct {
	Record []byte   `json:"record,omitempty" form:"record" query:"record" validate:"required"`
	Anchor [32]byte `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
}

type BurnTokens struct {
	Amount big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type ChainMetadata struct {
	Name string    `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
}

type ChainParams struct {
	Data     []byte `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	IsUpdate bool   `json:"isUpdate,omitempty" form:"isUpdate" query:"isUpdate" validate:"required"`
}

type CreateDataAccount struct {
	Url               string `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	KeyBookUrl        string `json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl" validate:"acc-url"`
	ManagerKeyBookUrl string `json:"managerKeyBookUrl,omitempty" form:"managerKeyBookUrl" query:"managerKeyBookUrl" validate:"acc-url"`
	Scratch           bool   `json:"scratch,omitempty" form:"scratch" query:"scratch"`
}

type CreateIdentity struct {
	Url         string `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	PublicKey   []byte `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	KeyBookName string `json:"keyBookName,omitempty" form:"keyBookName" query:"keyBookName"`
	KeyPageName string `json:"keyPageName,omitempty" form:"keyPageName" query:"keyPageName"`
	Manager     string `json:"manager,omitempty" form:"manager" query:"manager"`
}

type CreateKeyBook struct {
	Url     string   `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	Pages   []string `json:"pages,omitempty" form:"pages" query:"pages" validate:"required"`
	Manager string   `json:"manager,omitempty" form:"manager" query:"manager"`
}

type CreateKeyPage struct {
	Url     string           `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	Keys    []*KeySpecParams `json:"keys,omitempty" form:"keys" query:"keys" validate:"required"`
	Manager string           `json:"manager,omitempty" form:"manager" query:"manager"`
}

type CreateToken struct {
	Url            string  `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	KeyBookUrl     string  `json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl" validate:"acc-url"`
	Symbol         string  `json:"symbol,omitempty" form:"symbol" query:"symbol" validate:"required"`
	Precision      uint64  `json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	Properties     string  `json:"properties,omitempty" form:"properties" query:"properties" validate:"acc-url"`
	InitialSupply  big.Int `json:"initialSupply,omitempty" form:"initialSupply" query:"initialSupply"`
	HasSupplyLimit bool    `json:"hasSupplyLimit,omitempty" form:"hasSupplyLimit" query:"hasSupplyLimit"`
	Manager        string  `json:"manager,omitempty" form:"manager" query:"manager"`
}

type CreateTokenAccount struct {
	Url        string `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	TokenUrl   string `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required,acc-url"`
	KeyBookUrl string `json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl" validate:"acc-url"`
	Scratch    bool   `json:"scratch,omitempty" form:"scratch" query:"scratch"`
	Manager    string `json:"manager,omitempty" form:"manager" query:"manager"`
}

type DataAccount struct {
	AccountHeader
	Scratch bool `json:"scratch,omitempty" form:"scratch" query:"scratch"`
}

type DataEntry struct {
	ExtIds [][]byte `json:"extIds,omitempty" form:"extIds" query:"extIds"`
	Data   []byte   `json:"data,omitempty" form:"data" query:"data"`
}

type DirectoryIndexMetadata struct {
	Count uint64 `json:"count,omitempty" form:"count" query:"count" validate:"required"`
}

type DirectoryQueryResult struct {
	Entries         []string  `json:"entries,omitempty" form:"entries" query:"entries"`
	ExpandedEntries []*Object `json:"expandedEntries,omitempty" form:"expandedEntries" query:"expandedEntries"`
	Total           uint64    `json:"total" form:"total" query:"total" validate:"required"`
}

type Envelope struct {
	Signatures  []*ED25519Sig `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	TxHash      []byte        `json:"txHash,omitempty" form:"txHash" query:"txHash" validate:"required"`
	Transaction *Transaction  `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	hash        []byte
}

type InternalGenesis struct {
}

type InternalLedger struct {
	AccountHeader
	Index     int64            `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Timestamp time.Time        `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	Synthetic SyntheticLedger  `json:"synthetic,omitempty" form:"synthetic" query:"synthetic" validate:"required"`
	Updates   []AnchorMetadata `json:"updates,omitempty" form:"updates" query:"updates" validate:"required"`
}

type InternalSendTransactions struct {
	Transactions []SendTransaction `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type InternalTransactionsSent struct {
	Transactions [][32]byte `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type InternalTransactionsSigned struct {
	Transactions []TransactionSignature `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type IssueTokens struct {
	Recipient string  `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required,acc-url"`
	Amount    big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type KeyBook struct {
	AccountHeader
	Pages []string `json:"pages,omitempty" form:"pages" query:"pages" validate:"required"`
}

type KeyPage struct {
	AccountHeader
	CreditBalance big.Int    `json:"creditBalance,omitempty" form:"creditBalance" query:"creditBalance" validate:"required"`
	Threshold     uint64     `json:"threshold,omitempty" form:"threshold" query:"threshold" validate:"required"`
	Keys          []*KeySpec `json:"keys,omitempty" form:"keys" query:"keys" validate:"required"`
}

type KeySpec struct {
	PublicKey []byte `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Nonce     uint64 `json:"nonce,omitempty" form:"nonce" query:"nonce" validate:"required"`
	Owner     string `json:"owner,omitempty" form:"owner" query:"owner" validate:"required"`
}

type KeySpecParams struct {
	PublicKey []byte `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
}

type LiteDataAccount struct {
	AccountHeader
	Tail []byte `json:"tail,omitempty" form:"tail" query:"tail" validate:"required"`
}

type LiteTokenAccount struct {
	AccountHeader
	TokenUrl      string  `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required,acc-url"`
	Balance       big.Int `json:"balance,omitempty" form:"balance" query:"balance" validate:"required"`
	Nonce         uint64  `json:"nonce,omitempty" form:"nonce" query:"nonce" validate:"required"`
	CreditBalance big.Int `json:"creditBalance,omitempty" form:"creditBalance" query:"creditBalance" validate:"required"`
}

type MetricsRequest struct {
	Metric   string        `json:"metric,omitempty" form:"metric" query:"metric" validate:"required"`
	Duration time.Duration `json:"duration,omitempty" form:"duration" query:"duration" validate:"required"`
}

type MetricsResponse struct {
	Value interface{} `json:"value,omitempty" form:"value" query:"value" validate:"required"`
}

type Object struct {
	Entry  []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	Height uint64   `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots  [][]byte `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
}

type ObjectMetadata struct {
	Type   ObjectType      `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Chains []ChainMetadata `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
}

type PendingTransactionState struct {
	AccountHeader
	Signature        []*ED25519Sig   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	TransactionState *TxState        `json:"transactionState,omitempty" form:"transactionState" query:"transactionState" validate:"required"`
	Status           json.RawMessage `json:"status,omitempty" form:"status" query:"status" validate:"required"`
}

type Receipt struct {
	Start   []byte         `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Entries []ReceiptEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
}

type ReceiptEntry struct {
	Right bool   `json:"right,omitempty" form:"right" query:"right" validate:"required"`
	Hash  []byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
}

type RemoveManager struct {
}

type RequestDataEntry struct {
	Url       string   `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	EntryHash [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash"`
}

type RequestDataEntrySet struct {
	Url          string `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	Start        uint64 `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Count        uint64 `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	ExpandChains bool   `json:"expandChains,omitempty" form:"expandChains" query:"expandChains"`
}

type ResponseDataEntry struct {
	EntryHash [32]byte  `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type ResponseDataEntrySet struct {
	DataEntries []ResponseDataEntry `json:"dataEntries,omitempty" form:"dataEntries" query:"dataEntries" validate:"required"`
	Total       uint64              `json:"total,omitempty" form:"total" query:"total" validate:"required"`
}

type SegWitDataEntry struct {
	Cause     [32]byte `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	EntryUrl  string   `json:"entryUrl,omitempty" form:"entryUrl" query:"entryUrl" validate:"required,acc-url"`
	EntryHash [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
}

type SendTokens struct {
	Hash [32]byte          `json:"hash,omitempty" form:"hash" query:"hash"`
	Meta json.RawMessage   `json:"meta,omitempty" form:"meta" query:"meta"`
	To   []*TokenRecipient `json:"to,omitempty" form:"to" query:"to" validate:"required"`
}

type SendTransaction struct {
	Payload   TransactionPayload `json:"payload,omitempty" form:"payload" query:"payload" validate:"required"`
	Recipient *url.URL           `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
}

type SignPending struct {
}

type SyntheticAnchor struct {
	Source      string   `json:"source,omitempty" form:"source" query:"source" validate:"required,acc-url"`
	Major       bool     `json:"major,omitempty" form:"major" query:"major" validate:"required"`
	RootAnchor  [32]byte `json:"rootAnchor,omitempty" form:"rootAnchor" query:"rootAnchor" validate:"required"`
	RootIndex   uint64   `json:"rootIndex,omitempty" form:"rootIndex" query:"rootIndex" validate:"required"`
	Block       uint64   `json:"block,omitempty" form:"block" query:"block" validate:"required"`
	SourceIndex uint64   `json:"sourceIndex,omitempty" form:"sourceIndex" query:"sourceIndex" validate:"required"`
	SourceBlock uint64   `json:"sourceBlock,omitempty" form:"sourceBlock" query:"sourceBlock" validate:"required"`
	Receipt     Receipt  `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
}

type SyntheticBurnTokens struct {
	Cause  [32]byte `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	Amount big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type SyntheticCreateChain struct {
	Cause  [32]byte      `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	Chains []ChainParams `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
}

type SyntheticDepositCredits struct {
	Cause  [32]byte `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	Amount uint64   `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type SyntheticDepositTokens struct {
	Cause  [32]byte `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	Token  string   `json:"token,omitempty" form:"token" query:"token" validate:"required,acc-url"`
	Amount big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type SyntheticLedger struct {
	Nonce    uint64     `json:"nonce,omitempty" form:"nonce" query:"nonce" validate:"required"`
	Produced [][32]byte `json:"produced,omitempty" form:"produced" query:"produced" validate:"required"`
	Unsigned [][32]byte `json:"unsigned,omitempty" form:"unsigned" query:"unsigned" validate:"required"`
	Unsent   [][32]byte `json:"unsent,omitempty" form:"unsent" query:"unsent" validate:"required"`
}

type SyntheticMirror struct {
	Objects []AnchoredRecord `json:"objects,omitempty" form:"objects" query:"objects" validate:"required"`
}

type SyntheticWriteData struct {
	Cause [32]byte  `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	Entry DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type TokenAccount struct {
	AccountHeader
	TokenUrl string  `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required,acc-url"`
	Balance  big.Int `json:"balance,omitempty" form:"balance" query:"balance" validate:"required"`
	Scratch  bool    `json:"scratch,omitempty" form:"scratch" query:"scratch"`
}

type TokenIssuer struct {
	AccountHeader
	Symbol         string  `json:"symbol,omitempty" form:"symbol" query:"symbol" validate:"required"`
	Precision      uint64  `json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	Properties     string  `json:"properties,omitempty" form:"properties" query:"properties" validate:"required,acc-url"`
	Supply         big.Int `json:"supply,omitempty" form:"supply" query:"supply"`
	HasSupplyLimit bool    `json:"hasSupplyLimit,omitempty" form:"hasSupplyLimit" query:"hasSupplyLimit"`
}

type TokenRecipient struct {
	Url    string  `json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	Amount big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type Transaction struct {
	TransactionHeader
	Body []byte `json:"body,omitempty" form:"body" query:"body" validate:"required"`
	hash []byte
}

type TransactionHeader struct {
	Origin        *url.URL `json:"origin,omitempty" form:"origin" query:"origin" validate:"required"`
	KeyPageHeight uint64   `json:"keyPageHeight,omitempty" form:"keyPageHeight" query:"keyPageHeight" validate:"required"`
	KeyPageIndex  uint64   `json:"keyPageIndex,omitempty" form:"keyPageIndex" query:"keyPageIndex" validate:"required"`
	Nonce         uint64   `json:"nonce,omitempty" form:"nonce" query:"nonce" validate:"required"`
}

type TransactionSignature struct {
	Transaction [32]byte    `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signature   *ED25519Sig `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
}

type TransactionState struct {
	AccountHeader
	TxState
}

type TransactionStatus struct {
	Remote    bool              `json:"remote,omitempty" form:"remote" query:"remote" validate:"required"`
	Delivered bool              `json:"delivered,omitempty" form:"delivered" query:"delivered" validate:"required"`
	Pending   bool              `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	Code      uint64            `json:"code,omitempty" form:"code" query:"code" validate:"required"`
	Message   string            `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Result    TransactionResult `json:"result,omitempty" form:"result" query:"result"`
}

type TxState struct {
	SigInfo         *TransactionHeader `json:"sigInfo,omitempty" form:"sigInfo" query:"sigInfo" validate:"required"`
	Transaction     []byte             `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	TransactionHash [32]byte
}

type UpdateKeyPage struct {
	Operation KeyPageOperation `json:"operation,omitempty" form:"operation" query:"operation" validate:"required"`
	Key       []byte           `json:"key,omitempty" form:"key" query:"key"`
	NewKey    []byte           `json:"newKey,omitempty" form:"newKey" query:"newKey"`
	Owner     string           `json:"owner,omitempty" form:"owner" query:"owner"`
	Threshold uint64           `json:"threshold,omitempty" form:"threshold" query:"threshold"`
}

type WriteData struct {
	Entry DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type WriteDataResult struct {
	EntryHash  [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	AccountUrl *url.URL `json:"accountUrl,omitempty" form:"accountUrl" query:"accountUrl" validate:"required"`
	AccountID  []byte   `json:"accountID,omitempty" form:"accountID" query:"accountID" validate:"required"`
}

type WriteDataTo struct {
	Recipient string    `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required,acc-url"`
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

func NewADI() *ADI {
	v := new(ADI)
	v.Type = AccountTypeIdentity
	return v
}

func NewAnchor() *Anchor {
	v := new(Anchor)
	v.Type = AccountTypeAnchor
	return v
}

func NewDataAccount() *DataAccount {
	v := new(DataAccount)
	v.Type = AccountTypeDataAccount
	return v
}

func NewInternalLedger() *InternalLedger {
	v := new(InternalLedger)
	v.Type = AccountTypeInternalLedger
	return v
}

func NewKeyBook() *KeyBook {
	v := new(KeyBook)
	v.Type = AccountTypeKeyBook
	return v
}

func NewKeyPage() *KeyPage {
	v := new(KeyPage)
	v.Type = AccountTypeKeyPage
	return v
}

func NewLiteDataAccount() *LiteDataAccount {
	v := new(LiteDataAccount)
	v.Type = AccountTypeLiteDataAccount
	return v
}

func NewLiteTokenAccount() *LiteTokenAccount {
	v := new(LiteTokenAccount)
	v.Type = AccountTypeLiteTokenAccount
	return v
}

func NewTokenAccount() *TokenAccount {
	v := new(TokenAccount)
	v.Type = AccountTypeTokenAccount
	return v
}

func NewTokenIssuer() *TokenIssuer {
	v := new(TokenIssuer)
	v.Type = AccountTypeTokenIssuer
	return v
}

func (*AcmeFaucet) GetType() TransactionType { return TransactionTypeAcmeFaucet }

func (*AddCredits) GetType() TransactionType { return TransactionTypeAddCredits }

func (*BurnTokens) GetType() TransactionType { return TransactionTypeBurnTokens }

func (*CreateDataAccount) GetType() TransactionType { return TransactionTypeCreateDataAccount }

func (*CreateIdentity) GetType() TransactionType { return TransactionTypeCreateIdentity }

func (*CreateKeyBook) GetType() TransactionType { return TransactionTypeCreateKeyBook }

func (*CreateKeyPage) GetType() TransactionType { return TransactionTypeCreateKeyPage }

func (*CreateToken) GetType() TransactionType { return TransactionTypeCreateToken }

func (*CreateTokenAccount) GetType() TransactionType { return TransactionTypeCreateTokenAccount }

func (*InternalGenesis) GetType() TransactionType { return TransactionTypeInternalGenesis }

func (*InternalSendTransactions) GetType() TransactionType {
	return TransactionTypeInternalSendTransactions
}

func (*InternalTransactionsSent) GetType() TransactionType {
	return TransactionTypeInternalTransactionsSent
}

func (*InternalTransactionsSigned) GetType() TransactionType {
	return TransactionTypeInternalTransactionsSigned
}

func (*IssueTokens) GetType() TransactionType { return TransactionTypeIssueTokens }

func (*RemoveManager) GetType() TransactionType { return TransactionTypeRemoveManager }

func (*SegWitDataEntry) GetType() TransactionType { return TransactionTypeSegWitDataEntry }

func (*SendTokens) GetType() TransactionType { return TransactionTypeSendTokens }

func (*SignPending) GetType() TransactionType { return TransactionTypeSignPending }

func (*SyntheticAnchor) GetType() TransactionType { return TransactionTypeSyntheticAnchor }

func (*SyntheticBurnTokens) GetType() TransactionType { return TransactionTypeSyntheticBurnTokens }

func (*SyntheticCreateChain) GetType() TransactionType { return TransactionTypeSyntheticCreateChain }

func (*SyntheticDepositCredits) GetType() TransactionType {
	return TransactionTypeSyntheticDepositCredits
}

func (*SyntheticDepositTokens) GetType() TransactionType {
	return TransactionTypeSyntheticDepositTokens
}

func (*SyntheticMirror) GetType() TransactionType { return TransactionTypeSyntheticMirror }

func (*SyntheticWriteData) GetType() TransactionType { return TransactionTypeSyntheticWriteData }

func (*UpdateKeyPage) GetType() TransactionType { return TransactionTypeUpdateKeyPage }

func (*WriteData) GetType() TransactionType { return TransactionTypeWriteData }

func (*WriteDataResult) GetType() TransactionType { return TransactionTypeWriteData }

func (*WriteDataTo) GetType() TransactionType { return TransactionTypeWriteDataTo }

func (v *ADI) Equal(u *ADI) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	return true
}

func (v *AccountHeader) Equal(u *AccountHeader) bool {
	if !(v.Type == u.Type) {
		return false
	}

	if !(v.Url == u.Url) {
		return false
	}

	if !(v.KeyBook == u.KeyBook) {
		return false
	}

	if !(v.ManagerKeyBook == u.ManagerKeyBook) {
		return false
	}

	return true
}

func (v *AcmeFaucet) Equal(u *AcmeFaucet) bool {
	if !(v.Url == u.Url) {
		return false
	}

	return true
}

func (v *AddCredits) Equal(u *AddCredits) bool {
	if !(v.Recipient == u.Recipient) {
		return false
	}

	if !(v.Amount == u.Amount) {
		return false
	}

	return true
}

func (v *Anchor) Equal(u *Anchor) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	return true
}

func (v *AnchorMetadata) Equal(u *AnchorMetadata) bool {
	if !(v.Account.Equal(u.Account)) {
		return false
	}

	if !(v.Index == u.Index) {
		return false
	}

	if !(v.SourceIndex == u.SourceIndex) {
		return false
	}

	if !(v.SourceBlock == u.SourceBlock) {
		return false
	}

	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}

	return true
}

func (v *AnchoredRecord) Equal(u *AnchoredRecord) bool {
	if !(bytes.Equal(v.Record, u.Record)) {
		return false
	}

	if !(v.Anchor == u.Anchor) {
		return false
	}

	return true
}

func (v *BurnTokens) Equal(u *BurnTokens) bool {
	if !(v.Amount.Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *ChainMetadata) Equal(u *ChainMetadata) bool {
	if !(v.Name == u.Name) {
		return false
	}

	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *ChainParams) Equal(u *ChainParams) bool {
	if !(bytes.Equal(v.Data, u.Data)) {
		return false
	}

	if !(v.IsUpdate == u.IsUpdate) {
		return false
	}

	return true
}

func (v *CreateDataAccount) Equal(u *CreateDataAccount) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(v.KeyBookUrl == u.KeyBookUrl) {
		return false
	}

	if !(v.ManagerKeyBookUrl == u.ManagerKeyBookUrl) {
		return false
	}

	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *CreateIdentity) Equal(u *CreateIdentity) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}

	if !(v.KeyBookName == u.KeyBookName) {
		return false
	}

	if !(v.KeyPageName == u.KeyPageName) {
		return false
	}

	if !(v.Manager == u.Manager) {
		return false
	}

	return true
}

func (v *CreateKeyBook) Equal(u *CreateKeyBook) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(len(v.Pages) == len(u.Pages)) {
		return false
	}

	for i := range v.Pages {
		v, u := v.Pages[i], u.Pages[i]
		if !(v == u) {
			return false
		}

	}

	if !(v.Manager == u.Manager) {
		return false
	}

	return true
}

func (v *CreateKeyPage) Equal(u *CreateKeyPage) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(len(v.Keys) == len(u.Keys)) {
		return false
	}

	for i := range v.Keys {
		v, u := v.Keys[i], u.Keys[i]
		if !(v.Equal(u)) {
			return false
		}

	}

	if !(v.Manager == u.Manager) {
		return false
	}

	return true
}

func (v *CreateToken) Equal(u *CreateToken) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(v.KeyBookUrl == u.KeyBookUrl) {
		return false
	}

	if !(v.Symbol == u.Symbol) {
		return false
	}

	if !(v.Precision == u.Precision) {
		return false
	}

	if !(v.Properties == u.Properties) {
		return false
	}

	if !(v.InitialSupply.Cmp(&u.InitialSupply) == 0) {
		return false
	}

	if !(v.HasSupplyLimit == u.HasSupplyLimit) {
		return false
	}

	if !(v.Manager == u.Manager) {
		return false
	}

	return true
}

func (v *CreateTokenAccount) Equal(u *CreateTokenAccount) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(v.TokenUrl == u.TokenUrl) {
		return false
	}

	if !(v.KeyBookUrl == u.KeyBookUrl) {
		return false
	}

	if !(v.Scratch == u.Scratch) {
		return false
	}

	if !(v.Manager == u.Manager) {
		return false
	}

	return true
}

func (v *DataAccount) Equal(u *DataAccount) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *DataEntry) Equal(u *DataEntry) bool {
	if !(len(v.ExtIds) == len(u.ExtIds)) {
		return false
	}

	for i := range v.ExtIds {
		v, u := v.ExtIds[i], u.ExtIds[i]
		if !(bytes.Equal(v, u)) {
			return false
		}

	}

	if !(bytes.Equal(v.Data, u.Data)) {
		return false
	}

	return true
}

func (v *DirectoryIndexMetadata) Equal(u *DirectoryIndexMetadata) bool {
	if !(v.Count == u.Count) {
		return false
	}

	return true
}

func (v *DirectoryQueryResult) Equal(u *DirectoryQueryResult) bool {
	if !(len(v.Entries) == len(u.Entries)) {
		return false
	}

	for i := range v.Entries {
		v, u := v.Entries[i], u.Entries[i]
		if !(v == u) {
			return false
		}

	}

	if !(len(v.ExpandedEntries) == len(u.ExpandedEntries)) {
		return false
	}

	for i := range v.ExpandedEntries {
		v, u := v.ExpandedEntries[i], u.ExpandedEntries[i]
		if !(v.Equal(u)) {
			return false
		}

	}

	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *Envelope) Equal(u *Envelope) bool {
	if !(len(v.Signatures) == len(u.Signatures)) {
		return false
	}

	for i := range v.Signatures {
		v, u := v.Signatures[i], u.Signatures[i]
		if !(v.Equal(u)) {
			return false
		}

	}

	if !(bytes.Equal(v.TxHash, u.TxHash)) {
		return false
	}

	if !(v.Transaction.Equal(u.Transaction)) {
		return false
	}

	return true
}

func (v *InternalGenesis) Equal(u *InternalGenesis) bool {

	return true
}

func (v *InternalLedger) Equal(u *InternalLedger) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(v.Index == u.Index) {
		return false
	}

	if !(v.Timestamp == u.Timestamp) {
		return false
	}

	if !(v.Synthetic.Equal(&u.Synthetic)) {
		return false
	}

	if !(len(v.Updates) == len(u.Updates)) {
		return false
	}

	for i := range v.Updates {
		v, u := v.Updates[i], u.Updates[i]
		if !(v.Equal(&u)) {
			return false
		}

	}

	return true
}

func (v *InternalTransactionsSent) Equal(u *InternalTransactionsSent) bool {
	if !(len(v.Transactions) == len(u.Transactions)) {
		return false
	}

	for i := range v.Transactions {
		if v.Transactions[i] != u.Transactions[i] {
			return false
		}
	}

	return true
}

func (v *InternalTransactionsSigned) Equal(u *InternalTransactionsSigned) bool {
	if !(len(v.Transactions) == len(u.Transactions)) {
		return false
	}

	for i := range v.Transactions {
		v, u := v.Transactions[i], u.Transactions[i]
		if !(v.Equal(&u)) {
			return false
		}

	}

	return true
}

func (v *IssueTokens) Equal(u *IssueTokens) bool {
	if !(v.Recipient == u.Recipient) {
		return false
	}

	if !(v.Amount.Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *KeyBook) Equal(u *KeyBook) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(len(v.Pages) == len(u.Pages)) {
		return false
	}

	for i := range v.Pages {
		v, u := v.Pages[i], u.Pages[i]
		if !(v == u) {
			return false
		}

	}

	return true
}

func (v *KeyPage) Equal(u *KeyPage) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(v.CreditBalance.Cmp(&u.CreditBalance) == 0) {
		return false
	}

	if !(v.Threshold == u.Threshold) {
		return false
	}

	if !(len(v.Keys) == len(u.Keys)) {
		return false
	}

	for i := range v.Keys {
		v, u := v.Keys[i], u.Keys[i]
		if !(v.Equal(u)) {
			return false
		}

	}

	return true
}

func (v *KeySpec) Equal(u *KeySpec) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}

	if !(v.Nonce == u.Nonce) {
		return false
	}

	if !(v.Owner == u.Owner) {
		return false
	}

	return true
}

func (v *KeySpecParams) Equal(u *KeySpecParams) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}

	return true
}

func (v *LiteDataAccount) Equal(u *LiteDataAccount) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(bytes.Equal(v.Tail, u.Tail)) {
		return false
	}

	return true
}

func (v *LiteTokenAccount) Equal(u *LiteTokenAccount) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(v.TokenUrl == u.TokenUrl) {
		return false
	}

	if !(v.Balance.Cmp(&u.Balance) == 0) {
		return false
	}

	if !(v.Nonce == u.Nonce) {
		return false
	}

	if !(v.CreditBalance.Cmp(&u.CreditBalance) == 0) {
		return false
	}

	return true
}

func (v *MetricsRequest) Equal(u *MetricsRequest) bool {
	if !(v.Metric == u.Metric) {
		return false
	}

	if !(v.Duration == u.Duration) {
		return false
	}

	return true
}

func (v *Object) Equal(u *Object) bool {
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}

	if !(v.Height == u.Height) {
		return false
	}

	if !(len(v.Roots) == len(u.Roots)) {
		return false
	}

	for i := range v.Roots {
		v, u := v.Roots[i], u.Roots[i]
		if !(bytes.Equal(v, u)) {
			return false
		}

	}

	return true
}

func (v *ObjectMetadata) Equal(u *ObjectMetadata) bool {
	if !(v.Type == u.Type) {
		return false
	}

	if !(len(v.Chains) == len(u.Chains)) {
		return false
	}

	for i := range v.Chains {
		v, u := v.Chains[i], u.Chains[i]
		if !(v.Equal(&u)) {
			return false
		}

	}

	return true
}

func (v *PendingTransactionState) Equal(u *PendingTransactionState) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(len(v.Signature) == len(u.Signature)) {
		return false
	}

	for i := range v.Signature {
		v, u := v.Signature[i], u.Signature[i]
		if !(v.Equal(u)) {
			return false
		}

	}

	if !(v.TransactionState.Equal(u.TransactionState)) {
		return false
	}

	if !(bytes.Equal(v.Status, u.Status)) {
		return false
	}

	return true
}

func (v *Receipt) Equal(u *Receipt) bool {
	if !(bytes.Equal(v.Start, u.Start)) {
		return false
	}

	if !(len(v.Entries) == len(u.Entries)) {
		return false
	}

	for i := range v.Entries {
		v, u := v.Entries[i], u.Entries[i]
		if !(v.Equal(&u)) {
			return false
		}

	}

	return true
}

func (v *ReceiptEntry) Equal(u *ReceiptEntry) bool {
	if !(v.Right == u.Right) {
		return false
	}

	if !(bytes.Equal(v.Hash, u.Hash)) {
		return false
	}

	return true
}

func (v *RemoveManager) Equal(u *RemoveManager) bool {

	return true
}

func (v *RequestDataEntry) Equal(u *RequestDataEntry) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	return true
}

func (v *RequestDataEntrySet) Equal(u *RequestDataEntrySet) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(v.Start == u.Start) {
		return false
	}

	if !(v.Count == u.Count) {
		return false
	}

	if !(v.ExpandChains == u.ExpandChains) {
		return false
	}

	return true
}

func (v *ResponseDataEntry) Equal(u *ResponseDataEntry) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	if !(v.Entry.Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *ResponseDataEntrySet) Equal(u *ResponseDataEntrySet) bool {
	if !(len(v.DataEntries) == len(u.DataEntries)) {
		return false
	}

	for i := range v.DataEntries {
		v, u := v.DataEntries[i], u.DataEntries[i]
		if !(v.Equal(&u)) {
			return false
		}

	}

	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *SegWitDataEntry) Equal(u *SegWitDataEntry) bool {
	if !(v.Cause == u.Cause) {
		return false
	}

	if !(v.EntryUrl == u.EntryUrl) {
		return false
	}

	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	return true
}

func (v *SendTokens) Equal(u *SendTokens) bool {
	if !(v.Hash == u.Hash) {
		return false
	}

	if !(bytes.Equal(v.Meta, u.Meta)) {
		return false
	}

	if !(len(v.To) == len(u.To)) {
		return false
	}

	for i := range v.To {
		v, u := v.To[i], u.To[i]
		if !(v.Equal(u)) {
			return false
		}

	}

	return true
}

func (v *SignPending) Equal(u *SignPending) bool {

	return true
}

func (v *SyntheticAnchor) Equal(u *SyntheticAnchor) bool {
	if !(v.Source == u.Source) {
		return false
	}

	if !(v.Major == u.Major) {
		return false
	}

	if !(v.RootAnchor == u.RootAnchor) {
		return false
	}

	if !(v.RootIndex == u.RootIndex) {
		return false
	}

	if !(v.Block == u.Block) {
		return false
	}

	if !(v.SourceIndex == u.SourceIndex) {
		return false
	}

	if !(v.SourceBlock == u.SourceBlock) {
		return false
	}

	if !(v.Receipt.Equal(&u.Receipt)) {
		return false
	}

	return true
}

func (v *SyntheticBurnTokens) Equal(u *SyntheticBurnTokens) bool {
	if !(v.Cause == u.Cause) {
		return false
	}

	if !(v.Amount.Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *SyntheticCreateChain) Equal(u *SyntheticCreateChain) bool {
	if !(v.Cause == u.Cause) {
		return false
	}

	if !(len(v.Chains) == len(u.Chains)) {
		return false
	}

	for i := range v.Chains {
		v, u := v.Chains[i], u.Chains[i]
		if !(v.Equal(&u)) {
			return false
		}

	}

	return true
}

func (v *SyntheticDepositCredits) Equal(u *SyntheticDepositCredits) bool {
	if !(v.Cause == u.Cause) {
		return false
	}

	if !(v.Amount == u.Amount) {
		return false
	}

	return true
}

func (v *SyntheticDepositTokens) Equal(u *SyntheticDepositTokens) bool {
	if !(v.Cause == u.Cause) {
		return false
	}

	if !(v.Token == u.Token) {
		return false
	}

	if !(v.Amount.Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *SyntheticLedger) Equal(u *SyntheticLedger) bool {
	if !(v.Nonce == u.Nonce) {
		return false
	}

	if !(len(v.Produced) == len(u.Produced)) {
		return false
	}

	for i := range v.Produced {
		if v.Produced[i] != u.Produced[i] {
			return false
		}
	}

	if !(len(v.Unsigned) == len(u.Unsigned)) {
		return false
	}

	for i := range v.Unsigned {
		if v.Unsigned[i] != u.Unsigned[i] {
			return false
		}
	}

	if !(len(v.Unsent) == len(u.Unsent)) {
		return false
	}

	for i := range v.Unsent {
		if v.Unsent[i] != u.Unsent[i] {
			return false
		}
	}

	return true
}

func (v *SyntheticMirror) Equal(u *SyntheticMirror) bool {
	if !(len(v.Objects) == len(u.Objects)) {
		return false
	}

	for i := range v.Objects {
		v, u := v.Objects[i], u.Objects[i]
		if !(v.Equal(&u)) {
			return false
		}

	}

	return true
}

func (v *SyntheticWriteData) Equal(u *SyntheticWriteData) bool {
	if !(v.Cause == u.Cause) {
		return false
	}

	if !(v.Entry.Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *TokenAccount) Equal(u *TokenAccount) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(v.TokenUrl == u.TokenUrl) {
		return false
	}

	if !(v.Balance.Cmp(&u.Balance) == 0) {
		return false
	}

	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *TokenIssuer) Equal(u *TokenIssuer) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	if !(v.Symbol == u.Symbol) {
		return false
	}

	if !(v.Precision == u.Precision) {
		return false
	}

	if !(v.Properties == u.Properties) {
		return false
	}

	if !(v.Supply.Cmp(&u.Supply) == 0) {
		return false
	}

	if !(v.HasSupplyLimit == u.HasSupplyLimit) {
		return false
	}

	return true
}

func (v *TokenRecipient) Equal(u *TokenRecipient) bool {
	if !(v.Url == u.Url) {
		return false
	}

	if !(v.Amount.Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *Transaction) Equal(u *Transaction) bool {
	if !(bytes.Equal(v.Body, u.Body)) {
		return false
	}

	return true
}

func (v *TransactionHeader) Equal(u *TransactionHeader) bool {
	if !(v.Origin.Equal(u.Origin)) {
		return false
	}

	if !(v.KeyPageHeight == u.KeyPageHeight) {
		return false
	}

	if !(v.KeyPageIndex == u.KeyPageIndex) {
		return false
	}

	if !(v.Nonce == u.Nonce) {
		return false
	}

	return true
}

func (v *TransactionSignature) Equal(u *TransactionSignature) bool {
	if !(v.Transaction == u.Transaction) {
		return false
	}

	if !(v.Signature.Equal(u.Signature)) {
		return false
	}

	return true
}

func (v *TransactionState) Equal(u *TransactionState) bool {
	if !v.AccountHeader.Equal(&u.AccountHeader) {
		return false
	}

	return true
}

func (v *TransactionStatus) Equal(u *TransactionStatus) bool {
	if !(v.Remote == u.Remote) {
		return false
	}

	if !(v.Delivered == u.Delivered) {
		return false
	}

	if !(v.Pending == u.Pending) {
		return false
	}

	if !(v.Code == u.Code) {
		return false
	}

	if !(v.Message == u.Message) {
		return false
	}

	if !(v.Result == u.Result) {
		return false
	}

	return true
}

func (v *TxState) Equal(u *TxState) bool {
	if !(v.SigInfo.Equal(u.SigInfo)) {
		return false
	}

	if !(bytes.Equal(v.Transaction, u.Transaction)) {
		return false
	}

	return true
}

func (v *UpdateKeyPage) Equal(u *UpdateKeyPage) bool {
	if !(v.Operation == u.Operation) {
		return false
	}

	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}

	if !(bytes.Equal(v.NewKey, u.NewKey)) {
		return false
	}

	if !(v.Owner == u.Owner) {
		return false
	}

	if !(v.Threshold == u.Threshold) {
		return false
	}

	return true
}

func (v *WriteData) Equal(u *WriteData) bool {
	if !(v.Entry.Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *WriteDataResult) Equal(u *WriteDataResult) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	if !(v.AccountUrl.Equal(u.AccountUrl)) {
		return false
	}

	if !(bytes.Equal(v.AccountID, u.AccountID)) {
		return false
	}

	return true
}

func (v *WriteDataTo) Equal(u *WriteDataTo) bool {
	if !(v.Recipient == u.Recipient) {
		return false
	}

	if !(v.Entry.Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *ADI) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeIdentity

	n += v.AccountHeader.GetHeaderSize()

	return n
}

func (v *AccountHeader) BinarySize() int {
	var n int

	n += v.Type.BinarySize()

	n += encoding.StringBinarySize(v.Url)

	n += encoding.StringBinarySize(v.KeyBook)

	n += encoding.StringBinarySize(v.ManagerKeyBook)

	return n
}

func (v *AcmeFaucet) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeAcmeFaucet.ID())

	n += encoding.StringBinarySize(v.Url)

	return n
}

func (v *AddCredits) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeAddCredits.ID())

	n += encoding.StringBinarySize(v.Recipient)

	n += encoding.UvarintBinarySize(v.Amount)

	return n
}

func (v *Anchor) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeAnchor

	n += v.AccountHeader.GetHeaderSize()

	return n
}

func (v *AnchorMetadata) BinarySize() int {
	var n int

	n += v.ChainMetadata.BinarySize()

	n += v.Account.BinarySize()

	n += encoding.UvarintBinarySize(v.Index)

	n += encoding.UvarintBinarySize(v.SourceIndex)

	n += encoding.UvarintBinarySize(v.SourceBlock)

	n += encoding.BytesBinarySize(v.Entry)

	return n
}

func (v *AnchoredRecord) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.Record)

	n += encoding.ChainBinarySize(&v.Anchor)

	return n
}

func (v *BurnTokens) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeBurnTokens.ID())

	n += encoding.BigintBinarySize(&v.Amount)

	return n
}

func (v *ChainMetadata) BinarySize() int {
	var n int

	n += encoding.StringBinarySize(v.Name)

	n += v.Type.BinarySize()

	return n
}

func (v *ChainParams) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.Data)

	n += encoding.BoolBinarySize(v.IsUpdate)

	return n
}

func (v *CreateDataAccount) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeCreateDataAccount.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.StringBinarySize(v.KeyBookUrl)

	n += encoding.StringBinarySize(v.ManagerKeyBookUrl)

	n += encoding.BoolBinarySize(v.Scratch)

	return n
}

func (v *CreateIdentity) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeCreateIdentity.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.BytesBinarySize(v.PublicKey)

	n += encoding.StringBinarySize(v.KeyBookName)

	n += encoding.StringBinarySize(v.KeyPageName)

	n += encoding.StringBinarySize(v.Manager)

	return n
}

func (v *CreateKeyBook) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeCreateKeyBook.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.UvarintBinarySize(uint64(len(v.Pages)))

	for _, v := range v.Pages {
		n += encoding.StringBinarySize(v)

	}

	n += encoding.StringBinarySize(v.Manager)

	return n
}

func (v *CreateKeyPage) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeCreateKeyPage.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.UvarintBinarySize(uint64(len(v.Keys)))

	for _, v := range v.Keys {
		n += v.BinarySize()

	}

	n += encoding.StringBinarySize(v.Manager)

	return n
}

func (v *CreateToken) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeCreateToken.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.StringBinarySize(v.KeyBookUrl)

	n += encoding.StringBinarySize(v.Symbol)

	n += encoding.UvarintBinarySize(v.Precision)

	n += encoding.StringBinarySize(v.Properties)

	n += encoding.BigintBinarySize(&v.InitialSupply)

	n += encoding.BoolBinarySize(v.HasSupplyLimit)

	n += encoding.StringBinarySize(v.Manager)

	return n
}

func (v *CreateTokenAccount) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeCreateTokenAccount.ID())

	n += encoding.StringBinarySize(v.Url)

	n += encoding.StringBinarySize(v.TokenUrl)

	n += encoding.StringBinarySize(v.KeyBookUrl)

	n += encoding.BoolBinarySize(v.Scratch)

	n += encoding.StringBinarySize(v.Manager)

	return n
}

func (v *DataAccount) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeDataAccount

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.BoolBinarySize(v.Scratch)

	return n
}

func (v *DataEntry) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(uint64(len(v.ExtIds)))

	for _, v := range v.ExtIds {
		n += encoding.BytesBinarySize(v)

	}

	n += encoding.BytesBinarySize(v.Data)

	return n
}

func (v *DirectoryIndexMetadata) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(v.Count)

	return n
}

func (v *DirectoryQueryResult) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(uint64(len(v.Entries)))

	for _, v := range v.Entries {
		n += encoding.StringBinarySize(v)

	}

	n += encoding.UvarintBinarySize(uint64(len(v.ExpandedEntries)))

	for _, v := range v.ExpandedEntries {
		n += v.BinarySize()

	}

	n += encoding.UvarintBinarySize(v.Total)

	return n
}

func (v *Envelope) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(uint64(len(v.Signatures)))

	for _, v := range v.Signatures {
		n += v.BinarySize()

	}

	n += encoding.BytesBinarySize(v.TxHash)

	n += v.Transaction.BinarySize()

	return n
}

func (v *InternalGenesis) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeInternalGenesis.ID())

	return n
}

func (v *InternalLedger) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeInternalLedger

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.VarintBinarySize(v.Index)

	n += encoding.TimeBinarySize(v.Timestamp)

	n += v.Synthetic.BinarySize()

	n += encoding.UvarintBinarySize(uint64(len(v.Updates)))

	for _, v := range v.Updates {
		n += v.BinarySize()

	}

	return n
}

func (v *InternalSendTransactions) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeInternalSendTransactions.ID())

	n += encoding.UvarintBinarySize(uint64(len(v.Transactions)))

	for _, v := range v.Transactions {
		n += v.BinarySize()

	}

	return n
}

func (v *InternalTransactionsSent) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeInternalTransactionsSent.ID())

	n += encoding.ChainSetBinarySize(v.Transactions)

	return n
}

func (v *InternalTransactionsSigned) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeInternalTransactionsSigned.ID())

	n += encoding.UvarintBinarySize(uint64(len(v.Transactions)))

	for _, v := range v.Transactions {
		n += v.BinarySize()

	}

	return n
}

func (v *IssueTokens) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeIssueTokens.ID())

	n += encoding.StringBinarySize(v.Recipient)

	n += encoding.BigintBinarySize(&v.Amount)

	return n
}

func (v *KeyBook) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeKeyBook

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.UvarintBinarySize(uint64(len(v.Pages)))

	for _, v := range v.Pages {
		n += encoding.StringBinarySize(v)

	}

	return n
}

func (v *KeyPage) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeKeyPage

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.BigintBinarySize(&v.CreditBalance)

	n += encoding.UvarintBinarySize(v.Threshold)

	n += encoding.UvarintBinarySize(uint64(len(v.Keys)))

	for _, v := range v.Keys {
		n += v.BinarySize()

	}

	return n
}

func (v *KeySpec) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.PublicKey)

	n += encoding.UvarintBinarySize(v.Nonce)

	n += encoding.StringBinarySize(v.Owner)

	return n
}

func (v *KeySpecParams) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.PublicKey)

	return n
}

func (v *LiteDataAccount) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeLiteDataAccount

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.BytesBinarySize(v.Tail)

	return n
}

func (v *LiteTokenAccount) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeLiteTokenAccount

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.StringBinarySize(v.TokenUrl)

	n += encoding.BigintBinarySize(&v.Balance)

	n += encoding.UvarintBinarySize(v.Nonce)

	n += encoding.BigintBinarySize(&v.CreditBalance)

	return n
}

func (v *MetricsRequest) BinarySize() int {
	var n int

	n += encoding.StringBinarySize(v.Metric)

	n += encoding.DurationBinarySize(v.Duration)

	return n
}

func (v *Object) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.Entry)

	n += encoding.UvarintBinarySize(v.Height)

	n += encoding.UvarintBinarySize(uint64(len(v.Roots)))

	for _, v := range v.Roots {
		n += encoding.BytesBinarySize(v)

	}

	return n
}

func (v *ObjectMetadata) BinarySize() int {
	var n int

	n += v.Type.BinarySize()

	n += encoding.UvarintBinarySize(uint64(len(v.Chains)))

	for _, v := range v.Chains {
		n += v.BinarySize()

	}

	return n
}

func (v *PendingTransactionState) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypePendingTransaction

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.UvarintBinarySize(uint64(len(v.Signature)))

	for _, v := range v.Signature {
		n += v.BinarySize()

	}

	n += v.TransactionState.BinarySize()

	n += encoding.BytesBinarySize(v.Status)

	return n
}

func (v *Receipt) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.Start)

	n += encoding.UvarintBinarySize(uint64(len(v.Entries)))

	for _, v := range v.Entries {
		n += v.BinarySize()

	}

	return n
}

func (v *ReceiptEntry) BinarySize() int {
	var n int

	n += encoding.BoolBinarySize(v.Right)

	n += encoding.BytesBinarySize(v.Hash)

	return n
}

func (v *RemoveManager) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeRemoveManager.ID())

	return n
}

func (v *RequestDataEntry) BinarySize() int {
	var n int

	n += encoding.StringBinarySize(v.Url)

	n += encoding.ChainBinarySize(&v.EntryHash)

	return n
}

func (v *RequestDataEntrySet) BinarySize() int {
	var n int

	n += encoding.StringBinarySize(v.Url)

	n += encoding.UvarintBinarySize(v.Start)

	n += encoding.UvarintBinarySize(v.Count)

	n += encoding.BoolBinarySize(v.ExpandChains)

	return n
}

func (v *ResponseDataEntry) BinarySize() int {
	var n int

	n += encoding.ChainBinarySize(&v.EntryHash)

	n += v.Entry.BinarySize()

	return n
}

func (v *ResponseDataEntrySet) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(uint64(len(v.DataEntries)))

	for _, v := range v.DataEntries {
		n += v.BinarySize()

	}

	n += encoding.UvarintBinarySize(v.Total)

	return n
}

func (v *SegWitDataEntry) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSegWitDataEntry.ID())

	n += encoding.ChainBinarySize(&v.Cause)

	n += encoding.StringBinarySize(v.EntryUrl)

	n += encoding.ChainBinarySize(&v.EntryHash)

	return n
}

func (v *SendTokens) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSendTokens.ID())

	n += encoding.ChainBinarySize(&v.Hash)

	n += encoding.BytesBinarySize(v.Meta)

	n += encoding.UvarintBinarySize(uint64(len(v.To)))

	for _, v := range v.To {
		n += v.BinarySize()

	}

	return n
}

func (v *SendTransaction) BinarySize() int {
	var n int

	n += v.Payload.BinarySize()

	n += v.Recipient.BinarySize()

	return n
}

func (v *SignPending) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSignPending.ID())

	return n
}

func (v *SyntheticAnchor) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSyntheticAnchor.ID())

	n += encoding.StringBinarySize(v.Source)

	n += encoding.BoolBinarySize(v.Major)

	n += encoding.ChainBinarySize(&v.RootAnchor)

	n += encoding.UvarintBinarySize(v.RootIndex)

	n += encoding.UvarintBinarySize(v.Block)

	n += encoding.UvarintBinarySize(v.SourceIndex)

	n += encoding.UvarintBinarySize(v.SourceBlock)

	n += v.Receipt.BinarySize()

	return n
}

func (v *SyntheticBurnTokens) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSyntheticBurnTokens.ID())

	n += encoding.ChainBinarySize(&v.Cause)

	n += encoding.BigintBinarySize(&v.Amount)

	return n
}

func (v *SyntheticCreateChain) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSyntheticCreateChain.ID())

	n += encoding.ChainBinarySize(&v.Cause)

	n += encoding.UvarintBinarySize(uint64(len(v.Chains)))

	for _, v := range v.Chains {
		n += v.BinarySize()

	}

	return n
}

func (v *SyntheticDepositCredits) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSyntheticDepositCredits.ID())

	n += encoding.ChainBinarySize(&v.Cause)

	n += encoding.UvarintBinarySize(v.Amount)

	return n
}

func (v *SyntheticDepositTokens) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSyntheticDepositTokens.ID())

	n += encoding.ChainBinarySize(&v.Cause)

	n += encoding.StringBinarySize(v.Token)

	n += encoding.BigintBinarySize(&v.Amount)

	return n
}

func (v *SyntheticLedger) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(v.Nonce)

	n += encoding.ChainSetBinarySize(v.Produced)

	n += encoding.ChainSetBinarySize(v.Unsigned)

	n += encoding.ChainSetBinarySize(v.Unsent)

	return n
}

func (v *SyntheticMirror) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSyntheticMirror.ID())

	n += encoding.UvarintBinarySize(uint64(len(v.Objects)))

	for _, v := range v.Objects {
		n += v.BinarySize()

	}

	return n
}

func (v *SyntheticWriteData) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeSyntheticWriteData.ID())

	n += encoding.ChainBinarySize(&v.Cause)

	n += v.Entry.BinarySize()

	return n
}

func (v *TokenAccount) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeTokenAccount

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.StringBinarySize(v.TokenUrl)

	n += encoding.BigintBinarySize(&v.Balance)

	n += encoding.BoolBinarySize(v.Scratch)

	return n
}

func (v *TokenIssuer) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeTokenIssuer

	n += v.AccountHeader.GetHeaderSize()

	n += encoding.StringBinarySize(v.Symbol)

	n += encoding.UvarintBinarySize(v.Precision)

	n += encoding.StringBinarySize(v.Properties)

	n += encoding.BigintBinarySize(&v.Supply)

	n += encoding.BoolBinarySize(v.HasSupplyLimit)

	return n
}

func (v *TokenRecipient) BinarySize() int {
	var n int

	n += encoding.StringBinarySize(v.Url)

	n += encoding.BigintBinarySize(&v.Amount)

	return n
}

func (v *Transaction) BinarySize() int {
	var n int

	n += v.TransactionHeader.BinarySize()

	n += encoding.BytesBinarySize(v.Body)

	return n
}

func (v *TransactionHeader) BinarySize() int {
	var n int

	n += v.Origin.BinarySize()

	n += encoding.UvarintBinarySize(v.KeyPageHeight)

	n += encoding.UvarintBinarySize(v.KeyPageIndex)

	n += encoding.UvarintBinarySize(v.Nonce)

	return n
}

func (v *TransactionSignature) BinarySize() int {
	var n int

	n += encoding.ChainBinarySize(&v.Transaction)

	n += v.Signature.BinarySize()

	return n
}

func (v *TransactionState) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = AccountTypeTransaction

	n += v.AccountHeader.GetHeaderSize()

	n += v.TxState.BinarySize()

	return n
}

func (v *TransactionStatus) BinarySize() int {
	var n int

	n += encoding.BoolBinarySize(v.Remote)

	n += encoding.BoolBinarySize(v.Delivered)

	n += encoding.BoolBinarySize(v.Pending)

	n += encoding.UvarintBinarySize(v.Code)

	n += encoding.StringBinarySize(v.Message)

	n += v.Result.BinarySize()

	return n
}

func (v *TxState) BinarySize() int {
	var n int

	n += v.SigInfo.BinarySize()

	n += encoding.BytesBinarySize(v.Transaction)

	return n
}

func (v *UpdateKeyPage) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeUpdateKeyPage.ID())

	n += v.Operation.BinarySize()

	n += encoding.BytesBinarySize(v.Key)

	n += encoding.BytesBinarySize(v.NewKey)

	n += encoding.StringBinarySize(v.Owner)

	n += encoding.UvarintBinarySize(v.Threshold)

	return n
}

func (v *WriteData) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeWriteData.ID())

	n += v.Entry.BinarySize()

	return n
}

func (v *WriteDataResult) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeWriteData.ID())

	n += encoding.ChainBinarySize(&v.EntryHash)

	n += v.AccountUrl.BinarySize()

	n += encoding.BytesBinarySize(v.AccountID)

	return n
}

func (v *WriteDataTo) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(TransactionTypeWriteDataTo.ID())

	n += encoding.StringBinarySize(v.Recipient)

	n += v.Entry.BinarySize()

	return n
}

func (v *ADI) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeIdentity

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *AccountHeader) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	if b, err := v.Type.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Type: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.StringMarshalBinary(v.KeyBook))

	buffer.Write(encoding.StringMarshalBinary(v.ManagerKeyBook))

	return buffer.Bytes(), nil
}

func (v *AcmeFaucet) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeAcmeFaucet.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	return buffer.Bytes(), nil
}

func (v *AddCredits) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeAddCredits.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Recipient))

	buffer.Write(encoding.UvarintMarshalBinary(v.Amount))

	return buffer.Bytes(), nil
}

func (v *Anchor) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeAnchor

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *AnchorMetadata) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	if b, err := v.ChainMetadata.MarshalBinary(); err != nil {
		return nil, err
	} else {
		buffer.Write(b)
	}

	if b, err := v.Account.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Account: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.UvarintMarshalBinary(v.Index))

	buffer.Write(encoding.UvarintMarshalBinary(v.SourceIndex))

	buffer.Write(encoding.UvarintMarshalBinary(v.SourceBlock))

	buffer.Write(encoding.BytesMarshalBinary(v.Entry))

	return buffer.Bytes(), nil
}

func (v *AnchoredRecord) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.Record))

	buffer.Write(encoding.ChainMarshalBinary(&v.Anchor))

	return buffer.Bytes(), nil
}

func (v *BurnTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeBurnTokens.ID()))

	buffer.Write(encoding.BigintMarshalBinary(&v.Amount))

	return buffer.Bytes(), nil
}

func (v *ChainMetadata) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.StringMarshalBinary(v.Name))

	if b, err := v.Type.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Type: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *ChainParams) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.Data))

	buffer.Write(encoding.BoolMarshalBinary(v.IsUpdate))

	return buffer.Bytes(), nil
}

func (v *CreateDataAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeCreateDataAccount.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))

	buffer.Write(encoding.StringMarshalBinary(v.ManagerKeyBookUrl))

	buffer.Write(encoding.BoolMarshalBinary(v.Scratch))

	return buffer.Bytes(), nil
}

func (v *CreateIdentity) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeCreateIdentity.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))

	buffer.Write(encoding.StringMarshalBinary(v.KeyBookName))

	buffer.Write(encoding.StringMarshalBinary(v.KeyPageName))

	buffer.Write(encoding.StringMarshalBinary(v.Manager))

	return buffer.Bytes(), nil
}

func (v *CreateKeyBook) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeCreateKeyBook.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Pages))))
	for i, v := range v.Pages {
		_ = i
		buffer.Write(encoding.StringMarshalBinary(v))

	}

	buffer.Write(encoding.StringMarshalBinary(v.Manager))

	return buffer.Bytes(), nil
}

func (v *CreateKeyPage) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeCreateKeyPage.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Keys))))
	for i, v := range v.Keys {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Keys[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	buffer.Write(encoding.StringMarshalBinary(v.Manager))

	return buffer.Bytes(), nil
}

func (v *CreateToken) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeCreateToken.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))

	buffer.Write(encoding.StringMarshalBinary(v.Symbol))

	buffer.Write(encoding.UvarintMarshalBinary(v.Precision))

	buffer.Write(encoding.StringMarshalBinary(v.Properties))

	buffer.Write(encoding.BigintMarshalBinary(&v.InitialSupply))

	buffer.Write(encoding.BoolMarshalBinary(v.HasSupplyLimit))

	buffer.Write(encoding.StringMarshalBinary(v.Manager))

	return buffer.Bytes(), nil
}

func (v *CreateTokenAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeCreateTokenAccount.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.StringMarshalBinary(v.TokenUrl))

	buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))

	buffer.Write(encoding.BoolMarshalBinary(v.Scratch))

	buffer.Write(encoding.StringMarshalBinary(v.Manager))

	return buffer.Bytes(), nil
}

func (v *DataAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeDataAccount

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.BoolMarshalBinary(v.Scratch))

	return buffer.Bytes(), nil
}

func (v *DataEntry) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.ExtIds))))
	for i, v := range v.ExtIds {
		_ = i
		buffer.Write(encoding.BytesMarshalBinary(v))

	}

	buffer.Write(encoding.BytesMarshalBinary(v.Data))

	return buffer.Bytes(), nil
}

func (v *DirectoryIndexMetadata) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(v.Count))

	return buffer.Bytes(), nil
}

func (v *DirectoryQueryResult) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Entries))))
	for i, v := range v.Entries {
		_ = i
		buffer.Write(encoding.StringMarshalBinary(v))

	}

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.ExpandedEntries))))
	for i, v := range v.ExpandedEntries {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding ExpandedEntries[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	buffer.Write(encoding.UvarintMarshalBinary(v.Total))

	return buffer.Bytes(), nil
}

func (v *Envelope) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Signatures))))
	for i, v := range v.Signatures {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Signatures[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	buffer.Write(encoding.BytesMarshalBinary(v.TxHash))

	if b, err := v.Transaction.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Transaction: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *InternalGenesis) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeInternalGenesis.ID()))

	return buffer.Bytes(), nil
}

func (v *InternalLedger) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeInternalLedger

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.VarintMarshalBinary(v.Index))

	buffer.Write(encoding.TimeMarshalBinary(v.Timestamp))

	if b, err := v.Synthetic.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Synthetic: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Updates))))
	for i, v := range v.Updates {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Updates[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *InternalSendTransactions) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeInternalSendTransactions.ID()))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Transactions))))
	for i, v := range v.Transactions {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Transactions[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *InternalTransactionsSent) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeInternalTransactionsSent.ID()))

	buffer.Write(encoding.ChainSetMarshalBinary(v.Transactions))

	return buffer.Bytes(), nil
}

func (v *InternalTransactionsSigned) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeInternalTransactionsSigned.ID()))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Transactions))))
	for i, v := range v.Transactions {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Transactions[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *IssueTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeIssueTokens.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Recipient))

	buffer.Write(encoding.BigintMarshalBinary(&v.Amount))

	return buffer.Bytes(), nil
}

func (v *KeyBook) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeKeyBook

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Pages))))
	for i, v := range v.Pages {
		_ = i
		buffer.Write(encoding.StringMarshalBinary(v))

	}

	return buffer.Bytes(), nil
}

func (v *KeyPage) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeKeyPage

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.BigintMarshalBinary(&v.CreditBalance))

	buffer.Write(encoding.UvarintMarshalBinary(v.Threshold))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Keys))))
	for i, v := range v.Keys {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Keys[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *KeySpec) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))

	buffer.Write(encoding.UvarintMarshalBinary(v.Nonce))

	buffer.Write(encoding.StringMarshalBinary(v.Owner))

	return buffer.Bytes(), nil
}

func (v *KeySpecParams) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))

	return buffer.Bytes(), nil
}

func (v *LiteDataAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeLiteDataAccount

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.BytesMarshalBinary(v.Tail))

	return buffer.Bytes(), nil
}

func (v *LiteTokenAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeLiteTokenAccount

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.StringMarshalBinary(v.TokenUrl))

	buffer.Write(encoding.BigintMarshalBinary(&v.Balance))

	buffer.Write(encoding.UvarintMarshalBinary(v.Nonce))

	buffer.Write(encoding.BigintMarshalBinary(&v.CreditBalance))

	return buffer.Bytes(), nil
}

func (v *MetricsRequest) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.StringMarshalBinary(v.Metric))

	buffer.Write(encoding.DurationMarshalBinary(v.Duration))

	return buffer.Bytes(), nil
}

func (v *Object) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.Entry))

	buffer.Write(encoding.UvarintMarshalBinary(v.Height))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Roots))))
	for i, v := range v.Roots {
		_ = i
		buffer.Write(encoding.BytesMarshalBinary(v))

	}

	return buffer.Bytes(), nil
}

func (v *ObjectMetadata) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	if b, err := v.Type.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Type: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Chains))))
	for i, v := range v.Chains {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Chains[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *PendingTransactionState) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypePendingTransaction

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Signature))))
	for i, v := range v.Signature {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Signature[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	if b, err := v.TransactionState.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding TransactionState: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.BytesMarshalBinary(v.Status))

	return buffer.Bytes(), nil
}

func (v *Receipt) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.Start))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Entries))))
	for i, v := range v.Entries {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Entries[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *ReceiptEntry) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BoolMarshalBinary(v.Right))

	buffer.Write(encoding.BytesMarshalBinary(v.Hash))

	return buffer.Bytes(), nil
}

func (v *RemoveManager) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeRemoveManager.ID()))

	return buffer.Bytes(), nil
}

func (v *RequestDataEntry) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.ChainMarshalBinary(&v.EntryHash))

	return buffer.Bytes(), nil
}

func (v *RequestDataEntrySet) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.UvarintMarshalBinary(v.Start))

	buffer.Write(encoding.UvarintMarshalBinary(v.Count))

	buffer.Write(encoding.BoolMarshalBinary(v.ExpandChains))

	return buffer.Bytes(), nil
}

func (v *ResponseDataEntry) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.ChainMarshalBinary(&v.EntryHash))

	if b, err := v.Entry.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Entry: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *ResponseDataEntrySet) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.DataEntries))))
	for i, v := range v.DataEntries {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding DataEntries[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	buffer.Write(encoding.UvarintMarshalBinary(v.Total))

	return buffer.Bytes(), nil
}

func (v *SegWitDataEntry) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSegWitDataEntry.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Cause))

	buffer.Write(encoding.StringMarshalBinary(v.EntryUrl))

	buffer.Write(encoding.ChainMarshalBinary(&v.EntryHash))

	return buffer.Bytes(), nil
}

func (v *SendTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSendTokens.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Hash))

	buffer.Write(encoding.BytesMarshalBinary(v.Meta))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.To))))
	for i, v := range v.To {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding To[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *SendTransaction) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	if b, err := v.Payload.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Payload: %w", err)
	} else {
		buffer.Write(b)
	}

	if b, err := v.Recipient.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Recipient: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *SignPending) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSignPending.ID()))

	return buffer.Bytes(), nil
}

func (v *SyntheticAnchor) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSyntheticAnchor.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Source))

	buffer.Write(encoding.BoolMarshalBinary(v.Major))

	buffer.Write(encoding.ChainMarshalBinary(&v.RootAnchor))

	buffer.Write(encoding.UvarintMarshalBinary(v.RootIndex))

	buffer.Write(encoding.UvarintMarshalBinary(v.Block))

	buffer.Write(encoding.UvarintMarshalBinary(v.SourceIndex))

	buffer.Write(encoding.UvarintMarshalBinary(v.SourceBlock))

	if b, err := v.Receipt.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Receipt: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *SyntheticBurnTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSyntheticBurnTokens.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Cause))

	buffer.Write(encoding.BigintMarshalBinary(&v.Amount))

	return buffer.Bytes(), nil
}

func (v *SyntheticCreateChain) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSyntheticCreateChain.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Cause))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Chains))))
	for i, v := range v.Chains {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Chains[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *SyntheticDepositCredits) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSyntheticDepositCredits.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Cause))

	buffer.Write(encoding.UvarintMarshalBinary(v.Amount))

	return buffer.Bytes(), nil
}

func (v *SyntheticDepositTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSyntheticDepositTokens.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Cause))

	buffer.Write(encoding.StringMarshalBinary(v.Token))

	buffer.Write(encoding.BigintMarshalBinary(&v.Amount))

	return buffer.Bytes(), nil
}

func (v *SyntheticLedger) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(v.Nonce))

	buffer.Write(encoding.ChainSetMarshalBinary(v.Produced))

	buffer.Write(encoding.ChainSetMarshalBinary(v.Unsigned))

	buffer.Write(encoding.ChainSetMarshalBinary(v.Unsent))

	return buffer.Bytes(), nil
}

func (v *SyntheticMirror) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSyntheticMirror.ID()))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Objects))))
	for i, v := range v.Objects {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Objects[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *SyntheticWriteData) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeSyntheticWriteData.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.Cause))

	if b, err := v.Entry.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Entry: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *TokenAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeTokenAccount

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.StringMarshalBinary(v.TokenUrl))

	buffer.Write(encoding.BigintMarshalBinary(&v.Balance))

	buffer.Write(encoding.BoolMarshalBinary(v.Scratch))

	return buffer.Bytes(), nil
}

func (v *TokenIssuer) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeTokenIssuer

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.StringMarshalBinary(v.Symbol))

	buffer.Write(encoding.UvarintMarshalBinary(v.Precision))

	buffer.Write(encoding.StringMarshalBinary(v.Properties))

	buffer.Write(encoding.BigintMarshalBinary(&v.Supply))

	buffer.Write(encoding.BoolMarshalBinary(v.HasSupplyLimit))

	return buffer.Bytes(), nil
}

func (v *TokenRecipient) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.StringMarshalBinary(v.Url))

	buffer.Write(encoding.BigintMarshalBinary(&v.Amount))

	return buffer.Bytes(), nil
}

func (v *Transaction) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	if b, err := v.TransactionHeader.MarshalBinary(); err != nil {
		return nil, err
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.BytesMarshalBinary(v.Body))

	return buffer.Bytes(), nil
}

func (v *TransactionHeader) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	if b, err := v.Origin.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Origin: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.UvarintMarshalBinary(v.KeyPageHeight))

	buffer.Write(encoding.UvarintMarshalBinary(v.KeyPageIndex))

	buffer.Write(encoding.UvarintMarshalBinary(v.Nonce))

	return buffer.Bytes(), nil
}

func (v *TransactionSignature) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.ChainMarshalBinary(&v.Transaction))

	if b, err := v.Signature.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Signature: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *TransactionState) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = AccountTypeTransaction

	if b, err := v.AccountHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	if b, err := v.TxState.MarshalBinary(); err != nil {
		return nil, err
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *TransactionStatus) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BoolMarshalBinary(v.Remote))

	buffer.Write(encoding.BoolMarshalBinary(v.Delivered))

	buffer.Write(encoding.BoolMarshalBinary(v.Pending))

	buffer.Write(encoding.UvarintMarshalBinary(v.Code))

	buffer.Write(encoding.StringMarshalBinary(v.Message))

	if b, err := v.Result.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Result: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *TxState) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	if b, err := v.SigInfo.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding SigInfo: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.BytesMarshalBinary(v.Transaction))

	return buffer.Bytes(), nil
}

func (v *UpdateKeyPage) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeUpdateKeyPage.ID()))

	if b, err := v.Operation.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Operation: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.BytesMarshalBinary(v.Key))

	buffer.Write(encoding.BytesMarshalBinary(v.NewKey))

	buffer.Write(encoding.StringMarshalBinary(v.Owner))

	buffer.Write(encoding.UvarintMarshalBinary(v.Threshold))

	return buffer.Bytes(), nil
}

func (v *WriteData) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeWriteData.ID()))

	if b, err := v.Entry.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Entry: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *WriteDataResult) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeWriteData.ID()))

	buffer.Write(encoding.ChainMarshalBinary(&v.EntryHash))

	if b, err := v.AccountUrl.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding AccountUrl: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.BytesMarshalBinary(v.AccountID))

	return buffer.Bytes(), nil
}

func (v *WriteDataTo) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(TransactionTypeWriteDataTo.ID()))

	buffer.Write(encoding.StringMarshalBinary(v.Recipient))

	if b, err := v.Entry.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding Entry: %w", err)
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *ADI) UnmarshalBinary(data []byte) error {
	typ := AccountTypeIdentity
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	return nil
}

func (v *AccountHeader) UnmarshalBinary(data []byte) error {
	if err := v.Type.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Type: %w", err)
	}
	data = data[v.Type.BinarySize():]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyBook: %w", err)
	} else {
		v.KeyBook = x
	}
	data = data[encoding.StringBinarySize(v.KeyBook):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding ManagerKeyBook: %w", err)
	} else {
		v.ManagerKeyBook = x
	}
	data = data[encoding.StringBinarySize(v.ManagerKeyBook):]

	return nil
}

func (v *AcmeFaucet) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeAcmeFaucet
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	return nil
}

func (v *AddCredits) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeAddCredits
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Recipient: %w", err)
	} else {
		v.Recipient = x
	}
	data = data[encoding.StringBinarySize(v.Recipient):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = x
	}
	data = data[encoding.UvarintBinarySize(v.Amount):]

	return nil
}

func (v *Anchor) UnmarshalBinary(data []byte) error {
	typ := AccountTypeAnchor
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	return nil
}

func (v *AnchorMetadata) UnmarshalBinary(data []byte) error {
	if err := v.ChainMetadata.UnmarshalBinary(data); err != nil {
		return err
	}
	data = data[v.ChainMetadata.BinarySize():]

	v.Account = new(url.URL)
	if err := v.Account.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Account: %w", err)
	}
	data = data[v.Account.BinarySize():]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Index: %w", err)
	} else {
		v.Index = x
	}
	data = data[encoding.UvarintBinarySize(v.Index):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SourceIndex: %w", err)
	} else {
		v.SourceIndex = x
	}
	data = data[encoding.UvarintBinarySize(v.SourceIndex):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SourceBlock: %w", err)
	} else {
		v.SourceBlock = x
	}
	data = data[encoding.UvarintBinarySize(v.SourceBlock):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	data = data[encoding.BytesBinarySize(v.Entry):]

	return nil
}

func (v *AnchoredRecord) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Record: %w", err)
	} else {
		v.Record = x
	}
	data = data[encoding.BytesBinarySize(v.Record):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Anchor = x
	}
	data = data[encoding.ChainBinarySize(&v.Anchor):]

	return nil
}

func (v *BurnTokens) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeBurnTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Amount):]

	return nil
}

func (v *ChainMetadata) UnmarshalBinary(data []byte) error {
	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Name: %w", err)
	} else {
		v.Name = x
	}
	data = data[encoding.StringBinarySize(v.Name):]

	if err := v.Type.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Type: %w", err)
	}
	data = data[v.Type.BinarySize():]

	return nil
}

func (v *ChainParams) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	data = data[encoding.BytesBinarySize(v.Data):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding IsUpdate: %w", err)
	} else {
		v.IsUpdate = x
	}
	data = data[encoding.BoolBinarySize(v.IsUpdate):]

	return nil
}

func (v *CreateDataAccount) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeCreateDataAccount
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyBookUrl: %w", err)
	} else {
		v.KeyBookUrl = x
	}
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding ManagerKeyBookUrl: %w", err)
	} else {
		v.ManagerKeyBookUrl = x
	}
	data = data[encoding.StringBinarySize(v.ManagerKeyBookUrl):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Scratch: %w", err)
	} else {
		v.Scratch = x
	}
	data = data[encoding.BoolBinarySize(v.Scratch):]

	return nil
}

func (v *CreateIdentity) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeCreateIdentity
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	data = data[encoding.BytesBinarySize(v.PublicKey):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyBookName: %w", err)
	} else {
		v.KeyBookName = x
	}
	data = data[encoding.StringBinarySize(v.KeyBookName):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyPageName: %w", err)
	} else {
		v.KeyPageName = x
	}
	data = data[encoding.StringBinarySize(v.KeyPageName):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Manager: %w", err)
	} else {
		v.Manager = x
	}
	data = data[encoding.StringBinarySize(v.Manager):]

	return nil
}

func (v *CreateKeyBook) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeCreateKeyBook
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	var lenPages uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Pages: %w", err)
	} else {
		lenPages = x
	}
	data = data[encoding.UvarintBinarySize(lenPages):]

	v.Pages = make([]string, lenPages)
	for i := range v.Pages {
		if x, err := encoding.StringUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Pages[%d]: %w", i, err)
		} else {
			v.Pages[i] = x
		}
		data = data[encoding.StringBinarySize(v.Pages[i]):]

	}

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Manager: %w", err)
	} else {
		v.Manager = x
	}
	data = data[encoding.StringBinarySize(v.Manager):]

	return nil
}

func (v *CreateKeyPage) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeCreateKeyPage
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	var lenKeys uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Keys: %w", err)
	} else {
		lenKeys = x
	}
	data = data[encoding.UvarintBinarySize(lenKeys):]

	v.Keys = make([]*KeySpecParams, lenKeys)
	for i := range v.Keys {
		var x *KeySpecParams
		x = new(KeySpecParams)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Keys[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.Keys[i] = x
	}

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Manager: %w", err)
	} else {
		v.Manager = x
	}
	data = data[encoding.StringBinarySize(v.Manager):]

	return nil
}

func (v *CreateToken) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeCreateToken
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyBookUrl: %w", err)
	} else {
		v.KeyBookUrl = x
	}
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Symbol: %w", err)
	} else {
		v.Symbol = x
	}
	data = data[encoding.StringBinarySize(v.Symbol):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Precision: %w", err)
	} else {
		v.Precision = x
	}
	data = data[encoding.UvarintBinarySize(v.Precision):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Properties: %w", err)
	} else {
		v.Properties = x
	}
	data = data[encoding.StringBinarySize(v.Properties):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding InitialSupply: %w", err)
	} else {
		v.InitialSupply.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.InitialSupply):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding HasSupplyLimit: %w", err)
	} else {
		v.HasSupplyLimit = x
	}
	data = data[encoding.BoolBinarySize(v.HasSupplyLimit):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Manager: %w", err)
	} else {
		v.Manager = x
	}
	data = data[encoding.StringBinarySize(v.Manager):]

	return nil
}

func (v *CreateTokenAccount) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeCreateTokenAccount
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TokenUrl: %w", err)
	} else {
		v.TokenUrl = x
	}
	data = data[encoding.StringBinarySize(v.TokenUrl):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyBookUrl: %w", err)
	} else {
		v.KeyBookUrl = x
	}
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Scratch: %w", err)
	} else {
		v.Scratch = x
	}
	data = data[encoding.BoolBinarySize(v.Scratch):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Manager: %w", err)
	} else {
		v.Manager = x
	}
	data = data[encoding.StringBinarySize(v.Manager):]

	return nil
}

func (v *DataAccount) UnmarshalBinary(data []byte) error {
	typ := AccountTypeDataAccount
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Scratch: %w", err)
	} else {
		v.Scratch = x
	}
	data = data[encoding.BoolBinarySize(v.Scratch):]

	return nil
}

func (v *DataEntry) UnmarshalBinary(data []byte) error {
	var lenExtIds uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding ExtIds: %w", err)
	} else {
		lenExtIds = x
	}
	data = data[encoding.UvarintBinarySize(lenExtIds):]

	v.ExtIds = make([][]byte, lenExtIds)
	for i := range v.ExtIds {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding ExtIds[%d]: %w", i, err)
		} else {
			v.ExtIds[i] = x
		}
		data = data[encoding.BytesBinarySize(v.ExtIds[i]):]

	}

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	data = data[encoding.BytesBinarySize(v.Data):]

	return nil
}

func (v *DirectoryIndexMetadata) UnmarshalBinary(data []byte) error {
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Count: %w", err)
	} else {
		v.Count = x
	}
	data = data[encoding.UvarintBinarySize(v.Count):]

	return nil
}

func (v *DirectoryQueryResult) UnmarshalBinary(data []byte) error {
	var lenEntries uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entries: %w", err)
	} else {
		lenEntries = x
	}
	data = data[encoding.UvarintBinarySize(lenEntries):]

	v.Entries = make([]string, lenEntries)
	for i := range v.Entries {
		if x, err := encoding.StringUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Entries[%d]: %w", i, err)
		} else {
			v.Entries[i] = x
		}
		data = data[encoding.StringBinarySize(v.Entries[i]):]

	}

	var lenExpandedEntries uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding ExpandedEntries: %w", err)
	} else {
		lenExpandedEntries = x
	}
	data = data[encoding.UvarintBinarySize(lenExpandedEntries):]

	v.ExpandedEntries = make([]*Object, lenExpandedEntries)
	for i := range v.ExpandedEntries {
		var x *Object
		x = new(Object)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding ExpandedEntries[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.ExpandedEntries[i] = x
	}

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Total: %w", err)
	} else {
		v.Total = x
	}
	data = data[encoding.UvarintBinarySize(v.Total):]

	return nil
}

func (v *Envelope) UnmarshalBinary(data []byte) error {
	var lenSignatures uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Signatures: %w", err)
	} else {
		lenSignatures = x
	}
	data = data[encoding.UvarintBinarySize(lenSignatures):]

	v.Signatures = make([]*ED25519Sig, lenSignatures)
	for i := range v.Signatures {
		var x *ED25519Sig
		x = new(ED25519Sig)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Signatures[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.Signatures[i] = x
	}

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TxHash: %w", err)
	} else {
		v.TxHash = x
	}
	data = data[encoding.BytesBinarySize(v.TxHash):]

	v.Transaction = new(Transaction)
	if err := v.Transaction.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	}
	data = data[v.Transaction.BinarySize():]

	return nil
}

func (v *InternalGenesis) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeInternalGenesis
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	return nil
}

func (v *InternalLedger) UnmarshalBinary(data []byte) error {
	typ := AccountTypeInternalLedger
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.VarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Index: %w", err)
	} else {
		v.Index = x
	}
	data = data[encoding.VarintBinarySize(v.Index):]

	if x, err := encoding.TimeUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Timestamp: %w", err)
	} else {
		v.Timestamp = x
	}
	data = data[encoding.TimeBinarySize(v.Timestamp):]

	if err := v.Synthetic.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Synthetic: %w", err)
	}
	data = data[v.Synthetic.BinarySize():]

	var lenUpdates uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Updates: %w", err)
	} else {
		lenUpdates = x
	}
	data = data[encoding.UvarintBinarySize(lenUpdates):]

	v.Updates = make([]AnchorMetadata, lenUpdates)
	for i := range v.Updates {
		if err := v.Updates[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Updates[%d]: %w", i, err)
		}
		data = data[v.Updates[i].BinarySize():]

	}

	return nil
}

func (v *InternalSendTransactions) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeInternalSendTransactions
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	var lenTransactions uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Transactions: %w", err)
	} else {
		lenTransactions = x
	}
	data = data[encoding.UvarintBinarySize(lenTransactions):]

	v.Transactions = make([]SendTransaction, lenTransactions)
	for i := range v.Transactions {
		if err := v.Transactions[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Transactions[%d]: %w", i, err)
		}
		data = data[v.Transactions[i].BinarySize():]

	}

	return nil
}

func (v *InternalTransactionsSent) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeInternalTransactionsSent
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainSetUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Transactions: %w", err)
	} else {
		v.Transactions = x
	}
	data = data[encoding.ChainSetBinarySize(v.Transactions):]

	return nil
}

func (v *InternalTransactionsSigned) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeInternalTransactionsSigned
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	var lenTransactions uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Transactions: %w", err)
	} else {
		lenTransactions = x
	}
	data = data[encoding.UvarintBinarySize(lenTransactions):]

	v.Transactions = make([]TransactionSignature, lenTransactions)
	for i := range v.Transactions {
		if err := v.Transactions[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Transactions[%d]: %w", i, err)
		}
		data = data[v.Transactions[i].BinarySize():]

	}

	return nil
}

func (v *IssueTokens) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeIssueTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Recipient: %w", err)
	} else {
		v.Recipient = x
	}
	data = data[encoding.StringBinarySize(v.Recipient):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Amount):]

	return nil
}

func (v *KeyBook) UnmarshalBinary(data []byte) error {
	typ := AccountTypeKeyBook
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	var lenPages uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Pages: %w", err)
	} else {
		lenPages = x
	}
	data = data[encoding.UvarintBinarySize(lenPages):]

	v.Pages = make([]string, lenPages)
	for i := range v.Pages {
		if x, err := encoding.StringUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Pages[%d]: %w", i, err)
		} else {
			v.Pages[i] = x
		}
		data = data[encoding.StringBinarySize(v.Pages[i]):]

	}

	return nil
}

func (v *KeyPage) UnmarshalBinary(data []byte) error {
	typ := AccountTypeKeyPage
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding CreditBalance: %w", err)
	} else {
		v.CreditBalance.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.CreditBalance):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Threshold: %w", err)
	} else {
		v.Threshold = x
	}
	data = data[encoding.UvarintBinarySize(v.Threshold):]

	var lenKeys uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Keys: %w", err)
	} else {
		lenKeys = x
	}
	data = data[encoding.UvarintBinarySize(lenKeys):]

	v.Keys = make([]*KeySpec, lenKeys)
	for i := range v.Keys {
		var x *KeySpec
		x = new(KeySpec)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Keys[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.Keys[i] = x
	}

	return nil
}

func (v *KeySpec) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	data = data[encoding.BytesBinarySize(v.PublicKey):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Nonce: %w", err)
	} else {
		v.Nonce = x
	}
	data = data[encoding.UvarintBinarySize(v.Nonce):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Owner: %w", err)
	} else {
		v.Owner = x
	}
	data = data[encoding.StringBinarySize(v.Owner):]

	return nil
}

func (v *KeySpecParams) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	data = data[encoding.BytesBinarySize(v.PublicKey):]

	return nil
}

func (v *LiteDataAccount) UnmarshalBinary(data []byte) error {
	typ := AccountTypeLiteDataAccount
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Tail: %w", err)
	} else {
		v.Tail = x
	}
	data = data[encoding.BytesBinarySize(v.Tail):]

	return nil
}

func (v *LiteTokenAccount) UnmarshalBinary(data []byte) error {
	typ := AccountTypeLiteTokenAccount
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TokenUrl: %w", err)
	} else {
		v.TokenUrl = x
	}
	data = data[encoding.StringBinarySize(v.TokenUrl):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Balance):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Nonce: %w", err)
	} else {
		v.Nonce = x
	}
	data = data[encoding.UvarintBinarySize(v.Nonce):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding CreditBalance: %w", err)
	} else {
		v.CreditBalance.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.CreditBalance):]

	return nil
}

func (v *MetricsRequest) UnmarshalBinary(data []byte) error {
	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Metric: %w", err)
	} else {
		v.Metric = x
	}
	data = data[encoding.StringBinarySize(v.Metric):]

	if x, err := encoding.DurationUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Duration: %w", err)
	} else {
		v.Duration = x
	}
	data = data[encoding.DurationBinarySize(v.Duration):]

	return nil
}

func (v *Object) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	data = data[encoding.BytesBinarySize(v.Entry):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Height: %w", err)
	} else {
		v.Height = x
	}
	data = data[encoding.UvarintBinarySize(v.Height):]

	var lenRoots uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Roots: %w", err)
	} else {
		lenRoots = x
	}
	data = data[encoding.UvarintBinarySize(lenRoots):]

	v.Roots = make([][]byte, lenRoots)
	for i := range v.Roots {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Roots[%d]: %w", i, err)
		} else {
			v.Roots[i] = x
		}
		data = data[encoding.BytesBinarySize(v.Roots[i]):]

	}

	return nil
}

func (v *ObjectMetadata) UnmarshalBinary(data []byte) error {
	if err := v.Type.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Type: %w", err)
	}
	data = data[v.Type.BinarySize():]

	var lenChains uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Chains: %w", err)
	} else {
		lenChains = x
	}
	data = data[encoding.UvarintBinarySize(lenChains):]

	v.Chains = make([]ChainMetadata, lenChains)
	for i := range v.Chains {
		if err := v.Chains[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Chains[%d]: %w", i, err)
		}
		data = data[v.Chains[i].BinarySize():]

	}

	return nil
}

func (v *PendingTransactionState) UnmarshalBinary(data []byte) error {
	typ := AccountTypePendingTransaction
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	var lenSignature uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		lenSignature = x
	}
	data = data[encoding.UvarintBinarySize(lenSignature):]

	v.Signature = make([]*ED25519Sig, lenSignature)
	for i := range v.Signature {
		var x *ED25519Sig
		x = new(ED25519Sig)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Signature[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.Signature[i] = x
	}

	v.TransactionState = new(TxState)
	if err := v.TransactionState.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TransactionState: %w", err)
	}
	data = data[v.TransactionState.BinarySize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Status: %w", err)
	} else {
		v.Status = x
	}
	data = data[encoding.BytesBinarySize(v.Status):]

	return nil
}

func (v *Receipt) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Start: %w", err)
	} else {
		v.Start = x
	}
	data = data[encoding.BytesBinarySize(v.Start):]

	var lenEntries uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entries: %w", err)
	} else {
		lenEntries = x
	}
	data = data[encoding.UvarintBinarySize(lenEntries):]

	v.Entries = make([]ReceiptEntry, lenEntries)
	for i := range v.Entries {
		if err := v.Entries[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Entries[%d]: %w", i, err)
		}
		data = data[v.Entries[i].BinarySize():]

	}

	return nil
}

func (v *ReceiptEntry) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Right: %w", err)
	} else {
		v.Right = x
	}
	data = data[encoding.BoolBinarySize(v.Right):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	data = data[encoding.BytesBinarySize(v.Hash):]

	return nil
}

func (v *RemoveManager) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeRemoveManager
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	return nil
}

func (v *RequestDataEntry) UnmarshalBinary(data []byte) error {
	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	data = data[encoding.ChainBinarySize(&v.EntryHash):]

	return nil
}

func (v *RequestDataEntrySet) UnmarshalBinary(data []byte) error {
	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Start: %w", err)
	} else {
		v.Start = x
	}
	data = data[encoding.UvarintBinarySize(v.Start):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Count: %w", err)
	} else {
		v.Count = x
	}
	data = data[encoding.UvarintBinarySize(v.Count):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding ExpandChains: %w", err)
	} else {
		v.ExpandChains = x
	}
	data = data[encoding.BoolBinarySize(v.ExpandChains):]

	return nil
}

func (v *ResponseDataEntry) UnmarshalBinary(data []byte) error {
	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	data = data[encoding.ChainBinarySize(&v.EntryHash):]

	if err := v.Entry.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	}
	data = data[v.Entry.BinarySize():]

	return nil
}

func (v *ResponseDataEntrySet) UnmarshalBinary(data []byte) error {
	var lenDataEntries uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding DataEntries: %w", err)
	} else {
		lenDataEntries = x
	}
	data = data[encoding.UvarintBinarySize(lenDataEntries):]

	v.DataEntries = make([]ResponseDataEntry, lenDataEntries)
	for i := range v.DataEntries {
		if err := v.DataEntries[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding DataEntries[%d]: %w", i, err)
		}
		data = data[v.DataEntries[i].BinarySize():]

	}

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Total: %w", err)
	} else {
		v.Total = x
	}
	data = data[encoding.UvarintBinarySize(v.Total):]

	return nil
}

func (v *SegWitDataEntry) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSegWitDataEntry
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	data = data[encoding.ChainBinarySize(&v.Cause):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding EntryUrl: %w", err)
	} else {
		v.EntryUrl = x
	}
	data = data[encoding.StringBinarySize(v.EntryUrl):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	data = data[encoding.ChainBinarySize(&v.EntryHash):]

	return nil
}

func (v *SendTokens) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSendTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	data = data[encoding.ChainBinarySize(&v.Hash):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Meta: %w", err)
	} else {
		v.Meta = x
	}
	data = data[encoding.BytesBinarySize(v.Meta):]

	var lenTo uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding To: %w", err)
	} else {
		lenTo = x
	}
	data = data[encoding.UvarintBinarySize(lenTo):]

	v.To = make([]*TokenRecipient, lenTo)
	for i := range v.To {
		var x *TokenRecipient
		x = new(TokenRecipient)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding To[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.To[i] = x
	}

	return nil
}

func (v *SendTransaction) UnmarshalBinary(data []byte) error {
	if x, err := UnmarshalTransaction(data); err != nil {
		return fmt.Errorf("error decoding Payload: %w", err)
	} else {
		v.Payload = x
	}
	data = data[v.Payload.BinarySize():]

	v.Recipient = new(url.URL)
	if err := v.Recipient.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Recipient: %w", err)
	}
	data = data[v.Recipient.BinarySize():]

	return nil
}

func (v *SignPending) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSignPending
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	return nil
}

func (v *SyntheticAnchor) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSyntheticAnchor
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Source: %w", err)
	} else {
		v.Source = x
	}
	data = data[encoding.StringBinarySize(v.Source):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Major: %w", err)
	} else {
		v.Major = x
	}
	data = data[encoding.BoolBinarySize(v.Major):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding RootAnchor: %w", err)
	} else {
		v.RootAnchor = x
	}
	data = data[encoding.ChainBinarySize(&v.RootAnchor):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding RootIndex: %w", err)
	} else {
		v.RootIndex = x
	}
	data = data[encoding.UvarintBinarySize(v.RootIndex):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Block: %w", err)
	} else {
		v.Block = x
	}
	data = data[encoding.UvarintBinarySize(v.Block):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SourceIndex: %w", err)
	} else {
		v.SourceIndex = x
	}
	data = data[encoding.UvarintBinarySize(v.SourceIndex):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SourceBlock: %w", err)
	} else {
		v.SourceBlock = x
	}
	data = data[encoding.UvarintBinarySize(v.SourceBlock):]

	if err := v.Receipt.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Receipt: %w", err)
	}
	data = data[v.Receipt.BinarySize():]

	return nil
}

func (v *SyntheticBurnTokens) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSyntheticBurnTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	data = data[encoding.ChainBinarySize(&v.Cause):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Amount):]

	return nil
}

func (v *SyntheticCreateChain) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSyntheticCreateChain
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	data = data[encoding.ChainBinarySize(&v.Cause):]

	var lenChains uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Chains: %w", err)
	} else {
		lenChains = x
	}
	data = data[encoding.UvarintBinarySize(lenChains):]

	v.Chains = make([]ChainParams, lenChains)
	for i := range v.Chains {
		if err := v.Chains[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Chains[%d]: %w", i, err)
		}
		data = data[v.Chains[i].BinarySize():]

	}

	return nil
}

func (v *SyntheticDepositCredits) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSyntheticDepositCredits
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	data = data[encoding.ChainBinarySize(&v.Cause):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = x
	}
	data = data[encoding.UvarintBinarySize(v.Amount):]

	return nil
}

func (v *SyntheticDepositTokens) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSyntheticDepositTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	data = data[encoding.ChainBinarySize(&v.Cause):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Token: %w", err)
	} else {
		v.Token = x
	}
	data = data[encoding.StringBinarySize(v.Token):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Amount):]

	return nil
}

func (v *SyntheticLedger) UnmarshalBinary(data []byte) error {
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Nonce: %w", err)
	} else {
		v.Nonce = x
	}
	data = data[encoding.UvarintBinarySize(v.Nonce):]

	if x, err := encoding.ChainSetUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Produced: %w", err)
	} else {
		v.Produced = x
	}
	data = data[encoding.ChainSetBinarySize(v.Produced):]

	if x, err := encoding.ChainSetUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Unsigned: %w", err)
	} else {
		v.Unsigned = x
	}
	data = data[encoding.ChainSetBinarySize(v.Unsigned):]

	if x, err := encoding.ChainSetUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Unsent: %w", err)
	} else {
		v.Unsent = x
	}
	data = data[encoding.ChainSetBinarySize(v.Unsent):]

	return nil
}

func (v *SyntheticMirror) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSyntheticMirror
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	var lenObjects uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Objects: %w", err)
	} else {
		lenObjects = x
	}
	data = data[encoding.UvarintBinarySize(lenObjects):]

	v.Objects = make([]AnchoredRecord, lenObjects)
	for i := range v.Objects {
		if err := v.Objects[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Objects[%d]: %w", i, err)
		}
		data = data[v.Objects[i].BinarySize():]

	}

	return nil
}

func (v *SyntheticWriteData) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeSyntheticWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	data = data[encoding.ChainBinarySize(&v.Cause):]

	if err := v.Entry.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	}
	data = data[v.Entry.BinarySize():]

	return nil
}

func (v *TokenAccount) UnmarshalBinary(data []byte) error {
	typ := AccountTypeTokenAccount
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TokenUrl: %w", err)
	} else {
		v.TokenUrl = x
	}
	data = data[encoding.StringBinarySize(v.TokenUrl):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Balance):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Scratch: %w", err)
	} else {
		v.Scratch = x
	}
	data = data[encoding.BoolBinarySize(v.Scratch):]

	return nil
}

func (v *TokenIssuer) UnmarshalBinary(data []byte) error {
	typ := AccountTypeTokenIssuer
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Symbol: %w", err)
	} else {
		v.Symbol = x
	}
	data = data[encoding.StringBinarySize(v.Symbol):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Precision: %w", err)
	} else {
		v.Precision = x
	}
	data = data[encoding.UvarintBinarySize(v.Precision):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Properties: %w", err)
	} else {
		v.Properties = x
	}
	data = data[encoding.StringBinarySize(v.Properties):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Supply: %w", err)
	} else {
		v.Supply.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Supply):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding HasSupplyLimit: %w", err)
	} else {
		v.HasSupplyLimit = x
	}
	data = data[encoding.BoolBinarySize(v.HasSupplyLimit):]

	return nil
}

func (v *TokenRecipient) UnmarshalBinary(data []byte) error {
	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Url: %w", err)
	} else {
		v.Url = x
	}
	data = data[encoding.StringBinarySize(v.Url):]

	if x, err := encoding.BigintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount.Set(x)
	}
	data = data[encoding.BigintBinarySize(&v.Amount):]

	return nil
}

func (v *Transaction) UnmarshalBinary(data []byte) error {
	if err := v.TransactionHeader.UnmarshalBinary(data); err != nil {
		return err
	}
	data = data[v.TransactionHeader.BinarySize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Body: %w", err)
	} else {
		v.Body = x
	}
	data = data[encoding.BytesBinarySize(v.Body):]

	return nil
}

func (v *TransactionHeader) UnmarshalBinary(data []byte) error {
	v.Origin = new(url.URL)
	if err := v.Origin.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Origin: %w", err)
	}
	data = data[v.Origin.BinarySize():]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyPageHeight: %w", err)
	} else {
		v.KeyPageHeight = x
	}
	data = data[encoding.UvarintBinarySize(v.KeyPageHeight):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding KeyPageIndex: %w", err)
	} else {
		v.KeyPageIndex = x
	}
	data = data[encoding.UvarintBinarySize(v.KeyPageIndex):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Nonce: %w", err)
	} else {
		v.Nonce = x
	}
	data = data[encoding.UvarintBinarySize(v.Nonce):]

	return nil
}

func (v *TransactionSignature) UnmarshalBinary(data []byte) error {
	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	data = data[encoding.ChainBinarySize(&v.Transaction):]

	v.Signature = new(ED25519Sig)
	if err := v.Signature.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	}
	data = data[v.Signature.BinarySize():]

	return nil
}

func (v *TransactionState) UnmarshalBinary(data []byte) error {
	typ := AccountTypeTransaction
	if err := v.AccountHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if err := v.TxState.UnmarshalBinary(data); err != nil {
		return err
	}
	data = data[v.TxState.BinarySize():]

	return nil
}

func (v *TransactionStatus) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Remote: %w", err)
	} else {
		v.Remote = x
	}
	data = data[encoding.BoolBinarySize(v.Remote):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Delivered: %w", err)
	} else {
		v.Delivered = x
	}
	data = data[encoding.BoolBinarySize(v.Delivered):]

	if x, err := encoding.BoolUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Pending: %w", err)
	} else {
		v.Pending = x
	}
	data = data[encoding.BoolBinarySize(v.Pending):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Code: %w", err)
	} else {
		v.Code = x
	}
	data = data[encoding.UvarintBinarySize(v.Code):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Message: %w", err)
	} else {
		v.Message = x
	}
	data = data[encoding.StringBinarySize(v.Message):]

	if x, err := UnmarshalTransactionResult(data); err != nil {
		return fmt.Errorf("error decoding Result: %w", err)
	} else {
		v.Result = x
	}
	data = data[v.Result.BinarySize():]

	return nil
}

func (v *TxState) UnmarshalBinary(data []byte) error {
	v.SigInfo = new(TransactionHeader)
	if err := v.SigInfo.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SigInfo: %w", err)
	}
	data = data[v.SigInfo.BinarySize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	data = data[encoding.BytesBinarySize(v.Transaction):]

	return nil
}

func (v *UpdateKeyPage) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeUpdateKeyPage
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if err := v.Operation.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Operation: %w", err)
	}
	data = data[v.Operation.BinarySize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	data = data[encoding.BytesBinarySize(v.Key):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding NewKey: %w", err)
	} else {
		v.NewKey = x
	}
	data = data[encoding.BytesBinarySize(v.NewKey):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Owner: %w", err)
	} else {
		v.Owner = x
	}
	data = data[encoding.StringBinarySize(v.Owner):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Threshold: %w", err)
	} else {
		v.Threshold = x
	}
	data = data[encoding.UvarintBinarySize(v.Threshold):]

	return nil
}

func (v *WriteData) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if err := v.Entry.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	}
	data = data[v.Entry.BinarySize():]

	return nil
}

func (v *WriteDataResult) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	data = data[encoding.ChainBinarySize(&v.EntryHash):]

	v.AccountUrl = new(url.URL)
	if err := v.AccountUrl.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding AccountUrl: %w", err)
	}
	data = data[v.AccountUrl.BinarySize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding AccountID: %w", err)
	} else {
		v.AccountID = x
	}
	data = data[encoding.BytesBinarySize(v.AccountID):]

	return nil
}

func (v *WriteDataTo) UnmarshalBinary(data []byte) error {
	typ := TransactionTypeWriteDataTo
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]

	if x, err := encoding.StringUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Recipient: %w", err)
	} else {
		v.Recipient = x
	}
	data = data[encoding.StringBinarySize(v.Recipient):]

	if err := v.Entry.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	}
	data = data[v.Entry.BinarySize():]

	return nil
}

func (v *AnchorMetadata) MarshalJSON() ([]byte, error) {
	u := struct {
		Name        string    `json:"name,omitempty"`
		Type        ChainType `json:"type,omitempty"`
		Account     *url.URL  `json:"account,omitempty"`
		Index       uint64    `json:"index,omitempty"`
		SourceIndex uint64    `json:"sourceIndex,omitempty"`
		SourceBlock uint64    `json:"sourceBlock,omitempty"`
		Entry       *string   `json:"entry,omitempty"`
	}{}
	u.Name = v.ChainMetadata.Name
	u.Type = v.ChainMetadata.Type
	u.Account = v.Account
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesToJSON(v.Entry)
	return json.Marshal(&u)
}

func (v *AnchoredRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		Record *string `json:"record,omitempty"`
		Anchor string  `json:"anchor,omitempty"`
	}{}
	u.Record = encoding.BytesToJSON(v.Record)
	u.Anchor = encoding.ChainToJSON(v.Anchor)
	return json.Marshal(&u)
}

func (v *BurnTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Amount *string `json:"amount,omitempty"`
	}{}
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *ChainParams) MarshalJSON() ([]byte, error) {
	u := struct {
		Data     *string `json:"data,omitempty"`
		IsUpdate bool    `json:"isUpdate,omitempty"`
	}{}
	u.Data = encoding.BytesToJSON(v.Data)
	u.IsUpdate = v.IsUpdate
	return json.Marshal(&u)
}

func (v *CreateIdentity) MarshalJSON() ([]byte, error) {
	u := struct {
		Url         string  `json:"url,omitempty"`
		PublicKey   *string `json:"publicKey,omitempty"`
		KeyBookName string  `json:"keyBookName,omitempty"`
		KeyPageName string  `json:"keyPageName,omitempty"`
		Manager     string  `json:"manager,omitempty"`
	}{}
	u.Url = v.Url
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.KeyBookName = v.KeyBookName
	u.KeyPageName = v.KeyPageName
	u.Manager = v.Manager
	return json.Marshal(&u)
}

func (v *CreateToken) MarshalJSON() ([]byte, error) {
	u := struct {
		Url            string  `json:"url,omitempty"`
		KeyBookUrl     string  `json:"keyBookUrl,omitempty"`
		Symbol         string  `json:"symbol,omitempty"`
		Precision      uint64  `json:"precision,omitempty"`
		Properties     string  `json:"properties,omitempty"`
		InitialSupply  *string `json:"initialSupply,omitempty"`
		HasSupplyLimit bool    `json:"hasSupplyLimit,omitempty"`
		Manager        string  `json:"manager,omitempty"`
	}{}
	u.Url = v.Url
	u.KeyBookUrl = v.KeyBookUrl
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.InitialSupply = encoding.BigintToJSON(&v.InitialSupply)
	u.HasSupplyLimit = v.HasSupplyLimit
	u.Manager = v.Manager
	return json.Marshal(&u)
}

func (v *DataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		ExtIds []*string `json:"extIds,omitempty"`
		Data   *string   `json:"data,omitempty"`
	}{}
	u.ExtIds = make([]*string, len(v.ExtIds))
	for i, x := range v.ExtIds {
		u.ExtIds[i] = encoding.BytesToJSON(x)
	}
	u.Data = encoding.BytesToJSON(v.Data)
	return json.Marshal(&u)
}

func (v *Envelope) MarshalJSON() ([]byte, error) {
	u := struct {
		Signatures  []*ED25519Sig `json:"signatures,omitempty"`
		TxHash      *string       `json:"txHash,omitempty"`
		Transaction *Transaction  `json:"transaction,omitempty"`
	}{}
	u.Signatures = v.Signatures
	u.TxHash = encoding.BytesToJSON(v.TxHash)
	u.Transaction = v.Transaction
	return json.Marshal(&u)
}

func (v *InternalTransactionsSent) MarshalJSON() ([]byte, error) {
	u := struct {
		Transactions []string `json:"transactions,omitempty"`
	}{}
	u.Transactions = encoding.ChainSetToJSON(v.Transactions)
	return json.Marshal(&u)
}

func (v *IssueTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Recipient string  `json:"recipient,omitempty"`
		Amount    *string `json:"amount,omitempty"`
	}{}
	u.Recipient = v.Recipient
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *KeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		AccountHeader
		CreditBalance *string    `json:"creditBalance,omitempty"`
		Threshold     uint64     `json:"threshold,omitempty"`
		Keys          []*KeySpec `json:"keys,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.CreditBalance = encoding.BigintToJSON(&v.CreditBalance)
	u.Threshold = v.Threshold
	u.Keys = v.Keys
	return json.Marshal(&u)
}

func (v *KeySpec) MarshalJSON() ([]byte, error) {
	u := struct {
		PublicKey *string `json:"publicKey,omitempty"`
		Nonce     uint64  `json:"nonce,omitempty"`
		Owner     string  `json:"owner,omitempty"`
	}{}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Nonce = v.Nonce
	u.Owner = v.Owner
	return json.Marshal(&u)
}

func (v *KeySpecParams) MarshalJSON() ([]byte, error) {
	u := struct {
		PublicKey *string `json:"publicKey,omitempty"`
	}{}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	return json.Marshal(&u)
}

func (v *LiteDataAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		AccountHeader
		Tail *string `json:"tail,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.Tail = encoding.BytesToJSON(v.Tail)
	return json.Marshal(&u)
}

func (v *LiteTokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		AccountHeader
		TokenUrl      string  `json:"tokenUrl,omitempty"`
		Balance       *string `json:"balance,omitempty"`
		Nonce         uint64  `json:"nonce,omitempty"`
		CreditBalance *string `json:"creditBalance,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.Nonce = v.Nonce
	u.CreditBalance = encoding.BigintToJSON(&v.CreditBalance)
	return json.Marshal(&u)
}

func (v *MetricsRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	return json.Marshal(&u)
}

func (v *MetricsResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	u.Value = encoding.AnyToJSON(v.Value)
	return json.Marshal(&u)
}

func (v *Object) MarshalJSON() ([]byte, error) {
	u := struct {
		Entry  *string   `json:"entry,omitempty"`
		Height uint64    `json:"height,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Height = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *Receipt) MarshalJSON() ([]byte, error) {
	u := struct {
		Start   *string        `json:"start,omitempty"`
		Entries []ReceiptEntry `json:"entries,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Start)
	u.Entries = v.Entries
	return json.Marshal(&u)
}

func (v *ReceiptEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Right bool    `json:"right,omitempty"`
		Hash  *string `json:"hash,omitempty"`
	}{}
	u.Right = v.Right
	u.Hash = encoding.BytesToJSON(v.Hash)
	return json.Marshal(&u)
}

func (v *RequestDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Url       string `json:"url,omitempty"`
		EntryHash string `json:"entryHash,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}

func (v *ResponseDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		EntryHash string    `json:"entryHash,omitempty"`
		Entry     DataEntry `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *SegWitDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Cause     string `json:"cause,omitempty"`
		EntryUrl  string `json:"entryUrl,omitempty"`
		EntryHash string `json:"entryHash,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.EntryUrl = v.EntryUrl
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}

func (v *SendTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Hash string            `json:"hash,omitempty"`
		Meta json.RawMessage   `json:"meta,omitempty"`
		To   []*TokenRecipient `json:"to,omitempty"`
	}{}
	u.Hash = encoding.ChainToJSON(v.Hash)
	u.Meta = v.Meta
	u.To = v.To
	return json.Marshal(&u)
}

func (v *SendTransaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Payload   json.RawMessage `json:"payload,omitempty"`
		Recipient *url.URL        `json:"recipient,omitempty"`
	}{}
	if x, err := json.Marshal(v.Payload); err != nil {
		return nil, fmt.Errorf("error encoding Payload: %w", err)
	} else {
		u.Payload = x
	}

	u.Recipient = v.Recipient
	return json.Marshal(&u)
}

func (v *SyntheticAnchor) MarshalJSON() ([]byte, error) {
	u := struct {
		Source      string  `json:"source,omitempty"`
		Major       bool    `json:"major,omitempty"`
		RootAnchor  string  `json:"rootAnchor,omitempty"`
		RootIndex   uint64  `json:"rootIndex,omitempty"`
		Block       uint64  `json:"block,omitempty"`
		SourceIndex uint64  `json:"sourceIndex,omitempty"`
		SourceBlock uint64  `json:"sourceBlock,omitempty"`
		Receipt     Receipt `json:"receipt,omitempty"`
	}{}
	u.Source = v.Source
	u.Major = v.Major
	u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
	u.RootIndex = v.RootIndex
	u.Block = v.Block
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *SyntheticBurnTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Cause  string  `json:"cause,omitempty"`
		Amount *string `json:"amount,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *SyntheticCreateChain) MarshalJSON() ([]byte, error) {
	u := struct {
		Cause  string        `json:"cause,omitempty"`
		Chains []ChainParams `json:"chains,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Chains = v.Chains
	return json.Marshal(&u)
}

func (v *SyntheticDepositCredits) MarshalJSON() ([]byte, error) {
	u := struct {
		Cause  string `json:"cause,omitempty"`
		Amount uint64 `json:"amount,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Amount = v.Amount
	return json.Marshal(&u)
}

func (v *SyntheticDepositTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Cause  string  `json:"cause,omitempty"`
		Token  string  `json:"token,omitempty"`
		Amount *string `json:"amount,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Token = v.Token
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *SyntheticLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Nonce    uint64   `json:"nonce,omitempty"`
		Produced []string `json:"produced,omitempty"`
		Unsigned []string `json:"unsigned,omitempty"`
		Unsent   []string `json:"unsent,omitempty"`
	}{}
	u.Nonce = v.Nonce
	u.Produced = encoding.ChainSetToJSON(v.Produced)
	u.Unsigned = encoding.ChainSetToJSON(v.Unsigned)
	u.Unsent = encoding.ChainSetToJSON(v.Unsent)
	return json.Marshal(&u)
}

func (v *SyntheticWriteData) MarshalJSON() ([]byte, error) {
	u := struct {
		Cause string    `json:"cause,omitempty"`
		Entry DataEntry `json:"entry,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *TokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		AccountHeader
		TokenUrl string  `json:"tokenUrl,omitempty"`
		Balance  *string `json:"balance,omitempty"`
		Scratch  bool    `json:"scratch,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.Scratch = v.Scratch
	return json.Marshal(&u)
}

func (v *TokenIssuer) MarshalJSON() ([]byte, error) {
	u := struct {
		AccountHeader
		Symbol         string  `json:"symbol,omitempty"`
		Precision      uint64  `json:"precision,omitempty"`
		Properties     string  `json:"properties,omitempty"`
		Supply         *string `json:"supply,omitempty"`
		HasSupplyLimit bool    `json:"hasSupplyLimit,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.Supply = encoding.BigintToJSON(&v.Supply)
	u.HasSupplyLimit = v.HasSupplyLimit
	return json.Marshal(&u)
}

func (v *TokenRecipient) MarshalJSON() ([]byte, error) {
	u := struct {
		Url    string  `json:"url,omitempty"`
		Amount *string `json:"amount,omitempty"`
	}{}
	u.Url = v.Url
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *Transaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Origin        *url.URL `json:"origin,omitempty"`
		KeyPageHeight uint64   `json:"keyPageHeight,omitempty"`
		KeyPageIndex  uint64   `json:"keyPageIndex,omitempty"`
		Nonce         uint64   `json:"nonce,omitempty"`
		Body          *string  `json:"body,omitempty"`
	}{}
	u.Origin = v.TransactionHeader.Origin
	u.KeyPageHeight = v.TransactionHeader.KeyPageHeight
	u.KeyPageIndex = v.TransactionHeader.KeyPageIndex
	u.Nonce = v.TransactionHeader.Nonce
	u.Body = encoding.BytesToJSON(v.Body)
	return json.Marshal(&u)
}

func (v *TransactionSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Transaction string      `json:"transaction,omitempty"`
		Signature   *ED25519Sig `json:"signature,omitempty"`
	}{}
	u.Transaction = encoding.ChainToJSON(v.Transaction)
	u.Signature = v.Signature
	return json.Marshal(&u)
}

func (v *TransactionState) MarshalJSON() ([]byte, error) {
	u := struct {
		AccountHeader
		SigInfo     *TransactionHeader `json:"sigInfo,omitempty"`
		Transaction *string            `json:"transaction,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.SigInfo = v.TxState.SigInfo
	u.Transaction = encoding.BytesToJSON(v.TxState.Transaction)
	return json.Marshal(&u)
}

func (v *TransactionStatus) MarshalJSON() ([]byte, error) {
	u := struct {
		Remote    bool            `json:"remote,omitempty"`
		Delivered bool            `json:"delivered,omitempty"`
		Pending   bool            `json:"pending,omitempty"`
		Code      uint64          `json:"code,omitempty"`
		Message   string          `json:"message,omitempty"`
		Result    json.RawMessage `json:"result,omitempty"`
	}{}
	u.Remote = v.Remote
	u.Delivered = v.Delivered
	u.Pending = v.Pending
	u.Code = v.Code
	u.Message = v.Message
	if x, err := json.Marshal(v.Result); err != nil {
		return nil, fmt.Errorf("error encoding Result: %w", err)
	} else {
		u.Result = x
	}

	return json.Marshal(&u)
}

func (v *TxState) MarshalJSON() ([]byte, error) {
	u := struct {
		SigInfo     *TransactionHeader `json:"sigInfo,omitempty"`
		Transaction *string            `json:"transaction,omitempty"`
	}{}
	u.SigInfo = v.SigInfo
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	return json.Marshal(&u)
}

func (v *UpdateKeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		Operation KeyPageOperation `json:"operation,omitempty"`
		Key       *string          `json:"key,omitempty"`
		NewKey    *string          `json:"newKey,omitempty"`
		Owner     string           `json:"owner,omitempty"`
		Threshold uint64           `json:"threshold,omitempty"`
	}{}
	u.Operation = v.Operation
	u.Key = encoding.BytesToJSON(v.Key)
	u.NewKey = encoding.BytesToJSON(v.NewKey)
	u.Owner = v.Owner
	u.Threshold = v.Threshold
	return json.Marshal(&u)
}

func (v *WriteDataResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType `json:"type"`
		EntryHash  string          `json:"entryHash,omitempty"`
		AccountUrl *url.URL        `json:"accountUrl,omitempty"`
		AccountID  *string         `json:"accountID,omitempty"`
	}{}
	u.Type = v.GetType()
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.AccountUrl = v.AccountUrl
	u.AccountID = encoding.BytesToJSON(v.AccountID)
	return json.Marshal(&u)
}

func (v *AnchorMetadata) UnmarshalJSON(data []byte) error {
	u := struct {
		Name        string    `json:"name,omitempty"`
		Type        ChainType `json:"type,omitempty"`
		Account     *url.URL  `json:"account,omitempty"`
		Index       uint64    `json:"index,omitempty"`
		SourceIndex uint64    `json:"sourceIndex,omitempty"`
		SourceBlock uint64    `json:"sourceBlock,omitempty"`
		Entry       *string   `json:"entry,omitempty"`
	}{}
	u.Name = v.ChainMetadata.Name
	u.Type = v.ChainMetadata.Type
	u.Account = v.Account
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesToJSON(v.Entry)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ChainMetadata.Name = u.Name
	v.ChainMetadata.Type = u.Type
	v.Account = u.Account
	v.Index = u.Index
	v.SourceIndex = u.SourceIndex
	v.SourceBlock = u.SourceBlock
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	return nil
}

func (v *AnchoredRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		Record *string `json:"record,omitempty"`
		Anchor string  `json:"anchor,omitempty"`
	}{}
	u.Record = encoding.BytesToJSON(v.Record)
	u.Anchor = encoding.ChainToJSON(v.Anchor)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Record); err != nil {
		return fmt.Errorf("error decoding Record: %w", err)
	} else {
		v.Record = x
	}
	if x, err := encoding.ChainFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Anchor = x
	}
	return nil
}

func (v *BurnTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Amount *string `json:"amount,omitempty"`
	}{}
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *ChainParams) UnmarshalJSON(data []byte) error {
	u := struct {
		Data     *string `json:"data,omitempty"`
		IsUpdate bool    `json:"isUpdate,omitempty"`
	}{}
	u.Data = encoding.BytesToJSON(v.Data)
	u.IsUpdate = v.IsUpdate
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	v.IsUpdate = u.IsUpdate
	return nil
}

func (v *CreateIdentity) UnmarshalJSON(data []byte) error {
	u := struct {
		Url         string  `json:"url,omitempty"`
		PublicKey   *string `json:"publicKey,omitempty"`
		KeyBookName string  `json:"keyBookName,omitempty"`
		KeyPageName string  `json:"keyPageName,omitempty"`
		Manager     string  `json:"manager,omitempty"`
	}{}
	u.Url = v.Url
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.KeyBookName = v.KeyBookName
	u.KeyPageName = v.KeyPageName
	u.Manager = v.Manager
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	v.KeyBookName = u.KeyBookName
	v.KeyPageName = u.KeyPageName
	v.Manager = u.Manager
	return nil
}

func (v *CreateToken) UnmarshalJSON(data []byte) error {
	u := struct {
		Url            string  `json:"url,omitempty"`
		KeyBookUrl     string  `json:"keyBookUrl,omitempty"`
		Symbol         string  `json:"symbol,omitempty"`
		Precision      uint64  `json:"precision,omitempty"`
		Properties     string  `json:"properties,omitempty"`
		InitialSupply  *string `json:"initialSupply,omitempty"`
		HasSupplyLimit bool    `json:"hasSupplyLimit,omitempty"`
		Manager        string  `json:"manager,omitempty"`
	}{}
	u.Url = v.Url
	u.KeyBookUrl = v.KeyBookUrl
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.InitialSupply = encoding.BigintToJSON(&v.InitialSupply)
	u.HasSupplyLimit = v.HasSupplyLimit
	u.Manager = v.Manager
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	v.KeyBookUrl = u.KeyBookUrl
	v.Symbol = u.Symbol
	v.Precision = u.Precision
	v.Properties = u.Properties
	if x, err := encoding.BigintFromJSON(u.InitialSupply); err != nil {
		return fmt.Errorf("error decoding InitialSupply: %w", err)
	} else {
		v.InitialSupply = *x
	}
	v.HasSupplyLimit = u.HasSupplyLimit
	v.Manager = u.Manager
	return nil
}

func (v *DataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		ExtIds []*string `json:"extIds,omitempty"`
		Data   *string   `json:"data,omitempty"`
	}{}
	u.ExtIds = make([]*string, len(v.ExtIds))
	for i, x := range v.ExtIds {
		u.ExtIds[i] = encoding.BytesToJSON(x)
	}
	u.Data = encoding.BytesToJSON(v.Data)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ExtIds = make([][]byte, len(u.ExtIds))
	for i, x := range u.ExtIds {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding ExtIds[%d]: %w", i, err)
		} else {
			v.ExtIds[i] = x
		}
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	return nil
}

func (v *Envelope) UnmarshalJSON(data []byte) error {
	u := struct {
		Signatures  []*ED25519Sig `json:"signatures,omitempty"`
		TxHash      *string       `json:"txHash,omitempty"`
		Transaction *Transaction  `json:"transaction,omitempty"`
	}{}
	u.Signatures = v.Signatures
	u.TxHash = encoding.BytesToJSON(v.TxHash)
	u.Transaction = v.Transaction
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Signatures = u.Signatures
	if x, err := encoding.BytesFromJSON(u.TxHash); err != nil {
		return fmt.Errorf("error decoding TxHash: %w", err)
	} else {
		v.TxHash = x
	}
	v.Transaction = u.Transaction
	return nil
}

func (v *InternalTransactionsSent) UnmarshalJSON(data []byte) error {
	u := struct {
		Transactions []string `json:"transactions,omitempty"`
	}{}
	u.Transactions = encoding.ChainSetToJSON(v.Transactions)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainSetFromJSON(u.Transactions); err != nil {
		return fmt.Errorf("error decoding Transactions: %w", err)
	} else {
		v.Transactions = x
	}
	return nil
}

func (v *IssueTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Recipient string  `json:"recipient,omitempty"`
		Amount    *string `json:"amount,omitempty"`
	}{}
	u.Recipient = v.Recipient
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Recipient = u.Recipient
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *KeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		AccountHeader
		CreditBalance *string    `json:"creditBalance,omitempty"`
		Threshold     uint64     `json:"threshold,omitempty"`
		Keys          []*KeySpec `json:"keys,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.CreditBalance = encoding.BigintToJSON(&v.CreditBalance)
	u.Threshold = v.Threshold
	u.Keys = v.Keys
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.AccountHeader = u.AccountHeader
	if x, err := encoding.BigintFromJSON(u.CreditBalance); err != nil {
		return fmt.Errorf("error decoding CreditBalance: %w", err)
	} else {
		v.CreditBalance = *x
	}
	v.Threshold = u.Threshold
	v.Keys = u.Keys
	return nil
}

func (v *KeySpec) UnmarshalJSON(data []byte) error {
	u := struct {
		PublicKey *string `json:"publicKey,omitempty"`
		Nonce     uint64  `json:"nonce,omitempty"`
		Owner     string  `json:"owner,omitempty"`
	}{}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Nonce = v.Nonce
	u.Owner = v.Owner
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	v.Nonce = u.Nonce
	v.Owner = u.Owner
	return nil
}

func (v *KeySpecParams) UnmarshalJSON(data []byte) error {
	u := struct {
		PublicKey *string `json:"publicKey,omitempty"`
	}{}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	return nil
}

func (v *LiteDataAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		AccountHeader
		Tail *string `json:"tail,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.Tail = encoding.BytesToJSON(v.Tail)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.AccountHeader = u.AccountHeader
	if x, err := encoding.BytesFromJSON(u.Tail); err != nil {
		return fmt.Errorf("error decoding Tail: %w", err)
	} else {
		v.Tail = x
	}
	return nil
}

func (v *LiteTokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		AccountHeader
		TokenUrl      string  `json:"tokenUrl,omitempty"`
		Balance       *string `json:"balance,omitempty"`
		Nonce         uint64  `json:"nonce,omitempty"`
		CreditBalance *string `json:"creditBalance,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.Nonce = v.Nonce
	u.CreditBalance = encoding.BigintToJSON(&v.CreditBalance)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.AccountHeader = u.AccountHeader
	v.TokenUrl = u.TokenUrl
	if x, err := encoding.BigintFromJSON(u.Balance); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance = *x
	}
	v.Nonce = u.Nonce
	if x, err := encoding.BigintFromJSON(u.CreditBalance); err != nil {
		return fmt.Errorf("error decoding CreditBalance: %w", err)
	} else {
		v.CreditBalance = *x
	}
	return nil
}

func (v *MetricsRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Metric = u.Metric
	if x, err := encoding.DurationFromJSON(u.Duration); err != nil {
		return fmt.Errorf("error decoding Duration: %w", err)
	} else {
		v.Duration = x
	}
	return nil
}

func (v *MetricsResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	u.Value = encoding.AnyToJSON(v.Value)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Value = encoding.AnyFromJSON(u.Value)

	return nil
}

func (v *Object) UnmarshalJSON(data []byte) error {
	u := struct {
		Entry  *string   `json:"entry,omitempty"`
		Height uint64    `json:"height,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Height = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.Height = u.Height
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots[%d]: %w", i, err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}

func (v *Receipt) UnmarshalJSON(data []byte) error {
	u := struct {
		Start   *string        `json:"start,omitempty"`
		Entries []ReceiptEntry `json:"entries,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Start)
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Start); err != nil {
		return fmt.Errorf("error decoding Start: %w", err)
	} else {
		v.Start = x
	}
	v.Entries = u.Entries
	return nil
}

func (v *ReceiptEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Right bool    `json:"right,omitempty"`
		Hash  *string `json:"hash,omitempty"`
	}{}
	u.Right = v.Right
	u.Hash = encoding.BytesToJSON(v.Hash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Right = u.Right
	if x, err := encoding.BytesFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	return nil
}

func (v *RequestDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Url       string `json:"url,omitempty"`
		EntryHash string `json:"entryHash,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}

func (v *ResponseDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		EntryHash string    `json:"entryHash,omitempty"`
		Entry     DataEntry `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	v.Entry = u.Entry
	return nil
}

func (v *SegWitDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Cause     string `json:"cause,omitempty"`
		EntryUrl  string `json:"entryUrl,omitempty"`
		EntryHash string `json:"entryHash,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.EntryUrl = v.EntryUrl
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	v.EntryUrl = u.EntryUrl
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}

func (v *SendTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Hash string            `json:"hash,omitempty"`
		Meta json.RawMessage   `json:"meta,omitempty"`
		To   []*TokenRecipient `json:"to,omitempty"`
	}{}
	u.Hash = encoding.ChainToJSON(v.Hash)
	u.Meta = v.Meta
	u.To = v.To
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	v.Meta = u.Meta
	v.To = u.To
	return nil
}

func (v *SendTransaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Payload   json.RawMessage `json:"payload,omitempty"`
		Recipient *url.URL        `json:"recipient,omitempty"`
	}{}
	if x, err := json.Marshal(v.Payload); err != nil {
		return fmt.Errorf("error encoding Payload: %w", err)
	} else {
		u.Payload = x
	}

	u.Recipient = v.Recipient
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := UnmarshalTransactionJSON(u.Payload); err != nil {
		return fmt.Errorf("error decoding Payload: %w", err)
	} else {
		v.Payload = x
	}

	v.Recipient = u.Recipient
	return nil
}

func (v *SyntheticAnchor) UnmarshalJSON(data []byte) error {
	u := struct {
		Source      string  `json:"source,omitempty"`
		Major       bool    `json:"major,omitempty"`
		RootAnchor  string  `json:"rootAnchor,omitempty"`
		RootIndex   uint64  `json:"rootIndex,omitempty"`
		Block       uint64  `json:"block,omitempty"`
		SourceIndex uint64  `json:"sourceIndex,omitempty"`
		SourceBlock uint64  `json:"sourceBlock,omitempty"`
		Receipt     Receipt `json:"receipt,omitempty"`
	}{}
	u.Source = v.Source
	u.Major = v.Major
	u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
	u.RootIndex = v.RootIndex
	u.Block = v.Block
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Source = u.Source
	v.Major = u.Major
	if x, err := encoding.ChainFromJSON(u.RootAnchor); err != nil {
		return fmt.Errorf("error decoding RootAnchor: %w", err)
	} else {
		v.RootAnchor = x
	}
	v.RootIndex = u.RootIndex
	v.Block = u.Block
	v.SourceIndex = u.SourceIndex
	v.SourceBlock = u.SourceBlock
	v.Receipt = u.Receipt
	return nil
}

func (v *SyntheticBurnTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Cause  string  `json:"cause,omitempty"`
		Amount *string `json:"amount,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *SyntheticCreateChain) UnmarshalJSON(data []byte) error {
	u := struct {
		Cause  string        `json:"cause,omitempty"`
		Chains []ChainParams `json:"chains,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Chains = v.Chains
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	v.Chains = u.Chains
	return nil
}

func (v *SyntheticDepositCredits) UnmarshalJSON(data []byte) error {
	u := struct {
		Cause  string `json:"cause,omitempty"`
		Amount uint64 `json:"amount,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Amount = v.Amount
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	v.Amount = u.Amount
	return nil
}

func (v *SyntheticDepositTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Cause  string  `json:"cause,omitempty"`
		Token  string  `json:"token,omitempty"`
		Amount *string `json:"amount,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Token = v.Token
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	v.Token = u.Token
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *SyntheticLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Nonce    uint64   `json:"nonce,omitempty"`
		Produced []string `json:"produced,omitempty"`
		Unsigned []string `json:"unsigned,omitempty"`
		Unsent   []string `json:"unsent,omitempty"`
	}{}
	u.Nonce = v.Nonce
	u.Produced = encoding.ChainSetToJSON(v.Produced)
	u.Unsigned = encoding.ChainSetToJSON(v.Unsigned)
	u.Unsent = encoding.ChainSetToJSON(v.Unsent)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Nonce = u.Nonce
	if x, err := encoding.ChainSetFromJSON(u.Produced); err != nil {
		return fmt.Errorf("error decoding Produced: %w", err)
	} else {
		v.Produced = x
	}
	if x, err := encoding.ChainSetFromJSON(u.Unsigned); err != nil {
		return fmt.Errorf("error decoding Unsigned: %w", err)
	} else {
		v.Unsigned = x
	}
	if x, err := encoding.ChainSetFromJSON(u.Unsent); err != nil {
		return fmt.Errorf("error decoding Unsent: %w", err)
	} else {
		v.Unsent = x
	}
	return nil
}

func (v *SyntheticWriteData) UnmarshalJSON(data []byte) error {
	u := struct {
		Cause string    `json:"cause,omitempty"`
		Entry DataEntry `json:"entry,omitempty"`
	}{}
	u.Cause = encoding.ChainToJSON(v.Cause)
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	v.Entry = u.Entry
	return nil
}

func (v *TokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		AccountHeader
		TokenUrl string  `json:"tokenUrl,omitempty"`
		Balance  *string `json:"balance,omitempty"`
		Scratch  bool    `json:"scratch,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.Scratch = v.Scratch
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.AccountHeader = u.AccountHeader
	v.TokenUrl = u.TokenUrl
	if x, err := encoding.BigintFromJSON(u.Balance); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance = *x
	}
	v.Scratch = u.Scratch
	return nil
}

func (v *TokenIssuer) UnmarshalJSON(data []byte) error {
	u := struct {
		AccountHeader
		Symbol         string  `json:"symbol,omitempty"`
		Precision      uint64  `json:"precision,omitempty"`
		Properties     string  `json:"properties,omitempty"`
		Supply         *string `json:"supply,omitempty"`
		HasSupplyLimit bool    `json:"hasSupplyLimit,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.Supply = encoding.BigintToJSON(&v.Supply)
	u.HasSupplyLimit = v.HasSupplyLimit
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.AccountHeader = u.AccountHeader
	v.Symbol = u.Symbol
	v.Precision = u.Precision
	v.Properties = u.Properties
	if x, err := encoding.BigintFromJSON(u.Supply); err != nil {
		return fmt.Errorf("error decoding Supply: %w", err)
	} else {
		v.Supply = *x
	}
	v.HasSupplyLimit = u.HasSupplyLimit
	return nil
}

func (v *TokenRecipient) UnmarshalJSON(data []byte) error {
	u := struct {
		Url    string  `json:"url,omitempty"`
		Amount *string `json:"amount,omitempty"`
	}{}
	u.Url = v.Url
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *Transaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Origin        *url.URL `json:"origin,omitempty"`
		KeyPageHeight uint64   `json:"keyPageHeight,omitempty"`
		KeyPageIndex  uint64   `json:"keyPageIndex,omitempty"`
		Nonce         uint64   `json:"nonce,omitempty"`
		Body          *string  `json:"body,omitempty"`
	}{}
	u.Origin = v.TransactionHeader.Origin
	u.KeyPageHeight = v.TransactionHeader.KeyPageHeight
	u.KeyPageIndex = v.TransactionHeader.KeyPageIndex
	u.Nonce = v.TransactionHeader.Nonce
	u.Body = encoding.BytesToJSON(v.Body)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.TransactionHeader.Origin = u.Origin
	v.TransactionHeader.KeyPageHeight = u.KeyPageHeight
	v.TransactionHeader.KeyPageIndex = u.KeyPageIndex
	v.TransactionHeader.Nonce = u.Nonce
	if x, err := encoding.BytesFromJSON(u.Body); err != nil {
		return fmt.Errorf("error decoding Body: %w", err)
	} else {
		v.Body = x
	}
	return nil
}

func (v *TransactionSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Transaction string      `json:"transaction,omitempty"`
		Signature   *ED25519Sig `json:"signature,omitempty"`
	}{}
	u.Transaction = encoding.ChainToJSON(v.Transaction)
	u.Signature = v.Signature
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Transaction); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	v.Signature = u.Signature
	return nil
}

func (v *TransactionState) UnmarshalJSON(data []byte) error {
	u := struct {
		AccountHeader
		SigInfo     *TransactionHeader `json:"sigInfo,omitempty"`
		Transaction *string            `json:"transaction,omitempty"`
	}{}
	u.AccountHeader = v.AccountHeader
	u.SigInfo = v.TxState.SigInfo
	u.Transaction = encoding.BytesToJSON(v.TxState.Transaction)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.AccountHeader = u.AccountHeader
	v.TxState.SigInfo = u.SigInfo
	if x, err := encoding.BytesFromJSON(u.Transaction); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.TxState.Transaction = x
	}
	return nil
}

func (v *TransactionStatus) UnmarshalJSON(data []byte) error {
	u := struct {
		Remote    bool            `json:"remote,omitempty"`
		Delivered bool            `json:"delivered,omitempty"`
		Pending   bool            `json:"pending,omitempty"`
		Code      uint64          `json:"code,omitempty"`
		Message   string          `json:"message,omitempty"`
		Result    json.RawMessage `json:"result,omitempty"`
	}{}
	u.Remote = v.Remote
	u.Delivered = v.Delivered
	u.Pending = v.Pending
	u.Code = v.Code
	u.Message = v.Message
	if x, err := json.Marshal(v.Result); err != nil {
		return fmt.Errorf("error encoding Result: %w", err)
	} else {
		u.Result = x
	}

	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Remote = u.Remote
	v.Delivered = u.Delivered
	v.Pending = u.Pending
	v.Code = u.Code
	v.Message = u.Message
	if x, err := UnmarshalTransactionResultJSON(u.Result); err != nil {
		return fmt.Errorf("error decoding Result: %w", err)
	} else {
		v.Result = x
	}

	return nil
}

func (v *TxState) UnmarshalJSON(data []byte) error {
	u := struct {
		SigInfo     *TransactionHeader `json:"sigInfo,omitempty"`
		Transaction *string            `json:"transaction,omitempty"`
	}{}
	u.SigInfo = v.SigInfo
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.SigInfo = u.SigInfo
	if x, err := encoding.BytesFromJSON(u.Transaction); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	return nil
}

func (v *UpdateKeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		Operation KeyPageOperation `json:"operation,omitempty"`
		Key       *string          `json:"key,omitempty"`
		NewKey    *string          `json:"newKey,omitempty"`
		Owner     string           `json:"owner,omitempty"`
		Threshold uint64           `json:"threshold,omitempty"`
	}{}
	u.Operation = v.Operation
	u.Key = encoding.BytesToJSON(v.Key)
	u.NewKey = encoding.BytesToJSON(v.NewKey)
	u.Owner = v.Owner
	u.Threshold = v.Threshold
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Operation = u.Operation
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	if x, err := encoding.BytesFromJSON(u.NewKey); err != nil {
		return fmt.Errorf("error decoding NewKey: %w", err)
	} else {
		v.NewKey = x
	}
	v.Owner = u.Owner
	v.Threshold = u.Threshold
	return nil
}

func (v *WriteDataResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType `json:"type"`
		EntryHash  string          `json:"entryHash,omitempty"`
		AccountUrl *url.URL        `json:"accountUrl,omitempty"`
		AccountID  *string         `json:"accountID,omitempty"`
	}{}
	u.Type = v.GetType()
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.AccountUrl = v.AccountUrl
	u.AccountID = encoding.BytesToJSON(v.AccountID)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	v.AccountUrl = u.AccountUrl
	if x, err := encoding.BytesFromJSON(u.AccountID); err != nil {
		return fmt.Errorf("error decoding AccountID: %w", err)
	} else {
		v.AccountID = x
	}
	return nil
}
