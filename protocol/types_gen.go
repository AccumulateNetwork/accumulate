package protocol

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
)

type ADI struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
}

type AccountAuth struct {
	fieldsSet   []bool
	Authorities []AuthorityEntry `json:"authorities,omitempty" form:"authorities" query:"authorities" validate:"required"`
}

type AcmeFaucet struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
}

type AcmeOracle struct {
	fieldsSet []bool
	Price     uint64 `json:"price,omitempty" form:"price" query:"price" validate:"required"`
}

type AddAccountAuthorityOperation struct {
	fieldsSet []bool
	// Authority is the authority to add.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
}

type AddCredits struct {
	fieldsSet []bool
	Recipient *url.URL `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	Amount    big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	Oracle    uint64   `json:"oracle,omitempty" form:"oracle" query:"oracle"`
}

type AddCreditsResult struct {
	fieldsSet []bool
	Amount    big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	Credits   uint64  `json:"credits,omitempty" form:"credits" query:"credits" validate:"required"`
	Oracle    uint64  `json:"oracle,omitempty" form:"oracle" query:"oracle" validate:"required"`
}

type AddKeyOperation struct {
	fieldsSet []bool
	Entry     KeySpecParams `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type AddValidator struct {
	fieldsSet []bool
	Key       []byte `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	// Owner reserved for future use.
	Owner *url.URL `json:"owner,omitempty" form:"owner" query:"owner"`
}

type Anchor struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
}

type AnchorMetadata struct {
	fieldsSet []bool
	ChainMetadata
	Account     *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Index       uint64   `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	SourceIndex uint64   `json:"sourceIndex,omitempty" form:"sourceIndex" query:"sourceIndex" validate:"required"`
	SourceBlock uint64   `json:"sourceBlock,omitempty" form:"sourceBlock" query:"sourceBlock" validate:"required"`
	Entry       []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type AnchoredRecord struct {
	fieldsSet []bool
	Record    []byte   `json:"record,omitempty" form:"record" query:"record" validate:"required"`
	Anchor    [32]byte `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
}

type AuthorityEntry struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	// Disabled disables auth checks for this authority, allowing anyone to sign for it.
	Disabled bool `json:"disabled,omitempty" form:"disabled" query:"disabled" validate:"required"`
}

type BurnTokens struct {
	fieldsSet []bool
	Amount    big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type ChainMetadata struct {
	fieldsSet []bool
	Name      string    `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
}

type ChainParams struct {
	fieldsSet []bool
	Data      []byte `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	IsUpdate  bool   `json:"isUpdate,omitempty" form:"isUpdate" query:"isUpdate" validate:"required"`
}

type CreateDataAccount struct {
	fieldsSet         []bool
	Url               *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	KeyBookUrl        *url.URL `json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl"`
	ManagerKeyBookUrl *url.URL `json:"managerKeyBookUrl,omitempty" form:"managerKeyBookUrl" query:"managerKeyBookUrl"`
	Scratch           bool     `json:"scratch,omitempty" form:"scratch" query:"scratch"`
}

type CreateIdentity struct {
	fieldsSet  []bool
	Url        *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	KeyHash    []byte   `json:"keyHash,omitempty" form:"keyHash" query:"keyHash"`
	KeyBookUrl *url.URL `json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl"`
	Manager    *url.URL `json:"manager,omitempty" form:"manager" query:"manager"`
}

type CreateKeyBook struct {
	fieldsSet     []bool
	Url           *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	PublicKeyHash []byte   `json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	Manager       *url.URL `json:"manager,omitempty" form:"manager" query:"manager"`
}

type CreateKeyPage struct {
	fieldsSet []bool
	Keys      []*KeySpecParams `json:"keys,omitempty" form:"keys" query:"keys" validate:"required"`
	Manager   *url.URL         `json:"manager,omitempty" form:"manager" query:"manager"`
}

type CreateToken struct {
	fieldsSet   []bool
	Url         *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	KeyBookUrl  *url.URL `json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl"`
	Symbol      string   `json:"symbol,omitempty" form:"symbol" query:"symbol" validate:"required"`
	Precision   uint64   `json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	Properties  *url.URL `json:"properties,omitempty" form:"properties" query:"properties"`
	SupplyLimit *big.Int `json:"supplyLimit,omitempty" form:"supplyLimit" query:"supplyLimit"`
	Manager     *url.URL `json:"manager,omitempty" form:"manager" query:"manager"`
}

type CreateTokenAccount struct {
	fieldsSet  []bool
	Url        *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	TokenUrl   *url.URL `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required"`
	KeyBookUrl *url.URL `json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl"`
	Scratch    bool     `json:"scratch,omitempty" form:"scratch" query:"scratch"`
	Manager    *url.URL `json:"manager,omitempty" form:"manager" query:"manager"`
}

type DataAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	Scratch bool `json:"scratch,omitempty" form:"scratch" query:"scratch"`
}

type DataEntry struct {
	fieldsSet []bool
	Data      [][]byte `json:"data,omitempty" form:"data" query:"data" validate:"required"`
}

type DirectoryIndexMetadata struct {
	fieldsSet []bool
	Count     uint64 `json:"count,omitempty" form:"count" query:"count" validate:"required"`
}

type DisableAccountAuthOperation struct {
	fieldsSet []bool
	// Authority is the authority to enable authorization for.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
}

type ED25519Signature struct {
	fieldsSet     []bool
	PublicKey     []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature     []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer        *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Timestamp     uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp"`
	Vote          VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
}

type EmptyResult struct {
	fieldsSet []bool
}

type EnableAccountAuthOperation struct {
	fieldsSet []bool
	// Authority is the authority to enable authorization for.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
}

type Envelope struct {
	fieldsSet   []bool
	Signatures  []Signature  `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	TxHash      []byte       `json:"txHash,omitempty" form:"txHash" query:"txHash"`
	Transaction *Transaction `json:"transaction,omitempty" form:"transaction" query:"transaction"`
	hash        []byte
}

// ForwardedSignature is used when forwarding signatures from one subnet to another.
type ForwardedSignature struct {
	fieldsSet []bool
	Signature KeySignature `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer    Signer       `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
}

type HashSet struct {
	fieldsSet []bool
	Hashes    [][32]byte `json:"hashes,omitempty" form:"hashes" query:"hashes" validate:"required"`
}

// IndexEntry represents an entry in an index chain.
type IndexEntry struct {
	fieldsSet []bool
	// Source is the index of the chain from which an anchor was taken.
	Source uint64 `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	// Anchor is the index of the chain into which the anchor was added. Omit when indexing the root anchor chain.
	Anchor uint64 `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	// BlockIndex is the index of the block. Only include when indexing the root anchor chain.
	BlockIndex uint64 `json:"blockIndex,omitempty" form:"blockIndex" query:"blockIndex" validate:"required"`
	// BlockTime is the start time of the block. Only include when indexing the root anchor chain.
	BlockTime *time.Time `json:"blockTime,omitempty" form:"blockTime" query:"blockTime" validate:"required"`
}

type InternalGenesis struct {
	fieldsSet []bool
}

type InternalLedger struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	Index         int64           `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Timestamp     time.Time       `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	Synthetic     SyntheticLedger `json:"synthetic,omitempty" form:"synthetic" query:"synthetic" validate:"required"`
	PendingOracle uint64          `json:"pendingOracle,omitempty" form:"pendingOracle" query:"pendingOracle" validate:"required"`
	ActiveOracle  uint64          `json:"activeOracle,omitempty" form:"activeOracle" query:"activeOracle" validate:"required"`
	AcmeBurnt     big.Int         `json:"acmeBurnt,omitempty" form:"acmeBurnt" query:"acmeBurnt" validate:"required"`
}

type InternalSendTransactions struct {
	fieldsSet    []bool
	Transactions []SendTransaction `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

// InternalSignature is used when executing transactions internally.
type InternalSignature struct {
	fieldsSet []bool
	// Network is the network that produced the transaction.
	Network *url.URL `json:"network,omitempty" form:"network" query:"network" validate:"required"`
}

type InternalSyntheticLedger struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	Pending []*SyntheticLedgerEntry `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
}

type InternalTransactionsSent struct {
	fieldsSet    []bool
	Transactions [][32]byte `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type InternalTransactionsSigned struct {
	fieldsSet    []bool
	Transactions []TransactionSignature `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type IssueTokens struct {
	fieldsSet []bool
	Recipient *url.URL `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	Amount    big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type KeyBook struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	PageCount uint64 `json:"pageCount,omitempty" form:"pageCount" query:"pageCount" validate:"required"`
}

type KeyPage struct {
	fieldsSet     []bool
	Url           *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	CreditBalance uint64   `json:"creditBalance,omitempty" form:"creditBalance" query:"creditBalance" validate:"required"`
	// AcceptThreshold is the number of acceptances required to accept a transaction.
	AcceptThreshold uint64 `json:"acceptThreshold,omitempty" form:"acceptThreshold" query:"acceptThreshold" validate:"required"`
	// RejectThreshold is the number of rejections required to reject a transaction.
	RejectThreshold uint64 `json:"rejectThreshold,omitempty" form:"rejectThreshold" query:"rejectThreshold" validate:"required"`
	// ResponseThreshold is the number of responses that must be received before a transaction will be processed.
	ResponseThreshold uint64 `json:"responseThreshold,omitempty" form:"responseThreshold" query:"responseThreshold" validate:"required"`
	// BlockThreshold is the number of minor blocks that must elapse before a transaction will be processed.
	BlockThreshold       uint64               `json:"blockThreshold,omitempty" form:"blockThreshold" query:"blockThreshold" validate:"required"`
	Version              uint64               `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Keys                 []*KeySpec           `json:"keys,omitempty" form:"keys" query:"keys" validate:"required"`
	TransactionBlacklist *AllowedTransactions `json:"transactionBlacklist,omitempty" form:"transactionBlacklist" query:"transactionBlacklist"`
}

type KeySpec struct {
	fieldsSet     []bool
	PublicKeyHash []byte   `json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	LastUsedOn    uint64   `json:"lastUsedOn,omitempty" form:"lastUsedOn" query:"lastUsedOn" validate:"required"`
	Owner         *url.URL `json:"owner,omitempty" form:"owner" query:"owner" validate:"required"`
}

type KeySpecParams struct {
	fieldsSet []bool
	KeyHash   []byte   `json:"keyHash,omitempty" form:"keyHash" query:"keyHash" validate:"required"`
	Owner     *url.URL `json:"owner,omitempty" form:"owner" query:"owner"`
}

type LegacyED25519Signature struct {
	fieldsSet     []bool
	Timestamp     uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	PublicKey     []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature     []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer        *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Vote          VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
}

type LiteDataAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Tail      []byte   `json:"tail,omitempty" form:"tail" query:"tail" validate:"required"`
}

type LiteIdentity struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
}

type LiteTokenAccount struct {
	fieldsSet     []bool
	Url           *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	TokenUrl      *url.URL `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required"`
	Balance       big.Int  `json:"balance,omitempty" form:"balance" query:"balance" validate:"required"`
	LastUsedOn    uint64   `json:"lastUsedOn,omitempty" form:"lastUsedOn" query:"lastUsedOn" validate:"required"`
	CreditBalance uint64   `json:"creditBalance,omitempty" form:"creditBalance" query:"creditBalance" validate:"required"`
}

type MetricsRequest struct {
	fieldsSet []bool
	Metric    string        `json:"metric,omitempty" form:"metric" query:"metric" validate:"required"`
	Duration  time.Duration `json:"duration,omitempty" form:"duration" query:"duration" validate:"required"`
}

type MetricsResponse struct {
	Value interface{} `json:"value,omitempty" form:"value" query:"value" validate:"required"`
}

type Object struct {
	fieldsSet []bool
	// Type is the object's type.
	Type ObjectType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	// Chains lists the object's chains.
	Chains []ChainMetadata `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
}

type RCD1Signature struct {
	fieldsSet     []bool
	PublicKey     []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Signature     []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Signer        *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	SignerVersion uint64   `json:"signerVersion,omitempty" form:"signerVersion" query:"signerVersion" validate:"required"`
	Timestamp     uint64   `json:"timestamp,omitempty" form:"timestamp" query:"timestamp"`
	Vote          VoteType `json:"vote,omitempty" form:"vote" query:"vote"`
}

type Receipt struct {
	fieldsSet []bool
	Start     []byte         `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Result    []byte         `json:"result,omitempty" form:"result" query:"result" validate:"required"`
	Entries   []ReceiptEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
}

type ReceiptEntry struct {
	fieldsSet []bool
	Right     bool   `json:"right,omitempty" form:"right" query:"right" validate:"required"`
	Hash      []byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
}

type ReceiptSignature struct {
	fieldsSet []bool
	Receipt
	// SourceNetwork is the network that produced the transaction.
	SourceNetwork *url.URL `json:"sourceNetwork,omitempty" form:"sourceNetwork" query:"sourceNetwork" validate:"required"`
}

type RemoteTransactionBody struct {
	fieldsSet []bool
}

type RemoveAccountAuthorityOperation struct {
	fieldsSet []bool
	// Authority is the authority to add.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
}

type RemoveKeyOperation struct {
	fieldsSet []bool
	Entry     KeySpecParams `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type RemoveValidator struct {
	fieldsSet []bool
	Key       []byte `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	// Owner reserved for future use.
	Owner *url.URL `json:"owner,omitempty" form:"owner" query:"owner"`
}

type SegWitDataEntry struct {
	fieldsSet []bool
	SyntheticOrigin
	EntryUrl  *url.URL `json:"entryUrl,omitempty" form:"entryUrl" query:"entryUrl" validate:"required"`
	EntryHash [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
}

type SendTokens struct {
	fieldsSet []bool
	Hash      [32]byte          `json:"hash,omitempty" form:"hash" query:"hash"`
	Meta      json.RawMessage   `json:"meta,omitempty" form:"meta" query:"meta"`
	To        []*TokenRecipient `json:"to,omitempty" form:"to" query:"to" validate:"required"`
}

type SendTransaction struct {
	fieldsSet []bool
	Payload   TransactionBody `json:"payload,omitempty" form:"payload" query:"payload" validate:"required"`
	Recipient *url.URL        `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
}

type SetThresholdKeyPageOperation struct {
	fieldsSet []bool
	Threshold uint64 `json:"threshold,omitempty" form:"threshold" query:"threshold" validate:"required"`
}

type SyntheticAnchor struct {
	fieldsSet []bool
	// Source is the principal of the transaction that produced this transaction.
	Source *url.URL `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	// Major indicates whether the anchor is a major block anchor.
	Major bool `json:"major,omitempty" form:"major" query:"major" validate:"required"`
	// RootAnchor is the anchor of the source's root anchor chain.
	RootAnchor [32]byte `json:"rootAnchor,omitempty" form:"rootAnchor" query:"rootAnchor" validate:"required"`
	// RootIndex is the index of the root anchor chain anchor.
	RootIndex uint64 `json:"rootIndex,omitempty" form:"rootIndex" query:"rootIndex" validate:"required"`
	// AcmeBurnt is the amount of acme tokens burnt in the transaction.
	AcmeBurnt big.Int `json:"acmeBurnt,omitempty" form:"acmeBurnt" query:"acmeBurnt" validate:"required"`
	// Block is the index of the block.
	Block           uint64 `json:"block,omitempty" form:"block" query:"block" validate:"required"`
	AcmeOraclePrice uint64 `json:"acmeOraclePrice,omitempty" form:"acmeOraclePrice" query:"acmeOraclePrice" validate:"required"`
	// Receipts are receipts for anchors from other subnets that were included in the block.
	Receipts []Receipt `json:"receipts,omitempty" form:"receipts" query:"receipts" validate:"required"`
}

type SyntheticBurnTokens struct {
	fieldsSet []bool
	SyntheticOrigin
	Amount big.Int `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type SyntheticCreateChain struct {
	fieldsSet []bool
	SyntheticOrigin
	Chains []ChainParams `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
}

type SyntheticDepositCredits struct {
	fieldsSet []bool
	SyntheticOrigin
	Amount uint64 `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type SyntheticDepositTokens struct {
	fieldsSet []bool
	SyntheticOrigin
	Token  *url.URL `json:"token,omitempty" form:"token" query:"token" validate:"required"`
	Amount big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type SyntheticForwardTransaction struct {
	fieldsSet       []bool
	Signatures      []ForwardedSignature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	TransactionHash []byte               `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash"`
	Transaction     *Transaction         `json:"transaction,omitempty" form:"transaction" query:"transaction"`
}

type SyntheticLedger struct {
	fieldsSet []bool
	Nonce     uint64     `json:"nonce,omitempty" form:"nonce" query:"nonce" validate:"required"`
	Unsigned  [][32]byte `json:"unsigned,omitempty" form:"unsigned" query:"unsigned" validate:"required"`
	Unsent    [][32]byte `json:"unsent,omitempty" form:"unsent" query:"unsent" validate:"required"`
}

// SyntheticLedgerEntry contains the information needed to produce a receipt for a synthetic transaction that was produced in some block.
type SyntheticLedgerEntry struct {
	fieldsSet []bool
	// TransactionHash is the hash of the synthetic transaction.
	TransactionHash [32]byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash" validate:"required"`
	// RootAnchor is the anchor of the root chain from the block.
	RootAnchor [32]byte `json:"rootAnchor,omitempty" form:"rootAnchor" query:"rootAnchor" validate:"required"`
	// SynthIndex is the index of the transaction in the synthetic transaction chain.
	SynthIndex uint64 `json:"synthIndex,omitempty" form:"synthIndex" query:"synthIndex" validate:"required"`
	// SynthIndexIndex is the index of the synthetic transaction index chain entry from the block.
	SynthIndexIndex uint64 `json:"synthIndexIndex,omitempty" form:"synthIndexIndex" query:"synthIndexIndex" validate:"required"`
	// RootIndexIndex is the index of the root index chain entry from the block.
	RootIndexIndex uint64 `json:"rootIndexIndex,omitempty" form:"rootIndexIndex" query:"rootIndexIndex" validate:"required"`
	// NeedsReceipt indicates whether the synthetic transaction is waiting for a receipt.
	NeedsReceipt bool `json:"needsReceipt,omitempty" form:"needsReceipt" query:"needsReceipt" validate:"required"`
}

type SyntheticMirror struct {
	fieldsSet []bool
	Objects   []AnchoredRecord `json:"objects,omitempty" form:"objects" query:"objects" validate:"required"`
}

type SyntheticOrigin struct {
	fieldsSet []bool
	// Source is the principal of the transaction that produced this transaction.
	Source *url.URL `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	Cause  [32]byte `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
}

type SyntheticReceipt struct {
	fieldsSet []bool
	SyntheticOrigin
	SynthTxHash [32]byte           `json:"synthTxHash,omitempty" form:"synthTxHash" query:"synthTxHash" validate:"required"`
	Status      *TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
}

// SyntheticSignature is used to initiate transactions between BVNs.
type SyntheticSignature struct {
	fieldsSet []bool
	// SourceNetwork is the network that produced the transaction.
	SourceNetwork *url.URL `json:"sourceNetwork,omitempty" form:"sourceNetwork" query:"sourceNetwork" validate:"required"`
	// DestinationNetwork is the network that the transaction is sent to.
	DestinationNetwork *url.URL `json:"destinationNetwork,omitempty" form:"destinationNetwork" query:"destinationNetwork" validate:"required"`
	// SequenceNumber is the sequence number of the transaction.
	SequenceNumber uint64 `json:"sequenceNumber,omitempty" form:"sequenceNumber" query:"sequenceNumber" validate:"required"`
}

type SyntheticWriteData struct {
	fieldsSet []bool
	SyntheticOrigin
	Entry DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type TokenAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	TokenUrl *url.URL `json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required"`
	Balance  big.Int  `json:"balance,omitempty" form:"balance" query:"balance" validate:"required"`
	Scratch  bool     `json:"scratch,omitempty" form:"scratch" query:"scratch"`
}

type TokenIssuer struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AccountAuth
	Symbol      string   `json:"symbol,omitempty" form:"symbol" query:"symbol" validate:"required"`
	Precision   uint64   `json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	Properties  *url.URL `json:"properties,omitempty" form:"properties" query:"properties" validate:"required"`
	Issued      big.Int  `json:"issued,omitempty" form:"issued" query:"issued" validate:"required"`
	SupplyLimit *big.Int `json:"supplyLimit,omitempty" form:"supplyLimit" query:"supplyLimit"`
}

type TokenRecipient struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Amount    big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
}

type Transaction struct {
	fieldsSet []bool
	Header    TransactionHeader `json:"header,omitempty" form:"header" query:"header" validate:"required"`
	Body      TransactionBody   `json:"body,omitempty" form:"body" query:"body" validate:"required"`
	hash      []byte
}

type TransactionHeader struct {
	fieldsSet []bool
	Principal *url.URL `json:"principal,omitempty" form:"principal" query:"principal" validate:"required"`
	Initiator [32]byte `json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	Memo      string   `json:"memo,omitempty" form:"memo" query:"memo"`
	Metadata  []byte   `json:"metadata,omitempty" form:"metadata" query:"metadata"`
}

type TransactionResultSet struct {
	fieldsSet []bool
	Results   []*TransactionStatus `json:"results,omitempty" form:"results" query:"results" validate:"required"`
}

type TransactionSignature struct {
	fieldsSet   []bool
	Transaction [32]byte  `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signature   Signature `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
}

type TransactionStatus struct {
	fieldsSet []bool
	// For is the transaction this status is for.
	For       [32]byte
	Remote    bool              `json:"remote,omitempty" form:"remote" query:"remote" validate:"required"`
	Delivered bool              `json:"delivered,omitempty" form:"delivered" query:"delivered" validate:"required"`
	Pending   bool              `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	Code      uint64            `json:"code,omitempty" form:"code" query:"code" validate:"required"`
	Message   string            `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Result    TransactionResult `json:"result,omitempty" form:"result" query:"result" validate:"required"`
	// Initiator is the signer that initiated the transaction.
	Initiator *url.URL `json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	// Signers lists accounts that have signed the transaction.
	Signers []Signer `json:"signers,omitempty" form:"signers" query:"signers" validate:"required"`
}

type UnknownAccount struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
}

type UnknownSigner struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Version   uint64   `json:"version,omitempty" form:"version" query:"version" validate:"required"`
}

type UpdateAccountAuth struct {
	fieldsSet  []bool
	Operations []AccountAuthOperation `json:"operations,omitempty" form:"operations" query:"operations" validate:"required"`
}

type UpdateAllowedKeyPageOperation struct {
	fieldsSet []bool
	Allow     []TransactionType `json:"allow,omitempty" form:"allow" query:"allow"`
	Deny      []TransactionType `json:"deny,omitempty" form:"deny" query:"deny"`
}

type UpdateKey struct {
	fieldsSet  []bool
	NewKeyHash []byte `json:"newKeyHash,omitempty" form:"newKeyHash" query:"newKeyHash" validate:"required"`
}

type UpdateKeyOperation struct {
	fieldsSet []bool
	OldEntry  KeySpecParams `json:"oldEntry,omitempty" form:"oldEntry" query:"oldEntry" validate:"required"`
	NewEntry  KeySpecParams `json:"newEntry,omitempty" form:"newEntry" query:"newEntry" validate:"required"`
}

type UpdateKeyPage struct {
	fieldsSet []bool
	Operation []KeyPageOperation `json:"operation,omitempty" form:"operation" query:"operation" validate:"required"`
}

type UpdateValidatorKey struct {
	fieldsSet  []bool
	KeyHash    []byte `json:"keyHash,omitempty" form:"keyHash" query:"keyHash" validate:"required"`
	NewKeyHash []byte `json:"newKeyHash,omitempty" form:"newKeyHash" query:"newKeyHash" validate:"required"`
}

type WriteData struct {
	fieldsSet []bool
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type WriteDataResult struct {
	fieldsSet  []bool
	EntryHash  [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	AccountUrl *url.URL `json:"accountUrl,omitempty" form:"accountUrl" query:"accountUrl" validate:"required"`
	AccountID  []byte   `json:"accountID,omitempty" form:"accountID" query:"accountID" validate:"required"`
}

type WriteDataTo struct {
	fieldsSet []bool
	Recipient *url.URL  `json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

func (*ADI) Type() AccountType { return AccountTypeIdentity }

func (*AcmeFaucet) Type() TransactionType { return TransactionTypeAcmeFaucet }

func (*AddAccountAuthorityOperation) Type() AccountAuthOperationType {
	return AccountAuthOperationTypeAddAuthority
}

func (*AddCredits) Type() TransactionType { return TransactionTypeAddCredits }

func (*AddCreditsResult) Type() TransactionType { return TransactionTypeAddCredits }

func (*AddKeyOperation) Type() KeyPageOperationType { return KeyPageOperationTypeAdd }

func (*AddValidator) Type() TransactionType { return TransactionTypeAddValidator }

func (*Anchor) Type() AccountType { return AccountTypeAnchor }

func (*BurnTokens) Type() TransactionType { return TransactionTypeBurnTokens }

func (*CreateDataAccount) Type() TransactionType { return TransactionTypeCreateDataAccount }

func (*CreateIdentity) Type() TransactionType { return TransactionTypeCreateIdentity }

func (*CreateKeyBook) Type() TransactionType { return TransactionTypeCreateKeyBook }

func (*CreateKeyPage) Type() TransactionType { return TransactionTypeCreateKeyPage }

func (*CreateToken) Type() TransactionType { return TransactionTypeCreateToken }

func (*CreateTokenAccount) Type() TransactionType { return TransactionTypeCreateTokenAccount }

func (*DataAccount) Type() AccountType { return AccountTypeDataAccount }

func (*DisableAccountAuthOperation) Type() AccountAuthOperationType {
	return AccountAuthOperationTypeDisable
}

func (*ED25519Signature) Type() SignatureType { return SignatureTypeED25519 }

func (*EmptyResult) Type() TransactionType { return TransactionTypeUnknown }

func (*EnableAccountAuthOperation) Type() AccountAuthOperationType {
	return AccountAuthOperationTypeEnable
}

func (*ForwardedSignature) Type() SignatureType { return SignatureTypeForwarded }

func (*InternalGenesis) Type() TransactionType { return TransactionTypeInternalGenesis }

func (*InternalLedger) Type() AccountType { return AccountTypeInternalLedger }

func (*InternalSendTransactions) Type() TransactionType {
	return TransactionTypeInternalSendTransactions
}

func (*InternalSignature) Type() SignatureType { return SignatureTypeInternal }

func (*InternalSyntheticLedger) Type() AccountType { return AccountTypeInternalSyntheticLedger }

func (*InternalTransactionsSent) Type() TransactionType {
	return TransactionTypeInternalTransactionsSent
}

func (*InternalTransactionsSigned) Type() TransactionType {
	return TransactionTypeInternalTransactionsSigned
}

func (*IssueTokens) Type() TransactionType { return TransactionTypeIssueTokens }

func (*KeyBook) Type() AccountType { return AccountTypeKeyBook }

func (*KeyPage) Type() AccountType { return AccountTypeKeyPage }

func (*LegacyED25519Signature) Type() SignatureType { return SignatureTypeLegacyED25519 }

func (*LiteDataAccount) Type() AccountType { return AccountTypeLiteDataAccount }

func (*LiteIdentity) Type() AccountType { return AccountTypeLiteIdentity }

func (*LiteTokenAccount) Type() AccountType { return AccountTypeLiteTokenAccount }

func (*RCD1Signature) Type() SignatureType { return SignatureTypeRCD1 }

func (*ReceiptSignature) Type() SignatureType { return SignatureTypeReceipt }

func (*RemoteTransactionBody) Type() TransactionType { return TransactionTypeRemote }

func (*RemoveAccountAuthorityOperation) Type() AccountAuthOperationType {
	return AccountAuthOperationTypeRemoveAuthority
}

func (*RemoveKeyOperation) Type() KeyPageOperationType { return KeyPageOperationTypeRemove }

func (*RemoveValidator) Type() TransactionType { return TransactionTypeRemoveValidator }

func (*SegWitDataEntry) Type() TransactionType { return TransactionTypeSegWitDataEntry }

func (*SendTokens) Type() TransactionType { return TransactionTypeSendTokens }

func (*SetThresholdKeyPageOperation) Type() KeyPageOperationType {
	return KeyPageOperationTypeSetThreshold
}

func (*SyntheticAnchor) Type() TransactionType { return TransactionTypeSyntheticAnchor }

func (*SyntheticBurnTokens) Type() TransactionType { return TransactionTypeSyntheticBurnTokens }

func (*SyntheticCreateChain) Type() TransactionType { return TransactionTypeSyntheticCreateChain }

func (*SyntheticDepositCredits) Type() TransactionType { return TransactionTypeSyntheticDepositCredits }

func (*SyntheticDepositTokens) Type() TransactionType { return TransactionTypeSyntheticDepositTokens }

func (*SyntheticForwardTransaction) Type() TransactionType {
	return TransactionTypeSyntheticForwardTransaction
}

func (*SyntheticMirror) Type() TransactionType { return TransactionTypeSyntheticMirror }

func (*SyntheticReceipt) Type() TransactionType { return TransactionTypeSyntheticReceipt }

func (*SyntheticSignature) Type() SignatureType { return SignatureTypeSynthetic }

func (*SyntheticWriteData) Type() TransactionType { return TransactionTypeSyntheticWriteData }

func (*TokenAccount) Type() AccountType { return AccountTypeTokenAccount }

func (*TokenIssuer) Type() AccountType { return AccountTypeTokenIssuer }

func (*UnknownAccount) Type() AccountType { return AccountTypeUnknown }

func (*UnknownSigner) Type() AccountType { return AccountTypeUnknownSigner }

func (*UpdateAccountAuth) Type() TransactionType { return TransactionTypeUpdateAccountAuth }

func (*UpdateAllowedKeyPageOperation) Type() KeyPageOperationType {
	return KeyPageOperationTypeUpdateAllowed
}

func (*UpdateKey) Type() TransactionType { return TransactionTypeUpdateKey }

func (*UpdateKeyOperation) Type() KeyPageOperationType { return KeyPageOperationTypeUpdate }

func (*UpdateKeyPage) Type() TransactionType { return TransactionTypeUpdateKeyPage }

func (*UpdateValidatorKey) Type() TransactionType { return TransactionTypeUpdateValidatorKey }

func (*WriteData) Type() TransactionType { return TransactionTypeWriteData }

func (*WriteDataResult) Type() TransactionType { return TransactionTypeWriteData }

func (*WriteDataTo) Type() TransactionType { return TransactionTypeWriteDataTo }

func (v *ADI) Copy() *ADI {
	u := new(ADI)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.AccountAuth = *v.AccountAuth.Copy()

	return u
}

func (v *ADI) CopyAsInterface() interface{} { return v.Copy() }

func (v *AccountAuth) Copy() *AccountAuth {
	u := new(AccountAuth)

	u.Authorities = make([]AuthorityEntry, len(v.Authorities))
	for i, v := range v.Authorities {
		u.Authorities[i] = *(&v).Copy()
	}

	return u
}

func (v *AccountAuth) CopyAsInterface() interface{} { return v.Copy() }

func (v *AcmeFaucet) Copy() *AcmeFaucet {
	u := new(AcmeFaucet)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}

	return u
}

func (v *AcmeFaucet) CopyAsInterface() interface{} { return v.Copy() }

func (v *AcmeOracle) Copy() *AcmeOracle {
	u := new(AcmeOracle)

	u.Price = v.Price

	return u
}

func (v *AcmeOracle) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddAccountAuthorityOperation) Copy() *AddAccountAuthorityOperation {
	u := new(AddAccountAuthorityOperation)

	if v.Authority != nil {
		u.Authority = (v.Authority).Copy()
	}

	return u
}

func (v *AddAccountAuthorityOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddCredits) Copy() *AddCredits {
	u := new(AddCredits)

	if v.Recipient != nil {
		u.Recipient = (v.Recipient).Copy()
	}
	u.Amount = *encoding.BigintCopy(&v.Amount)
	u.Oracle = v.Oracle

	return u
}

func (v *AddCredits) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddCreditsResult) Copy() *AddCreditsResult {
	u := new(AddCreditsResult)

	u.Amount = *encoding.BigintCopy(&v.Amount)
	u.Credits = v.Credits
	u.Oracle = v.Oracle

	return u
}

func (v *AddCreditsResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddKeyOperation) Copy() *AddKeyOperation {
	u := new(AddKeyOperation)

	u.Entry = *(&v.Entry).Copy()

	return u
}

func (v *AddKeyOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *AddValidator) Copy() *AddValidator {
	u := new(AddValidator)

	u.Key = encoding.BytesCopy(v.Key)
	if v.Owner != nil {
		u.Owner = (v.Owner).Copy()
	}

	return u
}

func (v *AddValidator) CopyAsInterface() interface{} { return v.Copy() }

func (v *Anchor) Copy() *Anchor {
	u := new(Anchor)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.AccountAuth = *v.AccountAuth.Copy()

	return u
}

func (v *Anchor) CopyAsInterface() interface{} { return v.Copy() }

func (v *AnchorMetadata) Copy() *AnchorMetadata {
	u := new(AnchorMetadata)

	u.ChainMetadata = *v.ChainMetadata.Copy()
	if v.Account != nil {
		u.Account = (v.Account).Copy()
	}
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesCopy(v.Entry)

	return u
}

func (v *AnchorMetadata) CopyAsInterface() interface{} { return v.Copy() }

func (v *AnchoredRecord) Copy() *AnchoredRecord {
	u := new(AnchoredRecord)

	u.Record = encoding.BytesCopy(v.Record)
	u.Anchor = v.Anchor

	return u
}

func (v *AnchoredRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *AuthorityEntry) Copy() *AuthorityEntry {
	u := new(AuthorityEntry)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.Disabled = v.Disabled

	return u
}

func (v *AuthorityEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *BurnTokens) Copy() *BurnTokens {
	u := new(BurnTokens)

	u.Amount = *encoding.BigintCopy(&v.Amount)

	return u
}

func (v *BurnTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainMetadata) Copy() *ChainMetadata {
	u := new(ChainMetadata)

	u.Name = v.Name
	u.Type = v.Type

	return u
}

func (v *ChainMetadata) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainParams) Copy() *ChainParams {
	u := new(ChainParams)

	u.Data = encoding.BytesCopy(v.Data)
	u.IsUpdate = v.IsUpdate

	return u
}

func (v *ChainParams) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateDataAccount) Copy() *CreateDataAccount {
	u := new(CreateDataAccount)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	if v.KeyBookUrl != nil {
		u.KeyBookUrl = (v.KeyBookUrl).Copy()
	}
	if v.ManagerKeyBookUrl != nil {
		u.ManagerKeyBookUrl = (v.ManagerKeyBookUrl).Copy()
	}
	u.Scratch = v.Scratch

	return u
}

func (v *CreateDataAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateIdentity) Copy() *CreateIdentity {
	u := new(CreateIdentity)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.KeyHash = encoding.BytesCopy(v.KeyHash)
	if v.KeyBookUrl != nil {
		u.KeyBookUrl = (v.KeyBookUrl).Copy()
	}
	if v.Manager != nil {
		u.Manager = (v.Manager).Copy()
	}

	return u
}

func (v *CreateIdentity) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateKeyBook) Copy() *CreateKeyBook {
	u := new(CreateKeyBook)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.PublicKeyHash = encoding.BytesCopy(v.PublicKeyHash)
	if v.Manager != nil {
		u.Manager = (v.Manager).Copy()
	}

	return u
}

func (v *CreateKeyBook) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateKeyPage) Copy() *CreateKeyPage {
	u := new(CreateKeyPage)

	u.Keys = make([]*KeySpecParams, len(v.Keys))
	for i, v := range v.Keys {
		if v != nil {
			u.Keys[i] = (v).Copy()
		}
	}
	if v.Manager != nil {
		u.Manager = (v.Manager).Copy()
	}

	return u
}

func (v *CreateKeyPage) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateToken) Copy() *CreateToken {
	u := new(CreateToken)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	if v.KeyBookUrl != nil {
		u.KeyBookUrl = (v.KeyBookUrl).Copy()
	}
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	if v.Properties != nil {
		u.Properties = (v.Properties).Copy()
	}
	if v.SupplyLimit != nil {
		u.SupplyLimit = encoding.BigintCopy(v.SupplyLimit)
	}
	if v.Manager != nil {
		u.Manager = (v.Manager).Copy()
	}

	return u
}

func (v *CreateToken) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreateTokenAccount) Copy() *CreateTokenAccount {
	u := new(CreateTokenAccount)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	if v.TokenUrl != nil {
		u.TokenUrl = (v.TokenUrl).Copy()
	}
	if v.KeyBookUrl != nil {
		u.KeyBookUrl = (v.KeyBookUrl).Copy()
	}
	u.Scratch = v.Scratch
	if v.Manager != nil {
		u.Manager = (v.Manager).Copy()
	}

	return u
}

func (v *CreateTokenAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *DataAccount) Copy() *DataAccount {
	u := new(DataAccount)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	u.Scratch = v.Scratch

	return u
}

func (v *DataAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *DataEntry) Copy() *DataEntry {
	u := new(DataEntry)

	u.Data = make([][]byte, len(v.Data))
	for i, v := range v.Data {
		u.Data[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *DataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *DirectoryIndexMetadata) Copy() *DirectoryIndexMetadata {
	u := new(DirectoryIndexMetadata)

	u.Count = v.Count

	return u
}

func (v *DirectoryIndexMetadata) CopyAsInterface() interface{} { return v.Copy() }

func (v *DisableAccountAuthOperation) Copy() *DisableAccountAuthOperation {
	u := new(DisableAccountAuthOperation)

	if v.Authority != nil {
		u.Authority = (v.Authority).Copy()
	}

	return u
}

func (v *DisableAccountAuthOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *ED25519Signature) Copy() *ED25519Signature {
	u := new(ED25519Signature)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = (v.Signer).Copy()
	}
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote

	return u
}

func (v *ED25519Signature) CopyAsInterface() interface{} { return v.Copy() }

func (v *EmptyResult) Copy() *EmptyResult {
	u := new(EmptyResult)

	return u
}

func (v *EmptyResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *EnableAccountAuthOperation) Copy() *EnableAccountAuthOperation {
	u := new(EnableAccountAuthOperation)

	if v.Authority != nil {
		u.Authority = (v.Authority).Copy()
	}

	return u
}

func (v *EnableAccountAuthOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *Envelope) Copy() *Envelope {
	u := new(Envelope)

	u.Signatures = make([]Signature, len(v.Signatures))
	for i, v := range v.Signatures {
		u.Signatures[i] = v
	}
	u.TxHash = encoding.BytesCopy(v.TxHash)
	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}

	return u
}

func (v *Envelope) CopyAsInterface() interface{} { return v.Copy() }

func (v *ForwardedSignature) Copy() *ForwardedSignature {
	u := new(ForwardedSignature)

	u.Signature = v.Signature
	u.Signer = v.Signer

	return u
}

func (v *ForwardedSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *HashSet) Copy() *HashSet {
	u := new(HashSet)

	u.Hashes = make([][32]byte, len(v.Hashes))
	for i, v := range v.Hashes {
		u.Hashes[i] = v
	}

	return u
}

func (v *HashSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *IndexEntry) Copy() *IndexEntry {
	u := new(IndexEntry)

	u.Source = v.Source
	u.Anchor = v.Anchor
	u.BlockIndex = v.BlockIndex
	if v.BlockTime != nil {
		u.BlockTime = new(time.Time)
		*u.BlockTime = *v.BlockTime
	}

	return u
}

func (v *IndexEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *InternalGenesis) Copy() *InternalGenesis {
	u := new(InternalGenesis)

	return u
}

func (v *InternalGenesis) CopyAsInterface() interface{} { return v.Copy() }

func (v *InternalLedger) Copy() *InternalLedger {
	u := new(InternalLedger)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	u.Index = v.Index
	u.Timestamp = v.Timestamp
	u.Synthetic = *(&v.Synthetic).Copy()
	u.PendingOracle = v.PendingOracle
	u.ActiveOracle = v.ActiveOracle
	u.AcmeBurnt = *encoding.BigintCopy(&v.AcmeBurnt)

	return u
}

func (v *InternalLedger) CopyAsInterface() interface{} { return v.Copy() }

func (v *InternalSignature) Copy() *InternalSignature {
	u := new(InternalSignature)

	if v.Network != nil {
		u.Network = (v.Network).Copy()
	}

	return u
}

func (v *InternalSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *InternalSyntheticLedger) Copy() *InternalSyntheticLedger {
	u := new(InternalSyntheticLedger)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	u.Pending = make([]*SyntheticLedgerEntry, len(v.Pending))
	for i, v := range v.Pending {
		if v != nil {
			u.Pending[i] = (v).Copy()
		}
	}

	return u
}

func (v *InternalSyntheticLedger) CopyAsInterface() interface{} { return v.Copy() }

func (v *InternalTransactionsSent) Copy() *InternalTransactionsSent {
	u := new(InternalTransactionsSent)

	u.Transactions = make([][32]byte, len(v.Transactions))
	for i, v := range v.Transactions {
		u.Transactions[i] = v
	}

	return u
}

func (v *InternalTransactionsSent) CopyAsInterface() interface{} { return v.Copy() }

func (v *InternalTransactionsSigned) Copy() *InternalTransactionsSigned {
	u := new(InternalTransactionsSigned)

	u.Transactions = make([]TransactionSignature, len(v.Transactions))
	for i, v := range v.Transactions {
		u.Transactions[i] = *(&v).Copy()
	}

	return u
}

func (v *InternalTransactionsSigned) CopyAsInterface() interface{} { return v.Copy() }

func (v *IssueTokens) Copy() *IssueTokens {
	u := new(IssueTokens)

	if v.Recipient != nil {
		u.Recipient = (v.Recipient).Copy()
	}
	u.Amount = *encoding.BigintCopy(&v.Amount)

	return u
}

func (v *IssueTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeyBook) Copy() *KeyBook {
	u := new(KeyBook)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	u.PageCount = v.PageCount

	return u
}

func (v *KeyBook) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeyPage) Copy() *KeyPage {
	u := new(KeyPage)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.CreditBalance = v.CreditBalance
	u.AcceptThreshold = v.AcceptThreshold
	u.RejectThreshold = v.RejectThreshold
	u.ResponseThreshold = v.ResponseThreshold
	u.BlockThreshold = v.BlockThreshold
	u.Version = v.Version
	u.Keys = make([]*KeySpec, len(v.Keys))
	for i, v := range v.Keys {
		if v != nil {
			u.Keys[i] = (v).Copy()
		}
	}
	if v.TransactionBlacklist != nil {
		u.TransactionBlacklist = new(AllowedTransactions)
		*u.TransactionBlacklist = *v.TransactionBlacklist
	}

	return u
}

func (v *KeyPage) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeySpec) Copy() *KeySpec {
	u := new(KeySpec)

	u.PublicKeyHash = encoding.BytesCopy(v.PublicKeyHash)
	u.LastUsedOn = v.LastUsedOn
	if v.Owner != nil {
		u.Owner = (v.Owner).Copy()
	}

	return u
}

func (v *KeySpec) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeySpecParams) Copy() *KeySpecParams {
	u := new(KeySpecParams)

	u.KeyHash = encoding.BytesCopy(v.KeyHash)
	if v.Owner != nil {
		u.Owner = (v.Owner).Copy()
	}

	return u
}

func (v *KeySpecParams) CopyAsInterface() interface{} { return v.Copy() }

func (v *LegacyED25519Signature) Copy() *LegacyED25519Signature {
	u := new(LegacyED25519Signature)

	u.Timestamp = v.Timestamp
	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = (v.Signer).Copy()
	}
	u.SignerVersion = v.SignerVersion
	u.Vote = v.Vote

	return u
}

func (v *LegacyED25519Signature) CopyAsInterface() interface{} { return v.Copy() }

func (v *LiteDataAccount) Copy() *LiteDataAccount {
	u := new(LiteDataAccount)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.Tail = encoding.BytesCopy(v.Tail)

	return u
}

func (v *LiteDataAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *LiteIdentity) Copy() *LiteIdentity {
	u := new(LiteIdentity)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}

	return u
}

func (v *LiteIdentity) CopyAsInterface() interface{} { return v.Copy() }

func (v *LiteTokenAccount) Copy() *LiteTokenAccount {
	u := new(LiteTokenAccount)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	if v.TokenUrl != nil {
		u.TokenUrl = (v.TokenUrl).Copy()
	}
	u.Balance = *encoding.BigintCopy(&v.Balance)
	u.LastUsedOn = v.LastUsedOn
	u.CreditBalance = v.CreditBalance

	return u
}

func (v *LiteTokenAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *MetricsRequest) Copy() *MetricsRequest {
	u := new(MetricsRequest)

	u.Metric = v.Metric
	u.Duration = v.Duration

	return u
}

func (v *MetricsRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *Object) Copy() *Object {
	u := new(Object)

	u.Type = v.Type
	u.Chains = make([]ChainMetadata, len(v.Chains))
	for i, v := range v.Chains {
		u.Chains[i] = *(&v).Copy()
	}

	return u
}

func (v *Object) CopyAsInterface() interface{} { return v.Copy() }

func (v *RCD1Signature) Copy() *RCD1Signature {
	u := new(RCD1Signature)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Signature = encoding.BytesCopy(v.Signature)
	if v.Signer != nil {
		u.Signer = (v.Signer).Copy()
	}
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote

	return u
}

func (v *RCD1Signature) CopyAsInterface() interface{} { return v.Copy() }

func (v *Receipt) Copy() *Receipt {
	u := new(Receipt)

	u.Start = encoding.BytesCopy(v.Start)
	u.Result = encoding.BytesCopy(v.Result)
	u.Entries = make([]ReceiptEntry, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = *(&v).Copy()
	}

	return u
}

func (v *Receipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *ReceiptEntry) Copy() *ReceiptEntry {
	u := new(ReceiptEntry)

	u.Right = v.Right
	u.Hash = encoding.BytesCopy(v.Hash)

	return u
}

func (v *ReceiptEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ReceiptSignature) Copy() *ReceiptSignature {
	u := new(ReceiptSignature)

	u.Receipt = *v.Receipt.Copy()
	if v.SourceNetwork != nil {
		u.SourceNetwork = (v.SourceNetwork).Copy()
	}

	return u
}

func (v *ReceiptSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *RemoteTransactionBody) Copy() *RemoteTransactionBody {
	u := new(RemoteTransactionBody)

	return u
}

func (v *RemoteTransactionBody) CopyAsInterface() interface{} { return v.Copy() }

func (v *RemoveAccountAuthorityOperation) Copy() *RemoveAccountAuthorityOperation {
	u := new(RemoveAccountAuthorityOperation)

	if v.Authority != nil {
		u.Authority = (v.Authority).Copy()
	}

	return u
}

func (v *RemoveAccountAuthorityOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *RemoveKeyOperation) Copy() *RemoveKeyOperation {
	u := new(RemoveKeyOperation)

	u.Entry = *(&v.Entry).Copy()

	return u
}

func (v *RemoveKeyOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *RemoveValidator) Copy() *RemoveValidator {
	u := new(RemoveValidator)

	u.Key = encoding.BytesCopy(v.Key)
	if v.Owner != nil {
		u.Owner = (v.Owner).Copy()
	}

	return u
}

func (v *RemoveValidator) CopyAsInterface() interface{} { return v.Copy() }

func (v *SegWitDataEntry) Copy() *SegWitDataEntry {
	u := new(SegWitDataEntry)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	if v.EntryUrl != nil {
		u.EntryUrl = (v.EntryUrl).Copy()
	}
	u.EntryHash = v.EntryHash

	return u
}

func (v *SegWitDataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *SendTokens) Copy() *SendTokens {
	u := new(SendTokens)

	u.Hash = v.Hash
	u.Meta = encoding.BytesCopy(v.Meta)
	u.To = make([]*TokenRecipient, len(v.To))
	for i, v := range v.To {
		if v != nil {
			u.To[i] = (v).Copy()
		}
	}

	return u
}

func (v *SendTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *SetThresholdKeyPageOperation) Copy() *SetThresholdKeyPageOperation {
	u := new(SetThresholdKeyPageOperation)

	u.Threshold = v.Threshold

	return u
}

func (v *SetThresholdKeyPageOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticAnchor) Copy() *SyntheticAnchor {
	u := new(SyntheticAnchor)

	if v.Source != nil {
		u.Source = (v.Source).Copy()
	}
	u.Major = v.Major
	u.RootAnchor = v.RootAnchor
	u.RootIndex = v.RootIndex
	u.AcmeBurnt = *encoding.BigintCopy(&v.AcmeBurnt)
	u.Block = v.Block
	u.AcmeOraclePrice = v.AcmeOraclePrice
	u.Receipts = make([]Receipt, len(v.Receipts))
	for i, v := range v.Receipts {
		u.Receipts[i] = *(&v).Copy()
	}

	return u
}

func (v *SyntheticAnchor) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticBurnTokens) Copy() *SyntheticBurnTokens {
	u := new(SyntheticBurnTokens)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	u.Amount = *encoding.BigintCopy(&v.Amount)

	return u
}

func (v *SyntheticBurnTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticCreateChain) Copy() *SyntheticCreateChain {
	u := new(SyntheticCreateChain)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	u.Chains = make([]ChainParams, len(v.Chains))
	for i, v := range v.Chains {
		u.Chains[i] = *(&v).Copy()
	}

	return u
}

func (v *SyntheticCreateChain) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticDepositCredits) Copy() *SyntheticDepositCredits {
	u := new(SyntheticDepositCredits)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	u.Amount = v.Amount

	return u
}

func (v *SyntheticDepositCredits) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticDepositTokens) Copy() *SyntheticDepositTokens {
	u := new(SyntheticDepositTokens)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	if v.Token != nil {
		u.Token = (v.Token).Copy()
	}
	u.Amount = *encoding.BigintCopy(&v.Amount)

	return u
}

func (v *SyntheticDepositTokens) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticForwardTransaction) Copy() *SyntheticForwardTransaction {
	u := new(SyntheticForwardTransaction)

	u.Signatures = make([]ForwardedSignature, len(v.Signatures))
	for i, v := range v.Signatures {
		u.Signatures[i] = *(&v).Copy()
	}
	u.TransactionHash = encoding.BytesCopy(v.TransactionHash)
	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}

	return u
}

func (v *SyntheticForwardTransaction) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticLedger) Copy() *SyntheticLedger {
	u := new(SyntheticLedger)

	u.Nonce = v.Nonce
	u.Unsigned = make([][32]byte, len(v.Unsigned))
	for i, v := range v.Unsigned {
		u.Unsigned[i] = v
	}
	u.Unsent = make([][32]byte, len(v.Unsent))
	for i, v := range v.Unsent {
		u.Unsent[i] = v
	}

	return u
}

func (v *SyntheticLedger) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticLedgerEntry) Copy() *SyntheticLedgerEntry {
	u := new(SyntheticLedgerEntry)

	u.TransactionHash = v.TransactionHash
	u.RootAnchor = v.RootAnchor
	u.SynthIndex = v.SynthIndex
	u.SynthIndexIndex = v.SynthIndexIndex
	u.RootIndexIndex = v.RootIndexIndex
	u.NeedsReceipt = v.NeedsReceipt

	return u
}

func (v *SyntheticLedgerEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticMirror) Copy() *SyntheticMirror {
	u := new(SyntheticMirror)

	u.Objects = make([]AnchoredRecord, len(v.Objects))
	for i, v := range v.Objects {
		u.Objects[i] = *(&v).Copy()
	}

	return u
}

func (v *SyntheticMirror) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticOrigin) Copy() *SyntheticOrigin {
	u := new(SyntheticOrigin)

	if v.Source != nil {
		u.Source = (v.Source).Copy()
	}
	u.Cause = v.Cause

	return u
}

func (v *SyntheticOrigin) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticReceipt) Copy() *SyntheticReceipt {
	u := new(SyntheticReceipt)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	u.SynthTxHash = v.SynthTxHash
	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}

	return u
}

func (v *SyntheticReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticSignature) Copy() *SyntheticSignature {
	u := new(SyntheticSignature)

	if v.SourceNetwork != nil {
		u.SourceNetwork = (v.SourceNetwork).Copy()
	}
	if v.DestinationNetwork != nil {
		u.DestinationNetwork = (v.DestinationNetwork).Copy()
	}
	u.SequenceNumber = v.SequenceNumber

	return u
}

func (v *SyntheticSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticWriteData) Copy() *SyntheticWriteData {
	u := new(SyntheticWriteData)

	u.SyntheticOrigin = *v.SyntheticOrigin.Copy()
	u.Entry = *(&v.Entry).Copy()

	return u
}

func (v *SyntheticWriteData) CopyAsInterface() interface{} { return v.Copy() }

func (v *TokenAccount) Copy() *TokenAccount {
	u := new(TokenAccount)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	if v.TokenUrl != nil {
		u.TokenUrl = (v.TokenUrl).Copy()
	}
	u.Balance = *encoding.BigintCopy(&v.Balance)
	u.Scratch = v.Scratch

	return u
}

func (v *TokenAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *TokenIssuer) Copy() *TokenIssuer {
	u := new(TokenIssuer)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.AccountAuth = *v.AccountAuth.Copy()
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	if v.Properties != nil {
		u.Properties = (v.Properties).Copy()
	}
	u.Issued = *encoding.BigintCopy(&v.Issued)
	if v.SupplyLimit != nil {
		u.SupplyLimit = encoding.BigintCopy(v.SupplyLimit)
	}

	return u
}

func (v *TokenIssuer) CopyAsInterface() interface{} { return v.Copy() }

func (v *TokenRecipient) Copy() *TokenRecipient {
	u := new(TokenRecipient)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.Amount = *encoding.BigintCopy(&v.Amount)

	return u
}

func (v *TokenRecipient) CopyAsInterface() interface{} { return v.Copy() }

func (v *Transaction) Copy() *Transaction {
	u := new(Transaction)

	u.Header = *(&v.Header).Copy()
	u.Body = v.Body

	return u
}

func (v *Transaction) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionHeader) Copy() *TransactionHeader {
	u := new(TransactionHeader)

	if v.Principal != nil {
		u.Principal = (v.Principal).Copy()
	}
	u.Initiator = v.Initiator
	u.Memo = v.Memo
	u.Metadata = encoding.BytesCopy(v.Metadata)

	return u
}

func (v *TransactionHeader) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionResultSet) Copy() *TransactionResultSet {
	u := new(TransactionResultSet)

	u.Results = make([]*TransactionStatus, len(v.Results))
	for i, v := range v.Results {
		if v != nil {
			u.Results[i] = (v).Copy()
		}
	}

	return u
}

func (v *TransactionResultSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionSignature) Copy() *TransactionSignature {
	u := new(TransactionSignature)

	u.Transaction = v.Transaction
	u.Signature = v.Signature

	return u
}

func (v *TransactionSignature) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionStatus) Copy() *TransactionStatus {
	u := new(TransactionStatus)

	u.Remote = v.Remote
	u.Delivered = v.Delivered
	u.Pending = v.Pending
	u.Code = v.Code
	u.Message = v.Message
	u.Result = v.Result
	if v.Initiator != nil {
		u.Initiator = (v.Initiator).Copy()
	}
	u.Signers = make([]Signer, len(v.Signers))
	for i, v := range v.Signers {
		u.Signers[i] = v
	}

	return u
}

func (v *TransactionStatus) CopyAsInterface() interface{} { return v.Copy() }

func (v *UnknownAccount) Copy() *UnknownAccount {
	u := new(UnknownAccount)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}

	return u
}

func (v *UnknownAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *UnknownSigner) Copy() *UnknownSigner {
	u := new(UnknownSigner)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.Version = v.Version

	return u
}

func (v *UnknownSigner) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateAccountAuth) Copy() *UpdateAccountAuth {
	u := new(UpdateAccountAuth)

	u.Operations = make([]AccountAuthOperation, len(v.Operations))
	for i, v := range v.Operations {
		u.Operations[i] = v
	}

	return u
}

func (v *UpdateAccountAuth) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateAllowedKeyPageOperation) Copy() *UpdateAllowedKeyPageOperation {
	u := new(UpdateAllowedKeyPageOperation)

	u.Allow = make([]TransactionType, len(v.Allow))
	for i, v := range v.Allow {
		u.Allow[i] = v
	}
	u.Deny = make([]TransactionType, len(v.Deny))
	for i, v := range v.Deny {
		u.Deny[i] = v
	}

	return u
}

func (v *UpdateAllowedKeyPageOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateKey) Copy() *UpdateKey {
	u := new(UpdateKey)

	u.NewKeyHash = encoding.BytesCopy(v.NewKeyHash)

	return u
}

func (v *UpdateKey) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateKeyOperation) Copy() *UpdateKeyOperation {
	u := new(UpdateKeyOperation)

	u.OldEntry = *(&v.OldEntry).Copy()
	u.NewEntry = *(&v.NewEntry).Copy()

	return u
}

func (v *UpdateKeyOperation) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateKeyPage) Copy() *UpdateKeyPage {
	u := new(UpdateKeyPage)

	u.Operation = make([]KeyPageOperation, len(v.Operation))
	for i, v := range v.Operation {
		u.Operation[i] = v
	}

	return u
}

func (v *UpdateKeyPage) CopyAsInterface() interface{} { return v.Copy() }

func (v *UpdateValidatorKey) Copy() *UpdateValidatorKey {
	u := new(UpdateValidatorKey)

	u.KeyHash = encoding.BytesCopy(v.KeyHash)
	u.NewKeyHash = encoding.BytesCopy(v.NewKeyHash)

	return u
}

func (v *UpdateValidatorKey) CopyAsInterface() interface{} { return v.Copy() }

func (v *WriteData) Copy() *WriteData {
	u := new(WriteData)

	u.Entry = *(&v.Entry).Copy()

	return u
}

func (v *WriteData) CopyAsInterface() interface{} { return v.Copy() }

func (v *WriteDataResult) Copy() *WriteDataResult {
	u := new(WriteDataResult)

	u.EntryHash = v.EntryHash
	if v.AccountUrl != nil {
		u.AccountUrl = (v.AccountUrl).Copy()
	}
	u.AccountID = encoding.BytesCopy(v.AccountID)

	return u
}

func (v *WriteDataResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *WriteDataTo) Copy() *WriteDataTo {
	u := new(WriteDataTo)

	if v.Recipient != nil {
		u.Recipient = (v.Recipient).Copy()
	}
	u.Entry = *(&v.Entry).Copy()

	return u
}

func (v *WriteDataTo) CopyAsInterface() interface{} { return v.Copy() }

func (v *ADI) Equal(u *ADI) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}

	return true
}

func (v *AccountAuth) Equal(u *AccountAuth) bool {
	if len(v.Authorities) != len(u.Authorities) {
		return false
	}
	for i := range v.Authorities {
		if !((&v.Authorities[i]).Equal(&u.Authorities[i])) {
			return false
		}
	}

	return true
}

func (v *AcmeFaucet) Equal(u *AcmeFaucet) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}

	return true
}

func (v *AcmeOracle) Equal(u *AcmeOracle) bool {
	if !(v.Price == u.Price) {
		return false
	}

	return true
}

func (v *AddAccountAuthorityOperation) Equal(u *AddAccountAuthorityOperation) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *AddCredits) Equal(u *AddCredits) bool {
	switch {
	case v.Recipient == u.Recipient:
		// equal
	case v.Recipient == nil || u.Recipient == nil:
		return false
	case !((v.Recipient).Equal(u.Recipient)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}
	if !(v.Oracle == u.Oracle) {
		return false
	}

	return true
}

func (v *AddCreditsResult) Equal(u *AddCreditsResult) bool {
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}
	if !(v.Credits == u.Credits) {
		return false
	}
	if !(v.Oracle == u.Oracle) {
		return false
	}

	return true
}

func (v *AddKeyOperation) Equal(u *AddKeyOperation) bool {
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *AddValidator) Equal(u *AddValidator) bool {
	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}
	switch {
	case v.Owner == u.Owner:
		// equal
	case v.Owner == nil || u.Owner == nil:
		return false
	case !((v.Owner).Equal(u.Owner)):
		return false
	}

	return true
}

func (v *Anchor) Equal(u *Anchor) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}

	return true
}

func (v *AnchorMetadata) Equal(u *AnchorMetadata) bool {
	if !v.ChainMetadata.Equal(&u.ChainMetadata) {
		return false
	}
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !(v.SourceIndex == u.SourceIndex) {
		return false
	}
	if !(v.SourceBlock == u.SourceBlock) {
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}

	return true
}

func (v *AnchoredRecord) Equal(u *AnchoredRecord) bool {
	if !(bytes.Equal(v.Record, u.Record)) {
		return false
	}
	if !(v.Anchor == u.Anchor) {
		return false
	}

	return true
}

func (v *AuthorityEntry) Equal(u *AuthorityEntry) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Disabled == u.Disabled) {
		return false
	}

	return true
}

func (v *BurnTokens) Equal(u *BurnTokens) bool {
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *ChainMetadata) Equal(u *ChainMetadata) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *ChainParams) Equal(u *ChainParams) bool {
	if !(bytes.Equal(v.Data, u.Data)) {
		return false
	}
	if !(v.IsUpdate == u.IsUpdate) {
		return false
	}

	return true
}

func (v *CreateDataAccount) Equal(u *CreateDataAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	switch {
	case v.KeyBookUrl == u.KeyBookUrl:
		// equal
	case v.KeyBookUrl == nil || u.KeyBookUrl == nil:
		return false
	case !((v.KeyBookUrl).Equal(u.KeyBookUrl)):
		return false
	}
	switch {
	case v.ManagerKeyBookUrl == u.ManagerKeyBookUrl:
		// equal
	case v.ManagerKeyBookUrl == nil || u.ManagerKeyBookUrl == nil:
		return false
	case !((v.ManagerKeyBookUrl).Equal(u.ManagerKeyBookUrl)):
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *CreateIdentity) Equal(u *CreateIdentity) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(bytes.Equal(v.KeyHash, u.KeyHash)) {
		return false
	}
	switch {
	case v.KeyBookUrl == u.KeyBookUrl:
		// equal
	case v.KeyBookUrl == nil || u.KeyBookUrl == nil:
		return false
	case !((v.KeyBookUrl).Equal(u.KeyBookUrl)):
		return false
	}
	switch {
	case v.Manager == u.Manager:
		// equal
	case v.Manager == nil || u.Manager == nil:
		return false
	case !((v.Manager).Equal(u.Manager)):
		return false
	}

	return true
}

func (v *CreateKeyBook) Equal(u *CreateKeyBook) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(bytes.Equal(v.PublicKeyHash, u.PublicKeyHash)) {
		return false
	}
	switch {
	case v.Manager == u.Manager:
		// equal
	case v.Manager == nil || u.Manager == nil:
		return false
	case !((v.Manager).Equal(u.Manager)):
		return false
	}

	return true
}

func (v *CreateKeyPage) Equal(u *CreateKeyPage) bool {
	if len(v.Keys) != len(u.Keys) {
		return false
	}
	for i := range v.Keys {
		if !((v.Keys[i]).Equal(u.Keys[i])) {
			return false
		}
	}
	switch {
	case v.Manager == u.Manager:
		// equal
	case v.Manager == nil || u.Manager == nil:
		return false
	case !((v.Manager).Equal(u.Manager)):
		return false
	}

	return true
}

func (v *CreateToken) Equal(u *CreateToken) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	switch {
	case v.KeyBookUrl == u.KeyBookUrl:
		// equal
	case v.KeyBookUrl == nil || u.KeyBookUrl == nil:
		return false
	case !((v.KeyBookUrl).Equal(u.KeyBookUrl)):
		return false
	}
	if !(v.Symbol == u.Symbol) {
		return false
	}
	if !(v.Precision == u.Precision) {
		return false
	}
	switch {
	case v.Properties == u.Properties:
		// equal
	case v.Properties == nil || u.Properties == nil:
		return false
	case !((v.Properties).Equal(u.Properties)):
		return false
	}
	switch {
	case v.SupplyLimit == u.SupplyLimit:
		// equal
	case v.SupplyLimit == nil || u.SupplyLimit == nil:
		return false
	case !((v.SupplyLimit).Cmp(u.SupplyLimit) == 0):
		return false
	}
	switch {
	case v.Manager == u.Manager:
		// equal
	case v.Manager == nil || u.Manager == nil:
		return false
	case !((v.Manager).Equal(u.Manager)):
		return false
	}

	return true
}

func (v *CreateTokenAccount) Equal(u *CreateTokenAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	switch {
	case v.TokenUrl == u.TokenUrl:
		// equal
	case v.TokenUrl == nil || u.TokenUrl == nil:
		return false
	case !((v.TokenUrl).Equal(u.TokenUrl)):
		return false
	}
	switch {
	case v.KeyBookUrl == u.KeyBookUrl:
		// equal
	case v.KeyBookUrl == nil || u.KeyBookUrl == nil:
		return false
	case !((v.KeyBookUrl).Equal(u.KeyBookUrl)):
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}
	switch {
	case v.Manager == u.Manager:
		// equal
	case v.Manager == nil || u.Manager == nil:
		return false
	case !((v.Manager).Equal(u.Manager)):
		return false
	}

	return true
}

func (v *DataAccount) Equal(u *DataAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *DataEntry) Equal(u *DataEntry) bool {
	if len(v.Data) != len(u.Data) {
		return false
	}
	for i := range v.Data {
		if !(bytes.Equal(v.Data[i], u.Data[i])) {
			return false
		}
	}

	return true
}

func (v *DirectoryIndexMetadata) Equal(u *DirectoryIndexMetadata) bool {
	if !(v.Count == u.Count) {
		return false
	}

	return true
}

func (v *DisableAccountAuthOperation) Equal(u *DisableAccountAuthOperation) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *ED25519Signature) Equal(u *ED25519Signature) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}

	return true
}

func (v *EmptyResult) Equal(u *EmptyResult) bool {

	return true
}

func (v *EnableAccountAuthOperation) Equal(u *EnableAccountAuthOperation) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *Envelope) Equal(u *Envelope) bool {
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(v.Signatures[i] == u.Signatures[i]) {
			return false
		}
	}
	if !(bytes.Equal(v.TxHash, u.TxHash)) {
		return false
	}
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}

	return true
}

func (v *ForwardedSignature) Equal(u *ForwardedSignature) bool {
	if !(v.Signature == u.Signature) {
		return false
	}
	if !(v.Signer == u.Signer) {
		return false
	}

	return true
}

func (v *HashSet) Equal(u *HashSet) bool {
	if len(v.Hashes) != len(u.Hashes) {
		return false
	}
	for i := range v.Hashes {
		if !(v.Hashes[i] == u.Hashes[i]) {
			return false
		}
	}

	return true
}

func (v *IndexEntry) Equal(u *IndexEntry) bool {
	if !(v.Source == u.Source) {
		return false
	}
	if !(v.Anchor == u.Anchor) {
		return false
	}
	if !(v.BlockIndex == u.BlockIndex) {
		return false
	}
	switch {
	case v.BlockTime == u.BlockTime:
		// equal
	case v.BlockTime == nil || u.BlockTime == nil:
		return false
	case !(*v.BlockTime == *u.BlockTime):
		return false
	}

	return true
}

func (v *InternalGenesis) Equal(u *InternalGenesis) bool {

	return true
}

func (v *InternalLedger) Equal(u *InternalLedger) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !((&v.Synthetic).Equal(&u.Synthetic)) {
		return false
	}
	if !(v.PendingOracle == u.PendingOracle) {
		return false
	}
	if !(v.ActiveOracle == u.ActiveOracle) {
		return false
	}
	if !((&v.AcmeBurnt).Cmp(&u.AcmeBurnt) == 0) {
		return false
	}

	return true
}

func (v *InternalSignature) Equal(u *InternalSignature) bool {
	switch {
	case v.Network == u.Network:
		// equal
	case v.Network == nil || u.Network == nil:
		return false
	case !((v.Network).Equal(u.Network)):
		return false
	}

	return true
}

func (v *InternalSyntheticLedger) Equal(u *InternalSyntheticLedger) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	if len(v.Pending) != len(u.Pending) {
		return false
	}
	for i := range v.Pending {
		if !((v.Pending[i]).Equal(u.Pending[i])) {
			return false
		}
	}

	return true
}

func (v *InternalTransactionsSent) Equal(u *InternalTransactionsSent) bool {
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !(v.Transactions[i] == u.Transactions[i]) {
			return false
		}
	}

	return true
}

func (v *InternalTransactionsSigned) Equal(u *InternalTransactionsSigned) bool {
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((&v.Transactions[i]).Equal(&u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *IssueTokens) Equal(u *IssueTokens) bool {
	switch {
	case v.Recipient == u.Recipient:
		// equal
	case v.Recipient == nil || u.Recipient == nil:
		return false
	case !((v.Recipient).Equal(u.Recipient)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *KeyBook) Equal(u *KeyBook) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	if !(v.PageCount == u.PageCount) {
		return false
	}

	return true
}

func (v *KeyPage) Equal(u *KeyPage) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.CreditBalance == u.CreditBalance) {
		return false
	}
	if !(v.AcceptThreshold == u.AcceptThreshold) {
		return false
	}
	if !(v.RejectThreshold == u.RejectThreshold) {
		return false
	}
	if !(v.ResponseThreshold == u.ResponseThreshold) {
		return false
	}
	if !(v.BlockThreshold == u.BlockThreshold) {
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if len(v.Keys) != len(u.Keys) {
		return false
	}
	for i := range v.Keys {
		if !((v.Keys[i]).Equal(u.Keys[i])) {
			return false
		}
	}
	switch {
	case v.TransactionBlacklist == u.TransactionBlacklist:
		// equal
	case v.TransactionBlacklist == nil || u.TransactionBlacklist == nil:
		return false
	case !(*v.TransactionBlacklist == *u.TransactionBlacklist):
		return false
	}

	return true
}

func (v *KeySpec) Equal(u *KeySpec) bool {
	if !(bytes.Equal(v.PublicKeyHash, u.PublicKeyHash)) {
		return false
	}
	if !(v.LastUsedOn == u.LastUsedOn) {
		return false
	}
	switch {
	case v.Owner == u.Owner:
		// equal
	case v.Owner == nil || u.Owner == nil:
		return false
	case !((v.Owner).Equal(u.Owner)):
		return false
	}

	return true
}

func (v *KeySpecParams) Equal(u *KeySpecParams) bool {
	if !(bytes.Equal(v.KeyHash, u.KeyHash)) {
		return false
	}
	switch {
	case v.Owner == u.Owner:
		// equal
	case v.Owner == nil || u.Owner == nil:
		return false
	case !((v.Owner).Equal(u.Owner)):
		return false
	}

	return true
}

func (v *LegacyED25519Signature) Equal(u *LegacyED25519Signature) bool {
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}

	return true
}

func (v *LiteDataAccount) Equal(u *LiteDataAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(bytes.Equal(v.Tail, u.Tail)) {
		return false
	}

	return true
}

func (v *LiteIdentity) Equal(u *LiteIdentity) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}

	return true
}

func (v *LiteTokenAccount) Equal(u *LiteTokenAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	switch {
	case v.TokenUrl == u.TokenUrl:
		// equal
	case v.TokenUrl == nil || u.TokenUrl == nil:
		return false
	case !((v.TokenUrl).Equal(u.TokenUrl)):
		return false
	}
	if !((&v.Balance).Cmp(&u.Balance) == 0) {
		return false
	}
	if !(v.LastUsedOn == u.LastUsedOn) {
		return false
	}
	if !(v.CreditBalance == u.CreditBalance) {
		return false
	}

	return true
}

func (v *MetricsRequest) Equal(u *MetricsRequest) bool {
	if !(v.Metric == u.Metric) {
		return false
	}
	if !(v.Duration == u.Duration) {
		return false
	}

	return true
}

func (v *Object) Equal(u *Object) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if len(v.Chains) != len(u.Chains) {
		return false
	}
	for i := range v.Chains {
		if !((&v.Chains[i]).Equal(&u.Chains[i])) {
			return false
		}
	}

	return true
}

func (v *RCD1Signature) Equal(u *RCD1Signature) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.SignerVersion == u.SignerVersion) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	if !(v.Vote == u.Vote) {
		return false
	}

	return true
}

func (v *Receipt) Equal(u *Receipt) bool {
	if !(bytes.Equal(v.Start, u.Start)) {
		return false
	}
	if !(bytes.Equal(v.Result, u.Result)) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((&v.Entries[i]).Equal(&u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ReceiptEntry) Equal(u *ReceiptEntry) bool {
	if !(v.Right == u.Right) {
		return false
	}
	if !(bytes.Equal(v.Hash, u.Hash)) {
		return false
	}

	return true
}

func (v *ReceiptSignature) Equal(u *ReceiptSignature) bool {
	if !v.Receipt.Equal(&u.Receipt) {
		return false
	}
	switch {
	case v.SourceNetwork == u.SourceNetwork:
		// equal
	case v.SourceNetwork == nil || u.SourceNetwork == nil:
		return false
	case !((v.SourceNetwork).Equal(u.SourceNetwork)):
		return false
	}

	return true
}

func (v *RemoteTransactionBody) Equal(u *RemoteTransactionBody) bool {

	return true
}

func (v *RemoveAccountAuthorityOperation) Equal(u *RemoveAccountAuthorityOperation) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}

	return true
}

func (v *RemoveKeyOperation) Equal(u *RemoveKeyOperation) bool {
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *RemoveValidator) Equal(u *RemoveValidator) bool {
	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}
	switch {
	case v.Owner == u.Owner:
		// equal
	case v.Owner == nil || u.Owner == nil:
		return false
	case !((v.Owner).Equal(u.Owner)):
		return false
	}

	return true
}

func (v *SegWitDataEntry) Equal(u *SegWitDataEntry) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	switch {
	case v.EntryUrl == u.EntryUrl:
		// equal
	case v.EntryUrl == nil || u.EntryUrl == nil:
		return false
	case !((v.EntryUrl).Equal(u.EntryUrl)):
		return false
	}
	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	return true
}

func (v *SendTokens) Equal(u *SendTokens) bool {
	if !(v.Hash == u.Hash) {
		return false
	}
	if !(bytes.Equal(v.Meta, u.Meta)) {
		return false
	}
	if len(v.To) != len(u.To) {
		return false
	}
	for i := range v.To {
		if !((v.To[i]).Equal(u.To[i])) {
			return false
		}
	}

	return true
}

func (v *SetThresholdKeyPageOperation) Equal(u *SetThresholdKeyPageOperation) bool {
	if !(v.Threshold == u.Threshold) {
		return false
	}

	return true
}

func (v *SyntheticAnchor) Equal(u *SyntheticAnchor) bool {
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	if !(v.Major == u.Major) {
		return false
	}
	if !(v.RootAnchor == u.RootAnchor) {
		return false
	}
	if !(v.RootIndex == u.RootIndex) {
		return false
	}
	if !((&v.AcmeBurnt).Cmp(&u.AcmeBurnt) == 0) {
		return false
	}
	if !(v.Block == u.Block) {
		return false
	}
	if !(v.AcmeOraclePrice == u.AcmeOraclePrice) {
		return false
	}
	if len(v.Receipts) != len(u.Receipts) {
		return false
	}
	for i := range v.Receipts {
		if !((&v.Receipts[i]).Equal(&u.Receipts[i])) {
			return false
		}
	}

	return true
}

func (v *SyntheticBurnTokens) Equal(u *SyntheticBurnTokens) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *SyntheticCreateChain) Equal(u *SyntheticCreateChain) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if len(v.Chains) != len(u.Chains) {
		return false
	}
	for i := range v.Chains {
		if !((&v.Chains[i]).Equal(&u.Chains[i])) {
			return false
		}
	}

	return true
}

func (v *SyntheticDepositCredits) Equal(u *SyntheticDepositCredits) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if !(v.Amount == u.Amount) {
		return false
	}

	return true
}

func (v *SyntheticDepositTokens) Equal(u *SyntheticDepositTokens) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	switch {
	case v.Token == u.Token:
		// equal
	case v.Token == nil || u.Token == nil:
		return false
	case !((v.Token).Equal(u.Token)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *SyntheticForwardTransaction) Equal(u *SyntheticForwardTransaction) bool {
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !((&v.Signatures[i]).Equal(&u.Signatures[i])) {
			return false
		}
	}
	if !(bytes.Equal(v.TransactionHash, u.TransactionHash)) {
		return false
	}
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}

	return true
}

func (v *SyntheticLedger) Equal(u *SyntheticLedger) bool {
	if !(v.Nonce == u.Nonce) {
		return false
	}
	if len(v.Unsigned) != len(u.Unsigned) {
		return false
	}
	for i := range v.Unsigned {
		if !(v.Unsigned[i] == u.Unsigned[i]) {
			return false
		}
	}
	if len(v.Unsent) != len(u.Unsent) {
		return false
	}
	for i := range v.Unsent {
		if !(v.Unsent[i] == u.Unsent[i]) {
			return false
		}
	}

	return true
}

func (v *SyntheticLedgerEntry) Equal(u *SyntheticLedgerEntry) bool {
	if !(v.TransactionHash == u.TransactionHash) {
		return false
	}
	if !(v.RootAnchor == u.RootAnchor) {
		return false
	}
	if !(v.SynthIndex == u.SynthIndex) {
		return false
	}
	if !(v.SynthIndexIndex == u.SynthIndexIndex) {
		return false
	}
	if !(v.RootIndexIndex == u.RootIndexIndex) {
		return false
	}
	if !(v.NeedsReceipt == u.NeedsReceipt) {
		return false
	}

	return true
}

func (v *SyntheticMirror) Equal(u *SyntheticMirror) bool {
	if len(v.Objects) != len(u.Objects) {
		return false
	}
	for i := range v.Objects {
		if !((&v.Objects[i]).Equal(&u.Objects[i])) {
			return false
		}
	}

	return true
}

func (v *SyntheticOrigin) Equal(u *SyntheticOrigin) bool {
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	if !(v.Cause == u.Cause) {
		return false
	}

	return true
}

func (v *SyntheticReceipt) Equal(u *SyntheticReceipt) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if !(v.SynthTxHash == u.SynthTxHash) {
		return false
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}

	return true
}

func (v *SyntheticSignature) Equal(u *SyntheticSignature) bool {
	switch {
	case v.SourceNetwork == u.SourceNetwork:
		// equal
	case v.SourceNetwork == nil || u.SourceNetwork == nil:
		return false
	case !((v.SourceNetwork).Equal(u.SourceNetwork)):
		return false
	}
	switch {
	case v.DestinationNetwork == u.DestinationNetwork:
		// equal
	case v.DestinationNetwork == nil || u.DestinationNetwork == nil:
		return false
	case !((v.DestinationNetwork).Equal(u.DestinationNetwork)):
		return false
	}
	if !(v.SequenceNumber == u.SequenceNumber) {
		return false
	}

	return true
}

func (v *SyntheticWriteData) Equal(u *SyntheticWriteData) bool {
	if !v.SyntheticOrigin.Equal(&u.SyntheticOrigin) {
		return false
	}
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *TokenAccount) Equal(u *TokenAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	switch {
	case v.TokenUrl == u.TokenUrl:
		// equal
	case v.TokenUrl == nil || u.TokenUrl == nil:
		return false
	case !((v.TokenUrl).Equal(u.TokenUrl)):
		return false
	}
	if !((&v.Balance).Cmp(&u.Balance) == 0) {
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *TokenIssuer) Equal(u *TokenIssuer) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !v.AccountAuth.Equal(&u.AccountAuth) {
		return false
	}
	if !(v.Symbol == u.Symbol) {
		return false
	}
	if !(v.Precision == u.Precision) {
		return false
	}
	switch {
	case v.Properties == u.Properties:
		// equal
	case v.Properties == nil || u.Properties == nil:
		return false
	case !((v.Properties).Equal(u.Properties)):
		return false
	}
	if !((&v.Issued).Cmp(&u.Issued) == 0) {
		return false
	}
	switch {
	case v.SupplyLimit == u.SupplyLimit:
		// equal
	case v.SupplyLimit == nil || u.SupplyLimit == nil:
		return false
	case !((v.SupplyLimit).Cmp(u.SupplyLimit) == 0):
		return false
	}

	return true
}

func (v *TokenRecipient) Equal(u *TokenRecipient) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}

	return true
}

func (v *Transaction) Equal(u *Transaction) bool {
	if !((&v.Header).Equal(&u.Header)) {
		return false
	}
	if !(v.Body == u.Body) {
		return false
	}

	return true
}

func (v *TransactionHeader) Equal(u *TransactionHeader) bool {
	switch {
	case v.Principal == u.Principal:
		// equal
	case v.Principal == nil || u.Principal == nil:
		return false
	case !((v.Principal).Equal(u.Principal)):
		return false
	}
	if !(v.Initiator == u.Initiator) {
		return false
	}
	if !(v.Memo == u.Memo) {
		return false
	}
	if !(bytes.Equal(v.Metadata, u.Metadata)) {
		return false
	}

	return true
}

func (v *TransactionResultSet) Equal(u *TransactionResultSet) bool {
	if len(v.Results) != len(u.Results) {
		return false
	}
	for i := range v.Results {
		if !((v.Results[i]).Equal(u.Results[i])) {
			return false
		}
	}

	return true
}

func (v *TransactionSignature) Equal(u *TransactionSignature) bool {
	if !(v.Transaction == u.Transaction) {
		return false
	}
	if !(v.Signature == u.Signature) {
		return false
	}

	return true
}

func (v *TransactionStatus) Equal(u *TransactionStatus) bool {
	if !(v.Remote == u.Remote) {
		return false
	}
	if !(v.Delivered == u.Delivered) {
		return false
	}
	if !(v.Pending == u.Pending) {
		return false
	}
	if !(v.Code == u.Code) {
		return false
	}
	if !(v.Message == u.Message) {
		return false
	}
	if !(v.Result == u.Result) {
		return false
	}
	switch {
	case v.Initiator == u.Initiator:
		// equal
	case v.Initiator == nil || u.Initiator == nil:
		return false
	case !((v.Initiator).Equal(u.Initiator)):
		return false
	}
	if len(v.Signers) != len(u.Signers) {
		return false
	}
	for i := range v.Signers {
		if !(v.Signers[i] == u.Signers[i]) {
			return false
		}
	}

	return true
}

func (v *UnknownAccount) Equal(u *UnknownAccount) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}

	return true
}

func (v *UnknownSigner) Equal(u *UnknownSigner) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}

	return true
}

func (v *UpdateAccountAuth) Equal(u *UpdateAccountAuth) bool {
	if len(v.Operations) != len(u.Operations) {
		return false
	}
	for i := range v.Operations {
		if !(v.Operations[i] == u.Operations[i]) {
			return false
		}
	}

	return true
}

func (v *UpdateAllowedKeyPageOperation) Equal(u *UpdateAllowedKeyPageOperation) bool {
	if len(v.Allow) != len(u.Allow) {
		return false
	}
	for i := range v.Allow {
		if !(v.Allow[i] == u.Allow[i]) {
			return false
		}
	}
	if len(v.Deny) != len(u.Deny) {
		return false
	}
	for i := range v.Deny {
		if !(v.Deny[i] == u.Deny[i]) {
			return false
		}
	}

	return true
}

func (v *UpdateKey) Equal(u *UpdateKey) bool {
	if !(bytes.Equal(v.NewKeyHash, u.NewKeyHash)) {
		return false
	}

	return true
}

func (v *UpdateKeyOperation) Equal(u *UpdateKeyOperation) bool {
	if !((&v.OldEntry).Equal(&u.OldEntry)) {
		return false
	}
	if !((&v.NewEntry).Equal(&u.NewEntry)) {
		return false
	}

	return true
}

func (v *UpdateKeyPage) Equal(u *UpdateKeyPage) bool {
	if len(v.Operation) != len(u.Operation) {
		return false
	}
	for i := range v.Operation {
		if !(v.Operation[i] == u.Operation[i]) {
			return false
		}
	}

	return true
}

func (v *UpdateValidatorKey) Equal(u *UpdateValidatorKey) bool {
	if !(bytes.Equal(v.KeyHash, u.KeyHash)) {
		return false
	}
	if !(bytes.Equal(v.NewKeyHash, u.NewKeyHash)) {
		return false
	}

	return true
}

func (v *WriteData) Equal(u *WriteData) bool {
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *WriteDataResult) Equal(u *WriteDataResult) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}
	switch {
	case v.AccountUrl == u.AccountUrl:
		// equal
	case v.AccountUrl == nil || u.AccountUrl == nil:
		return false
	case !((v.AccountUrl).Equal(u.AccountUrl)):
		return false
	}
	if !(bytes.Equal(v.AccountID, u.AccountID)) {
		return false
	}

	return true
}

func (v *WriteDataTo) Equal(u *WriteDataTo) bool {
	switch {
	case v.Recipient == u.Recipient:
		// equal
	case v.Recipient == nil || u.Recipient == nil:
		return false
	case !((v.Recipient).Equal(u.Recipient)):
		return false
	}
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

var fieldNames_ADI = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
}

func (v *ADI) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, &v.AccountAuth)

	_, _, err := writer.Reset(fieldNames_ADI)
	return buffer.Bytes(), err
}

func (v *ADI) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AccountAuth = []string{
	1: "Authorities",
}

func (v *AccountAuth) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Authorities) == 0) {
		for _, v := range v.Authorities {
			writer.WriteValue(1, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_AccountAuth)
	return buffer.Bytes(), err
}

func (v *AccountAuth) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authorities is missing")
	} else if len(v.Authorities) == 0 {
		errs = append(errs, "field Authorities is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AcmeFaucet = []string{
	1: "Type",
	2: "Url",
}

func (v *AcmeFaucet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}

	_, _, err := writer.Reset(fieldNames_AcmeFaucet)
	return buffer.Bytes(), err
}

func (v *AcmeFaucet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AcmeOracle = []string{
	1: "Price",
}

func (v *AcmeOracle) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Price == 0) {
		writer.WriteUint(1, v.Price)
	}

	_, _, err := writer.Reset(fieldNames_AcmeOracle)
	return buffer.Bytes(), err
}

func (v *AcmeOracle) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Price is missing")
	} else if v.Price == 0 {
		errs = append(errs, "field Price is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddAccountAuthorityOperation = []string{
	1: "Type",
	2: "Authority",
}

func (v *AddAccountAuthorityOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_AddAccountAuthorityOperation)
	return buffer.Bytes(), err
}

func (v *AddAccountAuthorityOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddCredits = []string{
	1: "Type",
	2: "Recipient",
	3: "Amount",
	4: "Oracle",
}

func (v *AddCredits) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Recipient == nil) {
		writer.WriteUrl(2, v.Recipient)
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(3, &v.Amount)
	}
	if !(v.Oracle == 0) {
		writer.WriteUint(4, v.Oracle)
	}

	_, _, err := writer.Reset(fieldNames_AddCredits)
	return buffer.Bytes(), err
}

func (v *AddCredits) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Recipient is missing")
	} else if v.Recipient == nil {
		errs = append(errs, "field Recipient is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddCreditsResult = []string{
	1: "Type",
	2: "Amount",
	3: "Credits",
	4: "Oracle",
}

func (v *AddCreditsResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(2, &v.Amount)
	}
	if !(v.Credits == 0) {
		writer.WriteUint(3, v.Credits)
	}
	if !(v.Oracle == 0) {
		writer.WriteUint(4, v.Oracle)
	}

	_, _, err := writer.Reset(fieldNames_AddCreditsResult)
	return buffer.Bytes(), err
}

func (v *AddCreditsResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Credits is missing")
	} else if v.Credits == 0 {
		errs = append(errs, "field Credits is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Oracle is missing")
	} else if v.Oracle == 0 {
		errs = append(errs, "field Oracle is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddKeyOperation = []string{
	1: "Type",
	2: "Entry",
}

func (v *AddKeyOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Entry).Equal(new(KeySpecParams))) {
		writer.WriteValue(2, &v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_AddKeyOperation)
	return buffer.Bytes(), err
}

func (v *AddKeyOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(KeySpecParams)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AddValidator = []string{
	1: "Type",
	2: "Key",
	3: "Owner",
}

func (v *AddValidator) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Key) == 0) {
		writer.WriteBytes(2, v.Key)
	}
	if !(v.Owner == nil) {
		writer.WriteUrl(3, v.Owner)
	}

	_, _, err := writer.Reset(fieldNames_AddValidator)
	return buffer.Bytes(), err
}

func (v *AddValidator) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Key is missing")
	} else if len(v.Key) == 0 {
		errs = append(errs, "field Key is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Anchor = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
}

func (v *Anchor) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, &v.AccountAuth)

	_, _, err := writer.Reset(fieldNames_Anchor)
	return buffer.Bytes(), err
}

func (v *Anchor) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AnchorMetadata = []string{
	1: "ChainMetadata",
	2: "Account",
	3: "Index",
	4: "SourceIndex",
	5: "SourceBlock",
	6: "Entry",
}

func (v *AnchorMetadata) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, &v.ChainMetadata)
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(v.Index == 0) {
		writer.WriteUint(3, v.Index)
	}
	if !(v.SourceIndex == 0) {
		writer.WriteUint(4, v.SourceIndex)
	}
	if !(v.SourceBlock == 0) {
		writer.WriteUint(5, v.SourceBlock)
	}
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(6, v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_AnchorMetadata)
	return buffer.Bytes(), err
}

func (v *AnchorMetadata) IsValid() error {
	var errs []string

	if err := v.ChainMetadata.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SourceIndex is missing")
	} else if v.SourceIndex == 0 {
		errs = append(errs, "field SourceIndex is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field SourceBlock is missing")
	} else if v.SourceBlock == 0 {
		errs = append(errs, "field SourceBlock is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Entry is missing")
	} else if len(v.Entry) == 0 {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AnchoredRecord = []string{
	1: "Record",
	2: "Anchor",
}

func (v *AnchoredRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Record) == 0) {
		writer.WriteBytes(1, v.Record)
	}
	if !(v.Anchor == ([32]byte{})) {
		writer.WriteHash(2, &v.Anchor)
	}

	_, _, err := writer.Reset(fieldNames_AnchoredRecord)
	return buffer.Bytes(), err
}

func (v *AnchoredRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Record is missing")
	} else if len(v.Record) == 0 {
		errs = append(errs, "field Record is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Anchor is missing")
	} else if v.Anchor == ([32]byte{}) {
		errs = append(errs, "field Anchor is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AuthorityEntry = []string{
	1: "Url",
	2: "Disabled",
}

func (v *AuthorityEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(!v.Disabled) {
		writer.WriteBool(2, v.Disabled)
	}

	_, _, err := writer.Reset(fieldNames_AuthorityEntry)
	return buffer.Bytes(), err
}

func (v *AuthorityEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Disabled is missing")
	} else if !v.Disabled {
		errs = append(errs, "field Disabled is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BurnTokens = []string{
	1: "Type",
	2: "Amount",
}

func (v *BurnTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(2, &v.Amount)
	}

	_, _, err := writer.Reset(fieldNames_BurnTokens)
	return buffer.Bytes(), err
}

func (v *BurnTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainMetadata = []string{
	1: "Name",
	2: "Type",
}

func (v *ChainMetadata) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}

	_, _, err := writer.Reset(fieldNames_ChainMetadata)
	return buffer.Bytes(), err
}

func (v *ChainMetadata) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainParams = []string{
	1: "Data",
	2: "IsUpdate",
}

func (v *ChainParams) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Data) == 0) {
		writer.WriteBytes(1, v.Data)
	}
	if !(!v.IsUpdate) {
		writer.WriteBool(2, v.IsUpdate)
	}

	_, _, err := writer.Reset(fieldNames_ChainParams)
	return buffer.Bytes(), err
}

func (v *ChainParams) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Data is missing")
	} else if len(v.Data) == 0 {
		errs = append(errs, "field Data is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field IsUpdate is missing")
	} else if !v.IsUpdate {
		errs = append(errs, "field IsUpdate is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateDataAccount = []string{
	1: "Type",
	2: "Url",
	3: "KeyBookUrl",
	4: "ManagerKeyBookUrl",
	5: "Scratch",
}

func (v *CreateDataAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.KeyBookUrl == nil) {
		writer.WriteUrl(3, v.KeyBookUrl)
	}
	if !(v.ManagerKeyBookUrl == nil) {
		writer.WriteUrl(4, v.ManagerKeyBookUrl)
	}
	if !(!v.Scratch) {
		writer.WriteBool(5, v.Scratch)
	}

	_, _, err := writer.Reset(fieldNames_CreateDataAccount)
	return buffer.Bytes(), err
}

func (v *CreateDataAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateIdentity = []string{
	1: "Type",
	2: "Url",
	3: "KeyHash",
	4: "KeyBookUrl",
	5: "Manager",
}

func (v *CreateIdentity) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.KeyHash) == 0) {
		writer.WriteBytes(3, v.KeyHash)
	}
	if !(v.KeyBookUrl == nil) {
		writer.WriteUrl(4, v.KeyBookUrl)
	}
	if !(v.Manager == nil) {
		writer.WriteUrl(5, v.Manager)
	}

	_, _, err := writer.Reset(fieldNames_CreateIdentity)
	return buffer.Bytes(), err
}

func (v *CreateIdentity) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateKeyBook = []string{
	1: "Type",
	2: "Url",
	3: "PublicKeyHash",
	4: "Manager",
}

func (v *CreateKeyBook) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.PublicKeyHash) == 0) {
		writer.WriteBytes(3, v.PublicKeyHash)
	}
	if !(v.Manager == nil) {
		writer.WriteUrl(4, v.Manager)
	}

	_, _, err := writer.Reset(fieldNames_CreateKeyBook)
	return buffer.Bytes(), err
}

func (v *CreateKeyBook) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field PublicKeyHash is missing")
	} else if len(v.PublicKeyHash) == 0 {
		errs = append(errs, "field PublicKeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateKeyPage = []string{
	1: "Type",
	2: "Keys",
	3: "Manager",
}

func (v *CreateKeyPage) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Keys) == 0) {
		for _, v := range v.Keys {
			writer.WriteValue(2, v)
		}
	}
	if !(v.Manager == nil) {
		writer.WriteUrl(3, v.Manager)
	}

	_, _, err := writer.Reset(fieldNames_CreateKeyPage)
	return buffer.Bytes(), err
}

func (v *CreateKeyPage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Keys is missing")
	} else if len(v.Keys) == 0 {
		errs = append(errs, "field Keys is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateToken = []string{
	1: "Type",
	2: "Url",
	3: "KeyBookUrl",
	4: "Symbol",
	5: "Precision",
	6: "Properties",
	7: "SupplyLimit",
	8: "Manager",
}

func (v *CreateToken) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.KeyBookUrl == nil) {
		writer.WriteUrl(3, v.KeyBookUrl)
	}
	if !(len(v.Symbol) == 0) {
		writer.WriteString(4, v.Symbol)
	}
	if !(v.Precision == 0) {
		writer.WriteUint(5, v.Precision)
	}
	if !(v.Properties == nil) {
		writer.WriteUrl(6, v.Properties)
	}
	if !(v.SupplyLimit == nil) {
		writer.WriteBigInt(7, v.SupplyLimit)
	}
	if !(v.Manager == nil) {
		writer.WriteUrl(8, v.Manager)
	}

	_, _, err := writer.Reset(fieldNames_CreateToken)
	return buffer.Bytes(), err
}

func (v *CreateToken) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Symbol is missing")
	} else if len(v.Symbol) == 0 {
		errs = append(errs, "field Symbol is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Precision is missing")
	} else if v.Precision == 0 {
		errs = append(errs, "field Precision is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreateTokenAccount = []string{
	1: "Type",
	2: "Url",
	3: "TokenUrl",
	4: "KeyBookUrl",
	5: "Scratch",
	6: "Manager",
}

func (v *CreateTokenAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.TokenUrl == nil) {
		writer.WriteUrl(3, v.TokenUrl)
	}
	if !(v.KeyBookUrl == nil) {
		writer.WriteUrl(4, v.KeyBookUrl)
	}
	if !(!v.Scratch) {
		writer.WriteBool(5, v.Scratch)
	}
	if !(v.Manager == nil) {
		writer.WriteUrl(6, v.Manager)
	}

	_, _, err := writer.Reset(fieldNames_CreateTokenAccount)
	return buffer.Bytes(), err
}

func (v *CreateTokenAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field TokenUrl is missing")
	} else if v.TokenUrl == nil {
		errs = append(errs, "field TokenUrl is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DataAccount = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "Scratch",
}

func (v *DataAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, &v.AccountAuth)
	if !(!v.Scratch) {
		writer.WriteBool(4, v.Scratch)
	}

	_, _, err := writer.Reset(fieldNames_DataAccount)
	return buffer.Bytes(), err
}

func (v *DataAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DataEntry = []string{
	1: "Data",
}

func (v *DataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Data) == 0) {
		for _, v := range v.Data {
			writer.WriteBytes(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_DataEntry)
	return buffer.Bytes(), err
}

func (v *DataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Data is missing")
	} else if len(v.Data) == 0 {
		errs = append(errs, "field Data is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DirectoryIndexMetadata = []string{
	1: "Count",
}

func (v *DirectoryIndexMetadata) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Count == 0) {
		writer.WriteUint(1, v.Count)
	}

	_, _, err := writer.Reset(fieldNames_DirectoryIndexMetadata)
	return buffer.Bytes(), err
}

func (v *DirectoryIndexMetadata) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DisableAccountAuthOperation = []string{
	1: "Type",
	2: "Authority",
}

func (v *DisableAccountAuthOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_DisableAccountAuthOperation)
	return buffer.Bytes(), err
}

func (v *DisableAccountAuthOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ED25519Signature = []string{
	1: "Type",
	2: "PublicKey",
	3: "Signature",
	4: "Signer",
	5: "SignerVersion",
	6: "Timestamp",
	7: "Vote",
}

func (v *ED25519Signature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(3, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(4, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(5, v.SignerVersion)
	}
	if !(v.Timestamp == 0) {
		writer.WriteUint(6, v.Timestamp)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}

	_, _, err := writer.Reset(fieldNames_ED25519Signature)
	return buffer.Bytes(), err
}

func (v *ED25519Signature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_EmptyResult = []string{
	1: "Type",
}

func (v *EmptyResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_EmptyResult)
	return buffer.Bytes(), err
}

func (v *EmptyResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_EnableAccountAuthOperation = []string{
	1: "Type",
	2: "Authority",
}

func (v *EnableAccountAuthOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_EnableAccountAuthOperation)
	return buffer.Bytes(), err
}

func (v *EnableAccountAuthOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Envelope = []string{
	1: "Signatures",
	2: "TxHash",
	3: "Transaction",
}

func (v *Envelope) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(1, v)
		}
	}
	if !(len(v.TxHash) == 0) {
		writer.WriteBytes(2, v.TxHash)
	}
	if !(v.Transaction == nil) {
		writer.WriteValue(3, v.Transaction)
	}

	_, _, err := writer.Reset(fieldNames_Envelope)
	return buffer.Bytes(), err
}

func (v *Envelope) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ForwardedSignature = []string{
	1: "Type",
	2: "Signature",
	3: "Signer",
}

func (v *ForwardedSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Signature == (nil)) {
		writer.WriteValue(2, v.Signature)
	}
	if !(v.Signer == (nil)) {
		writer.WriteValue(3, v.Signer)
	}

	_, _, err := writer.Reset(fieldNames_ForwardedSignature)
	return buffer.Bytes(), err
}

func (v *ForwardedSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if v.Signature == (nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == (nil) {
		errs = append(errs, "field Signer is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_HashSet = []string{
	1: "Hashes",
}

func (v *HashSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Hashes) == 0) {
		for _, v := range v.Hashes {
			writer.WriteHash(1, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_HashSet)
	return buffer.Bytes(), err
}

func (v *HashSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Hashes is missing")
	} else if len(v.Hashes) == 0 {
		errs = append(errs, "field Hashes is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_IndexEntry = []string{
	1: "Source",
	2: "Anchor",
	3: "BlockIndex",
	4: "BlockTime",
}

func (v *IndexEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Source == 0) {
		writer.WriteUint(1, v.Source)
	}
	if !(v.Anchor == 0) {
		writer.WriteUint(2, v.Anchor)
	}
	if !(v.BlockIndex == 0) {
		writer.WriteUint(3, v.BlockIndex)
	}
	if !(v.BlockTime == nil) {
		writer.WriteTime(4, *v.BlockTime)
	}

	_, _, err := writer.Reset(fieldNames_IndexEntry)
	return buffer.Bytes(), err
}

func (v *IndexEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Source is missing")
	} else if v.Source == 0 {
		errs = append(errs, "field Source is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Anchor is missing")
	} else if v.Anchor == 0 {
		errs = append(errs, "field Anchor is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field BlockIndex is missing")
	} else if v.BlockIndex == 0 {
		errs = append(errs, "field BlockIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field BlockTime is missing")
	} else if v.BlockTime == nil {
		errs = append(errs, "field BlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InternalGenesis = []string{
	1: "Type",
}

func (v *InternalGenesis) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_InternalGenesis)
	return buffer.Bytes(), err
}

func (v *InternalGenesis) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InternalLedger = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "Index",
	5: "Timestamp",
	6: "Synthetic",
	7: "PendingOracle",
	8: "ActiveOracle",
	9: "AcmeBurnt",
}

func (v *InternalLedger) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, &v.AccountAuth)
	if !(v.Index == 0) {
		writer.WriteInt(4, v.Index)
	}
	if !(v.Timestamp == (time.Time{})) {
		writer.WriteTime(5, v.Timestamp)
	}
	if !((v.Synthetic).Equal(new(SyntheticLedger))) {
		writer.WriteValue(6, &v.Synthetic)
	}
	if !(v.PendingOracle == 0) {
		writer.WriteUint(7, v.PendingOracle)
	}
	if !(v.ActiveOracle == 0) {
		writer.WriteUint(8, v.ActiveOracle)
	}
	if !((v.AcmeBurnt).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(9, &v.AcmeBurnt)
	}

	_, _, err := writer.Reset(fieldNames_InternalLedger)
	return buffer.Bytes(), err
}

func (v *InternalLedger) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Timestamp is missing")
	} else if v.Timestamp == (time.Time{}) {
		errs = append(errs, "field Timestamp is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Synthetic is missing")
	} else if (v.Synthetic).Equal(new(SyntheticLedger)) {
		errs = append(errs, "field Synthetic is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field PendingOracle is missing")
	} else if v.PendingOracle == 0 {
		errs = append(errs, "field PendingOracle is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field ActiveOracle is missing")
	} else if v.ActiveOracle == 0 {
		errs = append(errs, "field ActiveOracle is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field AcmeBurnt is missing")
	} else if (v.AcmeBurnt).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field AcmeBurnt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InternalSendTransactions = []string{
	1: "Type",
	2: "Transactions",
}

func (v *InternalSendTransactions) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(2, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_InternalSendTransactions)
	return buffer.Bytes(), err
}

func (v *InternalSendTransactions) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InternalSignature = []string{
	1: "Type",
	2: "Network",
}

func (v *InternalSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Network == nil) {
		writer.WriteUrl(2, v.Network)
	}

	_, _, err := writer.Reset(fieldNames_InternalSignature)
	return buffer.Bytes(), err
}

func (v *InternalSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Network is missing")
	} else if v.Network == nil {
		errs = append(errs, "field Network is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InternalSyntheticLedger = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "Pending",
}

func (v *InternalSyntheticLedger) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, &v.AccountAuth)
	if !(len(v.Pending) == 0) {
		for _, v := range v.Pending {
			writer.WriteValue(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_InternalSyntheticLedger)
	return buffer.Bytes(), err
}

func (v *InternalSyntheticLedger) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Pending is missing")
	} else if len(v.Pending) == 0 {
		errs = append(errs, "field Pending is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InternalTransactionsSent = []string{
	1: "Type",
	2: "Transactions",
}

func (v *InternalTransactionsSent) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteHash(2, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_InternalTransactionsSent)
	return buffer.Bytes(), err
}

func (v *InternalTransactionsSent) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InternalTransactionsSigned = []string{
	1: "Type",
	2: "Transactions",
}

func (v *InternalTransactionsSigned) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(2, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_InternalTransactionsSigned)
	return buffer.Bytes(), err
}

func (v *InternalTransactionsSigned) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_IssueTokens = []string{
	1: "Type",
	2: "Recipient",
	3: "Amount",
}

func (v *IssueTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Recipient == nil) {
		writer.WriteUrl(2, v.Recipient)
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(3, &v.Amount)
	}

	_, _, err := writer.Reset(fieldNames_IssueTokens)
	return buffer.Bytes(), err
}

func (v *IssueTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Recipient is missing")
	} else if v.Recipient == nil {
		errs = append(errs, "field Recipient is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeyBook = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "PageCount",
}

func (v *KeyBook) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, &v.AccountAuth)
	if !(v.PageCount == 0) {
		writer.WriteUint(4, v.PageCount)
	}

	_, _, err := writer.Reset(fieldNames_KeyBook)
	return buffer.Bytes(), err
}

func (v *KeyBook) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field PageCount is missing")
	} else if v.PageCount == 0 {
		errs = append(errs, "field PageCount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeyPage = []string{
	1:  "Type",
	2:  "Url",
	3:  "CreditBalance",
	4:  "AcceptThreshold",
	5:  "RejectThreshold",
	6:  "ResponseThreshold",
	7:  "BlockThreshold",
	8:  "Version",
	9:  "Keys",
	10: "TransactionBlacklist",
}

func (v *KeyPage) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.CreditBalance == 0) {
		writer.WriteUint(3, v.CreditBalance)
	}
	if !(v.AcceptThreshold == 0) {
		writer.WriteUint(4, v.AcceptThreshold)
	}
	if !(v.RejectThreshold == 0) {
		writer.WriteUint(5, v.RejectThreshold)
	}
	if !(v.ResponseThreshold == 0) {
		writer.WriteUint(6, v.ResponseThreshold)
	}
	if !(v.BlockThreshold == 0) {
		writer.WriteUint(7, v.BlockThreshold)
	}
	if !(v.Version == 0) {
		writer.WriteUint(8, v.Version)
	}
	if !(len(v.Keys) == 0) {
		for _, v := range v.Keys {
			writer.WriteValue(9, v)
		}
	}
	if !(v.TransactionBlacklist == nil) {
		writer.WriteEnum(10, *v.TransactionBlacklist)
	}

	_, _, err := writer.Reset(fieldNames_KeyPage)
	return buffer.Bytes(), err
}

func (v *KeyPage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field CreditBalance is missing")
	} else if v.CreditBalance == 0 {
		errs = append(errs, "field CreditBalance is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field AcceptThreshold is missing")
	} else if v.AcceptThreshold == 0 {
		errs = append(errs, "field AcceptThreshold is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field RejectThreshold is missing")
	} else if v.RejectThreshold == 0 {
		errs = append(errs, "field RejectThreshold is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field ResponseThreshold is missing")
	} else if v.ResponseThreshold == 0 {
		errs = append(errs, "field ResponseThreshold is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field BlockThreshold is missing")
	} else if v.BlockThreshold == 0 {
		errs = append(errs, "field BlockThreshold is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field Keys is missing")
	} else if len(v.Keys) == 0 {
		errs = append(errs, "field Keys is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeySpec = []string{
	1: "PublicKeyHash",
	2: "LastUsedOn",
	3: "Owner",
}

func (v *KeySpec) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.PublicKeyHash) == 0) {
		writer.WriteBytes(1, v.PublicKeyHash)
	}
	if !(v.LastUsedOn == 0) {
		writer.WriteUint(2, v.LastUsedOn)
	}
	if !(v.Owner == nil) {
		writer.WriteUrl(3, v.Owner)
	}

	_, _, err := writer.Reset(fieldNames_KeySpec)
	return buffer.Bytes(), err
}

func (v *KeySpec) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKeyHash is missing")
	} else if len(v.PublicKeyHash) == 0 {
		errs = append(errs, "field PublicKeyHash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field LastUsedOn is missing")
	} else if v.LastUsedOn == 0 {
		errs = append(errs, "field LastUsedOn is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Owner is missing")
	} else if v.Owner == nil {
		errs = append(errs, "field Owner is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeySpecParams = []string{
	1: "KeyHash",
	2: "Owner",
}

func (v *KeySpecParams) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.KeyHash) == 0) {
		writer.WriteBytes(1, v.KeyHash)
	}
	if !(v.Owner == nil) {
		writer.WriteUrl(2, v.Owner)
	}

	_, _, err := writer.Reset(fieldNames_KeySpecParams)
	return buffer.Bytes(), err
}

func (v *KeySpecParams) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field KeyHash is missing")
	} else if len(v.KeyHash) == 0 {
		errs = append(errs, "field KeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LegacyED25519Signature = []string{
	1: "Type",
	2: "Timestamp",
	3: "PublicKey",
	4: "Signature",
	5: "Signer",
	6: "SignerVersion",
	7: "Vote",
}

func (v *LegacyED25519Signature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Timestamp == 0) {
		writer.WriteUint(2, v.Timestamp)
	}
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(3, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(4, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(5, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(6, v.SignerVersion)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}

	_, _, err := writer.Reset(fieldNames_LegacyED25519Signature)
	return buffer.Bytes(), err
}

func (v *LegacyED25519Signature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Timestamp is missing")
	} else if v.Timestamp == 0 {
		errs = append(errs, "field Timestamp is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LiteDataAccount = []string{
	1: "Type",
	2: "Url",
	3: "Tail",
}

func (v *LiteDataAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.Tail) == 0) {
		writer.WriteBytes(3, v.Tail)
	}

	_, _, err := writer.Reset(fieldNames_LiteDataAccount)
	return buffer.Bytes(), err
}

func (v *LiteDataAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Tail is missing")
	} else if len(v.Tail) == 0 {
		errs = append(errs, "field Tail is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LiteIdentity = []string{
	1: "Type",
	2: "Url",
}

func (v *LiteIdentity) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}

	_, _, err := writer.Reset(fieldNames_LiteIdentity)
	return buffer.Bytes(), err
}

func (v *LiteIdentity) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LiteTokenAccount = []string{
	1: "Type",
	2: "Url",
	3: "TokenUrl",
	4: "Balance",
	5: "LastUsedOn",
	6: "CreditBalance",
}

func (v *LiteTokenAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.TokenUrl == nil) {
		writer.WriteUrl(3, v.TokenUrl)
	}
	if !((v.Balance).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(4, &v.Balance)
	}
	if !(v.LastUsedOn == 0) {
		writer.WriteUint(5, v.LastUsedOn)
	}
	if !(v.CreditBalance == 0) {
		writer.WriteUint(6, v.CreditBalance)
	}

	_, _, err := writer.Reset(fieldNames_LiteTokenAccount)
	return buffer.Bytes(), err
}

func (v *LiteTokenAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field TokenUrl is missing")
	} else if v.TokenUrl == nil {
		errs = append(errs, "field TokenUrl is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Balance is missing")
	} else if (v.Balance).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Balance is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field LastUsedOn is missing")
	} else if v.LastUsedOn == 0 {
		errs = append(errs, "field LastUsedOn is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field CreditBalance is missing")
	} else if v.CreditBalance == 0 {
		errs = append(errs, "field CreditBalance is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MetricsRequest = []string{
	1: "Metric",
	2: "Duration",
}

func (v *MetricsRequest) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Metric) == 0) {
		writer.WriteString(1, v.Metric)
	}
	if !(v.Duration == 0) {
		writer.WriteDuration(2, v.Duration)
	}

	_, _, err := writer.Reset(fieldNames_MetricsRequest)
	return buffer.Bytes(), err
}

func (v *MetricsRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Metric is missing")
	} else if len(v.Metric) == 0 {
		errs = append(errs, "field Metric is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Duration is missing")
	} else if v.Duration == 0 {
		errs = append(errs, "field Duration is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Object = []string{
	1: "Type",
	2: "Chains",
}

func (v *Object) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	if !(len(v.Chains) == 0) {
		for _, v := range v.Chains {
			writer.WriteValue(2, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_Object)
	return buffer.Bytes(), err
}

func (v *Object) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chains is missing")
	} else if len(v.Chains) == 0 {
		errs = append(errs, "field Chains is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RCD1Signature = []string{
	1: "Type",
	2: "PublicKey",
	3: "Signature",
	4: "Signer",
	5: "SignerVersion",
	6: "Timestamp",
	7: "Vote",
}

func (v *RCD1Signature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(len(v.Signature) == 0) {
		writer.WriteBytes(3, v.Signature)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(4, v.Signer)
	}
	if !(v.SignerVersion == 0) {
		writer.WriteUint(5, v.SignerVersion)
	}
	if !(v.Timestamp == 0) {
		writer.WriteUint(6, v.Timestamp)
	}
	if !(v.Vote == 0) {
		writer.WriteEnum(7, v.Vote)
	}

	_, _, err := writer.Reset(fieldNames_RCD1Signature)
	return buffer.Bytes(), err
}

func (v *RCD1Signature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signature is missing")
	} else if len(v.Signature) == 0 {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field SignerVersion is missing")
	} else if v.SignerVersion == 0 {
		errs = append(errs, "field SignerVersion is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Receipt = []string{
	1: "Start",
	2: "Result",
	3: "Entries",
}

func (v *Receipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Start) == 0) {
		writer.WriteBytes(1, v.Start)
	}
	if !(len(v.Result) == 0) {
		writer.WriteBytes(2, v.Result)
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(3, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_Receipt)
	return buffer.Bytes(), err
}

func (v *Receipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Start is missing")
	} else if len(v.Start) == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Result is missing")
	} else if len(v.Result) == 0 {
		errs = append(errs, "field Result is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ReceiptEntry = []string{
	1: "Right",
	2: "Hash",
}

func (v *ReceiptEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.Right) {
		writer.WriteBool(1, v.Right)
	}
	if !(len(v.Hash) == 0) {
		writer.WriteBytes(2, v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_ReceiptEntry)
	return buffer.Bytes(), err
}

func (v *ReceiptEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Right is missing")
	} else if !v.Right {
		errs = append(errs, "field Right is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Hash is missing")
	} else if len(v.Hash) == 0 {
		errs = append(errs, "field Hash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ReceiptSignature = []string{
	1: "Type",
	2: "Receipt",
	3: "SourceNetwork",
}

func (v *ReceiptSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, &v.Receipt)
	if !(v.SourceNetwork == nil) {
		writer.WriteUrl(3, v.SourceNetwork)
	}

	_, _, err := writer.Reset(fieldNames_ReceiptSignature)
	return buffer.Bytes(), err
}

func (v *ReceiptSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.Receipt.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field SourceNetwork is missing")
	} else if v.SourceNetwork == nil {
		errs = append(errs, "field SourceNetwork is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RemoteTransactionBody = []string{
	1: "Type",
}

func (v *RemoteTransactionBody) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_RemoteTransactionBody)
	return buffer.Bytes(), err
}

func (v *RemoteTransactionBody) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RemoveAccountAuthorityOperation = []string{
	1: "Type",
	2: "Authority",
}

func (v *RemoveAccountAuthorityOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}

	_, _, err := writer.Reset(fieldNames_RemoveAccountAuthorityOperation)
	return buffer.Bytes(), err
}

func (v *RemoveAccountAuthorityOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RemoveKeyOperation = []string{
	1: "Type",
	2: "Entry",
}

func (v *RemoveKeyOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Entry).Equal(new(KeySpecParams))) {
		writer.WriteValue(2, &v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_RemoveKeyOperation)
	return buffer.Bytes(), err
}

func (v *RemoveKeyOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(KeySpecParams)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RemoveValidator = []string{
	1: "Type",
	2: "Key",
	3: "Owner",
}

func (v *RemoveValidator) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Key) == 0) {
		writer.WriteBytes(2, v.Key)
	}
	if !(v.Owner == nil) {
		writer.WriteUrl(3, v.Owner)
	}

	_, _, err := writer.Reset(fieldNames_RemoveValidator)
	return buffer.Bytes(), err
}

func (v *RemoveValidator) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Key is missing")
	} else if len(v.Key) == 0 {
		errs = append(errs, "field Key is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SegWitDataEntry = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "EntryUrl",
	4: "EntryHash",
}

func (v *SegWitDataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, &v.SyntheticOrigin)
	if !(v.EntryUrl == nil) {
		writer.WriteUrl(3, v.EntryUrl)
	}
	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(4, &v.EntryHash)
	}

	_, _, err := writer.Reset(fieldNames_SegWitDataEntry)
	return buffer.Bytes(), err
}

func (v *SegWitDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field EntryUrl is missing")
	} else if v.EntryUrl == nil {
		errs = append(errs, "field EntryUrl is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SendTokens = []string{
	1: "Type",
	2: "Hash",
	3: "Meta",
	4: "To",
}

func (v *SendTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(2, &v.Hash)
	}
	if !(len(v.Meta) == 0) {
		writer.WriteBytes(3, v.Meta)
	}
	if !(len(v.To) == 0) {
		for _, v := range v.To {
			writer.WriteValue(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_SendTokens)
	return buffer.Bytes(), err
}

func (v *SendTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field To is missing")
	} else if len(v.To) == 0 {
		errs = append(errs, "field To is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SendTransaction = []string{
	1: "Payload",
	2: "Recipient",
}

func (v *SendTransaction) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Payload == (nil)) {
		writer.WriteValue(1, v.Payload)
	}
	if !(v.Recipient == nil) {
		writer.WriteUrl(2, v.Recipient)
	}

	_, _, err := writer.Reset(fieldNames_SendTransaction)
	return buffer.Bytes(), err
}

func (v *SendTransaction) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Payload is missing")
	} else if v.Payload == (nil) {
		errs = append(errs, "field Payload is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Recipient is missing")
	} else if v.Recipient == nil {
		errs = append(errs, "field Recipient is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SetThresholdKeyPageOperation = []string{
	1: "Type",
	2: "Threshold",
}

func (v *SetThresholdKeyPageOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Threshold == 0) {
		writer.WriteUint(2, v.Threshold)
	}

	_, _, err := writer.Reset(fieldNames_SetThresholdKeyPageOperation)
	return buffer.Bytes(), err
}

func (v *SetThresholdKeyPageOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Threshold is missing")
	} else if v.Threshold == 0 {
		errs = append(errs, "field Threshold is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticAnchor = []string{
	1: "Type",
	2: "Source",
	3: "Major",
	4: "RootAnchor",
	5: "RootIndex",
	6: "AcmeBurnt",
	7: "Block",
	8: "AcmeOraclePrice",
	9: "Receipts",
}

func (v *SyntheticAnchor) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Source == nil) {
		writer.WriteUrl(2, v.Source)
	}
	if !(!v.Major) {
		writer.WriteBool(3, v.Major)
	}
	if !(v.RootAnchor == ([32]byte{})) {
		writer.WriteHash(4, &v.RootAnchor)
	}
	if !(v.RootIndex == 0) {
		writer.WriteUint(5, v.RootIndex)
	}
	if !((v.AcmeBurnt).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(6, &v.AcmeBurnt)
	}
	if !(v.Block == 0) {
		writer.WriteUint(7, v.Block)
	}
	if !(v.AcmeOraclePrice == 0) {
		writer.WriteUint(8, v.AcmeOraclePrice)
	}
	if !(len(v.Receipts) == 0) {
		for _, v := range v.Receipts {
			writer.WriteValue(9, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_SyntheticAnchor)
	return buffer.Bytes(), err
}

func (v *SyntheticAnchor) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Source is missing")
	} else if v.Source == nil {
		errs = append(errs, "field Source is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Major is missing")
	} else if !v.Major {
		errs = append(errs, "field Major is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field RootAnchor is missing")
	} else if v.RootAnchor == ([32]byte{}) {
		errs = append(errs, "field RootAnchor is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field RootIndex is missing")
	} else if v.RootIndex == 0 {
		errs = append(errs, "field RootIndex is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field AcmeBurnt is missing")
	} else if (v.AcmeBurnt).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field AcmeBurnt is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Block is missing")
	} else if v.Block == 0 {
		errs = append(errs, "field Block is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field AcmeOraclePrice is missing")
	} else if v.AcmeOraclePrice == 0 {
		errs = append(errs, "field AcmeOraclePrice is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field Receipts is missing")
	} else if len(v.Receipts) == 0 {
		errs = append(errs, "field Receipts is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticBurnTokens = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Amount",
}

func (v *SyntheticBurnTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, &v.SyntheticOrigin)
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(3, &v.Amount)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticBurnTokens)
	return buffer.Bytes(), err
}

func (v *SyntheticBurnTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticCreateChain = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Chains",
}

func (v *SyntheticCreateChain) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, &v.SyntheticOrigin)
	if !(len(v.Chains) == 0) {
		for _, v := range v.Chains {
			writer.WriteValue(3, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_SyntheticCreateChain)
	return buffer.Bytes(), err
}

func (v *SyntheticCreateChain) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Chains is missing")
	} else if len(v.Chains) == 0 {
		errs = append(errs, "field Chains is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticDepositCredits = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Amount",
}

func (v *SyntheticDepositCredits) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, &v.SyntheticOrigin)
	if !(v.Amount == 0) {
		writer.WriteUint(3, v.Amount)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticDepositCredits)
	return buffer.Bytes(), err
}

func (v *SyntheticDepositCredits) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Amount is missing")
	} else if v.Amount == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticDepositTokens = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Token",
	4: "Amount",
}

func (v *SyntheticDepositTokens) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, &v.SyntheticOrigin)
	if !(v.Token == nil) {
		writer.WriteUrl(3, v.Token)
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(4, &v.Amount)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticDepositTokens)
	return buffer.Bytes(), err
}

func (v *SyntheticDepositTokens) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Token is missing")
	} else if v.Token == nil {
		errs = append(errs, "field Token is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticForwardTransaction = []string{
	1: "Type",
	2: "Signatures",
	3: "TransactionHash",
	4: "Transaction",
}

func (v *SyntheticForwardTransaction) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(2, &v)
		}
	}
	if !(len(v.TransactionHash) == 0) {
		writer.WriteBytes(3, v.TransactionHash)
	}
	if !(v.Transaction == nil) {
		writer.WriteValue(4, v.Transaction)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticForwardTransaction)
	return buffer.Bytes(), err
}

func (v *SyntheticForwardTransaction) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticLedger = []string{
	1: "Nonce",
	2: "Unsigned",
	3: "Unsent",
}

func (v *SyntheticLedger) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Nonce == 0) {
		writer.WriteUint(1, v.Nonce)
	}
	if !(len(v.Unsigned) == 0) {
		for _, v := range v.Unsigned {
			writer.WriteHash(2, &v)
		}
	}
	if !(len(v.Unsent) == 0) {
		for _, v := range v.Unsent {
			writer.WriteHash(3, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_SyntheticLedger)
	return buffer.Bytes(), err
}

func (v *SyntheticLedger) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Nonce is missing")
	} else if v.Nonce == 0 {
		errs = append(errs, "field Nonce is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Unsigned is missing")
	} else if len(v.Unsigned) == 0 {
		errs = append(errs, "field Unsigned is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Unsent is missing")
	} else if len(v.Unsent) == 0 {
		errs = append(errs, "field Unsent is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticLedgerEntry = []string{
	1: "TransactionHash",
	2: "RootAnchor",
	3: "SynthIndex",
	4: "SynthIndexIndex",
	5: "RootIndexIndex",
	6: "NeedsReceipt",
}

func (v *SyntheticLedgerEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.TransactionHash == ([32]byte{})) {
		writer.WriteHash(1, &v.TransactionHash)
	}
	if !(v.RootAnchor == ([32]byte{})) {
		writer.WriteHash(2, &v.RootAnchor)
	}
	if !(v.SynthIndex == 0) {
		writer.WriteUint(3, v.SynthIndex)
	}
	if !(v.SynthIndexIndex == 0) {
		writer.WriteUint(4, v.SynthIndexIndex)
	}
	if !(v.RootIndexIndex == 0) {
		writer.WriteUint(5, v.RootIndexIndex)
	}
	if !(!v.NeedsReceipt) {
		writer.WriteBool(6, v.NeedsReceipt)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticLedgerEntry)
	return buffer.Bytes(), err
}

func (v *SyntheticLedgerEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TransactionHash is missing")
	} else if v.TransactionHash == ([32]byte{}) {
		errs = append(errs, "field TransactionHash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field RootAnchor is missing")
	} else if v.RootAnchor == ([32]byte{}) {
		errs = append(errs, "field RootAnchor is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field SynthIndex is missing")
	} else if v.SynthIndex == 0 {
		errs = append(errs, "field SynthIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SynthIndexIndex is missing")
	} else if v.SynthIndexIndex == 0 {
		errs = append(errs, "field SynthIndexIndex is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field RootIndexIndex is missing")
	} else if v.RootIndexIndex == 0 {
		errs = append(errs, "field RootIndexIndex is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field NeedsReceipt is missing")
	} else if !v.NeedsReceipt {
		errs = append(errs, "field NeedsReceipt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticMirror = []string{
	1: "Type",
	2: "Objects",
}

func (v *SyntheticMirror) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Objects) == 0) {
		for _, v := range v.Objects {
			writer.WriteValue(2, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_SyntheticMirror)
	return buffer.Bytes(), err
}

func (v *SyntheticMirror) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Objects is missing")
	} else if len(v.Objects) == 0 {
		errs = append(errs, "field Objects is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticOrigin = []string{
	1: "Source",
	2: "Cause",
}

func (v *SyntheticOrigin) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Source == nil) {
		writer.WriteUrl(1, v.Source)
	}
	if !(v.Cause == ([32]byte{})) {
		writer.WriteHash(2, &v.Cause)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticOrigin)
	return buffer.Bytes(), err
}

func (v *SyntheticOrigin) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Source is missing")
	} else if v.Source == nil {
		errs = append(errs, "field Source is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Cause is missing")
	} else if v.Cause == ([32]byte{}) {
		errs = append(errs, "field Cause is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticReceipt = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "SynthTxHash",
	4: "Status",
}

func (v *SyntheticReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, &v.SyntheticOrigin)
	if !(v.SynthTxHash == ([32]byte{})) {
		writer.WriteHash(3, &v.SynthTxHash)
	}
	if !(v.Status == nil) {
		writer.WriteValue(4, v.Status)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticReceipt)
	return buffer.Bytes(), err
}

func (v *SyntheticReceipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field SynthTxHash is missing")
	} else if v.SynthTxHash == ([32]byte{}) {
		errs = append(errs, "field SynthTxHash is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticSignature = []string{
	1: "Type",
	2: "SourceNetwork",
	3: "DestinationNetwork",
	4: "SequenceNumber",
}

func (v *SyntheticSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.SourceNetwork == nil) {
		writer.WriteUrl(2, v.SourceNetwork)
	}
	if !(v.DestinationNetwork == nil) {
		writer.WriteUrl(3, v.DestinationNetwork)
	}
	if !(v.SequenceNumber == 0) {
		writer.WriteUint(4, v.SequenceNumber)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticSignature)
	return buffer.Bytes(), err
}

func (v *SyntheticSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field SourceNetwork is missing")
	} else if v.SourceNetwork == nil {
		errs = append(errs, "field SourceNetwork is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field DestinationNetwork is missing")
	} else if v.DestinationNetwork == nil {
		errs = append(errs, "field DestinationNetwork is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SequenceNumber is missing")
	} else if v.SequenceNumber == 0 {
		errs = append(errs, "field SequenceNumber is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticWriteData = []string{
	1: "Type",
	2: "SyntheticOrigin",
	3: "Entry",
}

func (v *SyntheticWriteData) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, &v.SyntheticOrigin)
	if !((v.Entry).Equal(new(DataEntry))) {
		writer.WriteValue(3, &v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticWriteData)
	return buffer.Bytes(), err
}

func (v *SyntheticWriteData) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SyntheticOrigin.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(DataEntry)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TokenAccount = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "TokenUrl",
	5: "Balance",
	6: "Scratch",
}

func (v *TokenAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, &v.AccountAuth)
	if !(v.TokenUrl == nil) {
		writer.WriteUrl(4, v.TokenUrl)
	}
	if !((v.Balance).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(5, &v.Balance)
	}
	if !(!v.Scratch) {
		writer.WriteBool(6, v.Scratch)
	}

	_, _, err := writer.Reset(fieldNames_TokenAccount)
	return buffer.Bytes(), err
}

func (v *TokenAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TokenUrl is missing")
	} else if v.TokenUrl == nil {
		errs = append(errs, "field TokenUrl is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Balance is missing")
	} else if (v.Balance).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Balance is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TokenIssuer = []string{
	1: "Type",
	2: "Url",
	3: "AccountAuth",
	4: "Symbol",
	5: "Precision",
	6: "Properties",
	7: "Issued",
	8: "SupplyLimit",
}

func (v *TokenIssuer) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	writer.WriteValue(3, &v.AccountAuth)
	if !(len(v.Symbol) == 0) {
		writer.WriteString(4, v.Symbol)
	}
	if !(v.Precision == 0) {
		writer.WriteUint(5, v.Precision)
	}
	if !(v.Properties == nil) {
		writer.WriteUrl(6, v.Properties)
	}
	if !((v.Issued).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(7, &v.Issued)
	}
	if !(v.SupplyLimit == nil) {
		writer.WriteBigInt(8, v.SupplyLimit)
	}

	_, _, err := writer.Reset(fieldNames_TokenIssuer)
	return buffer.Bytes(), err
}

func (v *TokenIssuer) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if err := v.AccountAuth.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Symbol is missing")
	} else if len(v.Symbol) == 0 {
		errs = append(errs, "field Symbol is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Precision is missing")
	} else if v.Precision == 0 {
		errs = append(errs, "field Precision is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Properties is missing")
	} else if v.Properties == nil {
		errs = append(errs, "field Properties is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Issued is missing")
	} else if (v.Issued).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Issued is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TokenRecipient = []string{
	1: "Url",
	2: "Amount",
}

func (v *TokenRecipient) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		writer.WriteBigInt(2, &v.Amount)
	}

	_, _, err := writer.Reset(fieldNames_TokenRecipient)
	return buffer.Bytes(), err
}

func (v *TokenRecipient) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Amount is missing")
	} else if (v.Amount).Cmp(new(big.Int)) == 0 {
		errs = append(errs, "field Amount is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Transaction = []string{
	1: "Header",
	2: "Body",
}

func (v *Transaction) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !((v.Header).Equal(new(TransactionHeader))) {
		writer.WriteValue(1, &v.Header)
	}
	if !(v.Body == (nil)) {
		writer.WriteValue(2, v.Body)
	}

	_, _, err := writer.Reset(fieldNames_Transaction)
	return buffer.Bytes(), err
}

func (v *Transaction) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Header is missing")
	} else if (v.Header).Equal(new(TransactionHeader)) {
		errs = append(errs, "field Header is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Body is missing")
	} else if v.Body == (nil) {
		errs = append(errs, "field Body is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionHeader = []string{
	1: "Principal",
	2: "Initiator",
	3: "Memo",
	4: "Metadata",
}

func (v *TransactionHeader) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Principal == nil) {
		writer.WriteUrl(1, v.Principal)
	}
	if !(v.Initiator == ([32]byte{})) {
		writer.WriteHash(2, &v.Initiator)
	}
	if !(len(v.Memo) == 0) {
		writer.WriteString(3, v.Memo)
	}
	if !(len(v.Metadata) == 0) {
		writer.WriteBytes(4, v.Metadata)
	}

	_, _, err := writer.Reset(fieldNames_TransactionHeader)
	return buffer.Bytes(), err
}

func (v *TransactionHeader) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Principal is missing")
	} else if v.Principal == nil {
		errs = append(errs, "field Principal is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Initiator is missing")
	} else if v.Initiator == ([32]byte{}) {
		errs = append(errs, "field Initiator is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionResultSet = []string{
	1: "Results",
}

func (v *TransactionResultSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Results) == 0) {
		for _, v := range v.Results {
			writer.WriteValue(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_TransactionResultSet)
	return buffer.Bytes(), err
}

func (v *TransactionResultSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Results is missing")
	} else if len(v.Results) == 0 {
		errs = append(errs, "field Results is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionSignature = []string{
	1: "Transaction",
	2: "Signature",
}

func (v *TransactionSignature) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Transaction == ([32]byte{})) {
		writer.WriteHash(1, &v.Transaction)
	}
	if !(v.Signature == (nil)) {
		writer.WriteValue(2, v.Signature)
	}

	_, _, err := writer.Reset(fieldNames_TransactionSignature)
	return buffer.Bytes(), err
}

func (v *TransactionSignature) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == ([32]byte{}) {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if v.Signature == (nil) {
		errs = append(errs, "field Signature is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionStatus = []string{
	1: "Remote",
	2: "Delivered",
	3: "Pending",
	4: "Code",
	5: "Message",
	6: "Result",
	7: "Initiator",
	8: "Signers",
}

func (v *TransactionStatus) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.Remote) {
		writer.WriteBool(1, v.Remote)
	}
	if !(!v.Delivered) {
		writer.WriteBool(2, v.Delivered)
	}
	if !(!v.Pending) {
		writer.WriteBool(3, v.Pending)
	}
	if !(v.Code == 0) {
		writer.WriteUint(4, v.Code)
	}
	if !(len(v.Message) == 0) {
		writer.WriteString(5, v.Message)
	}
	if !(v.Result == (nil)) {
		writer.WriteValue(6, v.Result)
	}
	if !(v.Initiator == nil) {
		writer.WriteUrl(7, v.Initiator)
	}
	if !(len(v.Signers) == 0) {
		for _, v := range v.Signers {
			writer.WriteValue(8, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_TransactionStatus)
	return buffer.Bytes(), err
}

func (v *TransactionStatus) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Remote is missing")
	} else if !v.Remote {
		errs = append(errs, "field Remote is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Delivered is missing")
	} else if !v.Delivered {
		errs = append(errs, "field Delivered is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Pending is missing")
	} else if !v.Pending {
		errs = append(errs, "field Pending is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Code is missing")
	} else if v.Code == 0 {
		errs = append(errs, "field Code is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Message is missing")
	} else if len(v.Message) == 0 {
		errs = append(errs, "field Message is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Result is missing")
	} else if v.Result == (nil) {
		errs = append(errs, "field Result is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Initiator is missing")
	} else if v.Initiator == nil {
		errs = append(errs, "field Initiator is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field Signers is missing")
	} else if len(v.Signers) == 0 {
		errs = append(errs, "field Signers is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UnknownAccount = []string{
	1: "Type",
	2: "Url",
}

func (v *UnknownAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}

	_, _, err := writer.Reset(fieldNames_UnknownAccount)
	return buffer.Bytes(), err
}

func (v *UnknownAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UnknownSigner = []string{
	1: "Type",
	2: "Url",
	3: "Version",
}

func (v *UnknownSigner) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.Version == 0) {
		writer.WriteUint(3, v.Version)
	}

	_, _, err := writer.Reset(fieldNames_UnknownSigner)
	return buffer.Bytes(), err
}

func (v *UnknownSigner) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateAccountAuth = []string{
	1: "Type",
	2: "Operations",
}

func (v *UpdateAccountAuth) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Operations) == 0) {
		for _, v := range v.Operations {
			writer.WriteValue(2, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_UpdateAccountAuth)
	return buffer.Bytes(), err
}

func (v *UpdateAccountAuth) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Operations is missing")
	} else if len(v.Operations) == 0 {
		errs = append(errs, "field Operations is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateAllowedKeyPageOperation = []string{
	1: "Type",
	2: "Allow",
	3: "Deny",
}

func (v *UpdateAllowedKeyPageOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Allow) == 0) {
		for _, v := range v.Allow {
			writer.WriteEnum(2, v)
		}
	}
	if !(len(v.Deny) == 0) {
		for _, v := range v.Deny {
			writer.WriteEnum(3, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_UpdateAllowedKeyPageOperation)
	return buffer.Bytes(), err
}

func (v *UpdateAllowedKeyPageOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateKey = []string{
	1: "Type",
	2: "NewKeyHash",
}

func (v *UpdateKey) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.NewKeyHash) == 0) {
		writer.WriteBytes(2, v.NewKeyHash)
	}

	_, _, err := writer.Reset(fieldNames_UpdateKey)
	return buffer.Bytes(), err
}

func (v *UpdateKey) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field NewKeyHash is missing")
	} else if len(v.NewKeyHash) == 0 {
		errs = append(errs, "field NewKeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateKeyOperation = []string{
	1: "Type",
	2: "OldEntry",
	3: "NewEntry",
}

func (v *UpdateKeyOperation) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.OldEntry).Equal(new(KeySpecParams))) {
		writer.WriteValue(2, &v.OldEntry)
	}
	if !((v.NewEntry).Equal(new(KeySpecParams))) {
		writer.WriteValue(3, &v.NewEntry)
	}

	_, _, err := writer.Reset(fieldNames_UpdateKeyOperation)
	return buffer.Bytes(), err
}

func (v *UpdateKeyOperation) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field OldEntry is missing")
	} else if (v.OldEntry).Equal(new(KeySpecParams)) {
		errs = append(errs, "field OldEntry is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field NewEntry is missing")
	} else if (v.NewEntry).Equal(new(KeySpecParams)) {
		errs = append(errs, "field NewEntry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateKeyPage = []string{
	1: "Type",
	2: "Operation",
}

func (v *UpdateKeyPage) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Operation) == 0) {
		for _, v := range v.Operation {
			writer.WriteValue(2, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_UpdateKeyPage)
	return buffer.Bytes(), err
}

func (v *UpdateKeyPage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Operation is missing")
	} else if len(v.Operation) == 0 {
		errs = append(errs, "field Operation is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UpdateValidatorKey = []string{
	1: "Type",
	2: "KeyHash",
	3: "NewKeyHash",
}

func (v *UpdateValidatorKey) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.KeyHash) == 0) {
		writer.WriteBytes(2, v.KeyHash)
	}
	if !(len(v.NewKeyHash) == 0) {
		writer.WriteBytes(3, v.NewKeyHash)
	}

	_, _, err := writer.Reset(fieldNames_UpdateValidatorKey)
	return buffer.Bytes(), err
}

func (v *UpdateValidatorKey) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field KeyHash is missing")
	} else if len(v.KeyHash) == 0 {
		errs = append(errs, "field KeyHash is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field NewKeyHash is missing")
	} else if len(v.NewKeyHash) == 0 {
		errs = append(errs, "field NewKeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_WriteData = []string{
	1: "Type",
	2: "Entry",
}

func (v *WriteData) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !((v.Entry).Equal(new(DataEntry))) {
		writer.WriteValue(2, &v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_WriteData)
	return buffer.Bytes(), err
}

func (v *WriteData) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(DataEntry)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_WriteDataResult = []string{
	1: "Type",
	2: "EntryHash",
	3: "AccountUrl",
	4: "AccountID",
}

func (v *WriteDataResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(2, &v.EntryHash)
	}
	if !(v.AccountUrl == nil) {
		writer.WriteUrl(3, v.AccountUrl)
	}
	if !(len(v.AccountID) == 0) {
		writer.WriteBytes(4, v.AccountID)
	}

	_, _, err := writer.Reset(fieldNames_WriteDataResult)
	return buffer.Bytes(), err
}

func (v *WriteDataResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field AccountUrl is missing")
	} else if v.AccountUrl == nil {
		errs = append(errs, "field AccountUrl is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field AccountID is missing")
	} else if len(v.AccountID) == 0 {
		errs = append(errs, "field AccountID is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_WriteDataTo = []string{
	1: "Type",
	2: "Recipient",
	3: "Entry",
}

func (v *WriteDataTo) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Recipient == nil) {
		writer.WriteUrl(2, v.Recipient)
	}
	if !((v.Entry).Equal(new(DataEntry))) {
		writer.WriteValue(3, &v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_WriteDataTo)
	return buffer.Bytes(), err
}

func (v *WriteDataTo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Recipient is missing")
	} else if v.Recipient == nil {
		errs = append(errs, "field Recipient is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(DataEntry)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *ADI) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ADI) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinary)

	seen, err := reader.Reset(fieldNames_ADI)
	v.fieldsSet = seen
	return err
}

func (v *AccountAuth) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AccountAuth) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(AuthorityEntry); reader.ReadValue(1, x.UnmarshalBinary) {
			v.Authorities = append(v.Authorities, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_AccountAuth)
	v.fieldsSet = seen
	return err
}

func (v *AcmeFaucet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AcmeFaucet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}

	seen, err := reader.Reset(fieldNames_AcmeFaucet)
	v.fieldsSet = seen
	return err
}

func (v *AcmeOracle) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AcmeOracle) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Price = x
	}

	seen, err := reader.Reset(fieldNames_AcmeOracle)
	v.fieldsSet = seen
	return err
}

func (v *AddAccountAuthorityOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddAccountAuthorityOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountAuthOperationType
	if x := new(AccountAuthOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_AddAccountAuthorityOperation)
	v.fieldsSet = seen
	return err
}

func (v *AddCredits) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddCredits) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Recipient = x
	}
	if x, ok := reader.ReadBigInt(3); ok {
		v.Amount = *x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Oracle = x
	}

	seen, err := reader.Reset(fieldNames_AddCredits)
	v.fieldsSet = seen
	return err
}

func (v *AddCreditsResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddCreditsResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadBigInt(2); ok {
		v.Amount = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Credits = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Oracle = x
	}

	seen, err := reader.Reset(fieldNames_AddCreditsResult)
	v.fieldsSet = seen
	return err
}

func (v *AddKeyOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddKeyOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x := new(KeySpecParams); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_AddKeyOperation)
	v.fieldsSet = seen
	return err
}

func (v *AddValidator) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AddValidator) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Key = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Owner = x
	}

	seen, err := reader.Reset(fieldNames_AddValidator)
	v.fieldsSet = seen
	return err
}

func (v *Anchor) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Anchor) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinary)

	seen, err := reader.Reset(fieldNames_Anchor)
	v.fieldsSet = seen
	return err
}

func (v *AnchorMetadata) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AnchorMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.ChainMetadata.UnmarshalBinary)
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.SourceIndex = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SourceBlock = x
	}
	if x, ok := reader.ReadBytes(6); ok {
		v.Entry = x
	}

	seen, err := reader.Reset(fieldNames_AnchorMetadata)
	v.fieldsSet = seen
	return err
}

func (v *AnchoredRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AnchoredRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.Record = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.Anchor = *x
	}

	seen, err := reader.Reset(fieldNames_AnchoredRecord)
	v.fieldsSet = seen
	return err
}

func (v *AuthorityEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AuthorityEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.Disabled = x
	}

	seen, err := reader.Reset(fieldNames_AuthorityEntry)
	v.fieldsSet = seen
	return err
}

func (v *BurnTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BurnTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadBigInt(2); ok {
		v.Amount = *x
	}

	seen, err := reader.Reset(fieldNames_BurnTokens)
	v.fieldsSet = seen
	return err
}

func (v *ChainMetadata) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x := new(ChainType); reader.ReadEnum(2, x) {
		v.Type = *x
	}

	seen, err := reader.Reset(fieldNames_ChainMetadata)
	v.fieldsSet = seen
	return err
}

func (v *ChainParams) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainParams) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.Data = x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.IsUpdate = x
	}

	seen, err := reader.Reset(fieldNames_ChainParams)
	v.fieldsSet = seen
	return err
}

func (v *CreateDataAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateDataAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.KeyBookUrl = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.ManagerKeyBookUrl = x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.Scratch = x
	}

	seen, err := reader.Reset(fieldNames_CreateDataAccount)
	v.fieldsSet = seen
	return err
}

func (v *CreateIdentity) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateIdentity) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.KeyHash = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.KeyBookUrl = x
	}
	if x, ok := reader.ReadUrl(5); ok {
		v.Manager = x
	}

	seen, err := reader.Reset(fieldNames_CreateIdentity)
	v.fieldsSet = seen
	return err
}

func (v *CreateKeyBook) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateKeyBook) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.PublicKeyHash = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Manager = x
	}

	seen, err := reader.Reset(fieldNames_CreateKeyBook)
	v.fieldsSet = seen
	return err
}

func (v *CreateKeyPage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateKeyPage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		if x := new(KeySpecParams); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Keys = append(v.Keys, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Manager = x
	}

	seen, err := reader.Reset(fieldNames_CreateKeyPage)
	v.fieldsSet = seen
	return err
}

func (v *CreateToken) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateToken) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.KeyBookUrl = x
	}
	if x, ok := reader.ReadString(4); ok {
		v.Symbol = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Precision = x
	}
	if x, ok := reader.ReadUrl(6); ok {
		v.Properties = x
	}
	if x, ok := reader.ReadBigInt(7); ok {
		v.SupplyLimit = x
	}
	if x, ok := reader.ReadUrl(8); ok {
		v.Manager = x
	}

	seen, err := reader.Reset(fieldNames_CreateToken)
	v.fieldsSet = seen
	return err
}

func (v *CreateTokenAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreateTokenAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.TokenUrl = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.KeyBookUrl = x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.Scratch = x
	}
	if x, ok := reader.ReadUrl(6); ok {
		v.Manager = x
	}

	seen, err := reader.Reset(fieldNames_CreateTokenAccount)
	v.fieldsSet = seen
	return err
}

func (v *DataAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinary)
	if x, ok := reader.ReadBool(4); ok {
		v.Scratch = x
	}

	seen, err := reader.Reset(fieldNames_DataAccount)
	v.fieldsSet = seen
	return err
}

func (v *DataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadBytes(1); ok {
			v.Data = append(v.Data, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_DataEntry)
	v.fieldsSet = seen
	return err
}

func (v *DirectoryIndexMetadata) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DirectoryIndexMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Count = x
	}

	seen, err := reader.Reset(fieldNames_DirectoryIndexMetadata)
	v.fieldsSet = seen
	return err
}

func (v *DisableAccountAuthOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DisableAccountAuthOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountAuthOperationType
	if x := new(AccountAuthOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_DisableAccountAuthOperation)
	v.fieldsSet = seen
	return err
}

func (v *ED25519Signature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ED25519Signature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SignerVersion = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.Timestamp = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}

	seen, err := reader.Reset(fieldNames_ED25519Signature)
	v.fieldsSet = seen
	return err
}

func (v *EmptyResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *EmptyResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	seen, err := reader.Reset(fieldNames_EmptyResult)
	v.fieldsSet = seen
	return err
}

func (v *EnableAccountAuthOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *EnableAccountAuthOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountAuthOperationType
	if x := new(AccountAuthOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_EnableAccountAuthOperation)
	v.fieldsSet = seen
	return err
}

func (v *Envelope) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Envelope) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		ok := reader.ReadValue(1, func(b []byte) error {
			x, err := UnmarshalSignature(b)
			if err == nil {
				v.Signatures = append(v.Signatures, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.TxHash = x
	}
	if x := new(Transaction); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Transaction = x
	}

	seen, err := reader.Reset(fieldNames_Envelope)
	v.fieldsSet = seen
	return err
}

func (v *ForwardedSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ForwardedSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, func(b []byte) error {
		x, err := UnmarshalKeySignature(b)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	reader.ReadValue(3, func(b []byte) error {
		x, err := UnmarshalSigner(b)
		if err == nil {
			v.Signer = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_ForwardedSignature)
	v.fieldsSet = seen
	return err
}

func (v *HashSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *HashSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadHash(1); ok {
			v.Hashes = append(v.Hashes, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_HashSet)
	v.fieldsSet = seen
	return err
}

func (v *IndexEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *IndexEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Source = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Anchor = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.BlockIndex = x
	}
	if x, ok := reader.ReadTime(4); ok {
		v.BlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_IndexEntry)
	v.fieldsSet = seen
	return err
}

func (v *InternalGenesis) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InternalGenesis) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	seen, err := reader.Reset(fieldNames_InternalGenesis)
	v.fieldsSet = seen
	return err
}

func (v *InternalLedger) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InternalLedger) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinary)
	if x, ok := reader.ReadInt(4); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(5); ok {
		v.Timestamp = x
	}
	if x := new(SyntheticLedger); reader.ReadValue(6, x.UnmarshalBinary) {
		v.Synthetic = *x
	}
	if x, ok := reader.ReadUint(7); ok {
		v.PendingOracle = x
	}
	if x, ok := reader.ReadUint(8); ok {
		v.ActiveOracle = x
	}
	if x, ok := reader.ReadBigInt(9); ok {
		v.AcmeBurnt = *x
	}

	seen, err := reader.Reset(fieldNames_InternalLedger)
	v.fieldsSet = seen
	return err
}

func (v *InternalSendTransactions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InternalSendTransactions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		if x := new(SendTransaction); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_InternalSendTransactions)
	v.fieldsSet = seen
	return err
}

func (v *InternalSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InternalSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Network = x
	}

	seen, err := reader.Reset(fieldNames_InternalSignature)
	v.fieldsSet = seen
	return err
}

func (v *InternalSyntheticLedger) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InternalSyntheticLedger) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinary)
	for {
		if x := new(SyntheticLedgerEntry); reader.ReadValue(4, x.UnmarshalBinary) {
			v.Pending = append(v.Pending, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_InternalSyntheticLedger)
	v.fieldsSet = seen
	return err
}

func (v *InternalTransactionsSent) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InternalTransactionsSent) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		if x, ok := reader.ReadHash(2); ok {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_InternalTransactionsSent)
	v.fieldsSet = seen
	return err
}

func (v *InternalTransactionsSigned) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InternalTransactionsSigned) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		if x := new(TransactionSignature); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_InternalTransactionsSigned)
	v.fieldsSet = seen
	return err
}

func (v *IssueTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *IssueTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Recipient = x
	}
	if x, ok := reader.ReadBigInt(3); ok {
		v.Amount = *x
	}

	seen, err := reader.Reset(fieldNames_IssueTokens)
	v.fieldsSet = seen
	return err
}

func (v *KeyBook) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeyBook) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinary)
	if x, ok := reader.ReadUint(4); ok {
		v.PageCount = x
	}

	seen, err := reader.Reset(fieldNames_KeyBook)
	v.fieldsSet = seen
	return err
}

func (v *KeyPage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeyPage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.CreditBalance = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.AcceptThreshold = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.RejectThreshold = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.ResponseThreshold = x
	}
	if x, ok := reader.ReadUint(7); ok {
		v.BlockThreshold = x
	}
	if x, ok := reader.ReadUint(8); ok {
		v.Version = x
	}
	for {
		if x := new(KeySpec); reader.ReadValue(9, x.UnmarshalBinary) {
			v.Keys = append(v.Keys, x)
		} else {
			break
		}
	}
	if x := new(AllowedTransactions); reader.ReadEnum(10, x) {
		v.TransactionBlacklist = x
	}

	seen, err := reader.Reset(fieldNames_KeyPage)
	v.fieldsSet = seen
	return err
}

func (v *KeySpec) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeySpec) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.PublicKeyHash = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.LastUsedOn = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Owner = x
	}

	seen, err := reader.Reset(fieldNames_KeySpec)
	v.fieldsSet = seen
	return err
}

func (v *KeySpecParams) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeySpecParams) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.KeyHash = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Owner = x
	}

	seen, err := reader.Reset(fieldNames_KeySpecParams)
	v.fieldsSet = seen
	return err
}

func (v *LegacyED25519Signature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LegacyED25519Signature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Timestamp = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(5); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.SignerVersion = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}

	seen, err := reader.Reset(fieldNames_LegacyED25519Signature)
	v.fieldsSet = seen
	return err
}

func (v *LiteDataAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LiteDataAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Tail = x
	}

	seen, err := reader.Reset(fieldNames_LiteDataAccount)
	v.fieldsSet = seen
	return err
}

func (v *LiteIdentity) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LiteIdentity) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}

	seen, err := reader.Reset(fieldNames_LiteIdentity)
	v.fieldsSet = seen
	return err
}

func (v *LiteTokenAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LiteTokenAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.TokenUrl = x
	}
	if x, ok := reader.ReadBigInt(4); ok {
		v.Balance = *x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.LastUsedOn = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.CreditBalance = x
	}

	seen, err := reader.Reset(fieldNames_LiteTokenAccount)
	v.fieldsSet = seen
	return err
}

func (v *MetricsRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MetricsRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Metric = x
	}
	if x, ok := reader.ReadDuration(2); ok {
		v.Duration = x
	}

	seen, err := reader.Reset(fieldNames_MetricsRequest)
	v.fieldsSet = seen
	return err
}

func (v *Object) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Object) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(ObjectType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	for {
		if x := new(ChainMetadata); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Chains = append(v.Chains, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_Object)
	v.fieldsSet = seen
	return err
}

func (v *RCD1Signature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RCD1Signature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Signature = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SignerVersion = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.Timestamp = x
	}
	if x := new(VoteType); reader.ReadEnum(7, x) {
		v.Vote = *x
	}

	seen, err := reader.Reset(fieldNames_RCD1Signature)
	v.fieldsSet = seen
	return err
}

func (v *Receipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Receipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Result = x
	}
	for {
		if x := new(ReceiptEntry); reader.ReadValue(3, x.UnmarshalBinary) {
			v.Entries = append(v.Entries, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_Receipt)
	v.fieldsSet = seen
	return err
}

func (v *ReceiptEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ReceiptEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Right = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Hash = x
	}

	seen, err := reader.Reset(fieldNames_ReceiptEntry)
	v.fieldsSet = seen
	return err
}

func (v *ReceiptSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ReceiptSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, v.Receipt.UnmarshalBinary)
	if x, ok := reader.ReadUrl(3); ok {
		v.SourceNetwork = x
	}

	seen, err := reader.Reset(fieldNames_ReceiptSignature)
	v.fieldsSet = seen
	return err
}

func (v *RemoteTransactionBody) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RemoteTransactionBody) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	seen, err := reader.Reset(fieldNames_RemoteTransactionBody)
	v.fieldsSet = seen
	return err
}

func (v *RemoveAccountAuthorityOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RemoveAccountAuthorityOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountAuthOperationType
	if x := new(AccountAuthOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}

	seen, err := reader.Reset(fieldNames_RemoveAccountAuthorityOperation)
	v.fieldsSet = seen
	return err
}

func (v *RemoveKeyOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RemoveKeyOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x := new(KeySpecParams); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_RemoveKeyOperation)
	v.fieldsSet = seen
	return err
}

func (v *RemoveValidator) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RemoveValidator) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Key = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Owner = x
	}

	seen, err := reader.Reset(fieldNames_RemoveValidator)
	v.fieldsSet = seen
	return err
}

func (v *SegWitDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SegWitDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinary)
	if x, ok := reader.ReadUrl(3); ok {
		v.EntryUrl = x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.EntryHash = *x
	}

	seen, err := reader.Reset(fieldNames_SegWitDataEntry)
	v.fieldsSet = seen
	return err
}

func (v *SendTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SendTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadHash(2); ok {
		v.Hash = *x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Meta = x
	}
	for {
		if x := new(TokenRecipient); reader.ReadValue(4, x.UnmarshalBinary) {
			v.To = append(v.To, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SendTokens)
	v.fieldsSet = seen
	return err
}

func (v *SendTransaction) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SendTransaction) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(b []byte) error {
		x, err := UnmarshalTransaction(b)
		if err == nil {
			v.Payload = x
		}
		return err
	})
	if x, ok := reader.ReadUrl(2); ok {
		v.Recipient = x
	}

	seen, err := reader.Reset(fieldNames_SendTransaction)
	v.fieldsSet = seen
	return err
}

func (v *SetThresholdKeyPageOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SetThresholdKeyPageOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Threshold = x
	}

	seen, err := reader.Reset(fieldNames_SetThresholdKeyPageOperation)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticAnchor) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticAnchor) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Source = x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.Major = x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.RootAnchor = *x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.RootIndex = x
	}
	if x, ok := reader.ReadBigInt(6); ok {
		v.AcmeBurnt = *x
	}
	if x, ok := reader.ReadUint(7); ok {
		v.Block = x
	}
	if x, ok := reader.ReadUint(8); ok {
		v.AcmeOraclePrice = x
	}
	for {
		if x := new(Receipt); reader.ReadValue(9, x.UnmarshalBinary) {
			v.Receipts = append(v.Receipts, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SyntheticAnchor)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticBurnTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticBurnTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinary)
	if x, ok := reader.ReadBigInt(3); ok {
		v.Amount = *x
	}

	seen, err := reader.Reset(fieldNames_SyntheticBurnTokens)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticCreateChain) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticCreateChain) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinary)
	for {
		if x := new(ChainParams); reader.ReadValue(3, x.UnmarshalBinary) {
			v.Chains = append(v.Chains, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SyntheticCreateChain)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticDepositCredits) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticDepositCredits) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinary)
	if x, ok := reader.ReadUint(3); ok {
		v.Amount = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticDepositCredits)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticDepositTokens) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticDepositTokens) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinary)
	if x, ok := reader.ReadUrl(3); ok {
		v.Token = x
	}
	if x, ok := reader.ReadBigInt(4); ok {
		v.Amount = *x
	}

	seen, err := reader.Reset(fieldNames_SyntheticDepositTokens)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticForwardTransaction) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticForwardTransaction) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		if x := new(ForwardedSignature); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Signatures = append(v.Signatures, *x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.TransactionHash = x
	}
	if x := new(Transaction); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Transaction = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticForwardTransaction)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticLedger) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticLedger) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Nonce = x
	}
	for {
		if x, ok := reader.ReadHash(2); ok {
			v.Unsigned = append(v.Unsigned, *x)
		} else {
			break
		}
	}
	for {
		if x, ok := reader.ReadHash(3); ok {
			v.Unsent = append(v.Unsent, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SyntheticLedger)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticLedgerEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticLedgerEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.TransactionHash = *x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.RootAnchor = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.SynthIndex = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.SynthIndexIndex = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.RootIndexIndex = x
	}
	if x, ok := reader.ReadBool(6); ok {
		v.NeedsReceipt = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticLedgerEntry)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticMirror) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticMirror) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		if x := new(AnchoredRecord); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Objects = append(v.Objects, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SyntheticMirror)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticOrigin) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticOrigin) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Source = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.Cause = *x
	}

	seen, err := reader.Reset(fieldNames_SyntheticOrigin)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinary)
	if x, ok := reader.ReadHash(3); ok {
		v.SynthTxHash = *x
	}
	if x := new(TransactionStatus); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Status = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticReceipt)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType SignatureType
	if x := new(SignatureType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.SourceNetwork = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.DestinationNetwork = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.SequenceNumber = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticSignature)
	v.fieldsSet = seen
	return err
}

func (v *SyntheticWriteData) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticWriteData) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	reader.ReadValue(2, v.SyntheticOrigin.UnmarshalBinary)
	if x := new(DataEntry); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_SyntheticWriteData)
	v.fieldsSet = seen
	return err
}

func (v *TokenAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TokenAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinary)
	if x, ok := reader.ReadUrl(4); ok {
		v.TokenUrl = x
	}
	if x, ok := reader.ReadBigInt(5); ok {
		v.Balance = *x
	}
	if x, ok := reader.ReadBool(6); ok {
		v.Scratch = x
	}

	seen, err := reader.Reset(fieldNames_TokenAccount)
	v.fieldsSet = seen
	return err
}

func (v *TokenIssuer) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TokenIssuer) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	reader.ReadValue(3, v.AccountAuth.UnmarshalBinary)
	if x, ok := reader.ReadString(4); ok {
		v.Symbol = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Precision = x
	}
	if x, ok := reader.ReadUrl(6); ok {
		v.Properties = x
	}
	if x, ok := reader.ReadBigInt(7); ok {
		v.Issued = *x
	}
	if x, ok := reader.ReadBigInt(8); ok {
		v.SupplyLimit = x
	}

	seen, err := reader.Reset(fieldNames_TokenIssuer)
	v.fieldsSet = seen
	return err
}

func (v *TokenRecipient) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TokenRecipient) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBigInt(2); ok {
		v.Amount = *x
	}

	seen, err := reader.Reset(fieldNames_TokenRecipient)
	v.fieldsSet = seen
	return err
}

func (v *Transaction) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Transaction) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(TransactionHeader); reader.ReadValue(1, x.UnmarshalBinary) {
		v.Header = *x
	}
	reader.ReadValue(2, func(b []byte) error {
		x, err := UnmarshalTransaction(b)
		if err == nil {
			v.Body = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_Transaction)
	v.fieldsSet = seen
	return err
}

func (v *TransactionHeader) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionHeader) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Principal = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.Initiator = *x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Memo = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.Metadata = x
	}

	seen, err := reader.Reset(fieldNames_TransactionHeader)
	v.fieldsSet = seen
	return err
}

func (v *TransactionResultSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionResultSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(TransactionStatus); reader.ReadValue(1, x.UnmarshalBinary) {
			v.Results = append(v.Results, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_TransactionResultSet)
	v.fieldsSet = seen
	return err
}

func (v *TransactionSignature) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionSignature) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.Transaction = *x
	}
	reader.ReadValue(2, func(b []byte) error {
		x, err := UnmarshalSignature(b)
		if err == nil {
			v.Signature = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_TransactionSignature)
	v.fieldsSet = seen
	return err
}

func (v *TransactionStatus) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionStatus) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Remote = x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.Delivered = x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.Pending = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Code = x
	}
	if x, ok := reader.ReadString(5); ok {
		v.Message = x
	}
	reader.ReadValue(6, func(b []byte) error {
		x, err := UnmarshalTransactionResult(b)
		if err == nil {
			v.Result = x
		}
		return err
	})
	if x, ok := reader.ReadUrl(7); ok {
		v.Initiator = x
	}
	for {
		ok := reader.ReadValue(8, func(b []byte) error {
			x, err := UnmarshalSigner(b)
			if err == nil {
				v.Signers = append(v.Signers, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_TransactionStatus)
	v.fieldsSet = seen
	return err
}

func (v *UnknownAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UnknownAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}

	seen, err := reader.Reset(fieldNames_UnknownAccount)
	v.fieldsSet = seen
	return err
}

func (v *UnknownSigner) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UnknownSigner) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType AccountType
	if x := new(AccountType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Version = x
	}

	seen, err := reader.Reset(fieldNames_UnknownSigner)
	v.fieldsSet = seen
	return err
}

func (v *UpdateAccountAuth) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateAccountAuth) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		ok := reader.ReadValue(2, func(b []byte) error {
			x, err := UnmarshalAccountAuthOperation(b)
			if err == nil {
				v.Operations = append(v.Operations, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_UpdateAccountAuth)
	v.fieldsSet = seen
	return err
}

func (v *UpdateAllowedKeyPageOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateAllowedKeyPageOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		if x := new(TransactionType); reader.ReadEnum(2, x) {
			v.Allow = append(v.Allow, *x)
		} else {
			break
		}
	}
	for {
		if x := new(TransactionType); reader.ReadEnum(3, x) {
			v.Deny = append(v.Deny, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_UpdateAllowedKeyPageOperation)
	v.fieldsSet = seen
	return err
}

func (v *UpdateKey) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateKey) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.NewKeyHash = x
	}

	seen, err := reader.Reset(fieldNames_UpdateKey)
	v.fieldsSet = seen
	return err
}

func (v *UpdateKeyOperation) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateKeyOperation) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyPageOperationType
	if x := new(KeyPageOperationType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x := new(KeySpecParams); reader.ReadValue(2, x.UnmarshalBinary) {
		v.OldEntry = *x
	}
	if x := new(KeySpecParams); reader.ReadValue(3, x.UnmarshalBinary) {
		v.NewEntry = *x
	}

	seen, err := reader.Reset(fieldNames_UpdateKeyOperation)
	v.fieldsSet = seen
	return err
}

func (v *UpdateKeyPage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateKeyPage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	for {
		ok := reader.ReadValue(2, func(b []byte) error {
			x, err := UnmarshalKeyPageOperation(b)
			if err == nil {
				v.Operation = append(v.Operation, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_UpdateKeyPage)
	v.fieldsSet = seen
	return err
}

func (v *UpdateValidatorKey) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UpdateValidatorKey) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.KeyHash = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.NewKeyHash = x
	}

	seen, err := reader.Reset(fieldNames_UpdateValidatorKey)
	v.fieldsSet = seen
	return err
}

func (v *WriteData) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *WriteData) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x := new(DataEntry); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_WriteData)
	v.fieldsSet = seen
	return err
}

func (v *WriteDataResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *WriteDataResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadHash(2); ok {
		v.EntryHash = *x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.AccountUrl = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.AccountID = x
	}

	seen, err := reader.Reset(fieldNames_WriteDataResult)
	v.fieldsSet = seen
	return err
}

func (v *WriteDataTo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *WriteDataTo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType TransactionType
	if x := new(TransactionType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Recipient = x
	}
	if x := new(DataEntry); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_WriteDataTo)
	v.fieldsSet = seen
	return err
}

func (v *ADI) MarshalJSON() ([]byte, error) {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	return json.Marshal(&u)
}

func (v *AcmeFaucet) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
		Url  *url.URL        `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	return json.Marshal(&u)
}

func (v *AddAccountAuthorityOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	return json.Marshal(&u)
}

func (v *AddCredits) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType `json:"type"`
		Recipient *url.URL        `json:"recipient,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
		Oracle    uint64          `json:"oracle,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Oracle = v.Oracle
	return json.Marshal(&u)
}

func (v *AddCreditsResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    TransactionType `json:"type"`
		Amount  *string         `json:"amount,omitempty"`
		Credits uint64          `json:"credits,omitempty"`
		Oracle  uint64          `json:"oracle,omitempty"`
	}{}
	u.Type = v.Type()
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Credits = v.Credits
	u.Oracle = v.Oracle
	return json.Marshal(&u)
}

func (v *AddKeyOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Entry KeySpecParams        `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *AddValidator) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  TransactionType `json:"type"`
		Key   *string         `json:"key,omitempty"`
		Owner *url.URL        `json:"owner,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = encoding.BytesToJSON(v.Key)
	u.Owner = v.Owner
	return json.Marshal(&u)
}

func (v *Anchor) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        AccountType      `json:"type"`
		Url         *url.URL         `json:"url,omitempty"`
		Authorities []AuthorityEntry `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	return json.Marshal(&u)
}

func (v *AnchorMetadata) MarshalJSON() ([]byte, error) {
	u := struct {
		Name        string    `json:"name,omitempty"`
		Type        ChainType `json:"type,omitempty"`
		Account     *url.URL  `json:"account,omitempty"`
		Index       uint64    `json:"index,omitempty"`
		SourceIndex uint64    `json:"sourceIndex,omitempty"`
		SourceBlock uint64    `json:"sourceBlock,omitempty"`
		Entry       *string   `json:"entry,omitempty"`
	}{}
	u.Name = v.ChainMetadata.Name
	u.Type = v.ChainMetadata.Type
	u.Account = v.Account
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesToJSON(v.Entry)
	return json.Marshal(&u)
}

func (v *AnchoredRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		Record *string `json:"record,omitempty"`
		Anchor string  `json:"anchor,omitempty"`
	}{}
	u.Record = encoding.BytesToJSON(v.Record)
	u.Anchor = encoding.ChainToJSON(v.Anchor)
	return json.Marshal(&u)
}

func (v *BurnTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   TransactionType `json:"type"`
		Amount *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *ChainParams) MarshalJSON() ([]byte, error) {
	u := struct {
		Data     *string `json:"data,omitempty"`
		IsUpdate bool    `json:"isUpdate,omitempty"`
	}{}
	u.Data = encoding.BytesToJSON(v.Data)
	u.IsUpdate = v.IsUpdate
	return json.Marshal(&u)
}

func (v *CreateDataAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type              TransactionType `json:"type"`
		Url               *url.URL        `json:"url,omitempty"`
		KeyBookUrl        *url.URL        `json:"keyBookUrl,omitempty"`
		ManagerKeyBookUrl *url.URL        `json:"managerKeyBookUrl,omitempty"`
		Scratch           bool            `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.KeyBookUrl = v.KeyBookUrl
	u.ManagerKeyBookUrl = v.ManagerKeyBookUrl
	u.Scratch = v.Scratch
	return json.Marshal(&u)
}

func (v *CreateIdentity) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType `json:"type"`
		Url        *url.URL        `json:"url,omitempty"`
		KeyHash    *string         `json:"keyHash,omitempty"`
		KeyBookUrl *url.URL        `json:"keyBookUrl,omitempty"`
		Manager    *url.URL        `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	u.KeyBookUrl = v.KeyBookUrl
	u.Manager = v.Manager
	return json.Marshal(&u)
}

func (v *CreateKeyBook) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          TransactionType `json:"type"`
		Url           *url.URL        `json:"url,omitempty"`
		PublicKeyHash *string         `json:"publicKeyHash,omitempty"`
		Manager       *url.URL        `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	u.Manager = v.Manager
	return json.Marshal(&u)
}

func (v *CreateKeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    TransactionType  `json:"type"`
		Keys    []*KeySpecParams `json:"keys,omitempty"`
		Manager *url.URL         `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Keys = v.Keys
	u.Manager = v.Manager
	return json.Marshal(&u)
}

func (v *CreateToken) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        TransactionType `json:"type"`
		Url         *url.URL        `json:"url,omitempty"`
		KeyBookUrl  *url.URL        `json:"keyBookUrl,omitempty"`
		Symbol      string          `json:"symbol,omitempty"`
		Precision   uint64          `json:"precision,omitempty"`
		Properties  *url.URL        `json:"properties,omitempty"`
		SupplyLimit *string         `json:"supplyLimit,omitempty"`
		Manager     *url.URL        `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.KeyBookUrl = v.KeyBookUrl
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.SupplyLimit = encoding.BigintToJSON(v.SupplyLimit)
	u.Manager = v.Manager
	return json.Marshal(&u)
}

func (v *CreateTokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType `json:"type"`
		Url        *url.URL        `json:"url,omitempty"`
		TokenUrl   *url.URL        `json:"tokenUrl,omitempty"`
		KeyBookUrl *url.URL        `json:"keyBookUrl,omitempty"`
		Scratch    bool            `json:"scratch,omitempty"`
		Manager    *url.URL        `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.TokenUrl = v.TokenUrl
	u.KeyBookUrl = v.KeyBookUrl
	u.Scratch = v.Scratch
	u.Manager = v.Manager
	return json.Marshal(&u)
}

func (v *DataAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
		Scratch        bool             `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Scratch = v.Scratch
	return json.Marshal(&u)
}

func (v *DataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Data []*string `json:"data,omitempty"`
	}{}
	u.Data = make([]*string, len(v.Data))
	for i, x := range v.Data {
		u.Data[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *DisableAccountAuthOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	return json.Marshal(&u)
}

func (v *ED25519Signature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          SignatureType `json:"type"`
		PublicKey     *string       `json:"publicKey,omitempty"`
		Signature     *string       `json:"signature,omitempty"`
		Signer        *url.URL      `json:"signer,omitempty"`
		SignerVersion uint64        `json:"signerVersion,omitempty"`
		Timestamp     uint64        `json:"timestamp,omitempty"`
		Vote          VoteType      `json:"vote,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	return json.Marshal(&u)
}

func (v *EmptyResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *EnableAccountAuthOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	return json.Marshal(&u)
}

func (v *Envelope) MarshalJSON() ([]byte, error) {
	u := struct {
		Signatures  []json.RawMessage `json:"signatures,omitempty"`
		TxHash      *string           `json:"txHash,omitempty"`
		Transaction *Transaction      `json:"transaction,omitempty"`
	}{}
	u.Signatures = make([]json.RawMessage, len(v.Signatures))
	for i, x := range v.Signatures {
		if y, err := json.Marshal(x); err != nil {
			return nil, fmt.Errorf("error encoding Signatures: %w", err)
		} else {
			u.Signatures[i] = y
		}
	}
	u.TxHash = encoding.BytesToJSON(v.TxHash)
	u.Transaction = v.Transaction
	return json.Marshal(&u)
}

func (v *ForwardedSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      SignatureType   `json:"type"`
		Signature json.RawMessage `json:"signature,omitempty"`
		Signer    json.RawMessage `json:"signer,omitempty"`
	}{}
	u.Type = v.Type()
	if x, err := json.Marshal(v.Signature); err != nil {
		return nil, fmt.Errorf("error encoding Signature: %w", err)
	} else {
		u.Signature = x
	}
	if x, err := json.Marshal(v.Signer); err != nil {
		return nil, fmt.Errorf("error encoding Signer: %w", err)
	} else {
		u.Signer = x
	}
	return json.Marshal(&u)
}

func (v *HashSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Hashes []string `json:"hashes,omitempty"`
	}{}
	u.Hashes = make([]string, len(v.Hashes))
	for i, x := range v.Hashes {
		u.Hashes[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *InternalGenesis) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *InternalLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          AccountType      `json:"type"`
		Url           *url.URL         `json:"url,omitempty"`
		Authorities   []AuthorityEntry `json:"authorities,omitempty"`
		Index         int64            `json:"index,omitempty"`
		Timestamp     time.Time        `json:"timestamp,omitempty"`
		Synthetic     SyntheticLedger  `json:"synthetic,omitempty"`
		PendingOracle uint64           `json:"pendingOracle,omitempty"`
		ActiveOracle  uint64           `json:"activeOracle,omitempty"`
		AcmeBurnt     *string          `json:"acmeBurnt,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Index = v.Index
	u.Timestamp = v.Timestamp
	u.Synthetic = v.Synthetic
	u.PendingOracle = v.PendingOracle
	u.ActiveOracle = v.ActiveOracle
	u.AcmeBurnt = encoding.BigintToJSON(&v.AcmeBurnt)
	return json.Marshal(&u)
}

func (v *InternalSendTransactions) MarshalJSON() ([]byte, error) {
	u := struct {
		Type         TransactionType   `json:"type"`
		Transactions []SendTransaction `json:"transactions,omitempty"`
	}{}
	u.Type = v.Type()
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *InternalSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    SignatureType `json:"type"`
		Network *url.URL      `json:"network,omitempty"`
	}{}
	u.Type = v.Type()
	u.Network = v.Network
	return json.Marshal(&u)
}

func (v *InternalSyntheticLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        AccountType             `json:"type"`
		Url         *url.URL                `json:"url,omitempty"`
		Authorities []AuthorityEntry        `json:"authorities,omitempty"`
		Pending     []*SyntheticLedgerEntry `json:"pending,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Pending = v.Pending
	return json.Marshal(&u)
}

func (v *InternalTransactionsSent) MarshalJSON() ([]byte, error) {
	u := struct {
		Type         TransactionType `json:"type"`
		Transactions []string        `json:"transactions,omitempty"`
	}{}
	u.Type = v.Type()
	u.Transactions = make([]string, len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *InternalTransactionsSigned) MarshalJSON() ([]byte, error) {
	u := struct {
		Type         TransactionType        `json:"type"`
		Transactions []TransactionSignature `json:"transactions,omitempty"`
	}{}
	u.Type = v.Type()
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *IssueTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType `json:"type"`
		Recipient *url.URL        `json:"recipient,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *KeyBook) MarshalJSON() ([]byte, error) {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
		PageCount      uint64           `json:"pageCount,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.PageCount = v.PageCount
	return json.Marshal(&u)
}

func (v *KeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type                 AccountType          `json:"type"`
		KeyBook              *url.URL             `json:"keyBook,omitempty"`
		Url                  *url.URL             `json:"url,omitempty"`
		CreditBalance        uint64               `json:"creditBalance,omitempty"`
		AcceptThreshold      uint64               `json:"acceptThreshold,omitempty"`
		Threshold            uint64               `json:"threshold,omitempty"`
		RejectThreshold      uint64               `json:"rejectThreshold,omitempty"`
		ResponseThreshold    uint64               `json:"responseThreshold,omitempty"`
		BlockThreshold       uint64               `json:"blockThreshold,omitempty"`
		Version              uint64               `json:"version,omitempty"`
		Keys                 []*KeySpec           `json:"keys,omitempty"`
		TransactionBlacklist *AllowedTransactions `json:"transactionBlacklist,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.Url = v.Url
	u.CreditBalance = v.CreditBalance
	u.AcceptThreshold = v.AcceptThreshold
	u.Threshold = v.AcceptThreshold
	u.RejectThreshold = v.RejectThreshold
	u.ResponseThreshold = v.ResponseThreshold
	u.BlockThreshold = v.BlockThreshold
	u.Version = v.Version
	u.Keys = v.Keys
	u.TransactionBlacklist = v.TransactionBlacklist
	return json.Marshal(&u)
}

func (v *KeySpec) MarshalJSON() ([]byte, error) {
	u := struct {
		PublicKeyHash *string  `json:"publicKeyHash,omitempty"`
		PublicKey     *string  `json:"publicKey,omitempty"`
		LastUsedOn    uint64   `json:"lastUsedOn,omitempty"`
		Nonce         uint64   `json:"nonce,omitempty"`
		Owner         *url.URL `json:"owner,omitempty"`
	}{}
	u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	u.PublicKey = encoding.BytesToJSON(v.PublicKeyHash)
	u.LastUsedOn = v.LastUsedOn
	u.Nonce = v.LastUsedOn
	u.Owner = v.Owner
	return json.Marshal(&u)
}

func (v *KeySpecParams) MarshalJSON() ([]byte, error) {
	u := struct {
		KeyHash *string  `json:"keyHash,omitempty"`
		Owner   *url.URL `json:"owner,omitempty"`
	}{}
	u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	u.Owner = v.Owner
	return json.Marshal(&u)
}

func (v *LegacyED25519Signature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          SignatureType `json:"type"`
		Timestamp     uint64        `json:"timestamp,omitempty"`
		Nonce         uint64        `json:"nonce,omitempty"`
		PublicKey     *string       `json:"publicKey,omitempty"`
		Signature     *string       `json:"signature,omitempty"`
		Signer        *url.URL      `json:"signer,omitempty"`
		SignerVersion uint64        `json:"signerVersion,omitempty"`
		Vote          VoteType      `json:"vote,omitempty"`
	}{}
	u.Type = v.Type()
	u.Timestamp = v.Timestamp
	u.Nonce = v.Timestamp
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Vote = v.Vote
	return json.Marshal(&u)
}

func (v *LiteDataAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
		Tail *string     `json:"tail,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Tail = encoding.BytesToJSON(v.Tail)
	return json.Marshal(&u)
}

func (v *LiteIdentity) MarshalJSON() ([]byte, error) {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	return json.Marshal(&u)
}

func (v *LiteTokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          AccountType `json:"type"`
		Url           *url.URL    `json:"url,omitempty"`
		TokenUrl      *url.URL    `json:"tokenUrl,omitempty"`
		Balance       *string     `json:"balance,omitempty"`
		LastUsedOn    uint64      `json:"lastUsedOn,omitempty"`
		Nonce         uint64      `json:"nonce,omitempty"`
		CreditBalance uint64      `json:"creditBalance,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.LastUsedOn = v.LastUsedOn
	u.Nonce = v.LastUsedOn
	u.CreditBalance = v.CreditBalance
	return json.Marshal(&u)
}

func (v *MetricsRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	return json.Marshal(&u)
}

func (v *MetricsResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	u.Value = encoding.AnyToJSON(v.Value)
	return json.Marshal(&u)
}

func (v *RCD1Signature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          SignatureType `json:"type"`
		PublicKey     *string       `json:"publicKey,omitempty"`
		Signature     *string       `json:"signature,omitempty"`
		Signer        *url.URL      `json:"signer,omitempty"`
		SignerVersion uint64        `json:"signerVersion,omitempty"`
		Timestamp     uint64        `json:"timestamp,omitempty"`
		Vote          VoteType      `json:"vote,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	return json.Marshal(&u)
}

func (v *Receipt) MarshalJSON() ([]byte, error) {
	u := struct {
		Start   *string        `json:"start,omitempty"`
		Result  *string        `json:"result,omitempty"`
		Entries []ReceiptEntry `json:"entries,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Start)
	u.Result = encoding.BytesToJSON(v.Result)
	u.Entries = v.Entries
	return json.Marshal(&u)
}

func (v *ReceiptEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Right bool    `json:"right,omitempty"`
		Hash  *string `json:"hash,omitempty"`
	}{}
	u.Right = v.Right
	u.Hash = encoding.BytesToJSON(v.Hash)
	return json.Marshal(&u)
}

func (v *ReceiptSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          SignatureType  `json:"type"`
		Start         *string        `json:"start,omitempty"`
		Result        *string        `json:"result,omitempty"`
		Entries       []ReceiptEntry `json:"entries,omitempty"`
		SourceNetwork *url.URL       `json:"sourceNetwork,omitempty"`
	}{}
	u.Type = v.Type()
	u.Start = encoding.BytesToJSON(v.Receipt.Start)
	u.Result = encoding.BytesToJSON(v.Receipt.Result)
	u.Entries = v.Receipt.Entries
	u.SourceNetwork = v.SourceNetwork
	return json.Marshal(&u)
}

func (v *RemoteTransactionBody) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *RemoveAccountAuthorityOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	return json.Marshal(&u)
}

func (v *RemoveKeyOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Entry KeySpecParams        `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *RemoveValidator) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  TransactionType `json:"type"`
		Key   *string         `json:"key,omitempty"`
		Owner *url.URL        `json:"owner,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = encoding.BytesToJSON(v.Key)
	u.Owner = v.Owner
	return json.Marshal(&u)
}

func (v *SegWitDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType `json:"type"`
		Source    *url.URL        `json:"source,omitempty"`
		Cause     string          `json:"cause,omitempty"`
		EntryUrl  *url.URL        `json:"entryUrl,omitempty"`
		EntryHash string          `json:"entryHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.EntryUrl = v.EntryUrl
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}

func (v *SendTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type TransactionType   `json:"type"`
		Hash string            `json:"hash,omitempty"`
		Meta json.RawMessage   `json:"meta,omitempty"`
		To   []*TokenRecipient `json:"to,omitempty"`
	}{}
	u.Type = v.Type()
	u.Hash = encoding.ChainToJSON(v.Hash)
	u.Meta = v.Meta
	u.To = v.To
	return json.Marshal(&u)
}

func (v *SendTransaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Payload   json.RawMessage `json:"payload,omitempty"`
		Recipient *url.URL        `json:"recipient,omitempty"`
	}{}
	if x, err := json.Marshal(v.Payload); err != nil {
		return nil, fmt.Errorf("error encoding Payload: %w", err)
	} else {
		u.Payload = x
	}
	u.Recipient = v.Recipient
	return json.Marshal(&u)
}

func (v *SetThresholdKeyPageOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      KeyPageOperationType `json:"type"`
		Threshold uint64               `json:"threshold,omitempty"`
	}{}
	u.Type = v.Type()
	u.Threshold = v.Threshold
	return json.Marshal(&u)
}

func (v *SyntheticAnchor) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            TransactionType `json:"type"`
		Source          *url.URL        `json:"source,omitempty"`
		Major           bool            `json:"major,omitempty"`
		RootAnchor      string          `json:"rootAnchor,omitempty"`
		RootIndex       uint64          `json:"rootIndex,omitempty"`
		AcmeBurnt       *string         `json:"acmeBurnt,omitempty"`
		Block           uint64          `json:"block,omitempty"`
		AcmeOraclePrice uint64          `json:"acmeOraclePrice,omitempty"`
		Receipts        []Receipt       `json:"receipts,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.Source
	u.Major = v.Major
	u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
	u.RootIndex = v.RootIndex
	u.AcmeBurnt = encoding.BigintToJSON(&v.AcmeBurnt)
	u.Block = v.Block
	u.AcmeOraclePrice = v.AcmeOraclePrice
	u.Receipts = v.Receipts
	return json.Marshal(&u)
}

func (v *SyntheticBurnTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Amount *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *SyntheticCreateChain) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Chains []ChainParams   `json:"chains,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Chains = v.Chains
	return json.Marshal(&u)
}

func (v *SyntheticDepositCredits) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Amount uint64          `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Amount = v.Amount
	return json.Marshal(&u)
}

func (v *SyntheticDepositTokens) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Token  *url.URL        `json:"token,omitempty"`
		Amount *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Token = v.Token
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *SyntheticForwardTransaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            TransactionType      `json:"type"`
		Signatures      []ForwardedSignature `json:"signatures,omitempty"`
		TransactionHash *string              `json:"transactionHash,omitempty"`
		Transaction     *Transaction         `json:"transaction,omitempty"`
	}{}
	u.Type = v.Type()
	u.Signatures = v.Signatures
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	u.Transaction = v.Transaction
	return json.Marshal(&u)
}

func (v *SyntheticLedger) MarshalJSON() ([]byte, error) {
	u := struct {
		Nonce    uint64   `json:"nonce,omitempty"`
		Unsigned []string `json:"unsigned,omitempty"`
		Unsent   []string `json:"unsent,omitempty"`
	}{}
	u.Nonce = v.Nonce
	u.Unsigned = make([]string, len(v.Unsigned))
	for i, x := range v.Unsigned {
		u.Unsigned[i] = encoding.ChainToJSON(x)
	}
	u.Unsent = make([]string, len(v.Unsent))
	for i, x := range v.Unsent {
		u.Unsent[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *SyntheticLedgerEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		TransactionHash string `json:"transactionHash,omitempty"`
		RootAnchor      string `json:"rootAnchor,omitempty"`
		SynthIndex      uint64 `json:"synthIndex,omitempty"`
		SynthIndexIndex uint64 `json:"synthIndexIndex,omitempty"`
		RootIndexIndex  uint64 `json:"rootIndexIndex,omitempty"`
		NeedsReceipt    bool   `json:"needsReceipt,omitempty"`
	}{}
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
	u.SynthIndex = v.SynthIndex
	u.SynthIndexIndex = v.SynthIndexIndex
	u.RootIndexIndex = v.RootIndexIndex
	u.NeedsReceipt = v.NeedsReceipt
	return json.Marshal(&u)
}

func (v *SyntheticMirror) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    TransactionType  `json:"type"`
		Objects []AnchoredRecord `json:"objects,omitempty"`
	}{}
	u.Type = v.Type()
	u.Objects = v.Objects
	return json.Marshal(&u)
}

func (v *SyntheticOrigin) MarshalJSON() ([]byte, error) {
	u := struct {
		Source *url.URL `json:"source,omitempty"`
		Cause  string   `json:"cause,omitempty"`
	}{}
	u.Source = v.Source
	u.Cause = encoding.ChainToJSON(v.Cause)
	return json.Marshal(&u)
}

func (v *SyntheticReceipt) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        TransactionType    `json:"type"`
		Source      *url.URL           `json:"source,omitempty"`
		Cause       string             `json:"cause,omitempty"`
		SynthTxHash string             `json:"synthTxHash,omitempty"`
		Status      *TransactionStatus `json:"status,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.SynthTxHash = encoding.ChainToJSON(v.SynthTxHash)
	u.Status = v.Status
	return json.Marshal(&u)
}

func (v *SyntheticSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Type               SignatureType `json:"type"`
		SourceNetwork      *url.URL      `json:"sourceNetwork,omitempty"`
		DestinationNetwork *url.URL      `json:"destinationNetwork,omitempty"`
		SequenceNumber     uint64        `json:"sequenceNumber,omitempty"`
	}{}
	u.Type = v.Type()
	u.SourceNetwork = v.SourceNetwork
	u.DestinationNetwork = v.DestinationNetwork
	u.SequenceNumber = v.SequenceNumber
	return json.Marshal(&u)
}

func (v *SyntheticWriteData) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Entry  DataEntry       `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *TokenAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
		TokenUrl       *url.URL         `json:"tokenUrl,omitempty"`
		Balance        *string          `json:"balance,omitempty"`
		Scratch        bool             `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.Scratch = v.Scratch
	return json.Marshal(&u)
}

func (v *TokenIssuer) MarshalJSON() ([]byte, error) {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
		Symbol         string           `json:"symbol,omitempty"`
		Precision      uint64           `json:"precision,omitempty"`
		Properties     *url.URL         `json:"properties,omitempty"`
		Issued         *string          `json:"issued,omitempty"`
		SupplyLimit    *string          `json:"supplyLimit,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.Issued = encoding.BigintToJSON(&v.Issued)
	u.SupplyLimit = encoding.BigintToJSON(v.SupplyLimit)
	return json.Marshal(&u)
}

func (v *TokenRecipient) MarshalJSON() ([]byte, error) {
	u := struct {
		Url    *url.URL `json:"url,omitempty"`
		Amount *string  `json:"amount,omitempty"`
	}{}
	u.Url = v.Url
	u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *Transaction) MarshalJSON() ([]byte, error) {
	u := struct {
		Header TransactionHeader `json:"header,omitempty"`
		Body   json.RawMessage   `json:"body,omitempty"`
	}{}
	u.Header = v.Header
	if x, err := json.Marshal(v.Body); err != nil {
		return nil, fmt.Errorf("error encoding Body: %w", err)
	} else {
		u.Body = x
	}
	return json.Marshal(&u)
}

func (v *TransactionHeader) MarshalJSON() ([]byte, error) {
	u := struct {
		Principal *url.URL `json:"principal,omitempty"`
		Origin    *url.URL `json:"origin,omitempty"`
		Initiator string   `json:"initiator,omitempty"`
		Memo      string   `json:"memo,omitempty"`
		Metadata  *string  `json:"metadata,omitempty"`
	}{}
	u.Principal = v.Principal
	u.Origin = v.Principal
	u.Initiator = encoding.ChainToJSON(v.Initiator)
	u.Memo = v.Memo
	u.Metadata = encoding.BytesToJSON(v.Metadata)
	return json.Marshal(&u)
}

func (v *TransactionSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Transaction string          `json:"transaction,omitempty"`
		Signature   json.RawMessage `json:"signature,omitempty"`
	}{}
	u.Transaction = encoding.ChainToJSON(v.Transaction)
	if x, err := json.Marshal(v.Signature); err != nil {
		return nil, fmt.Errorf("error encoding Signature: %w", err)
	} else {
		u.Signature = x
	}
	return json.Marshal(&u)
}

func (v *TransactionStatus) MarshalJSON() ([]byte, error) {
	u := struct {
		Remote    bool              `json:"remote,omitempty"`
		Delivered bool              `json:"delivered,omitempty"`
		Pending   bool              `json:"pending,omitempty"`
		Code      uint64            `json:"code,omitempty"`
		Message   string            `json:"message,omitempty"`
		Result    json.RawMessage   `json:"result,omitempty"`
		Initiator *url.URL          `json:"initiator,omitempty"`
		Signers   []json.RawMessage `json:"signers,omitempty"`
	}{}
	u.Remote = v.Remote
	u.Delivered = v.Delivered
	u.Pending = v.Pending
	u.Code = v.Code
	u.Message = v.Message
	if x, err := json.Marshal(v.Result); err != nil {
		return nil, fmt.Errorf("error encoding Result: %w", err)
	} else {
		u.Result = x
	}
	u.Initiator = v.Initiator
	u.Signers = make([]json.RawMessage, len(v.Signers))
	for i, x := range v.Signers {
		if y, err := json.Marshal(x); err != nil {
			return nil, fmt.Errorf("error encoding Signers: %w", err)
		} else {
			u.Signers[i] = y
		}
	}
	return json.Marshal(&u)
}

func (v *UnknownAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	return json.Marshal(&u)
}

func (v *UnknownSigner) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    AccountType `json:"type"`
		Url     *url.URL    `json:"url,omitempty"`
		Version uint64      `json:"version,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Version = v.Version
	return json.Marshal(&u)
}

func (v *UpdateAccountAuth) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType   `json:"type"`
		Operations []json.RawMessage `json:"operations,omitempty"`
	}{}
	u.Type = v.Type()
	u.Operations = make([]json.RawMessage, len(v.Operations))
	for i, x := range v.Operations {
		if y, err := json.Marshal(x); err != nil {
			return nil, fmt.Errorf("error encoding Operations: %w", err)
		} else {
			u.Operations[i] = y
		}
	}
	return json.Marshal(&u)
}

func (v *UpdateAllowedKeyPageOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Allow []TransactionType    `json:"allow,omitempty"`
		Deny  []TransactionType    `json:"deny,omitempty"`
	}{}
	u.Type = v.Type()
	u.Allow = v.Allow
	u.Deny = v.Deny
	return json.Marshal(&u)
}

func (v *UpdateKey) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType `json:"type"`
		NewKeyHash *string         `json:"newKeyHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.NewKeyHash = encoding.BytesToJSON(v.NewKeyHash)
	return json.Marshal(&u)
}

func (v *UpdateKeyOperation) MarshalJSON() ([]byte, error) {
	u := struct {
		Type     KeyPageOperationType `json:"type"`
		OldEntry KeySpecParams        `json:"oldEntry,omitempty"`
		NewEntry KeySpecParams        `json:"newEntry,omitempty"`
	}{}
	u.Type = v.Type()
	u.OldEntry = v.OldEntry
	u.NewEntry = v.NewEntry
	return json.Marshal(&u)
}

func (v *UpdateKeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType   `json:"type"`
		Operation []json.RawMessage `json:"operation,omitempty"`
	}{}
	u.Type = v.Type()
	u.Operation = make([]json.RawMessage, len(v.Operation))
	for i, x := range v.Operation {
		if y, err := json.Marshal(x); err != nil {
			return nil, fmt.Errorf("error encoding Operation: %w", err)
		} else {
			u.Operation[i] = y
		}
	}
	return json.Marshal(&u)
}

func (v *UpdateValidatorKey) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType `json:"type"`
		KeyHash    *string         `json:"keyHash,omitempty"`
		NewKeyHash *string         `json:"newKeyHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	u.NewKeyHash = encoding.BytesToJSON(v.NewKeyHash)
	return json.Marshal(&u)
}

func (v *WriteData) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  TransactionType `json:"type"`
		Entry DataEntry       `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *WriteDataResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       TransactionType `json:"type"`
		EntryHash  string          `json:"entryHash,omitempty"`
		AccountUrl *url.URL        `json:"accountUrl,omitempty"`
		AccountID  *string         `json:"accountID,omitempty"`
	}{}
	u.Type = v.Type()
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.AccountUrl = v.AccountUrl
	u.AccountID = encoding.BytesToJSON(v.AccountID)
	return json.Marshal(&u)
}

func (v *WriteDataTo) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      TransactionType `json:"type"`
		Recipient *url.URL        `json:"recipient,omitempty"`
		Entry     DataEntry       `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *ADI) UnmarshalJSON(data []byte) error {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	return nil
}

func (v *AcmeFaucet) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
		Url  *url.URL        `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	return nil
}

func (v *AddAccountAuthorityOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	return nil
}

func (v *AddCredits) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType `json:"type"`
		Recipient *url.URL        `json:"recipient,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
		Oracle    uint64          `json:"oracle,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Oracle = v.Oracle
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Recipient = u.Recipient
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	v.Oracle = u.Oracle
	return nil
}

func (v *AddCreditsResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    TransactionType `json:"type"`
		Amount  *string         `json:"amount,omitempty"`
		Credits uint64          `json:"credits,omitempty"`
		Oracle  uint64          `json:"oracle,omitempty"`
	}{}
	u.Type = v.Type()
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Credits = v.Credits
	u.Oracle = v.Oracle
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	v.Credits = u.Credits
	v.Oracle = u.Oracle
	return nil
}

func (v *AddKeyOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Entry KeySpecParams        `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Entry = u.Entry
	return nil
}

func (v *AddValidator) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  TransactionType `json:"type"`
		Key   *string         `json:"key,omitempty"`
		Owner *url.URL        `json:"owner,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = encoding.BytesToJSON(v.Key)
	u.Owner = v.Owner
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	v.Owner = u.Owner
	return nil
}

func (v *Anchor) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        AccountType      `json:"type"`
		Url         *url.URL         `json:"url,omitempty"`
		Authorities []AuthorityEntry `json:"authorities,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	return nil
}

func (v *AnchorMetadata) UnmarshalJSON(data []byte) error {
	u := struct {
		Name        string    `json:"name,omitempty"`
		Type        ChainType `json:"type,omitempty"`
		Account     *url.URL  `json:"account,omitempty"`
		Index       uint64    `json:"index,omitempty"`
		SourceIndex uint64    `json:"sourceIndex,omitempty"`
		SourceBlock uint64    `json:"sourceBlock,omitempty"`
		Entry       *string   `json:"entry,omitempty"`
	}{}
	u.Name = v.ChainMetadata.Name
	u.Type = v.ChainMetadata.Type
	u.Account = v.Account
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesToJSON(v.Entry)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ChainMetadata.Name = u.Name
	v.ChainMetadata.Type = u.Type
	v.Account = u.Account
	v.Index = u.Index
	v.SourceIndex = u.SourceIndex
	v.SourceBlock = u.SourceBlock
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	return nil
}

func (v *AnchoredRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		Record *string `json:"record,omitempty"`
		Anchor string  `json:"anchor,omitempty"`
	}{}
	u.Record = encoding.BytesToJSON(v.Record)
	u.Anchor = encoding.ChainToJSON(v.Anchor)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Record); err != nil {
		return fmt.Errorf("error decoding Record: %w", err)
	} else {
		v.Record = x
	}
	if x, err := encoding.ChainFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Anchor = x
	}
	return nil
}

func (v *BurnTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   TransactionType `json:"type"`
		Amount *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *ChainParams) UnmarshalJSON(data []byte) error {
	u := struct {
		Data     *string `json:"data,omitempty"`
		IsUpdate bool    `json:"isUpdate,omitempty"`
	}{}
	u.Data = encoding.BytesToJSON(v.Data)
	u.IsUpdate = v.IsUpdate
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	v.IsUpdate = u.IsUpdate
	return nil
}

func (v *CreateDataAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type              TransactionType `json:"type"`
		Url               *url.URL        `json:"url,omitempty"`
		KeyBookUrl        *url.URL        `json:"keyBookUrl,omitempty"`
		ManagerKeyBookUrl *url.URL        `json:"managerKeyBookUrl,omitempty"`
		Scratch           bool            `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.KeyBookUrl = v.KeyBookUrl
	u.ManagerKeyBookUrl = v.ManagerKeyBookUrl
	u.Scratch = v.Scratch
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.KeyBookUrl = u.KeyBookUrl
	v.ManagerKeyBookUrl = u.ManagerKeyBookUrl
	v.Scratch = u.Scratch
	return nil
}

func (v *CreateIdentity) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType `json:"type"`
		Url        *url.URL        `json:"url,omitempty"`
		KeyHash    *string         `json:"keyHash,omitempty"`
		KeyBookUrl *url.URL        `json:"keyBookUrl,omitempty"`
		Manager    *url.URL        `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	u.KeyBookUrl = v.KeyBookUrl
	u.Manager = v.Manager
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.KeyHash); err != nil {
		return fmt.Errorf("error decoding KeyHash: %w", err)
	} else {
		v.KeyHash = x
	}
	v.KeyBookUrl = u.KeyBookUrl
	v.Manager = u.Manager
	return nil
}

func (v *CreateKeyBook) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          TransactionType `json:"type"`
		Url           *url.URL        `json:"url,omitempty"`
		PublicKeyHash *string         `json:"publicKeyHash,omitempty"`
		Manager       *url.URL        `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	u.Manager = v.Manager
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.PublicKeyHash); err != nil {
		return fmt.Errorf("error decoding PublicKeyHash: %w", err)
	} else {
		v.PublicKeyHash = x
	}
	v.Manager = u.Manager
	return nil
}

func (v *CreateKeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    TransactionType  `json:"type"`
		Keys    []*KeySpecParams `json:"keys,omitempty"`
		Manager *url.URL         `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Keys = v.Keys
	u.Manager = v.Manager
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Keys = u.Keys
	v.Manager = u.Manager
	return nil
}

func (v *CreateToken) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        TransactionType `json:"type"`
		Url         *url.URL        `json:"url,omitempty"`
		KeyBookUrl  *url.URL        `json:"keyBookUrl,omitempty"`
		Symbol      string          `json:"symbol,omitempty"`
		Precision   uint64          `json:"precision,omitempty"`
		Properties  *url.URL        `json:"properties,omitempty"`
		SupplyLimit *string         `json:"supplyLimit,omitempty"`
		Manager     *url.URL        `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.KeyBookUrl = v.KeyBookUrl
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.SupplyLimit = encoding.BigintToJSON(v.SupplyLimit)
	u.Manager = v.Manager
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.KeyBookUrl = u.KeyBookUrl
	v.Symbol = u.Symbol
	v.Precision = u.Precision
	v.Properties = u.Properties
	if x, err := encoding.BigintFromJSON(u.SupplyLimit); err != nil {
		return fmt.Errorf("error decoding SupplyLimit: %w", err)
	} else {
		v.SupplyLimit = x
	}
	v.Manager = u.Manager
	return nil
}

func (v *CreateTokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType `json:"type"`
		Url        *url.URL        `json:"url,omitempty"`
		TokenUrl   *url.URL        `json:"tokenUrl,omitempty"`
		KeyBookUrl *url.URL        `json:"keyBookUrl,omitempty"`
		Scratch    bool            `json:"scratch,omitempty"`
		Manager    *url.URL        `json:"manager,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.TokenUrl = v.TokenUrl
	u.KeyBookUrl = v.KeyBookUrl
	u.Scratch = v.Scratch
	u.Manager = v.Manager
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.TokenUrl = u.TokenUrl
	v.KeyBookUrl = u.KeyBookUrl
	v.Scratch = u.Scratch
	v.Manager = u.Manager
	return nil
}

func (v *DataAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
		Scratch        bool             `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Scratch = v.Scratch
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	v.Scratch = u.Scratch
	return nil
}

func (v *DataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Data []*string `json:"data,omitempty"`
	}{}
	u.Data = make([]*string, len(v.Data))
	for i, x := range v.Data {
		u.Data[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Data = make([][]byte, len(u.Data))
	for i, x := range u.Data {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Data: %w", err)
		} else {
			v.Data[i] = x
		}
	}
	return nil
}

func (v *DisableAccountAuthOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	return nil
}

func (v *ED25519Signature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          SignatureType `json:"type"`
		PublicKey     *string       `json:"publicKey,omitempty"`
		Signature     *string       `json:"signature,omitempty"`
		Signer        *url.URL      `json:"signer,omitempty"`
		SignerVersion uint64        `json:"signerVersion,omitempty"`
		Timestamp     uint64        `json:"timestamp,omitempty"`
		Vote          VoteType      `json:"vote,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Timestamp = u.Timestamp
	v.Vote = u.Vote
	return nil
}

func (v *EmptyResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *EnableAccountAuthOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	return nil
}

func (v *Envelope) UnmarshalJSON(data []byte) error {
	u := struct {
		Signatures  []json.RawMessage `json:"signatures,omitempty"`
		TxHash      *string           `json:"txHash,omitempty"`
		Transaction *Transaction      `json:"transaction,omitempty"`
	}{}
	u.Signatures = make([]json.RawMessage, len(v.Signatures))
	for i, x := range v.Signatures {
		if y, err := json.Marshal(x); err != nil {
			return fmt.Errorf("error encoding Signatures: %w", err)
		} else {
			u.Signatures[i] = y
		}
	}
	u.TxHash = encoding.BytesToJSON(v.TxHash)
	u.Transaction = v.Transaction
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Signatures = make([]Signature, len(u.Signatures))
	for i, x := range u.Signatures {
		if y, err := UnmarshalSignatureJSON(x); err != nil {
			return fmt.Errorf("error decoding Signatures: %w", err)
		} else {
			v.Signatures[i] = y
		}
	}
	if x, err := encoding.BytesFromJSON(u.TxHash); err != nil {
		return fmt.Errorf("error decoding TxHash: %w", err)
	} else {
		v.TxHash = x
	}
	v.Transaction = u.Transaction
	return nil
}

func (v *ForwardedSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      SignatureType   `json:"type"`
		Signature json.RawMessage `json:"signature,omitempty"`
		Signer    json.RawMessage `json:"signer,omitempty"`
	}{}
	u.Type = v.Type()
	if x, err := json.Marshal(v.Signature); err != nil {
		return fmt.Errorf("error encoding Signature: %w", err)
	} else {
		u.Signature = x
	}
	if x, err := json.Marshal(v.Signer); err != nil {
		return fmt.Errorf("error encoding Signer: %w", err)
	} else {
		u.Signer = x
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := UnmarshalKeySignatureJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}

	if x, err := UnmarshalSignerJSON(u.Signer); err != nil {
		return fmt.Errorf("error decoding Signer: %w", err)
	} else {
		v.Signer = x
	}

	return nil
}

func (v *HashSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Hashes []string `json:"hashes,omitempty"`
	}{}
	u.Hashes = make([]string, len(v.Hashes))
	for i, x := range v.Hashes {
		u.Hashes[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Hashes = make([][32]byte, len(u.Hashes))
	for i, x := range u.Hashes {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Hashes: %w", err)
		} else {
			v.Hashes[i] = x
		}
	}
	return nil
}

func (v *InternalGenesis) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *InternalLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          AccountType      `json:"type"`
		Url           *url.URL         `json:"url,omitempty"`
		Authorities   []AuthorityEntry `json:"authorities,omitempty"`
		Index         int64            `json:"index,omitempty"`
		Timestamp     time.Time        `json:"timestamp,omitempty"`
		Synthetic     SyntheticLedger  `json:"synthetic,omitempty"`
		PendingOracle uint64           `json:"pendingOracle,omitempty"`
		ActiveOracle  uint64           `json:"activeOracle,omitempty"`
		AcmeBurnt     *string          `json:"acmeBurnt,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Index = v.Index
	u.Timestamp = v.Timestamp
	u.Synthetic = v.Synthetic
	u.PendingOracle = v.PendingOracle
	u.ActiveOracle = v.ActiveOracle
	u.AcmeBurnt = encoding.BigintToJSON(&v.AcmeBurnt)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	v.Index = u.Index
	v.Timestamp = u.Timestamp
	v.Synthetic = u.Synthetic
	v.PendingOracle = u.PendingOracle
	v.ActiveOracle = u.ActiveOracle
	if x, err := encoding.BigintFromJSON(u.AcmeBurnt); err != nil {
		return fmt.Errorf("error decoding AcmeBurnt: %w", err)
	} else {
		v.AcmeBurnt = *x
	}
	return nil
}

func (v *InternalSendTransactions) UnmarshalJSON(data []byte) error {
	u := struct {
		Type         TransactionType   `json:"type"`
		Transactions []SendTransaction `json:"transactions,omitempty"`
	}{}
	u.Type = v.Type()
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Transactions = u.Transactions
	return nil
}

func (v *InternalSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    SignatureType `json:"type"`
		Network *url.URL      `json:"network,omitempty"`
	}{}
	u.Type = v.Type()
	u.Network = v.Network
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Network = u.Network
	return nil
}

func (v *InternalSyntheticLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        AccountType             `json:"type"`
		Url         *url.URL                `json:"url,omitempty"`
		Authorities []AuthorityEntry        `json:"authorities,omitempty"`
		Pending     []*SyntheticLedgerEntry `json:"pending,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Pending = v.Pending
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	v.Pending = u.Pending
	return nil
}

func (v *InternalTransactionsSent) UnmarshalJSON(data []byte) error {
	u := struct {
		Type         TransactionType `json:"type"`
		Transactions []string        `json:"transactions,omitempty"`
	}{}
	u.Type = v.Type()
	u.Transactions = make([]string, len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Transactions = make([][32]byte, len(u.Transactions))
	for i, x := range u.Transactions {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Transactions: %w", err)
		} else {
			v.Transactions[i] = x
		}
	}
	return nil
}

func (v *InternalTransactionsSigned) UnmarshalJSON(data []byte) error {
	u := struct {
		Type         TransactionType        `json:"type"`
		Transactions []TransactionSignature `json:"transactions,omitempty"`
	}{}
	u.Type = v.Type()
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Transactions = u.Transactions
	return nil
}

func (v *IssueTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType `json:"type"`
		Recipient *url.URL        `json:"recipient,omitempty"`
		Amount    *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Recipient = u.Recipient
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *KeyBook) UnmarshalJSON(data []byte) error {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
		PageCount      uint64           `json:"pageCount,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.PageCount = v.PageCount
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	v.PageCount = u.PageCount
	return nil
}

func (v *KeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type                 AccountType          `json:"type"`
		KeyBook              *url.URL             `json:"keyBook,omitempty"`
		Url                  *url.URL             `json:"url,omitempty"`
		CreditBalance        uint64               `json:"creditBalance,omitempty"`
		AcceptThreshold      uint64               `json:"acceptThreshold,omitempty"`
		Threshold            uint64               `json:"threshold,omitempty"`
		RejectThreshold      uint64               `json:"rejectThreshold,omitempty"`
		ResponseThreshold    uint64               `json:"responseThreshold,omitempty"`
		BlockThreshold       uint64               `json:"blockThreshold,omitempty"`
		Version              uint64               `json:"version,omitempty"`
		Keys                 []*KeySpec           `json:"keys,omitempty"`
		TransactionBlacklist *AllowedTransactions `json:"transactionBlacklist,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.Url = v.Url
	u.CreditBalance = v.CreditBalance
	u.AcceptThreshold = v.AcceptThreshold
	u.Threshold = v.AcceptThreshold
	u.RejectThreshold = v.RejectThreshold
	u.ResponseThreshold = v.ResponseThreshold
	u.BlockThreshold = v.BlockThreshold
	u.Version = v.Version
	u.Keys = v.Keys
	u.TransactionBlacklist = v.TransactionBlacklist
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.CreditBalance = u.CreditBalance
	if u.AcceptThreshold != 0 {
		v.AcceptThreshold = u.AcceptThreshold
	} else {
		v.AcceptThreshold = u.Threshold
	}
	v.RejectThreshold = u.RejectThreshold
	v.ResponseThreshold = u.ResponseThreshold
	v.BlockThreshold = u.BlockThreshold
	v.Version = u.Version
	v.Keys = u.Keys
	v.TransactionBlacklist = u.TransactionBlacklist
	return nil
}

func (v *KeySpec) UnmarshalJSON(data []byte) error {
	u := struct {
		PublicKeyHash *string  `json:"publicKeyHash,omitempty"`
		PublicKey     *string  `json:"publicKey,omitempty"`
		LastUsedOn    uint64   `json:"lastUsedOn,omitempty"`
		Nonce         uint64   `json:"nonce,omitempty"`
		Owner         *url.URL `json:"owner,omitempty"`
	}{}
	u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	u.PublicKey = encoding.BytesToJSON(v.PublicKeyHash)
	u.LastUsedOn = v.LastUsedOn
	u.Nonce = v.LastUsedOn
	u.Owner = v.Owner
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.PublicKeyHash != nil {
		if x, err := encoding.BytesFromJSON(u.PublicKeyHash); err != nil {
			return fmt.Errorf("error decoding PublicKeyHash: %w", err)
		} else {
			v.PublicKeyHash = x
		}
	} else {
		if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
			return fmt.Errorf("error decoding PublicKeyHash: %w", err)
		} else {
			v.PublicKeyHash = x
		}
	}
	if u.LastUsedOn != 0 {
		v.LastUsedOn = u.LastUsedOn
	} else {
		v.LastUsedOn = u.Nonce
	}
	v.Owner = u.Owner
	return nil
}

func (v *KeySpecParams) UnmarshalJSON(data []byte) error {
	u := struct {
		KeyHash *string  `json:"keyHash,omitempty"`
		Owner   *url.URL `json:"owner,omitempty"`
	}{}
	u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	u.Owner = v.Owner
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.KeyHash); err != nil {
		return fmt.Errorf("error decoding KeyHash: %w", err)
	} else {
		v.KeyHash = x
	}
	v.Owner = u.Owner
	return nil
}

func (v *LegacyED25519Signature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          SignatureType `json:"type"`
		Timestamp     uint64        `json:"timestamp,omitempty"`
		Nonce         uint64        `json:"nonce,omitempty"`
		PublicKey     *string       `json:"publicKey,omitempty"`
		Signature     *string       `json:"signature,omitempty"`
		Signer        *url.URL      `json:"signer,omitempty"`
		SignerVersion uint64        `json:"signerVersion,omitempty"`
		Vote          VoteType      `json:"vote,omitempty"`
	}{}
	u.Type = v.Type()
	u.Timestamp = v.Timestamp
	u.Nonce = v.Timestamp
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Vote = v.Vote
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Timestamp != 0 {
		v.Timestamp = u.Timestamp
	} else {
		v.Timestamp = u.Nonce
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Vote = u.Vote
	return nil
}

func (v *LiteDataAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
		Tail *string     `json:"tail,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Tail = encoding.BytesToJSON(v.Tail)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.Tail); err != nil {
		return fmt.Errorf("error decoding Tail: %w", err)
	} else {
		v.Tail = x
	}
	return nil
}

func (v *LiteIdentity) UnmarshalJSON(data []byte) error {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	return nil
}

func (v *LiteTokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          AccountType `json:"type"`
		Url           *url.URL    `json:"url,omitempty"`
		TokenUrl      *url.URL    `json:"tokenUrl,omitempty"`
		Balance       *string     `json:"balance,omitempty"`
		LastUsedOn    uint64      `json:"lastUsedOn,omitempty"`
		Nonce         uint64      `json:"nonce,omitempty"`
		CreditBalance uint64      `json:"creditBalance,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.LastUsedOn = v.LastUsedOn
	u.Nonce = v.LastUsedOn
	u.CreditBalance = v.CreditBalance
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.TokenUrl = u.TokenUrl
	if x, err := encoding.BigintFromJSON(u.Balance); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance = *x
	}
	if u.LastUsedOn != 0 {
		v.LastUsedOn = u.LastUsedOn
	} else {
		v.LastUsedOn = u.Nonce
	}
	v.CreditBalance = u.CreditBalance
	return nil
}

func (v *MetricsRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Metric = u.Metric
	if x, err := encoding.DurationFromJSON(u.Duration); err != nil {
		return fmt.Errorf("error decoding Duration: %w", err)
	} else {
		v.Duration = x
	}
	return nil
}

func (v *MetricsResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	u.Value = encoding.AnyToJSON(v.Value)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.AnyFromJSON(u.Value); err != nil {
		return fmt.Errorf("error decoding Value: %w", err)
	} else {
		v.Value = x
	}
	return nil
}

func (v *RCD1Signature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          SignatureType `json:"type"`
		PublicKey     *string       `json:"publicKey,omitempty"`
		Signature     *string       `json:"signature,omitempty"`
		Signer        *url.URL      `json:"signer,omitempty"`
		SignerVersion uint64        `json:"signerVersion,omitempty"`
		Timestamp     uint64        `json:"timestamp,omitempty"`
		Vote          VoteType      `json:"vote,omitempty"`
	}{}
	u.Type = v.Type()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.Signer = v.Signer
	u.SignerVersion = v.SignerVersion
	u.Timestamp = v.Timestamp
	u.Vote = v.Vote
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.Signer = u.Signer
	v.SignerVersion = u.SignerVersion
	v.Timestamp = u.Timestamp
	v.Vote = u.Vote
	return nil
}

func (v *Receipt) UnmarshalJSON(data []byte) error {
	u := struct {
		Start   *string        `json:"start,omitempty"`
		Result  *string        `json:"result,omitempty"`
		Entries []ReceiptEntry `json:"entries,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Start)
	u.Result = encoding.BytesToJSON(v.Result)
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Start); err != nil {
		return fmt.Errorf("error decoding Start: %w", err)
	} else {
		v.Start = x
	}
	if x, err := encoding.BytesFromJSON(u.Result); err != nil {
		return fmt.Errorf("error decoding Result: %w", err)
	} else {
		v.Result = x
	}
	v.Entries = u.Entries
	return nil
}

func (v *ReceiptEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Right bool    `json:"right,omitempty"`
		Hash  *string `json:"hash,omitempty"`
	}{}
	u.Right = v.Right
	u.Hash = encoding.BytesToJSON(v.Hash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Right = u.Right
	if x, err := encoding.BytesFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	return nil
}

func (v *ReceiptSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          SignatureType  `json:"type"`
		Start         *string        `json:"start,omitempty"`
		Result        *string        `json:"result,omitempty"`
		Entries       []ReceiptEntry `json:"entries,omitempty"`
		SourceNetwork *url.URL       `json:"sourceNetwork,omitempty"`
	}{}
	u.Type = v.Type()
	u.Start = encoding.BytesToJSON(v.Receipt.Start)
	u.Result = encoding.BytesToJSON(v.Receipt.Result)
	u.Entries = v.Receipt.Entries
	u.SourceNetwork = v.SourceNetwork
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.Start); err != nil {
		return fmt.Errorf("error decoding Start: %w", err)
	} else {
		v.Receipt.Start = x
	}
	if x, err := encoding.BytesFromJSON(u.Result); err != nil {
		return fmt.Errorf("error decoding Result: %w", err)
	} else {
		v.Receipt.Result = x
	}
	v.Receipt.Entries = u.Entries
	v.SourceNetwork = u.SourceNetwork
	return nil
}

func (v *RemoteTransactionBody) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *RemoveAccountAuthorityOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      AccountAuthOperationType `json:"type"`
		Authority *url.URL                 `json:"authority,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	return nil
}

func (v *RemoveKeyOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Entry KeySpecParams        `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Entry = u.Entry
	return nil
}

func (v *RemoveValidator) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  TransactionType `json:"type"`
		Key   *string         `json:"key,omitempty"`
		Owner *url.URL        `json:"owner,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = encoding.BytesToJSON(v.Key)
	u.Owner = v.Owner
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	v.Owner = u.Owner
	return nil
}

func (v *SegWitDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType `json:"type"`
		Source    *url.URL        `json:"source,omitempty"`
		Cause     string          `json:"cause,omitempty"`
		EntryUrl  *url.URL        `json:"entryUrl,omitempty"`
		EntryHash string          `json:"entryHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.EntryUrl = v.EntryUrl
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Source = u.Source
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.SyntheticOrigin.Cause = x
	}
	v.EntryUrl = u.EntryUrl
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}

func (v *SendTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type TransactionType   `json:"type"`
		Hash string            `json:"hash,omitempty"`
		Meta json.RawMessage   `json:"meta,omitempty"`
		To   []*TokenRecipient `json:"to,omitempty"`
	}{}
	u.Type = v.Type()
	u.Hash = encoding.ChainToJSON(v.Hash)
	u.Meta = v.Meta
	u.To = v.To
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	v.Meta = u.Meta
	v.To = u.To
	return nil
}

func (v *SendTransaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Payload   json.RawMessage `json:"payload,omitempty"`
		Recipient *url.URL        `json:"recipient,omitempty"`
	}{}
	if x, err := json.Marshal(v.Payload); err != nil {
		return fmt.Errorf("error encoding Payload: %w", err)
	} else {
		u.Payload = x
	}
	u.Recipient = v.Recipient
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := UnmarshalTransactionJSON(u.Payload); err != nil {
		return fmt.Errorf("error decoding Payload: %w", err)
	} else {
		v.Payload = x
	}

	v.Recipient = u.Recipient
	return nil
}

func (v *SetThresholdKeyPageOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      KeyPageOperationType `json:"type"`
		Threshold uint64               `json:"threshold,omitempty"`
	}{}
	u.Type = v.Type()
	u.Threshold = v.Threshold
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Threshold = u.Threshold
	return nil
}

func (v *SyntheticAnchor) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            TransactionType `json:"type"`
		Source          *url.URL        `json:"source,omitempty"`
		Major           bool            `json:"major,omitempty"`
		RootAnchor      string          `json:"rootAnchor,omitempty"`
		RootIndex       uint64          `json:"rootIndex,omitempty"`
		AcmeBurnt       *string         `json:"acmeBurnt,omitempty"`
		Block           uint64          `json:"block,omitempty"`
		AcmeOraclePrice uint64          `json:"acmeOraclePrice,omitempty"`
		Receipts        []Receipt       `json:"receipts,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.Source
	u.Major = v.Major
	u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
	u.RootIndex = v.RootIndex
	u.AcmeBurnt = encoding.BigintToJSON(&v.AcmeBurnt)
	u.Block = v.Block
	u.AcmeOraclePrice = v.AcmeOraclePrice
	u.Receipts = v.Receipts
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Source = u.Source
	v.Major = u.Major
	if x, err := encoding.ChainFromJSON(u.RootAnchor); err != nil {
		return fmt.Errorf("error decoding RootAnchor: %w", err)
	} else {
		v.RootAnchor = x
	}
	v.RootIndex = u.RootIndex
	if x, err := encoding.BigintFromJSON(u.AcmeBurnt); err != nil {
		return fmt.Errorf("error decoding AcmeBurnt: %w", err)
	} else {
		v.AcmeBurnt = *x
	}
	v.Block = u.Block
	v.AcmeOraclePrice = u.AcmeOraclePrice
	v.Receipts = u.Receipts
	return nil
}

func (v *SyntheticBurnTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Amount *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Source = u.Source
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.SyntheticOrigin.Cause = x
	}
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *SyntheticCreateChain) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Chains []ChainParams   `json:"chains,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Chains = v.Chains
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Source = u.Source
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.SyntheticOrigin.Cause = x
	}
	v.Chains = u.Chains
	return nil
}

func (v *SyntheticDepositCredits) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Amount uint64          `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Amount = v.Amount
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Source = u.Source
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.SyntheticOrigin.Cause = x
	}
	v.Amount = u.Amount
	return nil
}

func (v *SyntheticDepositTokens) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Token  *url.URL        `json:"token,omitempty"`
		Amount *string         `json:"amount,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Token = v.Token
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Source = u.Source
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.SyntheticOrigin.Cause = x
	}
	v.Token = u.Token
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *SyntheticForwardTransaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            TransactionType      `json:"type"`
		Signatures      []ForwardedSignature `json:"signatures,omitempty"`
		TransactionHash *string              `json:"transactionHash,omitempty"`
		Transaction     *Transaction         `json:"transaction,omitempty"`
	}{}
	u.Type = v.Type()
	u.Signatures = v.Signatures
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	u.Transaction = v.Transaction
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Signatures = u.Signatures
	if x, err := encoding.BytesFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	v.Transaction = u.Transaction
	return nil
}

func (v *SyntheticLedger) UnmarshalJSON(data []byte) error {
	u := struct {
		Nonce    uint64   `json:"nonce,omitempty"`
		Unsigned []string `json:"unsigned,omitempty"`
		Unsent   []string `json:"unsent,omitempty"`
	}{}
	u.Nonce = v.Nonce
	u.Unsigned = make([]string, len(v.Unsigned))
	for i, x := range v.Unsigned {
		u.Unsigned[i] = encoding.ChainToJSON(x)
	}
	u.Unsent = make([]string, len(v.Unsent))
	for i, x := range v.Unsent {
		u.Unsent[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Nonce = u.Nonce
	v.Unsigned = make([][32]byte, len(u.Unsigned))
	for i, x := range u.Unsigned {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Unsigned: %w", err)
		} else {
			v.Unsigned[i] = x
		}
	}
	v.Unsent = make([][32]byte, len(u.Unsent))
	for i, x := range u.Unsent {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Unsent: %w", err)
		} else {
			v.Unsent[i] = x
		}
	}
	return nil
}

func (v *SyntheticLedgerEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		TransactionHash string `json:"transactionHash,omitempty"`
		RootAnchor      string `json:"rootAnchor,omitempty"`
		SynthIndex      uint64 `json:"synthIndex,omitempty"`
		SynthIndexIndex uint64 `json:"synthIndexIndex,omitempty"`
		RootIndexIndex  uint64 `json:"rootIndexIndex,omitempty"`
		NeedsReceipt    bool   `json:"needsReceipt,omitempty"`
	}{}
	u.TransactionHash = encoding.ChainToJSON(v.TransactionHash)
	u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
	u.SynthIndex = v.SynthIndex
	u.SynthIndexIndex = v.SynthIndexIndex
	u.RootIndexIndex = v.RootIndexIndex
	u.NeedsReceipt = v.NeedsReceipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	if x, err := encoding.ChainFromJSON(u.RootAnchor); err != nil {
		return fmt.Errorf("error decoding RootAnchor: %w", err)
	} else {
		v.RootAnchor = x
	}
	v.SynthIndex = u.SynthIndex
	v.SynthIndexIndex = u.SynthIndexIndex
	v.RootIndexIndex = u.RootIndexIndex
	v.NeedsReceipt = u.NeedsReceipt
	return nil
}

func (v *SyntheticMirror) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    TransactionType  `json:"type"`
		Objects []AnchoredRecord `json:"objects,omitempty"`
	}{}
	u.Type = v.Type()
	u.Objects = v.Objects
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Objects = u.Objects
	return nil
}

func (v *SyntheticOrigin) UnmarshalJSON(data []byte) error {
	u := struct {
		Source *url.URL `json:"source,omitempty"`
		Cause  string   `json:"cause,omitempty"`
	}{}
	u.Source = v.Source
	u.Cause = encoding.ChainToJSON(v.Cause)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Source = u.Source
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	return nil
}

func (v *SyntheticReceipt) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        TransactionType    `json:"type"`
		Source      *url.URL           `json:"source,omitempty"`
		Cause       string             `json:"cause,omitempty"`
		SynthTxHash string             `json:"synthTxHash,omitempty"`
		Status      *TransactionStatus `json:"status,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.SynthTxHash = encoding.ChainToJSON(v.SynthTxHash)
	u.Status = v.Status
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Source = u.Source
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.SyntheticOrigin.Cause = x
	}
	if x, err := encoding.ChainFromJSON(u.SynthTxHash); err != nil {
		return fmt.Errorf("error decoding SynthTxHash: %w", err)
	} else {
		v.SynthTxHash = x
	}
	v.Status = u.Status
	return nil
}

func (v *SyntheticSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Type               SignatureType `json:"type"`
		SourceNetwork      *url.URL      `json:"sourceNetwork,omitempty"`
		DestinationNetwork *url.URL      `json:"destinationNetwork,omitempty"`
		SequenceNumber     uint64        `json:"sequenceNumber,omitempty"`
	}{}
	u.Type = v.Type()
	u.SourceNetwork = v.SourceNetwork
	u.DestinationNetwork = v.DestinationNetwork
	u.SequenceNumber = v.SequenceNumber
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SourceNetwork = u.SourceNetwork
	v.DestinationNetwork = u.DestinationNetwork
	v.SequenceNumber = u.SequenceNumber
	return nil
}

func (v *SyntheticWriteData) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   TransactionType `json:"type"`
		Source *url.URL        `json:"source,omitempty"`
		Cause  string          `json:"cause,omitempty"`
		Entry  DataEntry       `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.SyntheticOrigin.Source
	u.Cause = encoding.ChainToJSON(v.SyntheticOrigin.Cause)
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SyntheticOrigin.Source = u.Source
	if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.SyntheticOrigin.Cause = x
	}
	v.Entry = u.Entry
	return nil
}

func (v *TokenAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
		TokenUrl       *url.URL         `json:"tokenUrl,omitempty"`
		Balance        *string          `json:"balance,omitempty"`
		Scratch        bool             `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.TokenUrl = v.TokenUrl
	u.Balance = encoding.BigintToJSON(&v.Balance)
	u.Scratch = v.Scratch
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	v.TokenUrl = u.TokenUrl
	if x, err := encoding.BigintFromJSON(u.Balance); err != nil {
		return fmt.Errorf("error decoding Balance: %w", err)
	} else {
		v.Balance = *x
	}
	v.Scratch = u.Scratch
	return nil
}

func (v *TokenIssuer) UnmarshalJSON(data []byte) error {
	u := struct {
		Type           AccountType      `json:"type"`
		KeyBook        *url.URL         `json:"keyBook,omitempty"`
		ManagerKeyBook *url.URL         `json:"managerKeyBook,omitempty"`
		Url            *url.URL         `json:"url,omitempty"`
		Authorities    []AuthorityEntry `json:"authorities,omitempty"`
		Symbol         string           `json:"symbol,omitempty"`
		Precision      uint64           `json:"precision,omitempty"`
		Properties     *url.URL         `json:"properties,omitempty"`
		Issued         *string          `json:"issued,omitempty"`
		SupplyLimit    *string          `json:"supplyLimit,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyBook = v.KeyBook()
	u.ManagerKeyBook = v.ManagerKeyBook()
	u.Url = v.Url
	u.Authorities = v.AccountAuth.Authorities
	u.Symbol = v.Symbol
	u.Precision = v.Precision
	u.Properties = v.Properties
	u.Issued = encoding.BigintToJSON(&v.Issued)
	u.SupplyLimit = encoding.BigintToJSON(v.SupplyLimit)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.AccountAuth.Authorities = u.Authorities
	v.Symbol = u.Symbol
	v.Precision = u.Precision
	v.Properties = u.Properties
	if x, err := encoding.BigintFromJSON(u.Issued); err != nil {
		return fmt.Errorf("error decoding Issued: %w", err)
	} else {
		v.Issued = *x
	}
	if x, err := encoding.BigintFromJSON(u.SupplyLimit); err != nil {
		return fmt.Errorf("error decoding SupplyLimit: %w", err)
	} else {
		v.SupplyLimit = x
	}
	return nil
}

func (v *TokenRecipient) UnmarshalJSON(data []byte) error {
	u := struct {
		Url    *url.URL `json:"url,omitempty"`
		Amount *string  `json:"amount,omitempty"`
	}{}
	u.Url = v.Url
	u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *Transaction) UnmarshalJSON(data []byte) error {
	u := struct {
		Header TransactionHeader `json:"header,omitempty"`
		Body   json.RawMessage   `json:"body,omitempty"`
	}{}
	u.Header = v.Header
	if x, err := json.Marshal(v.Body); err != nil {
		return fmt.Errorf("error encoding Body: %w", err)
	} else {
		u.Body = x
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Header = u.Header
	if x, err := UnmarshalTransactionJSON(u.Body); err != nil {
		return fmt.Errorf("error decoding Body: %w", err)
	} else {
		v.Body = x
	}

	return nil
}

func (v *TransactionHeader) UnmarshalJSON(data []byte) error {
	u := struct {
		Principal *url.URL `json:"principal,omitempty"`
		Origin    *url.URL `json:"origin,omitempty"`
		Initiator string   `json:"initiator,omitempty"`
		Memo      string   `json:"memo,omitempty"`
		Metadata  *string  `json:"metadata,omitempty"`
	}{}
	u.Principal = v.Principal
	u.Origin = v.Principal
	u.Initiator = encoding.ChainToJSON(v.Initiator)
	u.Memo = v.Memo
	u.Metadata = encoding.BytesToJSON(v.Metadata)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Principal != nil {
		v.Principal = u.Principal
	} else {
		v.Principal = u.Origin
	}
	if x, err := encoding.ChainFromJSON(u.Initiator); err != nil {
		return fmt.Errorf("error decoding Initiator: %w", err)
	} else {
		v.Initiator = x
	}
	v.Memo = u.Memo
	if x, err := encoding.BytesFromJSON(u.Metadata); err != nil {
		return fmt.Errorf("error decoding Metadata: %w", err)
	} else {
		v.Metadata = x
	}
	return nil
}

func (v *TransactionSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Transaction string          `json:"transaction,omitempty"`
		Signature   json.RawMessage `json:"signature,omitempty"`
	}{}
	u.Transaction = encoding.ChainToJSON(v.Transaction)
	if x, err := json.Marshal(v.Signature); err != nil {
		return fmt.Errorf("error encoding Signature: %w", err)
	} else {
		u.Signature = x
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Transaction); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	if x, err := UnmarshalSignatureJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}

	return nil
}

func (v *TransactionStatus) UnmarshalJSON(data []byte) error {
	u := struct {
		Remote    bool              `json:"remote,omitempty"`
		Delivered bool              `json:"delivered,omitempty"`
		Pending   bool              `json:"pending,omitempty"`
		Code      uint64            `json:"code,omitempty"`
		Message   string            `json:"message,omitempty"`
		Result    json.RawMessage   `json:"result,omitempty"`
		Initiator *url.URL          `json:"initiator,omitempty"`
		Signers   []json.RawMessage `json:"signers,omitempty"`
	}{}
	u.Remote = v.Remote
	u.Delivered = v.Delivered
	u.Pending = v.Pending
	u.Code = v.Code
	u.Message = v.Message
	if x, err := json.Marshal(v.Result); err != nil {
		return fmt.Errorf("error encoding Result: %w", err)
	} else {
		u.Result = x
	}
	u.Initiator = v.Initiator
	u.Signers = make([]json.RawMessage, len(v.Signers))
	for i, x := range v.Signers {
		if y, err := json.Marshal(x); err != nil {
			return fmt.Errorf("error encoding Signers: %w", err)
		} else {
			u.Signers[i] = y
		}
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Remote = u.Remote
	v.Delivered = u.Delivered
	v.Pending = u.Pending
	v.Code = u.Code
	v.Message = u.Message
	if x, err := UnmarshalTransactionResultJSON(u.Result); err != nil {
		return fmt.Errorf("error decoding Result: %w", err)
	} else {
		v.Result = x
	}

	v.Initiator = u.Initiator
	v.Signers = make([]Signer, len(u.Signers))
	for i, x := range u.Signers {
		if y, err := UnmarshalSignerJSON(x); err != nil {
			return fmt.Errorf("error decoding Signers: %w", err)
		} else {
			v.Signers[i] = y
		}
	}
	return nil
}

func (v *UnknownAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Type AccountType `json:"type"`
		Url  *url.URL    `json:"url,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	return nil
}

func (v *UnknownSigner) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    AccountType `json:"type"`
		Url     *url.URL    `json:"url,omitempty"`
		Version uint64      `json:"version,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Version = v.Version
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Version = u.Version
	return nil
}

func (v *UpdateAccountAuth) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType   `json:"type"`
		Operations []json.RawMessage `json:"operations,omitempty"`
	}{}
	u.Type = v.Type()
	u.Operations = make([]json.RawMessage, len(v.Operations))
	for i, x := range v.Operations {
		if y, err := json.Marshal(x); err != nil {
			return fmt.Errorf("error encoding Operations: %w", err)
		} else {
			u.Operations[i] = y
		}
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Operations = make([]AccountAuthOperation, len(u.Operations))
	for i, x := range u.Operations {
		if y, err := UnmarshalAccountAuthOperationJSON(x); err != nil {
			return fmt.Errorf("error decoding Operations: %w", err)
		} else {
			v.Operations[i] = y
		}
	}
	return nil
}

func (v *UpdateAllowedKeyPageOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  KeyPageOperationType `json:"type"`
		Allow []TransactionType    `json:"allow,omitempty"`
		Deny  []TransactionType    `json:"deny,omitempty"`
	}{}
	u.Type = v.Type()
	u.Allow = v.Allow
	u.Deny = v.Deny
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Allow = u.Allow
	v.Deny = u.Deny
	return nil
}

func (v *UpdateKey) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType `json:"type"`
		NewKeyHash *string         `json:"newKeyHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.NewKeyHash = encoding.BytesToJSON(v.NewKeyHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.NewKeyHash); err != nil {
		return fmt.Errorf("error decoding NewKeyHash: %w", err)
	} else {
		v.NewKeyHash = x
	}
	return nil
}

func (v *UpdateKeyOperation) UnmarshalJSON(data []byte) error {
	u := struct {
		Type     KeyPageOperationType `json:"type"`
		OldEntry KeySpecParams        `json:"oldEntry,omitempty"`
		NewEntry KeySpecParams        `json:"newEntry,omitempty"`
	}{}
	u.Type = v.Type()
	u.OldEntry = v.OldEntry
	u.NewEntry = v.NewEntry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.OldEntry = u.OldEntry
	v.NewEntry = u.NewEntry
	return nil
}

func (v *UpdateKeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType   `json:"type"`
		Operation []json.RawMessage `json:"operation,omitempty"`
	}{}
	u.Type = v.Type()
	u.Operation = make([]json.RawMessage, len(v.Operation))
	for i, x := range v.Operation {
		if y, err := json.Marshal(x); err != nil {
			return fmt.Errorf("error encoding Operation: %w", err)
		} else {
			u.Operation[i] = y
		}
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Operation = make([]KeyPageOperation, len(u.Operation))
	for i, x := range u.Operation {
		if y, err := UnmarshalKeyPageOperationJSON(x); err != nil {
			return fmt.Errorf("error decoding Operation: %w", err)
		} else {
			v.Operation[i] = y
		}
	}
	return nil
}

func (v *UpdateValidatorKey) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType `json:"type"`
		KeyHash    *string         `json:"keyHash,omitempty"`
		NewKeyHash *string         `json:"newKeyHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.KeyHash = encoding.BytesToJSON(v.KeyHash)
	u.NewKeyHash = encoding.BytesToJSON(v.NewKeyHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.BytesFromJSON(u.KeyHash); err != nil {
		return fmt.Errorf("error decoding KeyHash: %w", err)
	} else {
		v.KeyHash = x
	}
	if x, err := encoding.BytesFromJSON(u.NewKeyHash); err != nil {
		return fmt.Errorf("error decoding NewKeyHash: %w", err)
	} else {
		v.NewKeyHash = x
	}
	return nil
}

func (v *WriteData) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  TransactionType `json:"type"`
		Entry DataEntry       `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Entry = u.Entry
	return nil
}

func (v *WriteDataResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       TransactionType `json:"type"`
		EntryHash  string          `json:"entryHash,omitempty"`
		AccountUrl *url.URL        `json:"accountUrl,omitempty"`
		AccountID  *string         `json:"accountID,omitempty"`
	}{}
	u.Type = v.Type()
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.AccountUrl = v.AccountUrl
	u.AccountID = encoding.BytesToJSON(v.AccountID)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	v.AccountUrl = u.AccountUrl
	if x, err := encoding.BytesFromJSON(u.AccountID); err != nil {
		return fmt.Errorf("error decoding AccountID: %w", err)
	} else {
		v.AccountID = x
	}
	return nil
}

func (v *WriteDataTo) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      TransactionType `json:"type"`
		Recipient *url.URL        `json:"recipient,omitempty"`
		Entry     DataEntry       `json:"entry,omitempty"`
	}{}
	u.Type = v.Type()
	u.Recipient = v.Recipient
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Recipient = u.Recipient
	v.Entry = u.Entry
	return nil
}
