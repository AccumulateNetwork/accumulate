// Copyright 2024 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package protocol

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	"strings"
)

// AccountAuthOperationTypeUnknown is used when the authorization operation is not known.
const AccountAuthOperationTypeUnknown AccountAuthOperationType = 0

// AccountAuthOperationTypeEnable enables authorization checks for an authority.
const AccountAuthOperationTypeEnable AccountAuthOperationType = 1

// AccountAuthOperationTypeDisable disables authorization checks for an authority.
const AccountAuthOperationTypeDisable AccountAuthOperationType = 2

// AccountAuthOperationTypeAddAuthority adds an authority.
const AccountAuthOperationTypeAddAuthority AccountAuthOperationType = 3

// AccountAuthOperationTypeRemoveAuthority removes an authority.
const AccountAuthOperationTypeRemoveAuthority AccountAuthOperationType = 4

// AccountTypeUnknown represents an unknown account type.
const AccountTypeUnknown AccountType = 0

// AccountTypeAnchorLedger anchors the other partitions.
const AccountTypeAnchorLedger AccountType = 1

// AccountTypeIdentity is an Identity account, aka an ADI.
const AccountTypeIdentity AccountType = 2

// AccountTypeTokenIssuer is a Token Issuer account.
const AccountTypeTokenIssuer AccountType = 3

// AccountTypeTokenAccount is an ADI Token Account.
const AccountTypeTokenAccount AccountType = 4

// AccountTypeLiteTokenAccount is a Lite Token Account.
const AccountTypeLiteTokenAccount AccountType = 5

// AccountTypeBlockLedger is a Block Ledger account.
const AccountTypeBlockLedger AccountType = 6

// AccountTypeKeyPage is a Key Page account.
const AccountTypeKeyPage AccountType = 9

// AccountTypeKeyBook is a Key Book account.
const AccountTypeKeyBook AccountType = 10

// AccountTypeDataAccount is an ADI Data Account.
const AccountTypeDataAccount AccountType = 11

// AccountTypeLiteDataAccount is a Lite Data Account.
const AccountTypeLiteDataAccount AccountType = 12

// AccountTypeUnknownSigner represents an unknown signer account.
const AccountTypeUnknownSigner AccountType = 13

// AccountTypeSystemLedger is a ledger that tracks the state of internal operations.
const AccountTypeSystemLedger AccountType = 14

// AccountTypeLiteIdentity is a lite identity account.
const AccountTypeLiteIdentity AccountType = 15

// AccountTypeSyntheticLedger is a ledger that tracks the status of produced and received synthetic transactions.
const AccountTypeSyntheticLedger AccountType = 16

// AllowedTransactionBitUpdateKeyPage is the offset of the UpdateKeyPage bit.
const AllowedTransactionBitUpdateKeyPage AllowedTransactionBit = 1

// AllowedTransactionBitUpdateAccountAuth is the offset of the UpdateAccountAuth bit.
const AllowedTransactionBitUpdateAccountAuth AllowedTransactionBit = 2

// BookTypeNormal is a normal key book.
const BookTypeNormal BookType = 0

// BookTypeValidator is a validator key book.
const BookTypeValidator BookType = 1

// BookTypeOperator Operator key book.
const BookTypeOperator BookType = 2

// DataEntryTypeUnknown .
const DataEntryTypeUnknown DataEntryType = 0

// DataEntryTypeFactom .
const DataEntryTypeFactom DataEntryType = 1

// DataEntryTypeAccumulate .
const DataEntryTypeAccumulate DataEntryType = 2

// DataEntryTypeDoubleHash .
const DataEntryTypeDoubleHash DataEntryType = 3

// ErrorCodeOK indicates the request succeeded.
const ErrorCodeOK ErrorCode = 0

// ErrorCodeEncodingError indicates something could not be decoded or encoded.
const ErrorCodeEncodingError ErrorCode = 1

// ErrorCodeFailed indicates the request failed.
const ErrorCodeFailed ErrorCode = 2

// ErrorCodeDidPanic indicates the request failed due to a fatal error.
const ErrorCodeDidPanic ErrorCode = 3

// ErrorCodeUnknownError indicates the request failed due to an unknown error.
const ErrorCodeUnknownError ErrorCode = 4

// ExecutorVersionV1 is the first version of the executor system.
const ExecutorVersionV1 ExecutorVersion = 1

// ExecutorVersionV1SignatureAnchoring introduces anchoring of signature chains into the root chain.
const ExecutorVersionV1SignatureAnchoring ExecutorVersion = 2

// ExecutorVersionV1DoubleHashEntries fixes a problem that prevented v1-signatureAnchoring from being activated correctly and enables double-hashed data entries.
const ExecutorVersionV1DoubleHashEntries ExecutorVersion = 3

// ExecutorVersionV1Halt halts transaction processing in preparation for v2.
const ExecutorVersionV1Halt ExecutorVersion = 4

// ExecutorVersionV2 is the second version of the executor system.
const ExecutorVersionV2 ExecutorVersion = 5

// ExecutorVersionV2Baikonur enables the Baikonur release.
const ExecutorVersionV2Baikonur ExecutorVersion = 6

// ExecutorVersionV2Vandenberg enables the Vandenberg release.
const ExecutorVersionV2Vandenberg ExecutorVersion = 7

// ExecutorVersionVNext is a placeholder for testing. DO NOT USE.
const ExecutorVersionVNext ExecutorVersion = 8

// KeyPageOperationTypeUnknown is used when the key page operation is not known.
const KeyPageOperationTypeUnknown KeyPageOperationType = 0

// KeyPageOperationTypeUpdate replaces a key in the page with a new key.
const KeyPageOperationTypeUpdate KeyPageOperationType = 1

// KeyPageOperationTypeRemove removes a key from the page.
const KeyPageOperationTypeRemove KeyPageOperationType = 2

// KeyPageOperationTypeAdd adds a key to the page.
const KeyPageOperationTypeAdd KeyPageOperationType = 3

// KeyPageOperationTypeSetThreshold sets the signing threshold (the M of "M of N" signatures required).
const KeyPageOperationTypeSetThreshold KeyPageOperationType = 4

// KeyPageOperationTypeUpdateAllowed updates the transactions the key page is allowed to execute.
const KeyPageOperationTypeUpdateAllowed KeyPageOperationType = 5

// KeyPageOperationTypeSetRejectThreshold sets the rejection threshold.
const KeyPageOperationTypeSetRejectThreshold KeyPageOperationType = 6

// KeyPageOperationTypeSetResponseThreshold sets the response threshold.
const KeyPageOperationTypeSetResponseThreshold KeyPageOperationType = 7

// NetworkMaintenanceOperationTypeUnknown is used when the operation type is not known.
const NetworkMaintenanceOperationTypeUnknown NetworkMaintenanceOperationType = 0

// NetworkMaintenanceOperationTypePendingTransactionGC removes pending transaction garbage.
const NetworkMaintenanceOperationTypePendingTransactionGC NetworkMaintenanceOperationType = 1

// ObjectTypeUnknown is used when the object type is not known.
const ObjectTypeUnknown ObjectType = 0

// ObjectTypeAccount represents an account object.
const ObjectTypeAccount ObjectType = 1

// ObjectTypeTransaction represents a transaction object.
const ObjectTypeTransaction ObjectType = 2

// PartitionTypeDirectory .
const PartitionTypeDirectory PartitionType = 1

// PartitionTypeBlockValidator .
const PartitionTypeBlockValidator PartitionType = 2

// PartitionTypeBlockSummary .
const PartitionTypeBlockSummary PartitionType = 3

// PartitionTypeBootstrap .
const PartitionTypeBootstrap PartitionType = 4

// SignatureTypeUnknown is used when the signature type is not known.
const SignatureTypeUnknown SignatureType = 0

// SignatureTypeLegacyED25519 represents a legacy ED25519 signature.
const SignatureTypeLegacyED25519 SignatureType = 1

// SignatureTypeED25519 represents an ED25519 signature.
const SignatureTypeED25519 SignatureType = 2

// SignatureTypeRCD1 represents an RCD1 signature.
const SignatureTypeRCD1 SignatureType = 3

// SignatureTypeReceipt represents a Merkle tree receipt.
const SignatureTypeReceipt SignatureType = 4

// SignatureTypePartition is used when sending synthetic and system transactions.
const SignatureTypePartition SignatureType = 5

// SignatureTypeSet is used when forwarding multiple signatures.
const SignatureTypeSet SignatureType = 6

// SignatureTypeRemote is used when forwarding a signature from one partition to another.
const SignatureTypeRemote SignatureType = 7

// SignatureTypeBTC represents an BTC signature.
const SignatureTypeBTC SignatureType = 8

// SignatureTypeBTCLegacy represents an BTC signature with uncompressed public key.
const SignatureTypeBTCLegacy SignatureType = 9

// SignatureTypeETH represents an ETH signature.
const SignatureTypeETH SignatureType = 10

// SignatureTypeDelegated represents a signature for a delegated authority.
const SignatureTypeDelegated SignatureType = 11

// SignatureTypeInternal is used for internally produced transactions.
const SignatureTypeInternal SignatureType = 12

// SignatureTypeAuthority is a signature produced by an authority.
const SignatureTypeAuthority SignatureType = 13

// SignatureTypeRsaSha256 represents an RSA signature of SHA256 hashed data (PKCS#1 encoding).
const SignatureTypeRsaSha256 SignatureType = 14

// SignatureTypeEcdsaSha256 represents a signature of SHA256 hashed data from an ecdsa algorithm with supported standard curves from NIST, SECG, and Brainpool typically (SEC, ANS.1 enocding).
const SignatureTypeEcdsaSha256 SignatureType = 15

// SignatureTypeTypedData implements EIP-712 sign typed data specification.
const SignatureTypeTypedData SignatureType = 16

// TransactionMaxUser is the highest number reserved for user transactions.
const TransactionMaxUser TransactionMax = 48

// TransactionMaxSynthetic is the highest number reserved for synthetic transactions.
const TransactionMaxSynthetic TransactionMax = 95

// TransactionMaxSystem is the highest number reserved for internal transactions.
const TransactionMaxSystem TransactionMax = 255

// TransactionTypeUnknown represents an unknown transaction type.
const TransactionTypeUnknown TransactionType = 0

// TransactionTypeCreateIdentity creates an ADI, which produces a synthetic chain.
const TransactionTypeCreateIdentity TransactionType = 1

// TransactionTypeCreateTokenAccount creates an ADI token account, which produces a synthetic chain create transaction.
const TransactionTypeCreateTokenAccount TransactionType = 2

// TransactionTypeSendTokens transfers tokens between token accounts, which produces a synthetic deposit tokens transaction.
const TransactionTypeSendTokens TransactionType = 3

// TransactionTypeCreateDataAccount creates an ADI Data Account, which produces a synthetic chain create transaction.
const TransactionTypeCreateDataAccount TransactionType = 4

// TransactionTypeWriteData writes data to an ADI Data Account, which *does not* produce a synthetic transaction.
const TransactionTypeWriteData TransactionType = 5

// TransactionTypeWriteDataTo writes data to a Lite Data Account, which produces a synthetic write data transaction.
const TransactionTypeWriteDataTo TransactionType = 6

// TransactionTypeAcmeFaucet produces a synthetic deposit tokens transaction that deposits ACME tokens into a lite token account.
const TransactionTypeAcmeFaucet TransactionType = 7

// TransactionTypeCreateToken creates a token issuer, which produces a synthetic chain create transaction.
const TransactionTypeCreateToken TransactionType = 8

// TransactionTypeIssueTokens issues tokens to a token account, which produces a synthetic token deposit transaction.
const TransactionTypeIssueTokens TransactionType = 9

// TransactionTypeBurnTokens burns tokens from a token account, which produces a synthetic burn tokens transaction.
const TransactionTypeBurnTokens TransactionType = 10

// TransactionTypeCreateLiteTokenAccount create a lite token account.
const TransactionTypeCreateLiteTokenAccount TransactionType = 11

// TransactionTypeCreateKeyPage creates a key page, which produces a synthetic chain create transaction.
const TransactionTypeCreateKeyPage TransactionType = 12

// TransactionTypeCreateKeyBook creates a key book, which produces a synthetic chain create transaction.
const TransactionTypeCreateKeyBook TransactionType = 13

// TransactionTypeAddCredits converts ACME tokens to credits, which produces a synthetic deposit credits transaction.
const TransactionTypeAddCredits TransactionType = 14

// TransactionTypeUpdateKeyPage adds, removes, or updates keys in a key page, which *does not* produce a synthetic transaction.
const TransactionTypeUpdateKeyPage TransactionType = 15

// TransactionTypeLockAccount sets a major block height that prevents tokens from being transferred out of a lite token account until that height has been reached.
const TransactionTypeLockAccount TransactionType = 16

// TransactionTypeBurnCredits burns credits from a credit account.
const TransactionTypeBurnCredits TransactionType = 17

// TransactionTypeTransferCredits transfers credits between credit accounts within the same domain.
const TransactionTypeTransferCredits TransactionType = 18

// TransactionTypeUpdateAccountAuth updates authorization for an account.
const TransactionTypeUpdateAccountAuth TransactionType = 21

// TransactionTypeUpdateKey update key for existing keys.
const TransactionTypeUpdateKey TransactionType = 22

// TransactionTypeNetworkMaintenance executes network maintenance operations.
const TransactionTypeNetworkMaintenance TransactionType = 46

// TransactionTypeActivateProtocolVersion activates a new version of the protocol.
const TransactionTypeActivateProtocolVersion TransactionType = 47

// TransactionTypeRemote is used to sign a remote transaction.
const TransactionTypeRemote TransactionType = 48

// TransactionTypeSyntheticCreateIdentity creates an identity.
const TransactionTypeSyntheticCreateIdentity TransactionType = 49

// TransactionTypeSyntheticWriteData writes data to a data account.
const TransactionTypeSyntheticWriteData TransactionType = 50

// TransactionTypeSyntheticDepositTokens deposits tokens into token accounts.
const TransactionTypeSyntheticDepositTokens TransactionType = 51

// TransactionTypeSyntheticDepositCredits deposits credits into a credit holder.
const TransactionTypeSyntheticDepositCredits TransactionType = 52

// TransactionTypeSyntheticBurnTokens returns tokens to a token issuer's pool of issuable tokens.
const TransactionTypeSyntheticBurnTokens TransactionType = 53

// TransactionTypeSyntheticForwardTransaction forwards a transaction from one partition to another.
const TransactionTypeSyntheticForwardTransaction TransactionType = 54

// TransactionTypeSystemGenesis initializes system chains.
const TransactionTypeSystemGenesis TransactionType = 96

// TransactionTypeDirectoryAnchor anchors one network to another.
const TransactionTypeDirectoryAnchor TransactionType = 97

// TransactionTypeBlockValidatorAnchor system transaction for partition data.
const TransactionTypeBlockValidatorAnchor TransactionType = 98

// TransactionTypeSystemWriteData writes data to a system data account.
const TransactionTypeSystemWriteData TransactionType = 99

// VoteTypeAccept vote yea in favor of proposal.
const VoteTypeAccept VoteType = 0

// VoteTypeReject vote nay against a proposal.
const VoteTypeReject VoteType = 1

// VoteTypeAbstain chose not to vote on a proposal.
const VoteTypeAbstain VoteType = 2

// VoteTypeSuggest put forth a proposal.
const VoteTypeSuggest VoteType = 3

// GetEnumValue returns the value of the Account Auth Operation Type
func (v AccountAuthOperationType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *AccountAuthOperationType) SetEnumValue(id uint64) bool {
	u := AccountAuthOperationType(id)
	switch u {
	case AccountAuthOperationTypeUnknown, AccountAuthOperationTypeEnable, AccountAuthOperationTypeDisable, AccountAuthOperationTypeAddAuthority, AccountAuthOperationTypeRemoveAuthority:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Account Auth Operation Type.
func (v AccountAuthOperationType) String() string {
	switch v {
	case AccountAuthOperationTypeUnknown:
		return "unknown"
	case AccountAuthOperationTypeEnable:
		return "enable"
	case AccountAuthOperationTypeDisable:
		return "disable"
	case AccountAuthOperationTypeAddAuthority:
		return "addAuthority"
	case AccountAuthOperationTypeRemoveAuthority:
		return "removeAuthority"
	}
	return fmt.Sprintf("AccountAuthOperationType:%d", v)
}

// AccountAuthOperationTypeByName returns the named Account Auth Operation Type.
func AccountAuthOperationTypeByName(name string) (AccountAuthOperationType, bool) {
	switch strings.ToLower(name) {
	case "unknown":
		return AccountAuthOperationTypeUnknown, true
	case "enable":
		return AccountAuthOperationTypeEnable, true
	case "disable":
		return AccountAuthOperationTypeDisable, true
	case "addauthority":
		return AccountAuthOperationTypeAddAuthority, true
	case "removeauthority":
		return AccountAuthOperationTypeRemoveAuthority, true
	}
	return 0, false
}

// MarshalJSON marshals the Account Auth Operation Type to JSON as a string.
func (v AccountAuthOperationType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Account Auth Operation Type from JSON as a string.
func (v *AccountAuthOperationType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = AccountAuthOperationTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Account Auth Operation Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Account Type
func (v AccountType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *AccountType) SetEnumValue(id uint64) bool {
	u := AccountType(id)
	switch u {
	case AccountTypeUnknown, AccountTypeAnchorLedger, AccountTypeIdentity, AccountTypeTokenIssuer, AccountTypeTokenAccount, AccountTypeLiteTokenAccount, AccountTypeBlockLedger, AccountTypeKeyPage, AccountTypeKeyBook, AccountTypeDataAccount, AccountTypeLiteDataAccount, AccountTypeUnknownSigner, AccountTypeSystemLedger, AccountTypeLiteIdentity, AccountTypeSyntheticLedger:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Account Type.
func (v AccountType) String() string {
	switch v {
	case AccountTypeUnknown:
		return "unknown"
	case AccountTypeAnchorLedger:
		return "anchorLedger"
	case AccountTypeIdentity:
		return "identity"
	case AccountTypeTokenIssuer:
		return "tokenIssuer"
	case AccountTypeTokenAccount:
		return "tokenAccount"
	case AccountTypeLiteTokenAccount:
		return "liteTokenAccount"
	case AccountTypeBlockLedger:
		return "blockLedger"
	case AccountTypeKeyPage:
		return "keyPage"
	case AccountTypeKeyBook:
		return "keyBook"
	case AccountTypeDataAccount:
		return "dataAccount"
	case AccountTypeLiteDataAccount:
		return "liteDataAccount"
	case AccountTypeUnknownSigner:
		return "unknownSigner"
	case AccountTypeSystemLedger:
		return "systemLedger"
	case AccountTypeLiteIdentity:
		return "liteIdentity"
	case AccountTypeSyntheticLedger:
		return "syntheticLedger"
	}
	return fmt.Sprintf("AccountType:%d", v)
}

// AccountTypeByName returns the named Account Type.
func AccountTypeByName(name string) (AccountType, bool) {
	switch strings.ToLower(name) {
	case "unknown":
		return AccountTypeUnknown, true
	case "anchorledger":
		return AccountTypeAnchorLedger, true
	case "identity":
		return AccountTypeIdentity, true
	case "tokenissuer":
		return AccountTypeTokenIssuer, true
	case "token":
		return AccountTypeTokenIssuer, true
	case "tokenaccount":
		return AccountTypeTokenAccount, true
	case "litetokenaccount":
		return AccountTypeLiteTokenAccount, true
	case "blockledger":
		return AccountTypeBlockLedger, true
	case "keypage":
		return AccountTypeKeyPage, true
	case "keybook":
		return AccountTypeKeyBook, true
	case "dataaccount":
		return AccountTypeDataAccount, true
	case "litedataaccount":
		return AccountTypeLiteDataAccount, true
	case "unknownsigner":
		return AccountTypeUnknownSigner, true
	case "systemledger":
		return AccountTypeSystemLedger, true
	case "liteidentity":
		return AccountTypeLiteIdentity, true
	case "syntheticledger":
		return AccountTypeSyntheticLedger, true
	}
	return 0, false
}

// MarshalJSON marshals the Account Type to JSON as a string.
func (v AccountType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Account Type from JSON as a string.
func (v *AccountType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = AccountTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Account Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Allowed Transaction Bit
func (v AllowedTransactionBit) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *AllowedTransactionBit) SetEnumValue(id uint64) bool {
	u := AllowedTransactionBit(id)
	switch u {
	case AllowedTransactionBitUpdateKeyPage, AllowedTransactionBitUpdateAccountAuth:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Allowed Transaction Bit.
func (v AllowedTransactionBit) String() string {
	switch v {
	case AllowedTransactionBitUpdateKeyPage:
		return "updateKeyPage"
	case AllowedTransactionBitUpdateAccountAuth:
		return "updateAccountAuth"
	}
	return fmt.Sprintf("AllowedTransactionBit:%d", v)
}

// AllowedTransactionBitByName returns the named Allowed Transaction Bit.
func AllowedTransactionBitByName(name string) (AllowedTransactionBit, bool) {
	switch strings.ToLower(name) {
	case "updatekeypage":
		return AllowedTransactionBitUpdateKeyPage, true
	case "updateaccountauth":
		return AllowedTransactionBitUpdateAccountAuth, true
	}
	return 0, false
}

// MarshalJSON marshals the Allowed Transaction Bit to JSON as a string.
func (v AllowedTransactionBit) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Allowed Transaction Bit from JSON as a string.
func (v *AllowedTransactionBit) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = AllowedTransactionBitByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Allowed Transaction Bit %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Book Type
func (v BookType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *BookType) SetEnumValue(id uint64) bool {
	u := BookType(id)
	switch u {
	case BookTypeNormal, BookTypeValidator, BookTypeOperator:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Book Type.
func (v BookType) String() string {
	switch v {
	case BookTypeNormal:
		return "normal"
	case BookTypeValidator:
		return "validator"
	case BookTypeOperator:
		return "operator"
	}
	return fmt.Sprintf("BookType:%d", v)
}

// BookTypeByName returns the named Book Type.
func BookTypeByName(name string) (BookType, bool) {
	switch strings.ToLower(name) {
	case "normal":
		return BookTypeNormal, true
	case "validator":
		return BookTypeValidator, true
	case "operator":
		return BookTypeOperator, true
	}
	return 0, false
}

// MarshalJSON marshals the Book Type to JSON as a string.
func (v BookType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Book Type from JSON as a string.
func (v *BookType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = BookTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Book Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Data Entry Type
func (v DataEntryType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *DataEntryType) SetEnumValue(id uint64) bool {
	u := DataEntryType(id)
	switch u {
	case DataEntryTypeUnknown, DataEntryTypeFactom, DataEntryTypeAccumulate, DataEntryTypeDoubleHash:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Data Entry Type.
func (v DataEntryType) String() string {
	switch v {
	case DataEntryTypeUnknown:
		return "unknown"
	case DataEntryTypeFactom:
		return "factom"
	case DataEntryTypeAccumulate:
		return "accumulate"
	case DataEntryTypeDoubleHash:
		return "doubleHash"
	}
	return fmt.Sprintf("DataEntryType:%d", v)
}

// DataEntryTypeByName returns the named Data Entry Type.
func DataEntryTypeByName(name string) (DataEntryType, bool) {
	switch strings.ToLower(name) {
	case "unknown":
		return DataEntryTypeUnknown, true
	case "factom":
		return DataEntryTypeFactom, true
	case "accumulate":
		return DataEntryTypeAccumulate, true
	case "doublehash":
		return DataEntryTypeDoubleHash, true
	}
	return 0, false
}

// MarshalJSON marshals the Data Entry Type to JSON as a string.
func (v DataEntryType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Data Entry Type from JSON as a string.
func (v *DataEntryType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = DataEntryTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Data Entry Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Error Code
func (v ErrorCode) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *ErrorCode) SetEnumValue(id uint64) bool {
	u := ErrorCode(id)
	switch u {
	case ErrorCodeOK, ErrorCodeEncodingError, ErrorCodeFailed, ErrorCodeDidPanic, ErrorCodeUnknownError:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Error Code.
func (v ErrorCode) String() string {
	switch v {
	case ErrorCodeOK:
		return "ok"
	case ErrorCodeEncodingError:
		return "encodingError"
	case ErrorCodeFailed:
		return "failed"
	case ErrorCodeDidPanic:
		return "didPanic"
	case ErrorCodeUnknownError:
		return "unknownError"
	}
	return fmt.Sprintf("ErrorCode:%d", v)
}

// ErrorCodeByName returns the named Error Code.
func ErrorCodeByName(name string) (ErrorCode, bool) {
	switch strings.ToLower(name) {
	case "ok":
		return ErrorCodeOK, true
	case "encodingerror":
		return ErrorCodeEncodingError, true
	case "failed":
		return ErrorCodeFailed, true
	case "didpanic":
		return ErrorCodeDidPanic, true
	case "unknownerror":
		return ErrorCodeUnknownError, true
	}
	return 0, false
}

// MarshalJSON marshals the Error Code to JSON as a string.
func (v ErrorCode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Error Code from JSON as a string.
func (v *ErrorCode) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = ErrorCodeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Error Code %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Executor Version
func (v ExecutorVersion) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *ExecutorVersion) SetEnumValue(id uint64) bool {
	u := ExecutorVersion(id)
	switch u {
	case ExecutorVersionV1, ExecutorVersionV1SignatureAnchoring, ExecutorVersionV1DoubleHashEntries, ExecutorVersionV1Halt, ExecutorVersionV2, ExecutorVersionV2Baikonur, ExecutorVersionV2Vandenberg, ExecutorVersionVNext:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Executor Version.
func (v ExecutorVersion) String() string {
	switch v {
	case ExecutorVersionV1:
		return "v1"
	case ExecutorVersionV1SignatureAnchoring:
		return "v1-signatureAnchoring"
	case ExecutorVersionV1DoubleHashEntries:
		return "v1-doubleHashEntries"
	case ExecutorVersionV1Halt:
		return "v1-halt"
	case ExecutorVersionV2:
		return "v2"
	case ExecutorVersionV2Baikonur:
		return "v2Baikonur"
	case ExecutorVersionV2Vandenberg:
		return "v2-vandenberg"
	case ExecutorVersionVNext:
		return "vnext"
	}
	return fmt.Sprintf("ExecutorVersion:%d", v)
}

// ExecutorVersionByName returns the named Executor Version.
func ExecutorVersionByName(name string) (ExecutorVersion, bool) {
	switch strings.ToLower(name) {
	case "v1":
		return ExecutorVersionV1, true
	case "v1signatureanchoring":
		return ExecutorVersionV1SignatureAnchoring, true
	case "v1-signatureanchoring":
		return ExecutorVersionV1SignatureAnchoring, true
	case "v1doublehashentries":
		return ExecutorVersionV1DoubleHashEntries, true
	case "v1-doublehashentries":
		return ExecutorVersionV1DoubleHashEntries, true
	case "v1halt":
		return ExecutorVersionV1Halt, true
	case "v1-halt":
		return ExecutorVersionV1Halt, true
	case "v2":
		return ExecutorVersionV2, true
	case "v2baikonur":
		return ExecutorVersionV2Baikonur, true
	case "v2-baikonur":
		return ExecutorVersionV2Baikonur, true
	case "v2vandenberg":
		return ExecutorVersionV2Vandenberg, true
	case "v2-vandenberg":
		return ExecutorVersionV2Vandenberg, true
	case "vnext":
		return ExecutorVersionVNext, true
	}
	return 0, false
}

// MarshalJSON marshals the Executor Version to JSON as a string.
func (v ExecutorVersion) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Executor Version from JSON as a string.
func (v *ExecutorVersion) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = ExecutorVersionByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Executor Version %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Key Page Operation Type
func (v KeyPageOperationType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *KeyPageOperationType) SetEnumValue(id uint64) bool {
	u := KeyPageOperationType(id)
	switch u {
	case KeyPageOperationTypeUnknown, KeyPageOperationTypeUpdate, KeyPageOperationTypeRemove, KeyPageOperationTypeAdd, KeyPageOperationTypeSetThreshold, KeyPageOperationTypeUpdateAllowed, KeyPageOperationTypeSetRejectThreshold, KeyPageOperationTypeSetResponseThreshold:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Key Page Operation Type.
func (v KeyPageOperationType) String() string {
	switch v {
	case KeyPageOperationTypeUnknown:
		return "unknown"
	case KeyPageOperationTypeUpdate:
		return "update"
	case KeyPageOperationTypeRemove:
		return "remove"
	case KeyPageOperationTypeAdd:
		return "add"
	case KeyPageOperationTypeSetThreshold:
		return "setThreshold"
	case KeyPageOperationTypeUpdateAllowed:
		return "updateAllowed"
	case KeyPageOperationTypeSetRejectThreshold:
		return "setRejectThreshold"
	case KeyPageOperationTypeSetResponseThreshold:
		return "setResponseThreshold"
	}
	return fmt.Sprintf("KeyPageOperationType:%d", v)
}

// KeyPageOperationTypeByName returns the named Key Page Operation Type.
func KeyPageOperationTypeByName(name string) (KeyPageOperationType, bool) {
	switch strings.ToLower(name) {
	case "unknown":
		return KeyPageOperationTypeUnknown, true
	case "update":
		return KeyPageOperationTypeUpdate, true
	case "remove":
		return KeyPageOperationTypeRemove, true
	case "add":
		return KeyPageOperationTypeAdd, true
	case "setthreshold":
		return KeyPageOperationTypeSetThreshold, true
	case "updateallowed":
		return KeyPageOperationTypeUpdateAllowed, true
	case "setrejectthreshold":
		return KeyPageOperationTypeSetRejectThreshold, true
	case "setresponsethreshold":
		return KeyPageOperationTypeSetResponseThreshold, true
	}
	return 0, false
}

// MarshalJSON marshals the Key Page Operation Type to JSON as a string.
func (v KeyPageOperationType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Key Page Operation Type from JSON as a string.
func (v *KeyPageOperationType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = KeyPageOperationTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Key Page Operation Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Network Maintenance Operation Type
func (v NetworkMaintenanceOperationType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *NetworkMaintenanceOperationType) SetEnumValue(id uint64) bool {
	u := NetworkMaintenanceOperationType(id)
	switch u {
	case NetworkMaintenanceOperationTypeUnknown, NetworkMaintenanceOperationTypePendingTransactionGC:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Network Maintenance Operation Type.
func (v NetworkMaintenanceOperationType) String() string {
	switch v {
	case NetworkMaintenanceOperationTypeUnknown:
		return "unknown"
	case NetworkMaintenanceOperationTypePendingTransactionGC:
		return "pendingTransactionGC"
	}
	return fmt.Sprintf("NetworkMaintenanceOperationType:%d", v)
}

// NetworkMaintenanceOperationTypeByName returns the named Network Maintenance Operation Type.
func NetworkMaintenanceOperationTypeByName(name string) (NetworkMaintenanceOperationType, bool) {
	switch strings.ToLower(name) {
	case "unknown":
		return NetworkMaintenanceOperationTypeUnknown, true
	case "pendingtransactiongc":
		return NetworkMaintenanceOperationTypePendingTransactionGC, true
	}
	return 0, false
}

// MarshalJSON marshals the Network Maintenance Operation Type to JSON as a string.
func (v NetworkMaintenanceOperationType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Network Maintenance Operation Type from JSON as a string.
func (v *NetworkMaintenanceOperationType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = NetworkMaintenanceOperationTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Network Maintenance Operation Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Object Type
func (v ObjectType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *ObjectType) SetEnumValue(id uint64) bool {
	u := ObjectType(id)
	switch u {
	case ObjectTypeUnknown, ObjectTypeAccount, ObjectTypeTransaction:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Object Type.
func (v ObjectType) String() string {
	switch v {
	case ObjectTypeUnknown:
		return "unknown"
	case ObjectTypeAccount:
		return "account"
	case ObjectTypeTransaction:
		return "transaction"
	}
	return fmt.Sprintf("ObjectType:%d", v)
}

// ObjectTypeByName returns the named Object Type.
func ObjectTypeByName(name string) (ObjectType, bool) {
	switch strings.ToLower(name) {
	case "unknown":
		return ObjectTypeUnknown, true
	case "account":
		return ObjectTypeAccount, true
	case "transaction":
		return ObjectTypeTransaction, true
	}
	return 0, false
}

// MarshalJSON marshals the Object Type to JSON as a string.
func (v ObjectType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Object Type from JSON as a string.
func (v *ObjectType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = ObjectTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Object Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Partition Type
func (v PartitionType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *PartitionType) SetEnumValue(id uint64) bool {
	u := PartitionType(id)
	switch u {
	case PartitionTypeDirectory, PartitionTypeBlockValidator, PartitionTypeBlockSummary, PartitionTypeBootstrap:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Partition Type.
func (v PartitionType) String() string {
	switch v {
	case PartitionTypeDirectory:
		return "directory"
	case PartitionTypeBlockValidator:
		return "blockValidator"
	case PartitionTypeBlockSummary:
		return "blockSummary"
	case PartitionTypeBootstrap:
		return "bootstrap"
	}
	return fmt.Sprintf("PartitionType:%d", v)
}

// PartitionTypeByName returns the named Partition Type.
func PartitionTypeByName(name string) (PartitionType, bool) {
	switch strings.ToLower(name) {
	case "directory":
		return PartitionTypeDirectory, true
	case "blockvalidator":
		return PartitionTypeBlockValidator, true
	case "block-validator":
		return PartitionTypeBlockValidator, true
	case "blocksummary":
		return PartitionTypeBlockSummary, true
	case "block-summary":
		return PartitionTypeBlockSummary, true
	case "bootstrap":
		return PartitionTypeBootstrap, true
	}
	return 0, false
}

// MarshalJSON marshals the Partition Type to JSON as a string.
func (v PartitionType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Partition Type from JSON as a string.
func (v *PartitionType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = PartitionTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Partition Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Signature Type
func (v SignatureType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *SignatureType) SetEnumValue(id uint64) bool {
	u := SignatureType(id)
	switch u {
	case SignatureTypeUnknown, SignatureTypeLegacyED25519, SignatureTypeED25519, SignatureTypeRCD1, SignatureTypeReceipt, SignatureTypePartition, SignatureTypeSet, SignatureTypeRemote, SignatureTypeBTC, SignatureTypeBTCLegacy, SignatureTypeETH, SignatureTypeDelegated, SignatureTypeInternal, SignatureTypeAuthority, SignatureTypeRsaSha256, SignatureTypeEcdsaSha256, SignatureTypeTypedData:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Signature Type.
func (v SignatureType) String() string {
	switch v {
	case SignatureTypeUnknown:
		return "unknown"
	case SignatureTypeLegacyED25519:
		return "legacyED25519"
	case SignatureTypeED25519:
		return "ed25519"
	case SignatureTypeRCD1:
		return "rcd1"
	case SignatureTypeReceipt:
		return "receipt"
	case SignatureTypePartition:
		return "partition"
	case SignatureTypeSet:
		return "set"
	case SignatureTypeRemote:
		return "remote"
	case SignatureTypeBTC:
		return "btc"
	case SignatureTypeBTCLegacy:
		return "btclegacy"
	case SignatureTypeETH:
		return "eth"
	case SignatureTypeDelegated:
		return "delegated"
	case SignatureTypeInternal:
		return "internal"
	case SignatureTypeAuthority:
		return "authority"
	case SignatureTypeRsaSha256:
		return "rsaSha256"
	case SignatureTypeEcdsaSha256:
		return "ecdsaSha256"
	case SignatureTypeTypedData:
		return "typedData"
	}
	return fmt.Sprintf("SignatureType:%d", v)
}

// SignatureTypeByName returns the named Signature Type.
func SignatureTypeByName(name string) (SignatureType, bool) {
	switch strings.ToLower(name) {
	case "unknown":
		return SignatureTypeUnknown, true
	case "legacyed25519":
		return SignatureTypeLegacyED25519, true
	case "ed25519":
		return SignatureTypeED25519, true
	case "rcd1":
		return SignatureTypeRCD1, true
	case "receipt":
		return SignatureTypeReceipt, true
	case "partition":
		return SignatureTypePartition, true
	case "synthetic":
		return SignatureTypePartition, true
	case "set":
		return SignatureTypeSet, true
	case "remote":
		return SignatureTypeRemote, true
	case "btc":
		return SignatureTypeBTC, true
	case "btclegacy":
		return SignatureTypeBTCLegacy, true
	case "eth":
		return SignatureTypeETH, true
	case "delegated":
		return SignatureTypeDelegated, true
	case "internal":
		return SignatureTypeInternal, true
	case "authority":
		return SignatureTypeAuthority, true
	case "rsasha256":
		return SignatureTypeRsaSha256, true
	case "ecdsasha256":
		return SignatureTypeEcdsaSha256, true
	case "typeddata":
		return SignatureTypeTypedData, true
	}
	return 0, false
}

// MarshalJSON marshals the Signature Type to JSON as a string.
func (v SignatureType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Signature Type from JSON as a string.
func (v *SignatureType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = SignatureTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Signature Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Transaction Max
func (v TransactionMax) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *TransactionMax) SetEnumValue(id uint64) bool {
	u := TransactionMax(id)
	switch u {
	case TransactionMaxUser, TransactionMaxSynthetic, TransactionMaxSystem:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Transaction Max.
func (v TransactionMax) String() string {
	switch v {
	case TransactionMaxUser:
		return "user"
	case TransactionMaxSynthetic:
		return "synthetic"
	case TransactionMaxSystem:
		return "system"
	}
	return fmt.Sprintf("TransactionMax:%d", v)
}

// TransactionMaxByName returns the named Transaction Max.
func TransactionMaxByName(name string) (TransactionMax, bool) {
	switch strings.ToLower(name) {
	case "user":
		return TransactionMaxUser, true
	case "synthetic":
		return TransactionMaxSynthetic, true
	case "system":
		return TransactionMaxSystem, true
	}
	return 0, false
}

// MarshalJSON marshals the Transaction Max to JSON as a string.
func (v TransactionMax) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Transaction Max from JSON as a string.
func (v *TransactionMax) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = TransactionMaxByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Transaction Max %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Transaction Type
func (v TransactionType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *TransactionType) SetEnumValue(id uint64) bool {
	u := TransactionType(id)
	switch u {
	case TransactionTypeUnknown, TransactionTypeCreateIdentity, TransactionTypeCreateTokenAccount, TransactionTypeSendTokens, TransactionTypeCreateDataAccount, TransactionTypeWriteData, TransactionTypeWriteDataTo, TransactionTypeAcmeFaucet, TransactionTypeCreateToken, TransactionTypeIssueTokens, TransactionTypeBurnTokens, TransactionTypeCreateLiteTokenAccount, TransactionTypeCreateKeyPage, TransactionTypeCreateKeyBook, TransactionTypeAddCredits, TransactionTypeUpdateKeyPage, TransactionTypeLockAccount, TransactionTypeBurnCredits, TransactionTypeTransferCredits, TransactionTypeUpdateAccountAuth, TransactionTypeUpdateKey, TransactionTypeNetworkMaintenance, TransactionTypeActivateProtocolVersion, TransactionTypeRemote, TransactionTypeSyntheticCreateIdentity, TransactionTypeSyntheticWriteData, TransactionTypeSyntheticDepositTokens, TransactionTypeSyntheticDepositCredits, TransactionTypeSyntheticBurnTokens, TransactionTypeSyntheticForwardTransaction, TransactionTypeSystemGenesis, TransactionTypeDirectoryAnchor, TransactionTypeBlockValidatorAnchor, TransactionTypeSystemWriteData:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Transaction Type.
func (v TransactionType) String() string {
	switch v {
	case TransactionTypeUnknown:
		return "unknown"
	case TransactionTypeCreateIdentity:
		return "createIdentity"
	case TransactionTypeCreateTokenAccount:
		return "createTokenAccount"
	case TransactionTypeSendTokens:
		return "sendTokens"
	case TransactionTypeCreateDataAccount:
		return "createDataAccount"
	case TransactionTypeWriteData:
		return "writeData"
	case TransactionTypeWriteDataTo:
		return "writeDataTo"
	case TransactionTypeAcmeFaucet:
		return "acmeFaucet"
	case TransactionTypeCreateToken:
		return "createToken"
	case TransactionTypeIssueTokens:
		return "issueTokens"
	case TransactionTypeBurnTokens:
		return "burnTokens"
	case TransactionTypeCreateLiteTokenAccount:
		return "createLiteTokenAccount"
	case TransactionTypeCreateKeyPage:
		return "createKeyPage"
	case TransactionTypeCreateKeyBook:
		return "createKeyBook"
	case TransactionTypeAddCredits:
		return "addCredits"
	case TransactionTypeUpdateKeyPage:
		return "updateKeyPage"
	case TransactionTypeLockAccount:
		return "lockAccount"
	case TransactionTypeBurnCredits:
		return "burnCredits"
	case TransactionTypeTransferCredits:
		return "transferCredits"
	case TransactionTypeUpdateAccountAuth:
		return "updateAccountAuth"
	case TransactionTypeUpdateKey:
		return "updateKey"
	case TransactionTypeNetworkMaintenance:
		return "networkMaintenance"
	case TransactionTypeActivateProtocolVersion:
		return "activateProtocolVersion"
	case TransactionTypeRemote:
		return "remote"
	case TransactionTypeSyntheticCreateIdentity:
		return "syntheticCreateIdentity"
	case TransactionTypeSyntheticWriteData:
		return "syntheticWriteData"
	case TransactionTypeSyntheticDepositTokens:
		return "syntheticDepositTokens"
	case TransactionTypeSyntheticDepositCredits:
		return "syntheticDepositCredits"
	case TransactionTypeSyntheticBurnTokens:
		return "syntheticBurnTokens"
	case TransactionTypeSyntheticForwardTransaction:
		return "syntheticForwardTransaction"
	case TransactionTypeSystemGenesis:
		return "systemGenesis"
	case TransactionTypeDirectoryAnchor:
		return "directoryAnchor"
	case TransactionTypeBlockValidatorAnchor:
		return "blockValidatorAnchor"
	case TransactionTypeSystemWriteData:
		return "systemWriteData"
	}
	return fmt.Sprintf("TransactionType:%d", v)
}

// TransactionTypeByName returns the named Transaction Type.
func TransactionTypeByName(name string) (TransactionType, bool) {
	switch strings.ToLower(name) {
	case "unknown":
		return TransactionTypeUnknown, true
	case "createidentity":
		return TransactionTypeCreateIdentity, true
	case "createtokenaccount":
		return TransactionTypeCreateTokenAccount, true
	case "sendtokens":
		return TransactionTypeSendTokens, true
	case "createdataaccount":
		return TransactionTypeCreateDataAccount, true
	case "writedata":
		return TransactionTypeWriteData, true
	case "writedatato":
		return TransactionTypeWriteDataTo, true
	case "acmefaucet":
		return TransactionTypeAcmeFaucet, true
	case "createtoken":
		return TransactionTypeCreateToken, true
	case "issuetokens":
		return TransactionTypeIssueTokens, true
	case "burntokens":
		return TransactionTypeBurnTokens, true
	case "createlitetokenaccount":
		return TransactionTypeCreateLiteTokenAccount, true
	case "createkeypage":
		return TransactionTypeCreateKeyPage, true
	case "createkeybook":
		return TransactionTypeCreateKeyBook, true
	case "addcredits":
		return TransactionTypeAddCredits, true
	case "updatekeypage":
		return TransactionTypeUpdateKeyPage, true
	case "lockaccount":
		return TransactionTypeLockAccount, true
	case "burncredits":
		return TransactionTypeBurnCredits, true
	case "transfercredits":
		return TransactionTypeTransferCredits, true
	case "updateaccountauth":
		return TransactionTypeUpdateAccountAuth, true
	case "updatekey":
		return TransactionTypeUpdateKey, true
	case "networkmaintenance":
		return TransactionTypeNetworkMaintenance, true
	case "activateprotocolversion":
		return TransactionTypeActivateProtocolVersion, true
	case "remote":
		return TransactionTypeRemote, true
	case "signPending":
		return TransactionTypeRemote, true
	case "syntheticcreateidentity":
		return TransactionTypeSyntheticCreateIdentity, true
	case "syntheticwritedata":
		return TransactionTypeSyntheticWriteData, true
	case "syntheticdeposittokens":
		return TransactionTypeSyntheticDepositTokens, true
	case "syntheticdepositcredits":
		return TransactionTypeSyntheticDepositCredits, true
	case "syntheticburntokens":
		return TransactionTypeSyntheticBurnTokens, true
	case "syntheticforwardtransaction":
		return TransactionTypeSyntheticForwardTransaction, true
	case "systemgenesis":
		return TransactionTypeSystemGenesis, true
	case "directoryanchor":
		return TransactionTypeDirectoryAnchor, true
	case "blockvalidatoranchor":
		return TransactionTypeBlockValidatorAnchor, true
	case "systemwritedata":
		return TransactionTypeSystemWriteData, true
	}
	return 0, false
}

// MarshalJSON marshals the Transaction Type to JSON as a string.
func (v TransactionType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Transaction Type from JSON as a string.
func (v *TransactionType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = TransactionTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Transaction Type %q", s)
	}
	return nil
}

// GetEnumValue returns the value of the Vote Type
func (v VoteType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *VoteType) SetEnumValue(id uint64) bool {
	u := VoteType(id)
	switch u {
	case VoteTypeAccept, VoteTypeReject, VoteTypeAbstain, VoteTypeSuggest:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Vote Type.
func (v VoteType) String() string {
	switch v {
	case VoteTypeAccept:
		return "accept"
	case VoteTypeReject:
		return "reject"
	case VoteTypeAbstain:
		return "abstain"
	case VoteTypeSuggest:
		return "suggest"
	}
	return fmt.Sprintf("VoteType:%d", v)
}

// VoteTypeByName returns the named Vote Type.
func VoteTypeByName(name string) (VoteType, bool) {
	switch strings.ToLower(name) {
	case "accept":
		return VoteTypeAccept, true
	case "reject":
		return VoteTypeReject, true
	case "abstain":
		return VoteTypeAbstain, true
	case "suggest":
		return VoteTypeSuggest, true
	}
	return 0, false
}

// MarshalJSON marshals the Vote Type to JSON as a string.
func (v VoteType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Vote Type from JSON as a string.
func (v *VoteType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = VoteTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Vote Type %q", s)
	}
	return nil
}
