// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package websocket

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/pkg/api/v3/message"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

type Message struct {
	fieldsSet []bool
	ID        uint64          `json:"id,omitempty" form:"id" query:"id" validate:"required"`
	Status    StreamStatus    `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	Message   message.Message `json:"message,omitempty" form:"message" query:"message"`
	extraData []byte
}

func (v *Message) Copy() *Message {
	u := new(Message)

	u.ID = v.ID
	u.Status = v.Status
	if v.Message != nil {
		u.Message = message.Copy(v.Message)
	}

	return u
}

func (v *Message) CopyAsInterface() interface{} { return v.Copy() }

func (v *Message) Equal(u *Message) bool {
	if !(v.ID == u.ID) {
		return false
	}
	if !(v.Status == u.Status) {
		return false
	}
	if !(message.Equal(v.Message, u.Message)) {
		return false
	}

	return true
}

var fieldNames_Message = []string{
	1: "ID",
	2: "Status",
	3: "Message",
}

func (v *Message) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.ID == 0) {
		writer.WriteUint(1, v.ID)
	}
	if !(v.Status == 0) {
		writer.WriteEnum(2, v.Status)
	}
	if !(message.Equal(v.Message, nil)) {
		writer.WriteValue(3, v.Message.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_Message)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Message) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field ID is missing")
	} else if v.ID == 0 {
		errs = append(errs, "field ID is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == 0 {
		errs = append(errs, "field Status is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *Message) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Message) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.ID = x
	}
	if x := new(StreamStatus); reader.ReadEnum(2, x) {
		v.Status = *x
	}
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := message.UnmarshalFrom(r)
		if err == nil {
			v.Message = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_Message)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Message) MarshalJSON() ([]byte, error) {
	u := struct {
		ID      uint64                                       `json:"id,omitempty"`
		Status  StreamStatus                                 `json:"status,omitempty"`
		Message *encoding.JsonUnmarshalWith[message.Message] `json:"message,omitempty"`
	}{}
	if !(v.ID == 0) {
		u.ID = v.ID
	}
	if !(v.Status == 0) {
		u.Status = v.Status
	}
	if !(message.Equal(v.Message, nil)) {
		u.Message = &encoding.JsonUnmarshalWith[message.Message]{Value: v.Message, Func: message.UnmarshalJSON}
	}
	return json.Marshal(&u)
}

func (v *Message) UnmarshalJSON(data []byte) error {
	u := struct {
		ID      uint64                                       `json:"id,omitempty"`
		Status  StreamStatus                                 `json:"status,omitempty"`
		Message *encoding.JsonUnmarshalWith[message.Message] `json:"message,omitempty"`
	}{}
	u.ID = v.ID
	u.Status = v.Status
	u.Message = &encoding.JsonUnmarshalWith[message.Message]{Value: v.Message, Func: message.UnmarshalJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ID = u.ID
	v.Status = u.Status
	if u.Message != nil {
		v.Message = u.Message.Value
	}

	return nil
}
