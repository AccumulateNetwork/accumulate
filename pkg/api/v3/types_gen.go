package api

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/smt/managed"
)

type AccountRecord struct {
	fieldsSet []bool
	Account   protocol.Account `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Receipt   *managed.Receipt `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	extraData []byte
}

type ChainRecord struct {
	fieldsSet []bool
	Name      string            `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      managed.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Count     uint64            `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	State     [][]byte          `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	extraData []byte
}

type LastBlock struct {
	fieldsSet             []bool
	Height                int64     `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Time                  time.Time `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	ChainRoot             [32]byte  `json:"chainRoot,omitempty" form:"chainRoot" query:"chainRoot" validate:"required"`
	StateRoot             [32]byte  `json:"stateRoot,omitempty" form:"stateRoot" query:"stateRoot" validate:"required"`
	DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty" form:"directoryAnchorHeight" query:"directoryAnchorHeight" validate:"required"`
	extraData             []byte
}

type NodeDescription struct {
	ValidatorKeyHash [32]byte                    `json:"validatorKeyHash,omitempty" form:"validatorKeyHash" query:"validatorKeyHash" validate:"required"`
	Network          *protocol.NetworkDefinition `json:"network,omitempty" form:"network" query:"network" validate:"required"`
}

type NodeMetrics struct {
	fieldsSet []bool
	TPS       float64 `json:"tps" form:"tps" query:"tps" validate:"required"`
	extraData []byte
}

type NodeStatus struct {
	fieldsSet []bool
	Ok        bool       `json:"ok,omitempty" form:"ok" query:"ok" validate:"required"`
	LastBlock *LastBlock `json:"lastBlock,omitempty" form:"lastBlock" query:"lastBlock" validate:"required"`
	extraData []byte
}

type NodeVersion struct {
	fieldsSet      []bool
	Version        string `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Commit         string `json:"commit,omitempty" form:"commit" query:"commit" validate:"required"`
	VersionIsKnown bool   `json:"versionIsKnown,omitempty" form:"versionIsKnown" query:"versionIsKnown" validate:"required"`
	extraData      []byte
}

type QueryRecordOptions struct {
	fieldsSet []bool
	// IncludeReceipt requests a Merkle receipt.
	IncludeReceipt bool `json:"includeReceipt,omitempty" form:"includeReceipt" query:"includeReceipt"`
	// WaitForRecord blocks until the record is available.
	WaitForRecord time.Duration `json:"waitForRecord,omitempty" form:"waitForRecord" query:"waitForRecord"`
	// OnlyDelivered ignores incomplete transactions.
	OnlyDelivered bool `json:"onlyDelivered,omitempty" form:"onlyDelivered" query:"onlyDelivered"`
	extraData     []byte
}

type QueryRecordSetOptions struct {
	fieldsSet []bool
	// Start is the starting index.
	Start bool `json:"start,omitempty" form:"start" query:"start"`
	// Count is the number of requested results.
	Count     bool `json:"count,omitempty" form:"count" query:"count"`
	extraData []byte
}

type Submission struct {
	fieldsSet   []bool
	Transaction url.TxID                    `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signatures  []url.TxID                  `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	Status      *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	extraData   []byte
}

type SubmitOptions struct {
	fieldsSet []bool
	extraData []byte
}

type TransactionRecord struct {
	fieldsSet   []bool
	TxID        *url.TxID                   `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Transaction *protocol.Transaction       `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Status      *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	Produced    []*url.TxID                 `json:"produced,omitempty" form:"produced" query:"produced" validate:"required"`
	Receipt     *managed.Receipt            `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	extraData   []byte
}

func (*AccountRecord) RecordType() RecordType { return RecordTypeAccount }

func (*ChainRecord) RecordType() RecordType { return RecordTypeChain }

func (*TransactionRecord) RecordType() RecordType { return RecordTypeTransaction }

func (v *AccountRecord) Copy() *AccountRecord {
	u := new(AccountRecord)

	if v.Account != nil {
		u.Account = (v.Account).CopyAsInterface().(protocol.Account)
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *AccountRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainRecord) Copy() *ChainRecord {
	u := new(ChainRecord)

	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.State = make([][]byte, len(v.State))
	for i, v := range v.State {
		u.State[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *ChainRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *LastBlock) Copy() *LastBlock {
	u := new(LastBlock)

	u.Height = v.Height
	u.Time = v.Time
	u.ChainRoot = v.ChainRoot
	u.StateRoot = v.StateRoot
	u.DirectoryAnchorHeight = v.DirectoryAnchorHeight

	return u
}

func (v *LastBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeMetrics) Copy() *NodeMetrics {
	u := new(NodeMetrics)

	u.TPS = v.TPS

	return u
}

func (v *NodeMetrics) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeStatus) Copy() *NodeStatus {
	u := new(NodeStatus)

	u.Ok = v.Ok
	if v.LastBlock != nil {
		u.LastBlock = (v.LastBlock).Copy()
	}

	return u
}

func (v *NodeStatus) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeVersion) Copy() *NodeVersion {
	u := new(NodeVersion)

	u.Version = v.Version
	u.Commit = v.Commit
	u.VersionIsKnown = v.VersionIsKnown

	return u
}

func (v *NodeVersion) CopyAsInterface() interface{} { return v.Copy() }

func (v *QueryRecordOptions) Copy() *QueryRecordOptions {
	u := new(QueryRecordOptions)

	u.IncludeReceipt = v.IncludeReceipt
	u.WaitForRecord = v.WaitForRecord
	u.OnlyDelivered = v.OnlyDelivered

	return u
}

func (v *QueryRecordOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *QueryRecordSetOptions) Copy() *QueryRecordSetOptions {
	u := new(QueryRecordSetOptions)

	u.Start = v.Start
	u.Count = v.Count

	return u
}

func (v *QueryRecordSetOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *Submission) Copy() *Submission {
	u := new(Submission)

	u.Transaction = *&v.Transaction
	u.Signatures = make([]url.TxID, len(v.Signatures))
	for i, v := range v.Signatures {
		u.Signatures[i] = *&v
	}
	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}

	return u
}

func (v *Submission) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubmitOptions) Copy() *SubmitOptions {
	u := new(SubmitOptions)

	return u
}

func (v *SubmitOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionRecord) Copy() *TransactionRecord {
	u := new(TransactionRecord)

	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}
	u.Produced = make([]*url.TxID, len(v.Produced))
	for i, v := range v.Produced {
		if v != nil {
			u.Produced[i] = v
		}
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *TransactionRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *AccountRecord) Equal(u *AccountRecord) bool {
	if !(protocol.EqualAccount(v.Account, u.Account)) {
		return false
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

func (v *ChainRecord) Equal(u *ChainRecord) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}

	return true
}

func (v *LastBlock) Equal(u *LastBlock) bool {
	if !(v.Height == u.Height) {
		return false
	}
	if !(v.Time == u.Time) {
		return false
	}
	if !(v.ChainRoot == u.ChainRoot) {
		return false
	}
	if !(v.StateRoot == u.StateRoot) {
		return false
	}
	if !(v.DirectoryAnchorHeight == u.DirectoryAnchorHeight) {
		return false
	}

	return true
}

func (v *NodeMetrics) Equal(u *NodeMetrics) bool {
	if !(v.TPS == u.TPS) {
		return false
	}

	return true
}

func (v *NodeStatus) Equal(u *NodeStatus) bool {
	if !(v.Ok == u.Ok) {
		return false
	}
	switch {
	case v.LastBlock == u.LastBlock:
		// equal
	case v.LastBlock == nil || u.LastBlock == nil:
		return false
	case !((v.LastBlock).Equal(u.LastBlock)):
		return false
	}

	return true
}

func (v *NodeVersion) Equal(u *NodeVersion) bool {
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.Commit == u.Commit) {
		return false
	}
	if !(v.VersionIsKnown == u.VersionIsKnown) {
		return false
	}

	return true
}

func (v *QueryRecordOptions) Equal(u *QueryRecordOptions) bool {
	if !(v.IncludeReceipt == u.IncludeReceipt) {
		return false
	}
	if !(v.WaitForRecord == u.WaitForRecord) {
		return false
	}
	if !(v.OnlyDelivered == u.OnlyDelivered) {
		return false
	}

	return true
}

func (v *QueryRecordSetOptions) Equal(u *QueryRecordSetOptions) bool {
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}

	return true
}

func (v *Submission) Equal(u *Submission) bool {
	if !((&v.Transaction).Equal(&u.Transaction)) {
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !((&v.Signatures[i]).Equal(&u.Signatures[i])) {
			return false
		}
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}

	return true
}

func (v *SubmitOptions) Equal(u *SubmitOptions) bool {

	return true
}

func (v *TransactionRecord) Equal(u *TransactionRecord) bool {
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}
	if len(v.Produced) != len(u.Produced) {
		return false
	}
	for i := range v.Produced {
		if !((v.Produced[i]).Equal(u.Produced[i])) {
			return false
		}
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

var fieldNames_AccountRecord = []string{
	1: "RecordType",
	2: "Account",
	3: "Receipt",
}

func (v *AccountRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Account == nil) {
		writer.WriteValue(2, v.Account.MarshalBinary)
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(3, v.Receipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_AccountRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AccountRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Receipt is missing")
	} else if v.Receipt == nil {
		errs = append(errs, "field Receipt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainRecord = []string{
	1: "RecordType",
	2: "Name",
	3: "Type",
	4: "Count",
	5: "State",
}

func (v *ChainRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(len(v.Name) == 0) {
		writer.WriteString(2, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(3, v.Type)
	}
	if !(v.Count == 0) {
		writer.WriteUint(4, v.Count)
	}
	if !(len(v.State) == 0) {
		for _, v := range v.State {
			writer.WriteBytes(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ChainRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field State is missing")
	} else if len(v.State) == 0 {
		errs = append(errs, "field State is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LastBlock = []string{
	1: "Height",
	2: "Time",
	3: "ChainRoot",
	4: "StateRoot",
	5: "DirectoryAnchorHeight",
}

func (v *LastBlock) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Height == 0) {
		writer.WriteInt(1, v.Height)
	}
	if !(v.Time == (time.Time{})) {
		writer.WriteTime(2, v.Time)
	}
	if !(v.ChainRoot == ([32]byte{})) {
		writer.WriteHash(3, &v.ChainRoot)
	}
	if !(v.StateRoot == ([32]byte{})) {
		writer.WriteHash(4, &v.StateRoot)
	}
	if !(v.DirectoryAnchorHeight == 0) {
		writer.WriteUint(5, v.DirectoryAnchorHeight)
	}

	_, _, err := writer.Reset(fieldNames_LastBlock)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LastBlock) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == (time.Time{}) {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ChainRoot is missing")
	} else if v.ChainRoot == ([32]byte{}) {
		errs = append(errs, "field ChainRoot is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field StateRoot is missing")
	} else if v.StateRoot == ([32]byte{}) {
		errs = append(errs, "field StateRoot is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field DirectoryAnchorHeight is missing")
	} else if v.DirectoryAnchorHeight == 0 {
		errs = append(errs, "field DirectoryAnchorHeight is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeMetrics = []string{
	1: "TPS",
}

func (v *NodeMetrics) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteFloat(1, v.TPS)

	_, _, err := writer.Reset(fieldNames_NodeMetrics)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeMetrics) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TPS is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeStatus = []string{
	1: "Ok",
	2: "LastBlock",
}

func (v *NodeStatus) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.Ok) {
		writer.WriteBool(1, v.Ok)
	}
	if !(v.LastBlock == nil) {
		writer.WriteValue(2, v.LastBlock.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_NodeStatus)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeStatus) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Ok is missing")
	} else if !v.Ok {
		errs = append(errs, "field Ok is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field LastBlock is missing")
	} else if v.LastBlock == nil {
		errs = append(errs, "field LastBlock is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeVersion = []string{
	1: "Version",
	2: "Commit",
	3: "VersionIsKnown",
}

func (v *NodeVersion) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Version) == 0) {
		writer.WriteString(1, v.Version)
	}
	if !(len(v.Commit) == 0) {
		writer.WriteString(2, v.Commit)
	}
	if !(!v.VersionIsKnown) {
		writer.WriteBool(3, v.VersionIsKnown)
	}

	_, _, err := writer.Reset(fieldNames_NodeVersion)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeVersion) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Version is missing")
	} else if len(v.Version) == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Commit is missing")
	} else if len(v.Commit) == 0 {
		errs = append(errs, "field Commit is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field VersionIsKnown is missing")
	} else if !v.VersionIsKnown {
		errs = append(errs, "field VersionIsKnown is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_QueryRecordOptions = []string{
	1: "IncludeReceipt",
	2: "WaitForRecord",
	3: "OnlyDelivered",
}

func (v *QueryRecordOptions) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.IncludeReceipt) {
		writer.WriteBool(1, v.IncludeReceipt)
	}
	if !(v.WaitForRecord == 0) {
		writer.WriteDuration(2, v.WaitForRecord)
	}
	if !(!v.OnlyDelivered) {
		writer.WriteBool(3, v.OnlyDelivered)
	}

	_, _, err := writer.Reset(fieldNames_QueryRecordOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *QueryRecordOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_QueryRecordSetOptions = []string{
	1: "Start",
	2: "Count",
}

func (v *QueryRecordSetOptions) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.Start) {
		writer.WriteBool(1, v.Start)
	}
	if !(!v.Count) {
		writer.WriteBool(2, v.Count)
	}

	_, _, err := writer.Reset(fieldNames_QueryRecordSetOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *QueryRecordSetOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Submission = []string{
	1: "Transaction",
	2: "Signatures",
	3: "Status",
}

func (v *Submission) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Transaction == (url.TxID{})) {
		writer.WriteTxid(1, &v.Transaction)
	}
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteTxid(2, &v)
		}
	}
	if !(v.Status == nil) {
		writer.WriteValue(3, v.Status.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_Submission)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Submission) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == (url.TxID{}) {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubmitOptions = []string{}

func (v *SubmitOptions) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	_, _, err := writer.Reset(fieldNames_SubmitOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubmitOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionRecord = []string{
	1: "RecordType",
	2: "TxID",
	3: "Transaction",
	4: "Status",
	5: "Produced",
	6: "Receipt",
}

func (v *TransactionRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.TxID == nil) {
		writer.WriteTxid(2, v.TxID)
	}
	if !(v.Transaction == nil) {
		writer.WriteValue(3, v.Transaction.MarshalBinary)
	}
	if !(v.Status == nil) {
		writer.WriteValue(4, v.Status.MarshalBinary)
	}
	if !(len(v.Produced) == 0) {
		for _, v := range v.Produced {
			writer.WriteTxid(5, v)
		}
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(6, v.Receipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_TransactionRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TransactionRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == nil {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Produced is missing")
	} else if len(v.Produced) == 0 {
		errs = append(errs, "field Produced is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Receipt is missing")
	} else if v.Receipt == nil {
		errs = append(errs, "field Receipt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *AccountRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AccountRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	reader.ReadValue(2, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.Account = x
		}
		return err
	})
	if x := new(managed.Receipt); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_AccountRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	if x, ok := reader.ReadString(2); ok {
		v.Name = x
	}
	if x := new(managed.ChainType); reader.ReadEnum(3, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Count = x
	}
	for {
		if x, ok := reader.ReadBytes(5); ok {
			v.State = append(v.State, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ChainRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LastBlock) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LastBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadInt(1); ok {
		v.Height = x
	}
	if x, ok := reader.ReadTime(2); ok {
		v.Time = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.ChainRoot = *x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.StateRoot = *x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.DirectoryAnchorHeight = x
	}

	seen, err := reader.Reset(fieldNames_LastBlock)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeMetrics) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeMetrics) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadFloat(1); ok {
		v.TPS = x
	}

	seen, err := reader.Reset(fieldNames_NodeMetrics)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeStatus) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeStatus) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Ok = x
	}
	if x := new(LastBlock); reader.ReadValue(2, x.UnmarshalBinary) {
		v.LastBlock = x
	}

	seen, err := reader.Reset(fieldNames_NodeStatus)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeVersion) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeVersion) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Version = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Commit = x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.VersionIsKnown = x
	}

	seen, err := reader.Reset(fieldNames_NodeVersion)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *QueryRecordOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *QueryRecordOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.IncludeReceipt = x
	}
	if x, ok := reader.ReadDuration(2); ok {
		v.WaitForRecord = x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.OnlyDelivered = x
	}

	seen, err := reader.Reset(fieldNames_QueryRecordOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *QueryRecordSetOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *QueryRecordSetOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.Count = x
	}

	seen, err := reader.Reset(fieldNames_QueryRecordSetOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Submission) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Submission) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadTxid(1); ok {
		v.Transaction = *x
	}
	for {
		if x, ok := reader.ReadTxid(2); ok {
			v.Signatures = append(v.Signatures, *x)
		} else {
			break
		}
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Status = x
	}

	seen, err := reader.Reset(fieldNames_Submission)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubmitOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubmitOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	seen, err := reader.Reset(fieldNames_SubmitOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TransactionRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	if x, ok := reader.ReadTxid(2); ok {
		v.TxID = x
	}
	if x := new(protocol.Transaction); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Transaction = x
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Status = x
	}
	for {
		if x, ok := reader.ReadTxid(5); ok {
			v.Produced = append(v.Produced, x)
		} else {
			break
		}
	}
	if x := new(managed.Receipt); reader.ReadValue(6, x.UnmarshalBinary) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_TransactionRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AccountRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType                                   `json:"recordType"`
		Account    encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		Receipt    *managed.Receipt                             `json:"receipt,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *ChainRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType                 `json:"recordType"`
		Name       string                     `json:"name,omitempty"`
		Type       managed.ChainType          `json:"type,omitempty"`
		Count      uint64                     `json:"count,omitempty"`
		State      encoding.JsonList[*string] `json:"state,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *LastBlock) MarshalJSON() ([]byte, error) {
	u := struct {
		Height                int64     `json:"height,omitempty"`
		Time                  time.Time `json:"time,omitempty"`
		ChainRoot             string    `json:"chainRoot,omitempty"`
		StateRoot             string    `json:"stateRoot,omitempty"`
		DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty"`
	}{}
	u.Height = v.Height
	u.Time = v.Time
	u.ChainRoot = encoding.ChainToJSON(v.ChainRoot)
	u.StateRoot = encoding.ChainToJSON(v.StateRoot)
	u.DirectoryAnchorHeight = v.DirectoryAnchorHeight
	return json.Marshal(&u)
}

func (v *NodeDescription) MarshalJSON() ([]byte, error) {
	u := struct {
		ValidatorKeyHash string                      `json:"validatorKeyHash,omitempty"`
		Network          *protocol.NetworkDefinition `json:"network,omitempty"`
	}{}
	u.ValidatorKeyHash = encoding.ChainToJSON(v.ValidatorKeyHash)
	u.Network = v.Network
	return json.Marshal(&u)
}

func (v *QueryRecordOptions) MarshalJSON() ([]byte, error) {
	u := struct {
		IncludeReceipt bool        `json:"includeReceipt,omitempty"`
		WaitForRecord  interface{} `json:"waitForRecord,omitempty"`
		OnlyDelivered  bool        `json:"onlyDelivered,omitempty"`
	}{}
	u.IncludeReceipt = v.IncludeReceipt
	u.WaitForRecord = encoding.DurationToJSON(v.WaitForRecord)
	u.OnlyDelivered = v.OnlyDelivered
	return json.Marshal(&u)
}

func (v *Submission) MarshalJSON() ([]byte, error) {
	u := struct {
		Transaction url.TxID                    `json:"transaction,omitempty"`
		Signatures  encoding.JsonList[url.TxID] `json:"signatures,omitempty"`
		Status      *protocol.TransactionStatus `json:"status,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.Signatures = v.Signatures
	u.Status = v.Status
	return json.Marshal(&u)
}

func (v *TransactionRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType     RecordType                   `json:"recordType"`
		TxID           *url.TxID                    `json:"txID,omitempty"`
		Transaction    *protocol.Transaction        `json:"transaction,omitempty"`
		Status         *protocol.TransactionStatus  `json:"status,omitempty"`
		Produced       encoding.JsonList[*url.TxID] `json:"produced,omitempty"`
		SyntheticTxids encoding.JsonList[*url.TxID] `json:"syntheticTxids,omitempty"`
		Receipt        *managed.Receipt             `json:"receipt,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.TxID = v.TxID
	u.Transaction = v.Transaction
	u.Status = v.Status
	u.Produced = v.Produced
	u.SyntheticTxids = v.Produced
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *AccountRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType                                   `json:"recordType"`
		Account    encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		Receipt    *managed.Receipt                             `json:"receipt,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Account = u.Account.Value

	v.Receipt = u.Receipt
	return nil
}

func (v *ChainRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType                 `json:"recordType"`
		Name       string                     `json:"name,omitempty"`
		Type       managed.ChainType          `json:"type,omitempty"`
		Count      uint64                     `json:"count,omitempty"`
		State      encoding.JsonList[*string] `json:"state,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Name = u.Name
	v.Type = u.Type
	v.Count = u.Count
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	return nil
}

func (v *LastBlock) UnmarshalJSON(data []byte) error {
	u := struct {
		Height                int64     `json:"height,omitempty"`
		Time                  time.Time `json:"time,omitempty"`
		ChainRoot             string    `json:"chainRoot,omitempty"`
		StateRoot             string    `json:"stateRoot,omitempty"`
		DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty"`
	}{}
	u.Height = v.Height
	u.Time = v.Time
	u.ChainRoot = encoding.ChainToJSON(v.ChainRoot)
	u.StateRoot = encoding.ChainToJSON(v.StateRoot)
	u.DirectoryAnchorHeight = v.DirectoryAnchorHeight
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Height = u.Height
	v.Time = u.Time
	if x, err := encoding.ChainFromJSON(u.ChainRoot); err != nil {
		return fmt.Errorf("error decoding ChainRoot: %w", err)
	} else {
		v.ChainRoot = x
	}
	if x, err := encoding.ChainFromJSON(u.StateRoot); err != nil {
		return fmt.Errorf("error decoding StateRoot: %w", err)
	} else {
		v.StateRoot = x
	}
	v.DirectoryAnchorHeight = u.DirectoryAnchorHeight
	return nil
}

func (v *NodeDescription) UnmarshalJSON(data []byte) error {
	u := struct {
		ValidatorKeyHash string                      `json:"validatorKeyHash,omitempty"`
		Network          *protocol.NetworkDefinition `json:"network,omitempty"`
	}{}
	u.ValidatorKeyHash = encoding.ChainToJSON(v.ValidatorKeyHash)
	u.Network = v.Network
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.ValidatorKeyHash); err != nil {
		return fmt.Errorf("error decoding ValidatorKeyHash: %w", err)
	} else {
		v.ValidatorKeyHash = x
	}
	v.Network = u.Network
	return nil
}

func (v *QueryRecordOptions) UnmarshalJSON(data []byte) error {
	u := struct {
		IncludeReceipt bool        `json:"includeReceipt,omitempty"`
		WaitForRecord  interface{} `json:"waitForRecord,omitempty"`
		OnlyDelivered  bool        `json:"onlyDelivered,omitempty"`
	}{}
	u.IncludeReceipt = v.IncludeReceipt
	u.WaitForRecord = encoding.DurationToJSON(v.WaitForRecord)
	u.OnlyDelivered = v.OnlyDelivered
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.IncludeReceipt = u.IncludeReceipt
	if x, err := encoding.DurationFromJSON(u.WaitForRecord); err != nil {
		return fmt.Errorf("error decoding WaitForRecord: %w", err)
	} else {
		v.WaitForRecord = x
	}
	v.OnlyDelivered = u.OnlyDelivered
	return nil
}

func (v *Submission) UnmarshalJSON(data []byte) error {
	u := struct {
		Transaction url.TxID                    `json:"transaction,omitempty"`
		Signatures  encoding.JsonList[url.TxID] `json:"signatures,omitempty"`
		Status      *protocol.TransactionStatus `json:"status,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.Signatures = v.Signatures
	u.Status = v.Status
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transaction = u.Transaction
	v.Signatures = u.Signatures
	v.Status = u.Status
	return nil
}

func (v *TransactionRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType     RecordType                   `json:"recordType"`
		TxID           *url.TxID                    `json:"txID,omitempty"`
		Transaction    *protocol.Transaction        `json:"transaction,omitempty"`
		Status         *protocol.TransactionStatus  `json:"status,omitempty"`
		Produced       encoding.JsonList[*url.TxID] `json:"produced,omitempty"`
		SyntheticTxids encoding.JsonList[*url.TxID] `json:"syntheticTxids,omitempty"`
		Receipt        *managed.Receipt             `json:"receipt,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.TxID = v.TxID
	u.Transaction = v.Transaction
	u.Status = v.Status
	u.Produced = v.Produced
	u.SyntheticTxids = v.Produced
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.TxID = u.TxID
	v.Transaction = u.Transaction
	v.Status = u.Status
	if !(len(u.Produced) == 0) {
		v.Produced = u.Produced
	} else {
		v.Produced = u.SyntheticTxids
	}
	v.Receipt = u.Receipt
	return nil
}
