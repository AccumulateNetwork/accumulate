// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package api

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"reflect"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/core"
	errors2 "gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/messaging"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type AccountRecord struct {
	fieldsSet     []bool
	Account       protocol.Account          `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Directory     *RecordRange[*UrlRecord]  `json:"directory,omitempty" form:"directory" query:"directory" validate:"required"`
	Pending       *RecordRange[*TxIDRecord] `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	Receipt       *Receipt                  `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	LastBlockTime *time.Time                `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

// AnchorSearchQuery queries {account}#anchor/{hash}.
type AnchorSearchQuery struct {
	fieldsSet      []bool
	Anchor         []byte          `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty" form:"includeReceipt" query:"includeReceipt"`
	extraData      []byte
}

type BlockEvent struct {
	fieldsSet []bool
	Partition string                      `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	Index     uint64                      `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Time      time.Time                   `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	Major     uint64                      `json:"major,omitempty" form:"major" query:"major" validate:"required"`
	Entries   []*ChainEntryRecord[Record] `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type BlockQuery struct {
	fieldsSet  []bool
	Minor      *uint64       `json:"minor,omitempty" form:"minor" query:"minor"`
	Major      *uint64       `json:"major,omitempty" form:"major" query:"major"`
	MinorRange *RangeOptions `json:"minorRange,omitempty" form:"minorRange" query:"minorRange"`
	MajorRange *RangeOptions `json:"majorRange,omitempty" form:"majorRange" query:"majorRange"`
	EntryRange *RangeOptions `json:"entryRange,omitempty" form:"entryRange" query:"entryRange"`
	// OmitEmpty omits empty (unrecorded) blocks from the response.
	OmitEmpty bool `json:"omitEmpty,omitempty" form:"omitEmpty" query:"omitEmpty"`
	extraData []byte
}

type ChainEntryRecord[T Record] struct {
	fieldsSet []bool
	// Account is the account (omitted if unambiguous).
	Account       *url.URL         `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Name          string           `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type          merkle.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Index         uint64           `json:"index" form:"index" query:"index" validate:"required"`
	Entry         [32]byte         `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	Value         T                `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	Receipt       *Receipt         `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	State         [][]byte         `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	LastBlockTime *time.Time       `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type ChainQuery struct {
	fieldsSet      []bool
	Name           string          `json:"name,omitempty" form:"name" query:"name"`
	Index          *uint64         `json:"index,omitempty" form:"index" query:"index"`
	Entry          []byte          `json:"entry,omitempty" form:"entry" query:"entry"`
	Range          *RangeOptions   `json:"range,omitempty" form:"range" query:"range"`
	IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty" form:"includeReceipt" query:"includeReceipt"`
	extraData      []byte
}

type ChainRecord struct {
	fieldsSet     []bool
	Name          string           `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type          merkle.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Count         uint64           `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	State         [][]byte         `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	LastBlockTime *time.Time       `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type ConsensusPeerInfo struct {
	fieldsSet []bool
	NodeID    string `json:"nodeID,omitempty" form:"nodeID" query:"nodeID" validate:"required"`
	Host      string `json:"host,omitempty" form:"host" query:"host" validate:"required"`
	Port      uint64 `json:"port,omitempty" form:"port" query:"port" validate:"required"`
	extraData []byte
}

type ConsensusStatus struct {
	fieldsSet        []bool
	Ok               bool                   `json:"ok,omitempty" form:"ok" query:"ok" validate:"required"`
	LastBlock        *LastBlock             `json:"lastBlock,omitempty" form:"lastBlock" query:"lastBlock" validate:"required"`
	Version          string                 `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Commit           string                 `json:"commit,omitempty" form:"commit" query:"commit" validate:"required"`
	NodeKeyHash      [32]byte               `json:"nodeKeyHash,omitempty" form:"nodeKeyHash" query:"nodeKeyHash" validate:"required"`
	ValidatorKeyHash [32]byte               `json:"validatorKeyHash,omitempty" form:"validatorKeyHash" query:"validatorKeyHash" validate:"required"`
	PartitionID      string                 `json:"partitionID,omitempty" form:"partitionID" query:"partitionID" validate:"required"`
	PartitionType    protocol.PartitionType `json:"partitionType,omitempty" form:"partitionType" query:"partitionType" validate:"required"`
	Peers            []*ConsensusPeerInfo   `json:"peers,omitempty" form:"peers" query:"peers" validate:"required"`
	extraData        []byte
}

type ConsensusStatusOptions struct {
	fieldsSet         []bool
	NodeID            string `json:"nodeID,omitempty" form:"nodeID" query:"nodeID" validate:"required"`
	Partition         string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	IncludePeers      *bool  `json:"includePeers,omitempty" form:"includePeers" query:"includePeers"`
	IncludeAccumulate *bool  `json:"includeAccumulate,omitempty" form:"includeAccumulate" query:"includeAccumulate"`
	extraData         []byte
}

type DataQuery struct {
	fieldsSet []bool
	Index     *uint64       `json:"index,omitempty" form:"index" query:"index"`
	Entry     []byte        `json:"entry,omitempty" form:"entry" query:"entry"`
	Range     *RangeOptions `json:"range,omitempty" form:"range" query:"range"`
	extraData []byte
}

type DefaultQuery struct {
	fieldsSet      []bool
	IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty" form:"includeReceipt" query:"includeReceipt"`
	extraData      []byte
}

type DelegateSearchQuery struct {
	fieldsSet []bool
	Delegate  *url.URL `json:"delegate,omitempty" form:"delegate" query:"delegate" validate:"required"`
	extraData []byte
}

type DirectoryQuery struct {
	fieldsSet []bool
	Range     *RangeOptions `json:"range,omitempty" form:"range" query:"range" validate:"required"`
	extraData []byte
}

type ErrorEvent struct {
	fieldsSet []bool
	Err       *errors2.Error `json:"err,omitempty" form:"err" query:"err" validate:"required"`
	extraData []byte
}

type ErrorRecord struct {
	fieldsSet []bool
	Value     *errors2.Error `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type FaucetOptions struct {
	fieldsSet []bool
	Token     *url.URL `json:"token,omitempty" form:"token" query:"token"`
	extraData []byte
}

type FindServiceOptions struct {
	fieldsSet []bool
	Network   string          `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Service   *ServiceAddress `json:"service,omitempty" form:"service" query:"service" validate:"required"`
	// Known restricts the results to known peers.
	Known bool `json:"known,omitempty" form:"known" query:"known"`
	// Timeout is the time to wait before stopping, when querying the DHT.
	Timeout   time.Duration `json:"timeout,omitempty" form:"timeout" query:"timeout"`
	extraData []byte
}

type FindServiceResult struct {
	fieldsSet []bool
	PeerID    p2p.PeerID      `json:"peerID,omitempty" form:"peerID" query:"peerID" validate:"required"`
	Status    KnownPeerStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	Addresses []p2p.Multiaddr `json:"addresses,omitempty" form:"addresses" query:"addresses" validate:"required"`
	extraData []byte
}

type GlobalsEvent struct {
	fieldsSet []bool
	Old       *core.GlobalValues `json:"old,omitempty" form:"old" query:"old" validate:"required"`
	New       *core.GlobalValues `json:"new,omitempty" form:"new" query:"new" validate:"required"`
	extraData []byte
}

type IndexEntryRecord struct {
	fieldsSet []bool
	Value     *protocol.IndexEntry `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type KeyRecord struct {
	fieldsSet []bool
	Authority *url.URL          `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	Signer    *url.URL          `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	Version   uint64            `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Index     uint64            `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Entry     *protocol.KeySpec `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData []byte
}

type LastBlock struct {
	fieldsSet             []bool
	Height                int64     `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Time                  time.Time `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	ChainRoot             [32]byte  `json:"chainRoot,omitempty" form:"chainRoot" query:"chainRoot" validate:"required"`
	StateRoot             [32]byte  `json:"stateRoot,omitempty" form:"stateRoot" query:"stateRoot" validate:"required"`
	DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty" form:"directoryAnchorHeight" query:"directoryAnchorHeight" validate:"required"`
	extraData             []byte
}

type MajorBlockRecord struct {
	fieldsSet     []bool
	Index         uint64                          `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Time          time.Time                       `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	MinorBlocks   *RecordRange[*MinorBlockRecord] `json:"minorBlocks,omitempty" form:"minorBlocks" query:"minorBlocks" validate:"required"`
	LastBlockTime *time.Time                      `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type MessageHashSearchQuery struct {
	fieldsSet []bool
	Hash      [32]byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	extraData []byte
}

type MessageRecord[T messaging.Message] struct {
	fieldsSet []bool
	ID        *url.TxID                  `json:"id,omitempty" form:"id" query:"id" validate:"required"`
	Message   T                          `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Status    errors2.Status             `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	Error     *errors2.Error             `json:"error,omitempty" form:"error" query:"error" validate:"required"`
	Result    protocol.TransactionResult `json:"result,omitempty" form:"result" query:"result" validate:"required"`
	// Received is the block when the transaction was first received.
	Received      uint64                            `json:"received,omitempty" form:"received" query:"received" validate:"required"`
	Produced      *RecordRange[*TxIDRecord]         `json:"produced,omitempty" form:"produced" query:"produced" validate:"required"`
	Cause         *RecordRange[*TxIDRecord]         `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	Signatures    *RecordRange[*SignatureSetRecord] `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	Historical    bool                              `json:"historical,omitempty" form:"historical" query:"historical" validate:"required"`
	Sequence      *messaging.SequencedMessage       `json:"sequence,omitempty" form:"sequence" query:"sequence"`
	SourceReceipt *merkle.Receipt                   `json:"sourceReceipt,omitempty" form:"sourceReceipt" query:"sourceReceipt" validate:"required"`
	LastBlockTime *time.Time                        `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type Metrics struct {
	fieldsSet []bool
	TPS       float64 `json:"tps" form:"tps" query:"tps" validate:"required"`
	extraData []byte
}

type MetricsOptions struct {
	fieldsSet []bool
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	// Span sets the width of the window in blocks.
	Span      uint64 `json:"span,omitempty" form:"span" query:"span"`
	extraData []byte
}

type MinorBlockRecord struct {
	fieldsSet     []bool
	Index         uint64                                  `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Time          *time.Time                              `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	Source        *url.URL                                `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	Entries       *RecordRange[*ChainEntryRecord[Record]] `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	Anchored      *RecordRange[*MinorBlockRecord]         `json:"anchored,omitempty" form:"anchored" query:"anchored" validate:"required"`
	LastBlockTime *time.Time                              `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type NetworkStatus struct {
	fieldsSet []bool
	Oracle    *protocol.AcmeOracle        `json:"oracle,omitempty" form:"oracle" query:"oracle" validate:"required"`
	Globals   *protocol.NetworkGlobals    `json:"globals,omitempty" form:"globals" query:"globals" validate:"required"`
	Network   *protocol.NetworkDefinition `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Routing   *protocol.RoutingTable      `json:"routing,omitempty" form:"routing" query:"routing" validate:"required"`
	// ExecutorVersion is the active executor version.
	ExecutorVersion protocol.ExecutorVersion `json:"executorVersion,omitempty" form:"executorVersion" query:"executorVersion"`
	// DirectoryHeight is the height of the directory network.
	DirectoryHeight  uint64 `json:"directoryHeight,omitempty" form:"directoryHeight" query:"directoryHeight" validate:"required"`
	MajorBlockHeight uint64 `json:"majorBlockHeight,omitempty" form:"majorBlockHeight" query:"majorBlockHeight" validate:"required"`
	// BvnExecutorVersions is the active executor version of each BVN.
	BvnExecutorVersions []*protocol.PartitionExecutorVersion `json:"bvnExecutorVersions,omitempty" form:"bvnExecutorVersions" query:"bvnExecutorVersions" validate:"required"`
	extraData           []byte
}

type NetworkStatusOptions struct {
	fieldsSet []bool
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	extraData []byte
}

type NodeInfo struct {
	fieldsSet []bool
	PeerID    p2p.PeerID        `json:"peerID,omitempty" form:"peerID" query:"peerID" validate:"required"`
	Network   string            `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Services  []*ServiceAddress `json:"services,omitempty" form:"services" query:"services" validate:"required"`
	Version   string            `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Commit    string            `json:"commit,omitempty" form:"commit" query:"commit" validate:"required"`
	extraData []byte
}

type NodeInfoOptions struct {
	fieldsSet []bool
	PeerID    p2p.PeerID `json:"peerID,omitempty" form:"peerID" query:"peerID" validate:"required"`
	extraData []byte
}

type PendingQuery struct {
	fieldsSet []bool
	Range     *RangeOptions `json:"range,omitempty" form:"range" query:"range" validate:"required"`
	extraData []byte
}

type PublicKeyHashSearchQuery struct {
	fieldsSet     []bool
	PublicKeyHash []byte `json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	extraData     []byte
}

type PublicKeySearchQuery struct {
	fieldsSet []bool
	PublicKey []byte                 `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Type      protocol.SignatureType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	extraData []byte
}

type RangeOptions struct {
	fieldsSet []bool
	// Start is the starting index.
	Start uint64 `json:"start,omitempty" form:"start" query:"start"`
	// Count is the number of requested results.
	Count *uint64 `json:"count,omitempty" form:"count" query:"count"`
	// Expand requests expanded results.
	Expand    *bool `json:"expand,omitempty" form:"expand" query:"expand"`
	FromEnd   bool  `json:"fromEnd,omitempty" form:"fromEnd" query:"fromEnd"`
	extraData []byte
}

type Receipt struct {
	fieldsSet []bool
	merkle.Receipt
	LocalBlock     uint64    `json:"localBlock,omitempty" form:"localBlock" query:"localBlock" validate:"required"`
	LocalBlockTime time.Time `json:"localBlockTime,omitempty" form:"localBlockTime" query:"localBlockTime" validate:"required"`
	MajorBlock     uint64    `json:"majorBlock,omitempty" form:"majorBlock" query:"majorBlock" validate:"required"`
	extraData      []byte
}

type ReceiptOptions struct {
	fieldsSet []bool
	ForAny    bool   `json:"forAny,omitempty" form:"forAny" query:"forAny" validate:"required"`
	ForHeight uint64 `json:"forHeight,omitempty" form:"forHeight" query:"forHeight" validate:"required"`
	extraData []byte
}

type RecordRange[T Record] struct {
	fieldsSet     []bool
	Records       []T        `json:"records,omitempty" form:"records" query:"records" validate:"required"`
	Start         uint64     `json:"start" form:"start" query:"start" validate:"required"`
	Total         uint64     `json:"total" form:"total" query:"total" validate:"required"`
	LastBlockTime *time.Time `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type ServiceAddress struct {
	fieldsSet []bool
	Type      ServiceType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Argument  string      `json:"argument,omitempty" form:"argument" query:"argument"`
	extraData []byte
}

type SignatureSetRecord struct {
	fieldsSet  []bool
	Account    protocol.Account                                `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Signatures *RecordRange[*MessageRecord[messaging.Message]] `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	extraData  []byte
}

type Submission struct {
	fieldsSet []bool
	Status    *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	// Success indicates whether the envelope was successfully submitted.
	Success bool `json:"success,omitempty" form:"success" query:"success" validate:"required"`
	// Message is the message returned by the consensus engine.
	Message   string `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	extraData []byte
}

type SubmitOptions struct {
	fieldsSet []bool
	// Verify verifies that the envelope is well formed before submitting (default yes).
	Verify *bool `json:"verify,omitempty" form:"verify" query:"verify"`
	// Wait waits until the envelope is accepted into a block or rejected (default yes).
	Wait      *bool `json:"wait,omitempty" form:"wait" query:"wait"`
	extraData []byte
}

type SubscribeOptions struct {
	fieldsSet []bool
	Partition string   `json:"partition,omitempty" form:"partition" query:"partition"`
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account"`
	extraData []byte
}

type TxIDRecord struct {
	fieldsSet []bool
	Value     *url.TxID `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type UrlRecord struct {
	fieldsSet []bool
	Value     *url.URL `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type ValidateOptions struct {
	fieldsSet []bool
	// Full fully validates the signatures and transactions (default yes).
	Full      *bool `json:"full,omitempty" form:"full" query:"full"`
	extraData []byte
}

func (*AccountRecord) RecordType() RecordType { return RecordTypeAccount }

func (*AnchorSearchQuery) QueryType() QueryType { return QueryTypeAnchorSearch }

func (*BlockEvent) EventType() EventType { return EventTypeBlock }

func (*BlockQuery) QueryType() QueryType { return QueryTypeBlock }

func (*ChainEntryRecord[T]) RecordType() RecordType { return RecordTypeChainEntry }

func (*ChainQuery) QueryType() QueryType { return QueryTypeChain }

func (*ChainRecord) RecordType() RecordType { return RecordTypeChain }

func (*DataQuery) QueryType() QueryType { return QueryTypeData }

func (*DefaultQuery) QueryType() QueryType { return QueryTypeDefault }

func (*DelegateSearchQuery) QueryType() QueryType { return QueryTypeDelegateSearch }

func (*DirectoryQuery) QueryType() QueryType { return QueryTypeDirectory }

func (*ErrorEvent) EventType() EventType { return EventTypeError }

func (*ErrorRecord) RecordType() RecordType { return RecordTypeError }

func (*GlobalsEvent) EventType() EventType { return EventTypeGlobals }

func (*IndexEntryRecord) RecordType() RecordType { return RecordTypeIndexEntry }

func (*KeyRecord) RecordType() RecordType { return RecordTypeKey }

func (*MajorBlockRecord) RecordType() RecordType { return RecordTypeMajorBlock }

func (*MessageHashSearchQuery) QueryType() QueryType { return QueryTypeMessageHashSearch }

func (*MessageRecord[T]) RecordType() RecordType { return RecordTypeMessage }

func (*MinorBlockRecord) RecordType() RecordType { return RecordTypeMinorBlock }

func (*PendingQuery) QueryType() QueryType { return QueryTypePending }

func (*PublicKeyHashSearchQuery) QueryType() QueryType { return QueryTypePublicKeyHashSearch }

func (*PublicKeySearchQuery) QueryType() QueryType { return QueryTypePublicKeySearch }

func (*RecordRange[T]) RecordType() RecordType { return RecordTypeRange }

func (*SignatureSetRecord) RecordType() RecordType { return RecordTypeSignatureSet }

func (*TxIDRecord) RecordType() RecordType { return RecordTypeTxID }

func (*UrlRecord) RecordType() RecordType { return RecordTypeUrl }

func (v *AccountRecord) Copy() *AccountRecord {
	u := new(AccountRecord)

	if v.Account != nil {
		u.Account = protocol.CopyAccount(v.Account)
	}
	if v.Directory != nil {
		u.Directory = (v.Directory).Copy()
	}
	if v.Pending != nil {
		u.Pending = (v.Pending).Copy()
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *AccountRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *AnchorSearchQuery) Copy() *AnchorSearchQuery {
	u := new(AnchorSearchQuery)

	u.Anchor = encoding.BytesCopy(v.Anchor)
	if v.IncludeReceipt != nil {
		u.IncludeReceipt = (v.IncludeReceipt).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *AnchorSearchQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockEvent) Copy() *BlockEvent {
	u := new(BlockEvent)

	u.Partition = v.Partition
	u.Index = v.Index
	u.Time = v.Time
	u.Major = v.Major
	u.Entries = make([]*ChainEntryRecord[Record], len(v.Entries))
	for i, v := range v.Entries {
		v := v
		if v != nil {
			u.Entries[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockEvent) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockQuery) Copy() *BlockQuery {
	u := new(BlockQuery)

	if v.Minor != nil {
		u.Minor = new(uint64)
		*u.Minor = *v.Minor
	}
	if v.Major != nil {
		u.Major = new(uint64)
		*u.Major = *v.Major
	}
	if v.MinorRange != nil {
		u.MinorRange = (v.MinorRange).Copy()
	}
	if v.MajorRange != nil {
		u.MajorRange = (v.MajorRange).Copy()
	}
	if v.EntryRange != nil {
		u.EntryRange = (v.EntryRange).Copy()
	}
	u.OmitEmpty = v.OmitEmpty
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainEntryRecord[T]) Copy() *ChainEntryRecord[T] {
	u := new(ChainEntryRecord[T])

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.Entry = v.Entry
	if !EqualRecord(v.Value, nil) {
		u.Value = CopyRecord(v.Value).(T)
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}
	u.State = make([][]byte, len(v.State))
	for i, v := range v.State {
		v := v
		u.State[i] = encoding.BytesCopy(v)
	}
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ChainEntryRecord[T]) CopyAsInterface() interface{} { return v.Copy() }

func ChainEntryRecordAs[T2 Record, T1 Record](v *ChainEntryRecord[T1]) (*ChainEntryRecord[T2], error) {
	if v == nil {
		return nil, nil
	}
	vValue, ok := any(v.Value).(T2)
	if !ok && any(v.Value) != nil {
		z := reflect.TypeOf(new(T2)).Elem()
		return nil, errors2.Conflict.WithFormat("want %v, got %T", z, v.Value)
	}

	u := new(ChainEntryRecord[T2])
	u.Account = v.Account
	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.Entry = v.Entry
	u.Value = vValue
	u.Receipt = v.Receipt
	u.State = v.State
	u.LastBlockTime = v.LastBlockTime
	return u, nil
}

func (v *ChainQuery) Copy() *ChainQuery {
	u := new(ChainQuery)

	u.Name = v.Name
	if v.Index != nil {
		u.Index = new(uint64)
		*u.Index = *v.Index
	}
	u.Entry = encoding.BytesCopy(v.Entry)
	if v.Range != nil {
		u.Range = (v.Range).Copy()
	}
	if v.IncludeReceipt != nil {
		u.IncludeReceipt = (v.IncludeReceipt).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ChainQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainRecord) Copy() *ChainRecord {
	u := new(ChainRecord)

	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.State = make([][]byte, len(v.State))
	for i, v := range v.State {
		v := v
		u.State[i] = encoding.BytesCopy(v)
	}
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ChainRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *ConsensusPeerInfo) Copy() *ConsensusPeerInfo {
	u := new(ConsensusPeerInfo)

	u.NodeID = v.NodeID
	u.Host = v.Host
	u.Port = v.Port
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ConsensusPeerInfo) CopyAsInterface() interface{} { return v.Copy() }

func (v *ConsensusStatus) Copy() *ConsensusStatus {
	u := new(ConsensusStatus)

	u.Ok = v.Ok
	if v.LastBlock != nil {
		u.LastBlock = (v.LastBlock).Copy()
	}
	u.Version = v.Version
	u.Commit = v.Commit
	u.NodeKeyHash = v.NodeKeyHash
	u.ValidatorKeyHash = v.ValidatorKeyHash
	u.PartitionID = v.PartitionID
	u.PartitionType = v.PartitionType
	u.Peers = make([]*ConsensusPeerInfo, len(v.Peers))
	for i, v := range v.Peers {
		v := v
		if v != nil {
			u.Peers[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ConsensusStatus) CopyAsInterface() interface{} { return v.Copy() }

func (v *ConsensusStatusOptions) Copy() *ConsensusStatusOptions {
	u := new(ConsensusStatusOptions)

	u.NodeID = v.NodeID
	u.Partition = v.Partition
	if v.IncludePeers != nil {
		u.IncludePeers = new(bool)
		*u.IncludePeers = *v.IncludePeers
	}
	if v.IncludeAccumulate != nil {
		u.IncludeAccumulate = new(bool)
		*u.IncludeAccumulate = *v.IncludeAccumulate
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ConsensusStatusOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *DataQuery) Copy() *DataQuery {
	u := new(DataQuery)

	if v.Index != nil {
		u.Index = new(uint64)
		*u.Index = *v.Index
	}
	u.Entry = encoding.BytesCopy(v.Entry)
	if v.Range != nil {
		u.Range = (v.Range).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *DataQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *DefaultQuery) Copy() *DefaultQuery {
	u := new(DefaultQuery)

	if v.IncludeReceipt != nil {
		u.IncludeReceipt = (v.IncludeReceipt).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *DefaultQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *DelegateSearchQuery) Copy() *DelegateSearchQuery {
	u := new(DelegateSearchQuery)

	if v.Delegate != nil {
		u.Delegate = v.Delegate
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *DelegateSearchQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *DirectoryQuery) Copy() *DirectoryQuery {
	u := new(DirectoryQuery)

	if v.Range != nil {
		u.Range = (v.Range).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *DirectoryQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *ErrorEvent) Copy() *ErrorEvent {
	u := new(ErrorEvent)

	if v.Err != nil {
		u.Err = (v.Err).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ErrorEvent) CopyAsInterface() interface{} { return v.Copy() }

func (v *ErrorRecord) Copy() *ErrorRecord {
	u := new(ErrorRecord)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ErrorRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *FaucetOptions) Copy() *FaucetOptions {
	u := new(FaucetOptions)

	if v.Token != nil {
		u.Token = v.Token
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *FaucetOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *FindServiceOptions) Copy() *FindServiceOptions {
	u := new(FindServiceOptions)

	u.Network = v.Network
	if v.Service != nil {
		u.Service = (v.Service).Copy()
	}
	u.Known = v.Known
	u.Timeout = v.Timeout
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *FindServiceOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *FindServiceResult) Copy() *FindServiceResult {
	u := new(FindServiceResult)

	if v.PeerID != "" {
		u.PeerID = p2p.CopyPeerID(v.PeerID)
	}
	u.Status = v.Status
	u.Addresses = make([]p2p.Multiaddr, len(v.Addresses))
	for i, v := range v.Addresses {
		v := v
		if v != nil {
			u.Addresses[i] = p2p.CopyMultiaddr(v)
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *FindServiceResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *GlobalsEvent) Copy() *GlobalsEvent {
	u := new(GlobalsEvent)

	if v.Old != nil {
		u.Old = (v.Old).Copy()
	}
	if v.New != nil {
		u.New = (v.New).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *GlobalsEvent) CopyAsInterface() interface{} { return v.Copy() }

func (v *IndexEntryRecord) Copy() *IndexEntryRecord {
	u := new(IndexEntryRecord)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *IndexEntryRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeyRecord) Copy() *KeyRecord {
	u := new(KeyRecord)

	if v.Authority != nil {
		u.Authority = v.Authority
	}
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.Version = v.Version
	u.Index = v.Index
	if v.Entry != nil {
		u.Entry = (v.Entry).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *KeyRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *LastBlock) Copy() *LastBlock {
	u := new(LastBlock)

	u.Height = v.Height
	u.Time = v.Time
	u.ChainRoot = v.ChainRoot
	u.StateRoot = v.StateRoot
	u.DirectoryAnchorHeight = v.DirectoryAnchorHeight
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *LastBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *MajorBlockRecord) Copy() *MajorBlockRecord {
	u := new(MajorBlockRecord)

	u.Index = v.Index
	u.Time = v.Time
	if v.MinorBlocks != nil {
		u.MinorBlocks = (v.MinorBlocks).Copy()
	}
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *MajorBlockRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *MessageHashSearchQuery) Copy() *MessageHashSearchQuery {
	u := new(MessageHashSearchQuery)

	u.Hash = v.Hash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *MessageHashSearchQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *MessageRecord[T]) Copy() *MessageRecord[T] {
	u := new(MessageRecord[T])

	if v.ID != nil {
		u.ID = v.ID
	}
	if !messaging.EqualMessage(v.Message, nil) {
		u.Message = messaging.CopyMessage(v.Message).(T)
	}
	u.Status = v.Status
	if v.Error != nil {
		u.Error = (v.Error).Copy()
	}
	if v.Result != nil {
		u.Result = protocol.CopyTransactionResult(v.Result)
	}
	u.Received = v.Received
	if v.Produced != nil {
		u.Produced = (v.Produced).Copy()
	}
	if v.Cause != nil {
		u.Cause = (v.Cause).Copy()
	}
	if v.Signatures != nil {
		u.Signatures = (v.Signatures).Copy()
	}
	u.Historical = v.Historical
	if v.Sequence != nil {
		u.Sequence = (v.Sequence).Copy()
	}
	if v.SourceReceipt != nil {
		u.SourceReceipt = (v.SourceReceipt).Copy()
	}
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *MessageRecord[T]) CopyAsInterface() interface{} { return v.Copy() }

func MessageRecordAs[T2 messaging.Message, T1 messaging.Message](v *MessageRecord[T1]) (*MessageRecord[T2], error) {
	if v == nil {
		return nil, nil
	}
	vMessage, ok := any(v.Message).(T2)
	if !ok && any(v.Message) != nil {
		z := reflect.TypeOf(new(T2)).Elem()
		return nil, errors2.Conflict.WithFormat("want %v, got %T", z, v.Message)
	}

	u := new(MessageRecord[T2])
	u.ID = v.ID
	u.Message = vMessage
	u.Status = v.Status
	u.Error = v.Error
	u.Result = v.Result
	u.Received = v.Received
	u.Produced = v.Produced
	u.Cause = v.Cause
	u.Signatures = v.Signatures
	u.Historical = v.Historical
	u.Sequence = v.Sequence
	u.SourceReceipt = v.SourceReceipt
	u.LastBlockTime = v.LastBlockTime
	return u, nil
}

func (v *Metrics) Copy() *Metrics {
	u := new(Metrics)

	u.TPS = v.TPS
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *Metrics) CopyAsInterface() interface{} { return v.Copy() }

func (v *MetricsOptions) Copy() *MetricsOptions {
	u := new(MetricsOptions)

	u.Partition = v.Partition
	u.Span = v.Span
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *MetricsOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *MinorBlockRecord) Copy() *MinorBlockRecord {
	u := new(MinorBlockRecord)

	u.Index = v.Index
	if v.Time != nil {
		u.Time = new(time.Time)
		*u.Time = *v.Time
	}
	if v.Source != nil {
		u.Source = v.Source
	}
	if v.Entries != nil {
		u.Entries = (v.Entries).Copy()
	}
	if v.Anchored != nil {
		u.Anchored = (v.Anchored).Copy()
	}
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *MinorBlockRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkStatus) Copy() *NetworkStatus {
	u := new(NetworkStatus)

	if v.Oracle != nil {
		u.Oracle = (v.Oracle).Copy()
	}
	if v.Globals != nil {
		u.Globals = (v.Globals).Copy()
	}
	if v.Network != nil {
		u.Network = (v.Network).Copy()
	}
	if v.Routing != nil {
		u.Routing = (v.Routing).Copy()
	}
	u.ExecutorVersion = v.ExecutorVersion
	u.DirectoryHeight = v.DirectoryHeight
	u.MajorBlockHeight = v.MajorBlockHeight
	u.BvnExecutorVersions = make([]*protocol.PartitionExecutorVersion, len(v.BvnExecutorVersions))
	for i, v := range v.BvnExecutorVersions {
		v := v
		if v != nil {
			u.BvnExecutorVersions[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NetworkStatus) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkStatusOptions) Copy() *NetworkStatusOptions {
	u := new(NetworkStatusOptions)

	u.Partition = v.Partition
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NetworkStatusOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeInfo) Copy() *NodeInfo {
	u := new(NodeInfo)

	if v.PeerID != "" {
		u.PeerID = p2p.CopyPeerID(v.PeerID)
	}
	u.Network = v.Network
	u.Services = make([]*ServiceAddress, len(v.Services))
	for i, v := range v.Services {
		v := v
		if v != nil {
			u.Services[i] = (v).Copy()
		}
	}
	u.Version = v.Version
	u.Commit = v.Commit
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NodeInfo) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeInfoOptions) Copy() *NodeInfoOptions {
	u := new(NodeInfoOptions)

	if v.PeerID != "" {
		u.PeerID = p2p.CopyPeerID(v.PeerID)
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NodeInfoOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *PendingQuery) Copy() *PendingQuery {
	u := new(PendingQuery)

	if v.Range != nil {
		u.Range = (v.Range).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *PendingQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *PublicKeyHashSearchQuery) Copy() *PublicKeyHashSearchQuery {
	u := new(PublicKeyHashSearchQuery)

	u.PublicKeyHash = encoding.BytesCopy(v.PublicKeyHash)
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *PublicKeyHashSearchQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *PublicKeySearchQuery) Copy() *PublicKeySearchQuery {
	u := new(PublicKeySearchQuery)

	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Type = v.Type
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *PublicKeySearchQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *RangeOptions) Copy() *RangeOptions {
	u := new(RangeOptions)

	u.Start = v.Start
	if v.Count != nil {
		u.Count = new(uint64)
		*u.Count = *v.Count
	}
	if v.Expand != nil {
		u.Expand = new(bool)
		*u.Expand = *v.Expand
	}
	u.FromEnd = v.FromEnd
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *RangeOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *Receipt) Copy() *Receipt {
	u := new(Receipt)

	u.Receipt = *v.Receipt.Copy()
	u.LocalBlock = v.LocalBlock
	u.LocalBlockTime = v.LocalBlockTime
	u.MajorBlock = v.MajorBlock
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *Receipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *ReceiptOptions) Copy() *ReceiptOptions {
	u := new(ReceiptOptions)

	u.ForAny = v.ForAny
	u.ForHeight = v.ForHeight
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ReceiptOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *RecordRange[T]) Copy() *RecordRange[T] {
	u := new(RecordRange[T])

	u.Records = make([]T, len(v.Records))
	for i, v := range v.Records {
		v := v
		if !EqualRecord(v, nil) {
			u.Records[i] = CopyRecord(v).(T)
		}
	}
	u.Start = v.Start
	u.Total = v.Total
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *RecordRange[T]) CopyAsInterface() interface{} { return v.Copy() }

func RecordRangeAs[T2 Record, T1 Record](v *RecordRange[T1]) (*RecordRange[T2], error) {
	if v == nil {
		return nil, nil
	}
	vRecords := make([]T2, len(v.Records))
	for i, v := range v.Records {
		if u, ok := any(v).(T2); ok || any(u) == nil {
			vRecords[i] = u
		} else {
			z := reflect.TypeOf(new(T2)).Elem()
			return nil, errors2.Conflict.WithFormat("want %v, got %T", z, v)
		}
	}

	u := new(RecordRange[T2])
	u.Records = vRecords
	u.Start = v.Start
	u.Total = v.Total
	u.LastBlockTime = v.LastBlockTime
	return u, nil
}

func (v *SignatureSetRecord) Copy() *SignatureSetRecord {
	u := new(SignatureSetRecord)

	if v.Account != nil {
		u.Account = protocol.CopyAccount(v.Account)
	}
	if v.Signatures != nil {
		u.Signatures = (v.Signatures).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SignatureSetRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *Submission) Copy() *Submission {
	u := new(Submission)

	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}
	u.Success = v.Success
	u.Message = v.Message
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *Submission) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubmitOptions) Copy() *SubmitOptions {
	u := new(SubmitOptions)

	if v.Verify != nil {
		u.Verify = new(bool)
		*u.Verify = *v.Verify
	}
	if v.Wait != nil {
		u.Wait = new(bool)
		*u.Wait = *v.Wait
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SubmitOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubscribeOptions) Copy() *SubscribeOptions {
	u := new(SubscribeOptions)

	u.Partition = v.Partition
	if v.Account != nil {
		u.Account = v.Account
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SubscribeOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *TxIDRecord) Copy() *TxIDRecord {
	u := new(TxIDRecord)

	if v.Value != nil {
		u.Value = v.Value
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *TxIDRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *UrlRecord) Copy() *UrlRecord {
	u := new(UrlRecord)

	if v.Value != nil {
		u.Value = v.Value
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *UrlRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *ValidateOptions) Copy() *ValidateOptions {
	u := new(ValidateOptions)

	if v.Full != nil {
		u.Full = new(bool)
		*u.Full = *v.Full
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ValidateOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *AccountRecord) Equal(u *AccountRecord) bool {
	if !(protocol.EqualAccount(v.Account, u.Account)) {
		return false
	}
	switch {
	case v.Directory == u.Directory:
		// equal
	case v.Directory == nil || u.Directory == nil:
		return false
	case !((v.Directory).Equal(u.Directory)):
		return false
	}
	switch {
	case v.Pending == u.Pending:
		// equal
	case v.Pending == nil || u.Pending == nil:
		return false
	case !((v.Pending).Equal(u.Pending)):
		return false
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *AnchorSearchQuery) Equal(u *AnchorSearchQuery) bool {
	if !(bytes.Equal(v.Anchor, u.Anchor)) {
		return false
	}
	switch {
	case v.IncludeReceipt == u.IncludeReceipt:
		// equal
	case v.IncludeReceipt == nil || u.IncludeReceipt == nil:
		return false
	case !((v.IncludeReceipt).Equal(u.IncludeReceipt)):
		return false
	}

	return true
}

func (v *BlockEvent) Equal(u *BlockEvent) bool {
	if !(v.Partition == u.Partition) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !((v.Time).Equal(u.Time)) {
		return false
	}
	if !(v.Major == u.Major) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((v.Entries[i]).Equal(u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *BlockQuery) Equal(u *BlockQuery) bool {
	switch {
	case v.Minor == u.Minor:
		// equal
	case v.Minor == nil || u.Minor == nil:
		return false
	case !(*v.Minor == *u.Minor):
		return false
	}
	switch {
	case v.Major == u.Major:
		// equal
	case v.Major == nil || u.Major == nil:
		return false
	case !(*v.Major == *u.Major):
		return false
	}
	switch {
	case v.MinorRange == u.MinorRange:
		// equal
	case v.MinorRange == nil || u.MinorRange == nil:
		return false
	case !((v.MinorRange).Equal(u.MinorRange)):
		return false
	}
	switch {
	case v.MajorRange == u.MajorRange:
		// equal
	case v.MajorRange == nil || u.MajorRange == nil:
		return false
	case !((v.MajorRange).Equal(u.MajorRange)):
		return false
	}
	switch {
	case v.EntryRange == u.EntryRange:
		// equal
	case v.EntryRange == nil || u.EntryRange == nil:
		return false
	case !((v.EntryRange).Equal(u.EntryRange)):
		return false
	}
	if !(v.OmitEmpty == u.OmitEmpty) {
		return false
	}

	return true
}

func (v *ChainEntryRecord[T]) Equal(u *ChainEntryRecord[T]) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !(v.Entry == u.Entry) {
		return false
	}
	if !(EqualRecord(v.Value, u.Value)) {
		return false
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *ChainQuery) Equal(u *ChainQuery) bool {
	if !(v.Name == u.Name) {
		return false
	}
	switch {
	case v.Index == u.Index:
		// equal
	case v.Index == nil || u.Index == nil:
		return false
	case !(*v.Index == *u.Index):
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}
	switch {
	case v.Range == u.Range:
		// equal
	case v.Range == nil || u.Range == nil:
		return false
	case !((v.Range).Equal(u.Range)):
		return false
	}
	switch {
	case v.IncludeReceipt == u.IncludeReceipt:
		// equal
	case v.IncludeReceipt == nil || u.IncludeReceipt == nil:
		return false
	case !((v.IncludeReceipt).Equal(u.IncludeReceipt)):
		return false
	}

	return true
}

func (v *ChainRecord) Equal(u *ChainRecord) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *ConsensusPeerInfo) Equal(u *ConsensusPeerInfo) bool {
	if !(v.NodeID == u.NodeID) {
		return false
	}
	if !(v.Host == u.Host) {
		return false
	}
	if !(v.Port == u.Port) {
		return false
	}

	return true
}

func (v *ConsensusStatus) Equal(u *ConsensusStatus) bool {
	if !(v.Ok == u.Ok) {
		return false
	}
	switch {
	case v.LastBlock == u.LastBlock:
		// equal
	case v.LastBlock == nil || u.LastBlock == nil:
		return false
	case !((v.LastBlock).Equal(u.LastBlock)):
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.Commit == u.Commit) {
		return false
	}
	if !(v.NodeKeyHash == u.NodeKeyHash) {
		return false
	}
	if !(v.ValidatorKeyHash == u.ValidatorKeyHash) {
		return false
	}
	if !(v.PartitionID == u.PartitionID) {
		return false
	}
	if !(v.PartitionType == u.PartitionType) {
		return false
	}
	if len(v.Peers) != len(u.Peers) {
		return false
	}
	for i := range v.Peers {
		if !((v.Peers[i]).Equal(u.Peers[i])) {
			return false
		}
	}

	return true
}

func (v *ConsensusStatusOptions) Equal(u *ConsensusStatusOptions) bool {
	if !(v.NodeID == u.NodeID) {
		return false
	}
	if !(v.Partition == u.Partition) {
		return false
	}
	switch {
	case v.IncludePeers == u.IncludePeers:
		// equal
	case v.IncludePeers == nil || u.IncludePeers == nil:
		return false
	case !(*v.IncludePeers == *u.IncludePeers):
		return false
	}
	switch {
	case v.IncludeAccumulate == u.IncludeAccumulate:
		// equal
	case v.IncludeAccumulate == nil || u.IncludeAccumulate == nil:
		return false
	case !(*v.IncludeAccumulate == *u.IncludeAccumulate):
		return false
	}

	return true
}

func (v *DataQuery) Equal(u *DataQuery) bool {
	switch {
	case v.Index == u.Index:
		// equal
	case v.Index == nil || u.Index == nil:
		return false
	case !(*v.Index == *u.Index):
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}
	switch {
	case v.Range == u.Range:
		// equal
	case v.Range == nil || u.Range == nil:
		return false
	case !((v.Range).Equal(u.Range)):
		return false
	}

	return true
}

func (v *DefaultQuery) Equal(u *DefaultQuery) bool {
	switch {
	case v.IncludeReceipt == u.IncludeReceipt:
		// equal
	case v.IncludeReceipt == nil || u.IncludeReceipt == nil:
		return false
	case !((v.IncludeReceipt).Equal(u.IncludeReceipt)):
		return false
	}

	return true
}

func (v *DelegateSearchQuery) Equal(u *DelegateSearchQuery) bool {
	switch {
	case v.Delegate == u.Delegate:
		// equal
	case v.Delegate == nil || u.Delegate == nil:
		return false
	case !((v.Delegate).Equal(u.Delegate)):
		return false
	}

	return true
}

func (v *DirectoryQuery) Equal(u *DirectoryQuery) bool {
	switch {
	case v.Range == u.Range:
		// equal
	case v.Range == nil || u.Range == nil:
		return false
	case !((v.Range).Equal(u.Range)):
		return false
	}

	return true
}

func (v *ErrorEvent) Equal(u *ErrorEvent) bool {
	switch {
	case v.Err == u.Err:
		// equal
	case v.Err == nil || u.Err == nil:
		return false
	case !((v.Err).Equal(u.Err)):
		return false
	}

	return true
}

func (v *ErrorRecord) Equal(u *ErrorRecord) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *FaucetOptions) Equal(u *FaucetOptions) bool {
	switch {
	case v.Token == u.Token:
		// equal
	case v.Token == nil || u.Token == nil:
		return false
	case !((v.Token).Equal(u.Token)):
		return false
	}

	return true
}

func (v *FindServiceOptions) Equal(u *FindServiceOptions) bool {
	if !(v.Network == u.Network) {
		return false
	}
	switch {
	case v.Service == u.Service:
		// equal
	case v.Service == nil || u.Service == nil:
		return false
	case !((v.Service).Equal(u.Service)):
		return false
	}
	if !(v.Known == u.Known) {
		return false
	}
	if !(v.Timeout == u.Timeout) {
		return false
	}

	return true
}

func (v *FindServiceResult) Equal(u *FindServiceResult) bool {
	if !(p2p.EqualPeerID(v.PeerID, u.PeerID)) {
		return false
	}
	if !(v.Status == u.Status) {
		return false
	}
	if len(v.Addresses) != len(u.Addresses) {
		return false
	}
	for i := range v.Addresses {
		if !(p2p.EqualMultiaddr(v.Addresses[i], u.Addresses[i])) {
			return false
		}
	}

	return true
}

func (v *GlobalsEvent) Equal(u *GlobalsEvent) bool {
	switch {
	case v.Old == u.Old:
		// equal
	case v.Old == nil || u.Old == nil:
		return false
	case !((v.Old).Equal(u.Old)):
		return false
	}
	switch {
	case v.New == u.New:
		// equal
	case v.New == nil || u.New == nil:
		return false
	case !((v.New).Equal(u.New)):
		return false
	}

	return true
}

func (v *IndexEntryRecord) Equal(u *IndexEntryRecord) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *KeyRecord) Equal(u *KeyRecord) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	switch {
	case v.Entry == u.Entry:
		// equal
	case v.Entry == nil || u.Entry == nil:
		return false
	case !((v.Entry).Equal(u.Entry)):
		return false
	}

	return true
}

func (v *LastBlock) Equal(u *LastBlock) bool {
	if !(v.Height == u.Height) {
		return false
	}
	if !((v.Time).Equal(u.Time)) {
		return false
	}
	if !(v.ChainRoot == u.ChainRoot) {
		return false
	}
	if !(v.StateRoot == u.StateRoot) {
		return false
	}
	if !(v.DirectoryAnchorHeight == u.DirectoryAnchorHeight) {
		return false
	}

	return true
}

func (v *MajorBlockRecord) Equal(u *MajorBlockRecord) bool {
	if !(v.Index == u.Index) {
		return false
	}
	if !((v.Time).Equal(u.Time)) {
		return false
	}
	switch {
	case v.MinorBlocks == u.MinorBlocks:
		// equal
	case v.MinorBlocks == nil || u.MinorBlocks == nil:
		return false
	case !((v.MinorBlocks).Equal(u.MinorBlocks)):
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *MessageHashSearchQuery) Equal(u *MessageHashSearchQuery) bool {
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *MessageRecord[T]) Equal(u *MessageRecord[T]) bool {
	switch {
	case v.ID == u.ID:
		// equal
	case v.ID == nil || u.ID == nil:
		return false
	case !((v.ID).Equal(u.ID)):
		return false
	}
	if !(messaging.EqualMessage(v.Message, u.Message)) {
		return false
	}
	if !(v.Status == u.Status) {
		return false
	}
	switch {
	case v.Error == u.Error:
		// equal
	case v.Error == nil || u.Error == nil:
		return false
	case !((v.Error).Equal(u.Error)):
		return false
	}
	if !(protocol.EqualTransactionResult(v.Result, u.Result)) {
		return false
	}
	if !(v.Received == u.Received) {
		return false
	}
	switch {
	case v.Produced == u.Produced:
		// equal
	case v.Produced == nil || u.Produced == nil:
		return false
	case !((v.Produced).Equal(u.Produced)):
		return false
	}
	switch {
	case v.Cause == u.Cause:
		// equal
	case v.Cause == nil || u.Cause == nil:
		return false
	case !((v.Cause).Equal(u.Cause)):
		return false
	}
	switch {
	case v.Signatures == u.Signatures:
		// equal
	case v.Signatures == nil || u.Signatures == nil:
		return false
	case !((v.Signatures).Equal(u.Signatures)):
		return false
	}
	if !(v.Historical == u.Historical) {
		return false
	}
	switch {
	case v.Sequence == u.Sequence:
		// equal
	case v.Sequence == nil || u.Sequence == nil:
		return false
	case !((v.Sequence).Equal(u.Sequence)):
		return false
	}
	switch {
	case v.SourceReceipt == u.SourceReceipt:
		// equal
	case v.SourceReceipt == nil || u.SourceReceipt == nil:
		return false
	case !((v.SourceReceipt).Equal(u.SourceReceipt)):
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *Metrics) Equal(u *Metrics) bool {
	if !(v.TPS == u.TPS) {
		return false
	}

	return true
}

func (v *MetricsOptions) Equal(u *MetricsOptions) bool {
	if !(v.Partition == u.Partition) {
		return false
	}
	if !(v.Span == u.Span) {
		return false
	}

	return true
}

func (v *MinorBlockRecord) Equal(u *MinorBlockRecord) bool {
	if !(v.Index == u.Index) {
		return false
	}
	switch {
	case v.Time == u.Time:
		// equal
	case v.Time == nil || u.Time == nil:
		return false
	case !((*v.Time).Equal(*u.Time)):
		return false
	}
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	switch {
	case v.Entries == u.Entries:
		// equal
	case v.Entries == nil || u.Entries == nil:
		return false
	case !((v.Entries).Equal(u.Entries)):
		return false
	}
	switch {
	case v.Anchored == u.Anchored:
		// equal
	case v.Anchored == nil || u.Anchored == nil:
		return false
	case !((v.Anchored).Equal(u.Anchored)):
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *NetworkStatus) Equal(u *NetworkStatus) bool {
	switch {
	case v.Oracle == u.Oracle:
		// equal
	case v.Oracle == nil || u.Oracle == nil:
		return false
	case !((v.Oracle).Equal(u.Oracle)):
		return false
	}
	switch {
	case v.Globals == u.Globals:
		// equal
	case v.Globals == nil || u.Globals == nil:
		return false
	case !((v.Globals).Equal(u.Globals)):
		return false
	}
	switch {
	case v.Network == u.Network:
		// equal
	case v.Network == nil || u.Network == nil:
		return false
	case !((v.Network).Equal(u.Network)):
		return false
	}
	switch {
	case v.Routing == u.Routing:
		// equal
	case v.Routing == nil || u.Routing == nil:
		return false
	case !((v.Routing).Equal(u.Routing)):
		return false
	}
	if !(v.ExecutorVersion == u.ExecutorVersion) {
		return false
	}
	if !(v.DirectoryHeight == u.DirectoryHeight) {
		return false
	}
	if !(v.MajorBlockHeight == u.MajorBlockHeight) {
		return false
	}
	if len(v.BvnExecutorVersions) != len(u.BvnExecutorVersions) {
		return false
	}
	for i := range v.BvnExecutorVersions {
		if !((v.BvnExecutorVersions[i]).Equal(u.BvnExecutorVersions[i])) {
			return false
		}
	}

	return true
}

func (v *NetworkStatusOptions) Equal(u *NetworkStatusOptions) bool {
	if !(v.Partition == u.Partition) {
		return false
	}

	return true
}

func (v *NodeInfo) Equal(u *NodeInfo) bool {
	if !(p2p.EqualPeerID(v.PeerID, u.PeerID)) {
		return false
	}
	if !(v.Network == u.Network) {
		return false
	}
	if len(v.Services) != len(u.Services) {
		return false
	}
	for i := range v.Services {
		if !((v.Services[i]).Equal(u.Services[i])) {
			return false
		}
	}
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.Commit == u.Commit) {
		return false
	}

	return true
}

func (v *NodeInfoOptions) Equal(u *NodeInfoOptions) bool {
	if !(p2p.EqualPeerID(v.PeerID, u.PeerID)) {
		return false
	}

	return true
}

func (v *PendingQuery) Equal(u *PendingQuery) bool {
	switch {
	case v.Range == u.Range:
		// equal
	case v.Range == nil || u.Range == nil:
		return false
	case !((v.Range).Equal(u.Range)):
		return false
	}

	return true
}

func (v *PublicKeyHashSearchQuery) Equal(u *PublicKeyHashSearchQuery) bool {
	if !(bytes.Equal(v.PublicKeyHash, u.PublicKeyHash)) {
		return false
	}

	return true
}

func (v *PublicKeySearchQuery) Equal(u *PublicKeySearchQuery) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *RangeOptions) Equal(u *RangeOptions) bool {
	if !(v.Start == u.Start) {
		return false
	}
	switch {
	case v.Count == u.Count:
		// equal
	case v.Count == nil || u.Count == nil:
		return false
	case !(*v.Count == *u.Count):
		return false
	}
	switch {
	case v.Expand == u.Expand:
		// equal
	case v.Expand == nil || u.Expand == nil:
		return false
	case !(*v.Expand == *u.Expand):
		return false
	}
	if !(v.FromEnd == u.FromEnd) {
		return false
	}

	return true
}

func (v *Receipt) Equal(u *Receipt) bool {
	if !v.Receipt.Equal(&u.Receipt) {
		return false
	}
	if !(v.LocalBlock == u.LocalBlock) {
		return false
	}
	if !((v.LocalBlockTime).Equal(u.LocalBlockTime)) {
		return false
	}
	if !(v.MajorBlock == u.MajorBlock) {
		return false
	}

	return true
}

func (v *ReceiptOptions) Equal(u *ReceiptOptions) bool {
	if !(v.ForAny == u.ForAny) {
		return false
	}
	if !(v.ForHeight == u.ForHeight) {
		return false
	}

	return true
}

func (v *RecordRange[T]) Equal(u *RecordRange[T]) bool {
	if len(v.Records) != len(u.Records) {
		return false
	}
	for i := range v.Records {
		if !(EqualRecord(v.Records[i], u.Records[i])) {
			return false
		}
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *SignatureSetRecord) Equal(u *SignatureSetRecord) bool {
	if !(protocol.EqualAccount(v.Account, u.Account)) {
		return false
	}
	switch {
	case v.Signatures == u.Signatures:
		// equal
	case v.Signatures == nil || u.Signatures == nil:
		return false
	case !((v.Signatures).Equal(u.Signatures)):
		return false
	}

	return true
}

func (v *Submission) Equal(u *Submission) bool {
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}
	if !(v.Success == u.Success) {
		return false
	}
	if !(v.Message == u.Message) {
		return false
	}

	return true
}

func (v *SubmitOptions) Equal(u *SubmitOptions) bool {
	switch {
	case v.Verify == u.Verify:
		// equal
	case v.Verify == nil || u.Verify == nil:
		return false
	case !(*v.Verify == *u.Verify):
		return false
	}
	switch {
	case v.Wait == u.Wait:
		// equal
	case v.Wait == nil || u.Wait == nil:
		return false
	case !(*v.Wait == *u.Wait):
		return false
	}

	return true
}

func (v *SubscribeOptions) Equal(u *SubscribeOptions) bool {
	if !(v.Partition == u.Partition) {
		return false
	}
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}

	return true
}

func (v *TxIDRecord) Equal(u *TxIDRecord) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *UrlRecord) Equal(u *UrlRecord) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *ValidateOptions) Equal(u *ValidateOptions) bool {
	switch {
	case v.Full == u.Full:
		// equal
	case v.Full == nil || u.Full == nil:
		return false
	case !(*v.Full == *u.Full):
		return false
	}

	return true
}

var fieldNames_AccountRecord = []string{
	1: "RecordType",
	2: "Account",
	3: "Directory",
	4: "Pending",
	5: "Receipt",
	6: "LastBlockTime",
}

func (v *AccountRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(protocol.EqualAccount(v.Account, nil)) {
		writer.WriteValue(2, v.Account.MarshalBinary)
	}
	if !(v.Directory == nil) {
		writer.WriteValue(3, v.Directory.MarshalBinary)
	}
	if !(v.Pending == nil) {
		writer.WriteValue(4, v.Pending.MarshalBinary)
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(5, v.Receipt.MarshalBinary)
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(6, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_AccountRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AccountRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if protocol.EqualAccount(v.Account, nil) {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Directory is missing")
	} else if v.Directory == nil {
		errs = append(errs, "field Directory is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Pending is missing")
	} else if v.Pending == nil {
		errs = append(errs, "field Pending is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Receipt is missing")
	} else if v.Receipt == nil {
		errs = append(errs, "field Receipt is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AnchorSearchQuery = []string{
	1: "QueryType",
	2: "Anchor",
	3: "IncludeReceipt",
}

func (v *AnchorSearchQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(len(v.Anchor) == 0) {
		writer.WriteBytes(2, v.Anchor)
	}
	if !(v.IncludeReceipt == nil) {
		writer.WriteValue(3, v.IncludeReceipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_AnchorSearchQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AnchorSearchQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Anchor is missing")
	} else if len(v.Anchor) == 0 {
		errs = append(errs, "field Anchor is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockEvent = []string{
	1: "EventType",
	2: "Partition",
	3: "Index",
	4: "Time",
	5: "Major",
	6: "Entries",
}

func (v *BlockEvent) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.EventType())
	if !(len(v.Partition) == 0) {
		writer.WriteString(2, v.Partition)
	}
	if !(v.Index == 0) {
		writer.WriteUint(3, v.Index)
	}
	if !(v.Time == (time.Time{})) {
		writer.WriteTime(4, v.Time)
	}
	if !(v.Major == 0) {
		writer.WriteUint(5, v.Major)
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(6, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_BlockEvent)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockEvent) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field EventType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Partition is missing")
	} else if len(v.Partition) == 0 {
		errs = append(errs, "field Partition is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == (time.Time{}) {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Major is missing")
	} else if v.Major == 0 {
		errs = append(errs, "field Major is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockQuery = []string{
	1: "QueryType",
	2: "Minor",
	3: "Major",
	4: "MinorRange",
	5: "MajorRange",
	6: "EntryRange",
	7: "OmitEmpty",
}

func (v *BlockQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(v.Minor == nil) {
		writer.WriteUint(2, *v.Minor)
	}
	if !(v.Major == nil) {
		writer.WriteUint(3, *v.Major)
	}
	if !(v.MinorRange == nil) {
		writer.WriteValue(4, v.MinorRange.MarshalBinary)
	}
	if !(v.MajorRange == nil) {
		writer.WriteValue(5, v.MajorRange.MarshalBinary)
	}
	if !(v.EntryRange == nil) {
		writer.WriteValue(6, v.EntryRange.MarshalBinary)
	}
	if !(!v.OmitEmpty) {
		writer.WriteBool(7, v.OmitEmpty)
	}

	_, _, err := writer.Reset(fieldNames_BlockQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockQuery) baseIsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainEntryRecord = []string{
	1:  "RecordType",
	2:  "Account",
	3:  "Name",
	4:  "Type",
	5:  "Index",
	6:  "Entry",
	7:  "Value",
	8:  "Receipt",
	9:  "State",
	10: "LastBlockTime",
}

func (v *ChainEntryRecord[T]) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(len(v.Name) == 0) {
		writer.WriteString(3, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(4, v.Type)
	}
	writer.WriteUint(5, v.Index)
	if !(v.Entry == ([32]byte{})) {
		writer.WriteHash(6, &v.Entry)
	}
	if !(EqualRecord(v.Value, nil)) {
		writer.WriteValue(7, v.Value.MarshalBinary)
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(8, v.Receipt.MarshalBinary)
	}
	if !(len(v.State) == 0) {
		for _, v := range v.State {
			writer.WriteBytes(9, v)
		}
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(10, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_ChainEntryRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainEntryRecord[T]) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Index is missing")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entry is missing")
	} else if v.Entry == ([32]byte{}) {
		errs = append(errs, "field Entry is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Value is missing")
	} else if EqualRecord(v.Value, nil) {
		errs = append(errs, "field Value is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Receipt is missing")
	} else if v.Receipt == nil {
		errs = append(errs, "field Receipt is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field State is missing")
	} else if len(v.State) == 0 {
		errs = append(errs, "field State is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainQuery = []string{
	1: "QueryType",
	2: "Name",
	3: "Index",
	4: "Entry",
	5: "Range",
	6: "IncludeReceipt",
}

func (v *ChainQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(len(v.Name) == 0) {
		writer.WriteString(2, v.Name)
	}
	if !(v.Index == nil) {
		writer.WriteUint(3, *v.Index)
	}
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(4, v.Entry)
	}
	if !(v.Range == nil) {
		writer.WriteValue(5, v.Range.MarshalBinary)
	}
	if !(v.IncludeReceipt == nil) {
		writer.WriteValue(6, v.IncludeReceipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ChainQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainQuery) baseIsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainRecord = []string{
	1: "RecordType",
	2: "Name",
	3: "Type",
	4: "Count",
	5: "State",
	6: "LastBlockTime",
}

func (v *ChainRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(len(v.Name) == 0) {
		writer.WriteString(2, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(3, v.Type)
	}
	if !(v.Count == 0) {
		writer.WriteUint(4, v.Count)
	}
	if !(len(v.State) == 0) {
		for _, v := range v.State {
			writer.WriteBytes(5, v)
		}
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(6, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_ChainRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field State is missing")
	} else if len(v.State) == 0 {
		errs = append(errs, "field State is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ConsensusPeerInfo = []string{
	1: "NodeID",
	2: "Host",
	3: "Port",
}

func (v *ConsensusPeerInfo) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.NodeID) == 0) {
		writer.WriteString(1, v.NodeID)
	}
	if !(len(v.Host) == 0) {
		writer.WriteString(2, v.Host)
	}
	if !(v.Port == 0) {
		writer.WriteUint(3, v.Port)
	}

	_, _, err := writer.Reset(fieldNames_ConsensusPeerInfo)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ConsensusPeerInfo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field NodeID is missing")
	} else if len(v.NodeID) == 0 {
		errs = append(errs, "field NodeID is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Host is missing")
	} else if len(v.Host) == 0 {
		errs = append(errs, "field Host is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Port is missing")
	} else if v.Port == 0 {
		errs = append(errs, "field Port is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ConsensusStatus = []string{
	1: "Ok",
	2: "LastBlock",
	3: "Version",
	4: "Commit",
	5: "NodeKeyHash",
	6: "ValidatorKeyHash",
	7: "PartitionID",
	8: "PartitionType",
	9: "Peers",
}

func (v *ConsensusStatus) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.Ok) {
		writer.WriteBool(1, v.Ok)
	}
	if !(v.LastBlock == nil) {
		writer.WriteValue(2, v.LastBlock.MarshalBinary)
	}
	if !(len(v.Version) == 0) {
		writer.WriteString(3, v.Version)
	}
	if !(len(v.Commit) == 0) {
		writer.WriteString(4, v.Commit)
	}
	if !(v.NodeKeyHash == ([32]byte{})) {
		writer.WriteHash(5, &v.NodeKeyHash)
	}
	if !(v.ValidatorKeyHash == ([32]byte{})) {
		writer.WriteHash(6, &v.ValidatorKeyHash)
	}
	if !(len(v.PartitionID) == 0) {
		writer.WriteString(7, v.PartitionID)
	}
	if !(v.PartitionType == 0) {
		writer.WriteEnum(8, v.PartitionType)
	}
	if !(len(v.Peers) == 0) {
		for _, v := range v.Peers {
			writer.WriteValue(9, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_ConsensusStatus)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ConsensusStatus) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Ok is missing")
	} else if !v.Ok {
		errs = append(errs, "field Ok is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field LastBlock is missing")
	} else if v.LastBlock == nil {
		errs = append(errs, "field LastBlock is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Version is missing")
	} else if len(v.Version) == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Commit is missing")
	} else if len(v.Commit) == 0 {
		errs = append(errs, "field Commit is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field NodeKeyHash is missing")
	} else if v.NodeKeyHash == ([32]byte{}) {
		errs = append(errs, "field NodeKeyHash is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field ValidatorKeyHash is missing")
	} else if v.ValidatorKeyHash == ([32]byte{}) {
		errs = append(errs, "field ValidatorKeyHash is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field PartitionID is missing")
	} else if len(v.PartitionID) == 0 {
		errs = append(errs, "field PartitionID is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field PartitionType is missing")
	} else if v.PartitionType == 0 {
		errs = append(errs, "field PartitionType is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field Peers is missing")
	} else if len(v.Peers) == 0 {
		errs = append(errs, "field Peers is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ConsensusStatusOptions = []string{
	1: "NodeID",
	2: "Partition",
	3: "IncludePeers",
	4: "IncludeAccumulate",
}

func (v *ConsensusStatusOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.NodeID) == 0) {
		writer.WriteString(1, v.NodeID)
	}
	if !(len(v.Partition) == 0) {
		writer.WriteString(2, v.Partition)
	}
	if !(v.IncludePeers == nil) {
		writer.WriteBool(3, *v.IncludePeers)
	}
	if !(v.IncludeAccumulate == nil) {
		writer.WriteBool(4, *v.IncludeAccumulate)
	}

	_, _, err := writer.Reset(fieldNames_ConsensusStatusOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ConsensusStatusOptions) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field NodeID is missing")
	} else if len(v.NodeID) == 0 {
		errs = append(errs, "field NodeID is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Partition is missing")
	} else if len(v.Partition) == 0 {
		errs = append(errs, "field Partition is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DataQuery = []string{
	1: "QueryType",
	2: "Index",
	3: "Entry",
	4: "Range",
}

func (v *DataQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(v.Index == nil) {
		writer.WriteUint(2, *v.Index)
	}
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(3, v.Entry)
	}
	if !(v.Range == nil) {
		writer.WriteValue(4, v.Range.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_DataQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DataQuery) baseIsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DefaultQuery = []string{
	1: "QueryType",
	2: "IncludeReceipt",
}

func (v *DefaultQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(v.IncludeReceipt == nil) {
		writer.WriteValue(2, v.IncludeReceipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_DefaultQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DefaultQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DelegateSearchQuery = []string{
	1: "QueryType",
	2: "Delegate",
}

func (v *DelegateSearchQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(v.Delegate == nil) {
		writer.WriteUrl(2, v.Delegate)
	}

	_, _, err := writer.Reset(fieldNames_DelegateSearchQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DelegateSearchQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Delegate is missing")
	} else if v.Delegate == nil {
		errs = append(errs, "field Delegate is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DirectoryQuery = []string{
	1: "QueryType",
	2: "Range",
}

func (v *DirectoryQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(v.Range == nil) {
		writer.WriteValue(2, v.Range.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_DirectoryQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DirectoryQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Range is missing")
	} else if v.Range == nil {
		errs = append(errs, "field Range is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ErrorEvent = []string{
	1: "EventType",
	2: "Err",
}

func (v *ErrorEvent) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.EventType())
	if !(v.Err == nil) {
		writer.WriteValue(2, v.Err.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ErrorEvent)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ErrorEvent) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field EventType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Err is missing")
	} else if v.Err == nil {
		errs = append(errs, "field Err is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ErrorRecord = []string{
	1: "RecordType",
	2: "Value",
}

func (v *ErrorRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ErrorRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ErrorRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FaucetOptions = []string{
	1: "Token",
}

func (v *FaucetOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Token == nil) {
		writer.WriteUrl(1, v.Token)
	}

	_, _, err := writer.Reset(fieldNames_FaucetOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FaucetOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FindServiceOptions = []string{
	1: "Network",
	2: "Service",
	3: "Known",
	4: "Timeout",
}

func (v *FindServiceOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Network) == 0) {
		writer.WriteString(1, v.Network)
	}
	if !(v.Service == nil) {
		writer.WriteValue(2, v.Service.MarshalBinary)
	}
	if !(!v.Known) {
		writer.WriteBool(3, v.Known)
	}
	if !(v.Timeout == 0) {
		writer.WriteDuration(4, v.Timeout)
	}

	_, _, err := writer.Reset(fieldNames_FindServiceOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FindServiceOptions) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Network is missing")
	} else if len(v.Network) == 0 {
		errs = append(errs, "field Network is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Service is missing")
	} else if v.Service == nil {
		errs = append(errs, "field Service is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FindServiceResult = []string{
	1: "PeerID",
	2: "Status",
	3: "Addresses",
}

func (v *FindServiceResult) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.PeerID == ("")) {
		writer.WriteValue(1, v.PeerID.MarshalBinary)
	}
	if !(v.Status == 0) {
		writer.WriteEnum(2, v.Status)
	}
	if !(len(v.Addresses) == 0) {
		for _, v := range v.Addresses {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_FindServiceResult)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FindServiceResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field PeerID is missing")
	} else if v.PeerID == ("") {
		errs = append(errs, "field PeerID is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == 0 {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Addresses is missing")
	} else if len(v.Addresses) == 0 {
		errs = append(errs, "field Addresses is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_GlobalsEvent = []string{
	1: "EventType",
	2: "Old",
	3: "New",
}

func (v *GlobalsEvent) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.EventType())
	if !(v.Old == nil) {
		writer.WriteValue(2, v.Old.MarshalBinary)
	}
	if !(v.New == nil) {
		writer.WriteValue(3, v.New.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_GlobalsEvent)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *GlobalsEvent) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field EventType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Old is missing")
	} else if v.Old == nil {
		errs = append(errs, "field Old is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field New is missing")
	} else if v.New == nil {
		errs = append(errs, "field New is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_IndexEntryRecord = []string{
	1: "RecordType",
	2: "Value",
}

func (v *IndexEntryRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_IndexEntryRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *IndexEntryRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeyRecord = []string{
	1: "RecordType",
	2: "Authority",
	3: "Signer",
	4: "Version",
	5: "Index",
	6: "Entry",
}

func (v *KeyRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(3, v.Signer)
	}
	if !(v.Version == 0) {
		writer.WriteUint(4, v.Version)
	}
	if !(v.Index == 0) {
		writer.WriteUint(5, v.Index)
	}
	if !(v.Entry == nil) {
		writer.WriteValue(6, v.Entry.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_KeyRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *KeyRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entry is missing")
	} else if v.Entry == nil {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LastBlock = []string{
	1: "Height",
	2: "Time",
	3: "ChainRoot",
	4: "StateRoot",
	5: "DirectoryAnchorHeight",
}

func (v *LastBlock) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Height == 0) {
		writer.WriteInt(1, v.Height)
	}
	if !(v.Time == (time.Time{})) {
		writer.WriteTime(2, v.Time)
	}
	if !(v.ChainRoot == ([32]byte{})) {
		writer.WriteHash(3, &v.ChainRoot)
	}
	if !(v.StateRoot == ([32]byte{})) {
		writer.WriteHash(4, &v.StateRoot)
	}
	if !(v.DirectoryAnchorHeight == 0) {
		writer.WriteUint(5, v.DirectoryAnchorHeight)
	}

	_, _, err := writer.Reset(fieldNames_LastBlock)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LastBlock) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == (time.Time{}) {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ChainRoot is missing")
	} else if v.ChainRoot == ([32]byte{}) {
		errs = append(errs, "field ChainRoot is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field StateRoot is missing")
	} else if v.StateRoot == ([32]byte{}) {
		errs = append(errs, "field StateRoot is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field DirectoryAnchorHeight is missing")
	} else if v.DirectoryAnchorHeight == 0 {
		errs = append(errs, "field DirectoryAnchorHeight is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MajorBlockRecord = []string{
	1: "RecordType",
	2: "Index",
	3: "Time",
	4: "MinorBlocks",
	5: "LastBlockTime",
}

func (v *MajorBlockRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Index == 0) {
		writer.WriteUint(2, v.Index)
	}
	if !(v.Time == (time.Time{})) {
		writer.WriteTime(3, v.Time)
	}
	if !(v.MinorBlocks == nil) {
		writer.WriteValue(4, v.MinorBlocks.MarshalBinary)
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(5, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_MajorBlockRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MajorBlockRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == (time.Time{}) {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field MinorBlocks is missing")
	} else if v.MinorBlocks == nil {
		errs = append(errs, "field MinorBlocks is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MessageHashSearchQuery = []string{
	1: "QueryType",
	2: "Hash",
}

func (v *MessageHashSearchQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(2, &v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_MessageHashSearchQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MessageHashSearchQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Hash is missing")
	} else if v.Hash == ([32]byte{}) {
		errs = append(errs, "field Hash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MessageRecord = []string{
	1:  "RecordType",
	2:  "ID",
	3:  "Message",
	4:  "Status",
	5:  "Error",
	6:  "Result",
	7:  "Received",
	8:  "Produced",
	9:  "Cause",
	10: "Signatures",
	11: "Historical",
	12: "Sequence",
	13: "SourceReceipt",
	14: "LastBlockTime",
}

func (v *MessageRecord[T]) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.ID == nil) {
		writer.WriteTxid(2, v.ID)
	}
	if !(messaging.EqualMessage(v.Message, nil)) {
		writer.WriteValue(3, v.Message.MarshalBinary)
	}
	if !(v.Status == 0) {
		writer.WriteEnum(4, v.Status)
	}
	if !(v.Error == nil) {
		writer.WriteValue(5, v.Error.MarshalBinary)
	}
	if !(protocol.EqualTransactionResult(v.Result, nil)) {
		writer.WriteValue(6, v.Result.MarshalBinary)
	}
	if !(v.Received == 0) {
		writer.WriteUint(7, v.Received)
	}
	if !(v.Produced == nil) {
		writer.WriteValue(8, v.Produced.MarshalBinary)
	}
	if !(v.Cause == nil) {
		writer.WriteValue(9, v.Cause.MarshalBinary)
	}
	if !(v.Signatures == nil) {
		writer.WriteValue(10, v.Signatures.MarshalBinary)
	}
	if !(!v.Historical) {
		writer.WriteBool(11, v.Historical)
	}
	if !(v.Sequence == nil) {
		writer.WriteValue(12, v.Sequence.MarshalBinary)
	}
	if !(v.SourceReceipt == nil) {
		writer.WriteValue(13, v.SourceReceipt.MarshalBinary)
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(14, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_MessageRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MessageRecord[T]) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field ID is missing")
	} else if v.ID == nil {
		errs = append(errs, "field ID is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Message is missing")
	} else if messaging.EqualMessage(v.Message, nil) {
		errs = append(errs, "field Message is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == 0 {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Error is missing")
	} else if v.Error == nil {
		errs = append(errs, "field Error is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Result is missing")
	} else if protocol.EqualTransactionResult(v.Result, nil) {
		errs = append(errs, "field Result is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Received is missing")
	} else if v.Received == 0 {
		errs = append(errs, "field Received is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Produced is missing")
	} else if v.Produced == nil {
		errs = append(errs, "field Produced is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field Cause is missing")
	} else if v.Cause == nil {
		errs = append(errs, "field Cause is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field Signatures is missing")
	} else if v.Signatures == nil {
		errs = append(errs, "field Signatures is not set")
	}
	if len(v.fieldsSet) > 10 && !v.fieldsSet[10] {
		errs = append(errs, "field Historical is missing")
	} else if !v.Historical {
		errs = append(errs, "field Historical is not set")
	}
	if len(v.fieldsSet) > 12 && !v.fieldsSet[12] {
		errs = append(errs, "field SourceReceipt is missing")
	} else if v.SourceReceipt == nil {
		errs = append(errs, "field SourceReceipt is not set")
	}
	if len(v.fieldsSet) > 13 && !v.fieldsSet[13] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Metrics = []string{
	1: "TPS",
}

func (v *Metrics) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteFloat(1, v.TPS)

	_, _, err := writer.Reset(fieldNames_Metrics)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Metrics) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field TPS is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MetricsOptions = []string{
	1: "Partition",
	2: "Span",
}

func (v *MetricsOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Partition) == 0) {
		writer.WriteString(1, v.Partition)
	}
	if !(v.Span == 0) {
		writer.WriteUint(2, v.Span)
	}

	_, _, err := writer.Reset(fieldNames_MetricsOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MetricsOptions) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Partition is missing")
	} else if len(v.Partition) == 0 {
		errs = append(errs, "field Partition is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MinorBlockRecord = []string{
	1: "RecordType",
	2: "Index",
	3: "Time",
	4: "Source",
	5: "Entries",
	6: "Anchored",
	7: "LastBlockTime",
}

func (v *MinorBlockRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Index == 0) {
		writer.WriteUint(2, v.Index)
	}
	if !(v.Time == nil) {
		writer.WriteTime(3, *v.Time)
	}
	if !(v.Source == nil) {
		writer.WriteUrl(4, v.Source)
	}
	if !(v.Entries == nil) {
		writer.WriteValue(5, v.Entries.MarshalBinary)
	}
	if !(v.Anchored == nil) {
		writer.WriteValue(6, v.Anchored.MarshalBinary)
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(7, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_MinorBlockRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MinorBlockRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == nil {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Source is missing")
	} else if v.Source == nil {
		errs = append(errs, "field Source is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Entries is missing")
	} else if v.Entries == nil {
		errs = append(errs, "field Entries is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Anchored is missing")
	} else if v.Anchored == nil {
		errs = append(errs, "field Anchored is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkStatus = []string{
	1: "Oracle",
	2: "Globals",
	3: "Network",
	4: "Routing",
	5: "ExecutorVersion",
	6: "DirectoryHeight",
	7: "MajorBlockHeight",
	8: "BvnExecutorVersions",
}

func (v *NetworkStatus) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Oracle == nil) {
		writer.WriteValue(1, v.Oracle.MarshalBinary)
	}
	if !(v.Globals == nil) {
		writer.WriteValue(2, v.Globals.MarshalBinary)
	}
	if !(v.Network == nil) {
		writer.WriteValue(3, v.Network.MarshalBinary)
	}
	if !(v.Routing == nil) {
		writer.WriteValue(4, v.Routing.MarshalBinary)
	}
	if !(v.ExecutorVersion == 0) {
		writer.WriteEnum(5, v.ExecutorVersion)
	}
	if !(v.DirectoryHeight == 0) {
		writer.WriteUint(6, v.DirectoryHeight)
	}
	if !(v.MajorBlockHeight == 0) {
		writer.WriteUint(7, v.MajorBlockHeight)
	}
	if !(len(v.BvnExecutorVersions) == 0) {
		for _, v := range v.BvnExecutorVersions {
			writer.WriteValue(8, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_NetworkStatus)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkStatus) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Oracle is missing")
	} else if v.Oracle == nil {
		errs = append(errs, "field Oracle is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Globals is missing")
	} else if v.Globals == nil {
		errs = append(errs, "field Globals is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Network is missing")
	} else if v.Network == nil {
		errs = append(errs, "field Network is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Routing is missing")
	} else if v.Routing == nil {
		errs = append(errs, "field Routing is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field DirectoryHeight is missing")
	} else if v.DirectoryHeight == 0 {
		errs = append(errs, "field DirectoryHeight is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field MajorBlockHeight is missing")
	} else if v.MajorBlockHeight == 0 {
		errs = append(errs, "field MajorBlockHeight is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field BvnExecutorVersions is missing")
	} else if len(v.BvnExecutorVersions) == 0 {
		errs = append(errs, "field BvnExecutorVersions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkStatusOptions = []string{
	1: "Partition",
}

func (v *NetworkStatusOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Partition) == 0) {
		writer.WriteString(1, v.Partition)
	}

	_, _, err := writer.Reset(fieldNames_NetworkStatusOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkStatusOptions) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Partition is missing")
	} else if len(v.Partition) == 0 {
		errs = append(errs, "field Partition is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeInfo = []string{
	1: "PeerID",
	2: "Network",
	3: "Services",
	4: "Version",
	5: "Commit",
}

func (v *NodeInfo) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.PeerID == ("")) {
		writer.WriteValue(1, v.PeerID.MarshalBinary)
	}
	if !(len(v.Network) == 0) {
		writer.WriteString(2, v.Network)
	}
	if !(len(v.Services) == 0) {
		for _, v := range v.Services {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}
	if !(len(v.Version) == 0) {
		writer.WriteString(4, v.Version)
	}
	if !(len(v.Commit) == 0) {
		writer.WriteString(5, v.Commit)
	}

	_, _, err := writer.Reset(fieldNames_NodeInfo)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeInfo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field PeerID is missing")
	} else if v.PeerID == ("") {
		errs = append(errs, "field PeerID is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Network is missing")
	} else if len(v.Network) == 0 {
		errs = append(errs, "field Network is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Services is missing")
	} else if len(v.Services) == 0 {
		errs = append(errs, "field Services is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Version is missing")
	} else if len(v.Version) == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Commit is missing")
	} else if len(v.Commit) == 0 {
		errs = append(errs, "field Commit is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeInfoOptions = []string{
	1: "PeerID",
}

func (v *NodeInfoOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.PeerID == ("")) {
		writer.WriteValue(1, v.PeerID.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_NodeInfoOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeInfoOptions) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field PeerID is missing")
	} else if v.PeerID == ("") {
		errs = append(errs, "field PeerID is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PendingQuery = []string{
	1: "QueryType",
	2: "Range",
}

func (v *PendingQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(v.Range == nil) {
		writer.WriteValue(2, v.Range.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_PendingQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PendingQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Range is missing")
	} else if v.Range == nil {
		errs = append(errs, "field Range is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PublicKeyHashSearchQuery = []string{
	1: "QueryType",
	2: "PublicKeyHash",
}

func (v *PublicKeyHashSearchQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(len(v.PublicKeyHash) == 0) {
		writer.WriteBytes(2, v.PublicKeyHash)
	}

	_, _, err := writer.Reset(fieldNames_PublicKeyHashSearchQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PublicKeyHashSearchQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKeyHash is missing")
	} else if len(v.PublicKeyHash) == 0 {
		errs = append(errs, "field PublicKeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PublicKeySearchQuery = []string{
	1: "QueryType",
	2: "PublicKey",
	3: "Type",
}

func (v *PublicKeySearchQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.QueryType())
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(3, v.Type)
	}

	_, _, err := writer.Reset(fieldNames_PublicKeySearchQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PublicKeySearchQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field QueryType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RangeOptions = []string{
	1: "Start",
	2: "Count",
	3: "Expand",
	4: "FromEnd",
}

func (v *RangeOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Start == 0) {
		writer.WriteUint(1, v.Start)
	}
	if !(v.Count == nil) {
		writer.WriteUint(2, *v.Count)
	}
	if !(v.Expand == nil) {
		writer.WriteBool(3, *v.Expand)
	}
	if !(!v.FromEnd) {
		writer.WriteBool(4, v.FromEnd)
	}

	_, _, err := writer.Reset(fieldNames_RangeOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RangeOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Receipt = []string{
	1: "Receipt",
	2: "LocalBlock",
	3: "LocalBlockTime",
	4: "MajorBlock",
}

func (v *Receipt) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, v.Receipt.MarshalBinary)
	if !(v.LocalBlock == 0) {
		writer.WriteUint(2, v.LocalBlock)
	}
	if !(v.LocalBlockTime == (time.Time{})) {
		writer.WriteTime(3, v.LocalBlockTime)
	}
	if !(v.MajorBlock == 0) {
		writer.WriteUint(4, v.MajorBlock)
	}

	_, _, err := writer.Reset(fieldNames_Receipt)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Receipt) IsValid() error {
	var errs []string

	if err := v.Receipt.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field LocalBlock is missing")
	} else if v.LocalBlock == 0 {
		errs = append(errs, "field LocalBlock is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field LocalBlockTime is missing")
	} else if v.LocalBlockTime == (time.Time{}) {
		errs = append(errs, "field LocalBlockTime is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field MajorBlock is missing")
	} else if v.MajorBlock == 0 {
		errs = append(errs, "field MajorBlock is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ReceiptOptions = []string{
	1: "ForAny",
	2: "ForHeight",
}

func (v *ReceiptOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.ForAny) {
		writer.WriteBool(1, v.ForAny)
	}
	if !(v.ForHeight == 0) {
		writer.WriteUint(2, v.ForHeight)
	}

	_, _, err := writer.Reset(fieldNames_ReceiptOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ReceiptOptions) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field ForAny is missing")
	} else if !v.ForAny {
		errs = append(errs, "field ForAny is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field ForHeight is missing")
	} else if v.ForHeight == 0 {
		errs = append(errs, "field ForHeight is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RecordRange = []string{
	1: "RecordType",
	2: "Records",
	3: "Start",
	4: "Total",
	5: "LastBlockTime",
}

func (v *RecordRange[T]) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(len(v.Records) == 0) {
		for _, v := range v.Records {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	writer.WriteUint(3, v.Start)
	writer.WriteUint(4, v.Total)
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(5, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_RecordRange)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RecordRange[T]) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Records is missing")
	} else if len(v.Records) == 0 {
		errs = append(errs, "field Records is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Start is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ServiceAddress = []string{
	1: "Type",
	2: "Argument",
}

func (v *ServiceAddress) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteUint(1, (uint64)(v.Type))
	}
	if !(len(v.Argument) == 0) {
		writer.WriteString(2, v.Argument)
	}

	_, _, err := writer.Reset(fieldNames_ServiceAddress)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ServiceAddress) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SignatureSetRecord = []string{
	1: "RecordType",
	2: "Account",
	3: "Signatures",
}

func (v *SignatureSetRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(protocol.EqualAccount(v.Account, nil)) {
		writer.WriteValue(2, v.Account.MarshalBinary)
	}
	if !(v.Signatures == nil) {
		writer.WriteValue(3, v.Signatures.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_SignatureSetRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SignatureSetRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if protocol.EqualAccount(v.Account, nil) {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signatures is missing")
	} else if v.Signatures == nil {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Submission = []string{
	1: "Status",
	2: "Success",
	3: "Message",
}

func (v *Submission) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Status == nil) {
		writer.WriteValue(1, v.Status.MarshalBinary)
	}
	if !(!v.Success) {
		writer.WriteBool(2, v.Success)
	}
	if !(len(v.Message) == 0) {
		writer.WriteString(3, v.Message)
	}

	_, _, err := writer.Reset(fieldNames_Submission)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Submission) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Success is missing")
	} else if !v.Success {
		errs = append(errs, "field Success is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Message is missing")
	} else if len(v.Message) == 0 {
		errs = append(errs, "field Message is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubmitOptions = []string{
	1: "Verify",
	2: "Wait",
}

func (v *SubmitOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Verify == nil) {
		writer.WriteBool(1, *v.Verify)
	}
	if !(v.Wait == nil) {
		writer.WriteBool(2, *v.Wait)
	}

	_, _, err := writer.Reset(fieldNames_SubmitOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubmitOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubscribeOptions = []string{
	1: "Partition",
	2: "Account",
}

func (v *SubscribeOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Partition) == 0) {
		writer.WriteString(1, v.Partition)
	}
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}

	_, _, err := writer.Reset(fieldNames_SubscribeOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubscribeOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TxIDRecord = []string{
	1: "RecordType",
	2: "Value",
}

func (v *TxIDRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Value == nil) {
		writer.WriteTxid(2, v.Value)
	}

	_, _, err := writer.Reset(fieldNames_TxIDRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TxIDRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UrlRecord = []string{
	1: "RecordType",
	2: "Value",
}

func (v *UrlRecord) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Value == nil) {
		writer.WriteUrl(2, v.Value)
	}

	_, _, err := writer.Reset(fieldNames_UrlRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UrlRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ValidateOptions = []string{
	1: "Full",
}

func (v *ValidateOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Full == nil) {
		writer.WriteBool(1, *v.Full)
	}

	_, _, err := writer.Reset(fieldNames_ValidateOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ValidateOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *AccountRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AccountRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AccountRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := protocol.UnmarshalAccountFrom(r)
		if err == nil {
			v.Account = x
		}
		return err
	})
	if x := new(RecordRange[*UrlRecord]); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.Directory = x
	}
	if x := new(RecordRange[*TxIDRecord]); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.Pending = x
	}
	if x := new(Receipt); reader.ReadValue(5, x.UnmarshalBinaryFrom) {
		v.Receipt = x
	}
	if x, ok := reader.ReadTime(6); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_AccountRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AnchorSearchQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AnchorSearchQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *AnchorSearchQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.Anchor = x
	}
	if x := new(ReceiptOptions); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.IncludeReceipt = x
	}

	seen, err := reader.Reset(fieldNames_AnchorSearchQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockEvent) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockEvent) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vEventType EventType
	if x := new(EventType); reader.ReadEnum(1, x) {
		vEventType = *x
	}
	if !(v.EventType() == vEventType) {
		return fmt.Errorf("field EventType: not equal: want %v, got %v", v.EventType(), vEventType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BlockEvent) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadString(2); ok {
		v.Partition = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(4); ok {
		v.Time = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Major = x
	}
	for {
		if x := new(ChainEntryRecord[Record]); reader.ReadValue(6, x.UnmarshalBinaryFrom) {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_BlockEvent)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BlockQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUint(2); ok {
		v.Minor = &x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Major = &x
	}
	if x := new(RangeOptions); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.MinorRange = x
	}
	if x := new(RangeOptions); reader.ReadValue(5, x.UnmarshalBinaryFrom) {
		v.MajorRange = x
	}
	if x := new(RangeOptions); reader.ReadValue(6, x.UnmarshalBinaryFrom) {
		v.EntryRange = x
	}
	if x, ok := reader.ReadBool(7); ok {
		v.OmitEmpty = x
	}

	seen, err := reader.Reset(fieldNames_BlockQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainEntryRecord[T]) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainEntryRecord[T]) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ChainEntryRecord[T]) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Name = x
	}
	if x := new(merkle.ChainType); reader.ReadEnum(4, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Index = x
	}
	if x, ok := reader.ReadHash(6); ok {
		v.Entry = *x
	}
	reader.ReadValue(7, func(r io.Reader) error {
		x, err := encoding.Cast[T](UnmarshalRecordFrom(r))
		if err == nil {
			v.Value = x
		}
		return err
	})
	if x := new(Receipt); reader.ReadValue(8, x.UnmarshalBinaryFrom) {
		v.Receipt = x
	}
	for {
		if x, ok := reader.ReadBytes(9); ok {
			v.State = append(v.State, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadTime(10); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_ChainEntryRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ChainQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadString(2); ok {
		v.Name = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = &x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.Entry = x
	}
	if x := new(RangeOptions); reader.ReadValue(5, x.UnmarshalBinaryFrom) {
		v.Range = x
	}
	if x := new(ReceiptOptions); reader.ReadValue(6, x.UnmarshalBinaryFrom) {
		v.IncludeReceipt = x
	}

	seen, err := reader.Reset(fieldNames_ChainQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ChainRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadString(2); ok {
		v.Name = x
	}
	if x := new(merkle.ChainType); reader.ReadEnum(3, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Count = x
	}
	for {
		if x, ok := reader.ReadBytes(5); ok {
			v.State = append(v.State, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadTime(6); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_ChainRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ConsensusPeerInfo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ConsensusPeerInfo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.NodeID = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Host = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Port = x
	}

	seen, err := reader.Reset(fieldNames_ConsensusPeerInfo)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ConsensusStatus) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ConsensusStatus) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Ok = x
	}
	if x := new(LastBlock); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.LastBlock = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Version = x
	}
	if x, ok := reader.ReadString(4); ok {
		v.Commit = x
	}
	if x, ok := reader.ReadHash(5); ok {
		v.NodeKeyHash = *x
	}
	if x, ok := reader.ReadHash(6); ok {
		v.ValidatorKeyHash = *x
	}
	if x, ok := reader.ReadString(7); ok {
		v.PartitionID = x
	}
	if x := new(protocol.PartitionType); reader.ReadEnum(8, x) {
		v.PartitionType = *x
	}
	for {
		if x := new(ConsensusPeerInfo); reader.ReadValue(9, x.UnmarshalBinaryFrom) {
			v.Peers = append(v.Peers, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ConsensusStatus)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ConsensusStatusOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ConsensusStatusOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.NodeID = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Partition = x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.IncludePeers = &x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.IncludeAccumulate = &x
	}

	seen, err := reader.Reset(fieldNames_ConsensusStatusOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DataQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *DataQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUint(2); ok {
		v.Index = &x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Entry = x
	}
	if x := new(RangeOptions); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.Range = x
	}

	seen, err := reader.Reset(fieldNames_DataQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DefaultQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DefaultQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *DefaultQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(ReceiptOptions); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.IncludeReceipt = x
	}

	seen, err := reader.Reset(fieldNames_DefaultQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DelegateSearchQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DelegateSearchQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *DelegateSearchQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Delegate = x
	}

	seen, err := reader.Reset(fieldNames_DelegateSearchQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DirectoryQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DirectoryQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *DirectoryQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(RangeOptions); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Range = x
	}

	seen, err := reader.Reset(fieldNames_DirectoryQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ErrorEvent) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ErrorEvent) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vEventType EventType
	if x := new(EventType); reader.ReadEnum(1, x) {
		vEventType = *x
	}
	if !(v.EventType() == vEventType) {
		return fmt.Errorf("field EventType: not equal: want %v, got %v", v.EventType(), vEventType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ErrorEvent) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(errors2.Error); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Err = x
	}

	seen, err := reader.Reset(fieldNames_ErrorEvent)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ErrorRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ErrorRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ErrorRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(errors2.Error); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_ErrorRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FaucetOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FaucetOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Token = x
	}

	seen, err := reader.Reset(fieldNames_FaucetOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FindServiceOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FindServiceOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Network = x
	}
	if x := new(ServiceAddress); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Service = x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.Known = x
	}
	if x, ok := reader.ReadDuration(4); ok {
		v.Timeout = x
	}

	seen, err := reader.Reset(fieldNames_FindServiceOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FindServiceResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FindServiceResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(r io.Reader) error {
		x, err := p2p.UnmarshalPeerIDFrom(r)
		if err == nil {
			v.PeerID = x
		}
		return err
	})
	if x := new(KnownPeerStatus); reader.ReadEnum(2, x) {
		v.Status = *x
	}
	for {
		ok := reader.ReadValue(3, func(r io.Reader) error {
			x, err := p2p.UnmarshalMultiaddrFrom(r)
			if err == nil {
				v.Addresses = append(v.Addresses, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_FindServiceResult)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *GlobalsEvent) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *GlobalsEvent) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vEventType EventType
	if x := new(EventType); reader.ReadEnum(1, x) {
		vEventType = *x
	}
	if !(v.EventType() == vEventType) {
		return fmt.Errorf("field EventType: not equal: want %v, got %v", v.EventType(), vEventType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *GlobalsEvent) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(core.GlobalValues); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Old = x
	}
	if x := new(core.GlobalValues); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.New = x
	}

	seen, err := reader.Reset(fieldNames_GlobalsEvent)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *IndexEntryRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *IndexEntryRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *IndexEntryRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(protocol.IndexEntry); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_IndexEntryRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *KeyRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeyRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *KeyRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Version = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Index = x
	}
	if x := new(protocol.KeySpec); reader.ReadValue(6, x.UnmarshalBinaryFrom) {
		v.Entry = x
	}

	seen, err := reader.Reset(fieldNames_KeyRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LastBlock) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LastBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadInt(1); ok {
		v.Height = x
	}
	if x, ok := reader.ReadTime(2); ok {
		v.Time = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.ChainRoot = *x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.StateRoot = *x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.DirectoryAnchorHeight = x
	}

	seen, err := reader.Reset(fieldNames_LastBlock)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MajorBlockRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MajorBlockRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *MajorBlockRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUint(2); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(3); ok {
		v.Time = x
	}
	if x := new(RecordRange[*MinorBlockRecord]); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.MinorBlocks = x
	}
	if x, ok := reader.ReadTime(5); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_MajorBlockRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MessageHashSearchQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MessageHashSearchQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *MessageHashSearchQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadHash(2); ok {
		v.Hash = *x
	}

	seen, err := reader.Reset(fieldNames_MessageHashSearchQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MessageRecord[T]) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MessageRecord[T]) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *MessageRecord[T]) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadTxid(2); ok {
		v.ID = x
	}
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := encoding.Cast[T](messaging.UnmarshalMessageFrom(r))
		if err == nil {
			v.Message = x
		}
		return err
	})
	if x := new(errors2.Status); reader.ReadEnum(4, x) {
		v.Status = *x
	}
	if x := new(errors2.Error); reader.ReadValue(5, x.UnmarshalBinaryFrom) {
		v.Error = x
	}
	reader.ReadValue(6, func(r io.Reader) error {
		x, err := protocol.UnmarshalTransactionResultFrom(r)
		if err == nil {
			v.Result = x
		}
		return err
	})
	if x, ok := reader.ReadUint(7); ok {
		v.Received = x
	}
	if x := new(RecordRange[*TxIDRecord]); reader.ReadValue(8, x.UnmarshalBinaryFrom) {
		v.Produced = x
	}
	if x := new(RecordRange[*TxIDRecord]); reader.ReadValue(9, x.UnmarshalBinaryFrom) {
		v.Cause = x
	}
	if x := new(RecordRange[*SignatureSetRecord]); reader.ReadValue(10, x.UnmarshalBinaryFrom) {
		v.Signatures = x
	}
	if x, ok := reader.ReadBool(11); ok {
		v.Historical = x
	}
	if x := new(messaging.SequencedMessage); reader.ReadValue(12, x.UnmarshalBinaryFrom) {
		v.Sequence = x
	}
	if x := new(merkle.Receipt); reader.ReadValue(13, x.UnmarshalBinaryFrom) {
		v.SourceReceipt = x
	}
	if x, ok := reader.ReadTime(14); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_MessageRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Metrics) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Metrics) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadFloat(1); ok {
		v.TPS = x
	}

	seen, err := reader.Reset(fieldNames_Metrics)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MetricsOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MetricsOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Partition = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Span = x
	}

	seen, err := reader.Reset(fieldNames_MetricsOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MinorBlockRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MinorBlockRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *MinorBlockRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUint(2); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(3); ok {
		v.Time = &x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Source = x
	}
	if x := new(RecordRange[*ChainEntryRecord[Record]]); reader.ReadValue(5, x.UnmarshalBinaryFrom) {
		v.Entries = x
	}
	if x := new(RecordRange[*MinorBlockRecord]); reader.ReadValue(6, x.UnmarshalBinaryFrom) {
		v.Anchored = x
	}
	if x, ok := reader.ReadTime(7); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_MinorBlockRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkStatus) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkStatus) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.AcmeOracle); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Oracle = x
	}
	if x := new(protocol.NetworkGlobals); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Globals = x
	}
	if x := new(protocol.NetworkDefinition); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.Network = x
	}
	if x := new(protocol.RoutingTable); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.Routing = x
	}
	if x := new(protocol.ExecutorVersion); reader.ReadEnum(5, x) {
		v.ExecutorVersion = *x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.DirectoryHeight = x
	}
	if x, ok := reader.ReadUint(7); ok {
		v.MajorBlockHeight = x
	}
	for {
		if x := new(protocol.PartitionExecutorVersion); reader.ReadValue(8, x.UnmarshalBinaryFrom) {
			v.BvnExecutorVersions = append(v.BvnExecutorVersions, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_NetworkStatus)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkStatusOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkStatusOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Partition = x
	}

	seen, err := reader.Reset(fieldNames_NetworkStatusOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeInfo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeInfo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(r io.Reader) error {
		x, err := p2p.UnmarshalPeerIDFrom(r)
		if err == nil {
			v.PeerID = x
		}
		return err
	})
	if x, ok := reader.ReadString(2); ok {
		v.Network = x
	}
	for {
		if x := new(ServiceAddress); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
			v.Services = append(v.Services, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadString(4); ok {
		v.Version = x
	}
	if x, ok := reader.ReadString(5); ok {
		v.Commit = x
	}

	seen, err := reader.Reset(fieldNames_NodeInfo)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeInfoOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeInfoOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(r io.Reader) error {
		x, err := p2p.UnmarshalPeerIDFrom(r)
		if err == nil {
			v.PeerID = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_NodeInfoOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PendingQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PendingQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *PendingQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(RangeOptions); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Range = x
	}

	seen, err := reader.Reset(fieldNames_PendingQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PublicKeyHashSearchQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PublicKeyHashSearchQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *PublicKeyHashSearchQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKeyHash = x
	}

	seen, err := reader.Reset(fieldNames_PublicKeyHashSearchQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PublicKeySearchQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PublicKeySearchQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vQueryType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vQueryType = *x
	}
	if !(v.QueryType() == vQueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), vQueryType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *PublicKeySearchQuery) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x := new(protocol.SignatureType); reader.ReadEnum(3, x) {
		v.Type = *x
	}

	seen, err := reader.Reset(fieldNames_PublicKeySearchQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RangeOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RangeOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Count = &x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.Expand = &x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.FromEnd = x
	}

	seen, err := reader.Reset(fieldNames_RangeOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Receipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Receipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.Receipt.UnmarshalBinaryFrom)
	if x, ok := reader.ReadUint(2); ok {
		v.LocalBlock = x
	}
	if x, ok := reader.ReadTime(3); ok {
		v.LocalBlockTime = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.MajorBlock = x
	}

	seen, err := reader.Reset(fieldNames_Receipt)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ReceiptOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ReceiptOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.ForAny = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.ForHeight = x
	}

	seen, err := reader.Reset(fieldNames_ReceiptOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RecordRange[T]) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RecordRange[T]) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *RecordRange[T]) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		ok := reader.ReadValue(2, func(r io.Reader) error {
			x, err := encoding.Cast[T](UnmarshalRecordFrom(r))
			if err == nil {
				v.Records = append(v.Records, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Total = x
	}
	if x, ok := reader.ReadTime(5); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_RecordRange)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ServiceAddress) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ServiceAddress) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Type = (ServiceType)(x)
	}
	if x, ok := reader.ReadString(2); ok {
		v.Argument = x
	}

	seen, err := reader.Reset(fieldNames_ServiceAddress)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SignatureSetRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureSetRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SignatureSetRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := protocol.UnmarshalAccountFrom(r)
		if err == nil {
			v.Account = x
		}
		return err
	})
	if x := new(RecordRange[*MessageRecord[messaging.Message]]); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.Signatures = x
	}

	seen, err := reader.Reset(fieldNames_SignatureSetRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Submission) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Submission) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.TransactionStatus); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Status = x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.Success = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Message = x
	}

	seen, err := reader.Reset(fieldNames_Submission)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubmitOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubmitOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Verify = &x
	}
	if x, ok := reader.ReadBool(2); ok {
		v.Wait = &x
	}

	seen, err := reader.Reset(fieldNames_SubmitOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubscribeOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubscribeOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Partition = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}

	seen, err := reader.Reset(fieldNames_SubscribeOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TxIDRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TxIDRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *TxIDRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadTxid(2); ok {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_TxIDRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UrlRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UrlRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *UrlRecord) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_UrlRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ValidateOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ValidateOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Full = &x
	}

	seen, err := reader.Reset(fieldNames_ValidateOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func init() {

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("account", "protocol.Account"),
		encoding.NewTypeField("directory", "RecordRange[*UrlRecord]"),
		encoding.NewTypeField("pending", "RecordRange[*TxIDRecord]"),
		encoding.NewTypeField("receipt", "Receipt"),
		encoding.NewTypeField("lastBlockTime", "string"),
	}, "AccountRecord", "accountRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("anchor", "bytes"),
		encoding.NewTypeField("includeReceipt", "ReceiptOptions"),
	}, "AnchorSearchQuery", "anchorSearchQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("eventType", "string"),
		encoding.NewTypeField("partition", "string"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("time", "string"),
		encoding.NewTypeField("major", "uint64"),
		encoding.NewTypeField("entries", "ChainEntryRecord[Record][]"),
	}, "BlockEvent", "blockEvent")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("minor", "uint64"),
		encoding.NewTypeField("major", "uint64"),
		encoding.NewTypeField("minorRange", "RangeOptions"),
		encoding.NewTypeField("majorRange", "RangeOptions"),
		encoding.NewTypeField("entryRange", "RangeOptions"),
		encoding.NewTypeField("omitEmpty", "bool"),
	}, "BlockQuery", "blockQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("account", "string"),
		encoding.NewTypeField("name", "string"),
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("entry", "bytes32"),
		encoding.NewTypeField("value", "T"),
		encoding.NewTypeField("receipt", "Receipt"),
		encoding.NewTypeField("state", "bytes[]"),
		encoding.NewTypeField("lastBlockTime", "string"),
	}, "ChainEntryRecord", "chainEntryRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("name", "string"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("entry", "bytes"),
		encoding.NewTypeField("range", "RangeOptions"),
		encoding.NewTypeField("includeReceipt", "ReceiptOptions"),
	}, "ChainQuery", "chainQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("name", "string"),
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("count", "uint64"),
		encoding.NewTypeField("state", "bytes[]"),
		encoding.NewTypeField("lastBlockTime", "string"),
	}, "ChainRecord", "chainRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("nodeID", "string"),
		encoding.NewTypeField("host", "string"),
		encoding.NewTypeField("port", "uint64"),
	}, "ConsensusPeerInfo", "consensusPeerInfo")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("ok", "bool"),
		encoding.NewTypeField("lastBlock", "LastBlock"),
		encoding.NewTypeField("version", "string"),
		encoding.NewTypeField("commit", "string"),
		encoding.NewTypeField("nodeKeyHash", "bytes32"),
		encoding.NewTypeField("validatorKeyHash", "bytes32"),
		encoding.NewTypeField("partitionID", "string"),
		encoding.NewTypeField("partitionType", "string"),
		encoding.NewTypeField("peers", "ConsensusPeerInfo[]"),
	}, "ConsensusStatus", "consensusStatus")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("nodeID", "string"),
		encoding.NewTypeField("partition", "string"),
		encoding.NewTypeField("includePeers", "bool"),
		encoding.NewTypeField("includeAccumulate", "bool"),
	}, "ConsensusStatusOptions", "consensusStatusOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("entry", "bytes"),
		encoding.NewTypeField("range", "RangeOptions"),
	}, "DataQuery", "dataQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("includeReceipt", "ReceiptOptions"),
	}, "DefaultQuery", "defaultQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("delegate", "string"),
	}, "DelegateSearchQuery", "delegateSearchQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("range", "RangeOptions"),
	}, "DirectoryQuery", "directoryQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("eventType", "string"),
		encoding.NewTypeField("err", "errors2.Error"),
	}, "ErrorEvent", "errorEvent")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("value", "errors2.Error"),
	}, "ErrorRecord", "errorRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("token", "string"),
	}, "FaucetOptions", "faucetOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("service", "ServiceAddress"),
		encoding.NewTypeField("known", "bool"),
		encoding.NewTypeField("timeout", "string"),
	}, "FindServiceOptions", "findServiceOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("peerID", "p2p.PeerID"),
		encoding.NewTypeField("status", "string"),
		encoding.NewTypeField("addresses", "p2p.Multiaddr[]"),
	}, "FindServiceResult", "findServiceResult")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("eventType", "string"),
		encoding.NewTypeField("old", "core.GlobalValues"),
		encoding.NewTypeField("new", "core.GlobalValues"),
	}, "GlobalsEvent", "globalsEvent")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("value", "protocol.IndexEntry"),
	}, "IndexEntryRecord", "indexEntryRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("authority", "string"),
		encoding.NewTypeField("signer", "string"),
		encoding.NewTypeField("version", "uint64"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("entry", "protocol.KeySpec"),
	}, "KeyRecord", "keyRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("height", "int64"),
		encoding.NewTypeField("time", "string"),
		encoding.NewTypeField("chainRoot", "bytes32"),
		encoding.NewTypeField("stateRoot", "bytes32"),
		encoding.NewTypeField("directoryAnchorHeight", "uint64"),
	}, "LastBlock", "lastBlock")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("time", "string"),
		encoding.NewTypeField("minorBlocks", "RecordRange[*MinorBlockRecord]"),
		encoding.NewTypeField("lastBlockTime", "string"),
	}, "MajorBlockRecord", "majorBlockRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("hash", "bytes32"),
	}, "MessageHashSearchQuery", "messageHashSearchQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("id", "string"),
		encoding.NewTypeField("message", "T"),
		encoding.NewTypeField("status", "string"),
		encoding.NewTypeField("statusNo", "uint64"),
		encoding.NewTypeField("error", "errors2.Error"),
		encoding.NewTypeField("result", "protocol.TransactionResult"),
		encoding.NewTypeField("received", "uint64"),
		encoding.NewTypeField("produced", "RecordRange[*TxIDRecord]"),
		encoding.NewTypeField("cause", "RecordRange[*TxIDRecord]"),
		encoding.NewTypeField("signatures", "RecordRange[*SignatureSetRecord]"),
		encoding.NewTypeField("historical", "bool"),
		encoding.NewTypeField("sequence", "messaging.SequencedMessage"),
		encoding.NewTypeField("sourceReceipt", "merkle.Receipt"),
		encoding.NewTypeField("lastBlockTime", "string"),
	}, "MessageRecord", "messageRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("tps", "float"),
	}, "Metrics", "metrics")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("partition", "string"),
		encoding.NewTypeField("span", "uint64"),
	}, "MetricsOptions", "metricsOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("time", "string"),
		encoding.NewTypeField("source", "string"),
		encoding.NewTypeField("entries", "RecordRange[*ChainEntryRecord[Record]]"),
		encoding.NewTypeField("anchored", "RecordRange[*MinorBlockRecord]"),
		encoding.NewTypeField("lastBlockTime", "string"),
	}, "MinorBlockRecord", "minorBlockRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("oracle", "protocol.AcmeOracle"),
		encoding.NewTypeField("globals", "protocol.NetworkGlobals"),
		encoding.NewTypeField("network", "protocol.NetworkDefinition"),
		encoding.NewTypeField("routing", "protocol.RoutingTable"),
		encoding.NewTypeField("executorVersion", "string"),
		encoding.NewTypeField("directoryHeight", "uint64"),
		encoding.NewTypeField("majorBlockHeight", "uint64"),
		encoding.NewTypeField("bvnExecutorVersions", "protocol.PartitionExecutorVersion[]"),
	}, "NetworkStatus", "networkStatus")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("partition", "string"),
	}, "NetworkStatusOptions", "networkStatusOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("peerID", "p2p.PeerID"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("services", "ServiceAddress[]"),
		encoding.NewTypeField("version", "string"),
		encoding.NewTypeField("commit", "string"),
	}, "NodeInfo", "nodeInfo")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("peerID", "p2p.PeerID"),
	}, "NodeInfoOptions", "nodeInfoOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("range", "RangeOptions"),
	}, "PendingQuery", "pendingQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("publicKeyHash", "bytes"),
	}, "PublicKeyHashSearchQuery", "publicKeyHashSearchQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("queryType", "string"),
		encoding.NewTypeField("publicKey", "bytes"),
		encoding.NewTypeField("type", "string"),
	}, "PublicKeySearchQuery", "publicKeySearchQuery")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("start", "uint64"),
		encoding.NewTypeField("count", "uint64"),
		encoding.NewTypeField("expand", "bool"),
		encoding.NewTypeField("fromEnd", "bool"),
	}, "RangeOptions", "rangeOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("start", "bytes"),
		encoding.NewTypeField("startIndex", "int64"),
		encoding.NewTypeField("end", "bytes"),
		encoding.NewTypeField("endIndex", "int64"),
		encoding.NewTypeField("anchor", "bytes"),
		encoding.NewTypeField("entries", "merkle.ReceiptEntry[]"),
		encoding.NewTypeField("localBlock", "uint64"),
		encoding.NewTypeField("localBlockTime", "string"),
		encoding.NewTypeField("majorBlock", "uint64"),
	}, "Receipt", "receipt")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("forAny", "bool"),
		encoding.NewTypeField("forHeight", "uint64"),
	}, "ReceiptOptions", "receiptOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("records", "T[]"),
		encoding.NewTypeField("start", "uint64"),
		encoding.NewTypeField("total", "uint64"),
		encoding.NewTypeField("lastBlockTime", "string"),
	}, "RecordRange", "recordRange")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "ServiceType"),
		encoding.NewTypeField("argument", "string"),
	}, "ServiceAddress", "serviceAddress")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("account", "protocol.Account"),
		encoding.NewTypeField("signatures", "RecordRange[*MessageRecord[messaging.Message]]"),
	}, "SignatureSetRecord", "signatureSetRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("status", "protocol.TransactionStatus"),
		encoding.NewTypeField("success", "bool"),
		encoding.NewTypeField("message", "string"),
	}, "Submission", "submission")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("verify", "bool"),
		encoding.NewTypeField("wait", "bool"),
	}, "SubmitOptions", "submitOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("partition", "string"),
		encoding.NewTypeField("account", "string"),
	}, "SubscribeOptions", "subscribeOptions")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("value", "string"),
	}, "TxIDRecord", "txIDRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("recordType", "string"),
		encoding.NewTypeField("value", "string"),
	}, "UrlRecord", "urlRecord")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("full", "bool"),
	}, "ValidateOptions", "validateOptions")

}

func (v *AccountRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType    RecordType                                    `json:"recordType"`
		Account       *encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		Directory     *RecordRange[*UrlRecord]                      `json:"directory,omitempty"`
		Pending       *RecordRange[*TxIDRecord]                     `json:"pending,omitempty"`
		Receipt       *Receipt                                      `json:"receipt,omitempty"`
		LastBlockTime *time.Time                                    `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                       `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(protocol.EqualAccount(v.Account, nil)) {
		u.Account = &encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	}
	if !(v.Directory == nil) {
		u.Directory = v.Directory
	}
	if !(v.Pending == nil) {
		u.Pending = v.Pending
	}
	if !(v.Receipt == nil) {
		u.Receipt = v.Receipt
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *AnchorSearchQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType      QueryType       `json:"queryType"`
		Anchor         *string         `json:"anchor,omitempty"`
		IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty"`
		ExtraData      *string         `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(len(v.Anchor) == 0) {
		u.Anchor = encoding.BytesToJSON(v.Anchor)
	}
	if !(v.IncludeReceipt == nil) {
		u.IncludeReceipt = v.IncludeReceipt
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *BlockEvent) MarshalJSON() ([]byte, error) {
	u := struct {
		EventType EventType                                    `json:"eventType"`
		Partition string                                       `json:"partition,omitempty"`
		Index     uint64                                       `json:"index,omitempty"`
		Time      time.Time                                    `json:"time,omitempty"`
		Major     uint64                                       `json:"major,omitempty"`
		Entries   encoding.JsonList[*ChainEntryRecord[Record]] `json:"entries,omitempty"`
		ExtraData *string                                      `json:"$epilogue,omitempty"`
	}{}
	u.EventType = v.EventType()
	if !(len(v.Partition) == 0) {
		u.Partition = v.Partition
	}
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.Time == (time.Time{})) {
		u.Time = v.Time
	}
	if !(v.Major == 0) {
		u.Major = v.Major
	}
	if !(len(v.Entries) == 0) {
		u.Entries = v.Entries
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *BlockQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType  QueryType     `json:"queryType"`
		Minor      *uint64       `json:"minor,omitempty"`
		Major      *uint64       `json:"major,omitempty"`
		MinorRange *RangeOptions `json:"minorRange,omitempty"`
		MajorRange *RangeOptions `json:"majorRange,omitempty"`
		EntryRange *RangeOptions `json:"entryRange,omitempty"`
		OmitEmpty  bool          `json:"omitEmpty,omitempty"`
		ExtraData  *string       `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(v.Minor == nil) {
		u.Minor = v.Minor
	}
	if !(v.Major == nil) {
		u.Major = v.Major
	}
	if !(v.MinorRange == nil) {
		u.MinorRange = v.MinorRange
	}
	if !(v.MajorRange == nil) {
		u.MajorRange = v.MajorRange
	}
	if !(v.EntryRange == nil) {
		u.EntryRange = v.EntryRange
	}
	if !(!v.OmitEmpty) {
		u.OmitEmpty = v.OmitEmpty
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ChainEntryRecord[T]) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType    RecordType                     `json:"recordType"`
		Account       *url.URL                       `json:"account,omitempty"`
		Name          string                         `json:"name,omitempty"`
		Type          merkle.ChainType               `json:"type,omitempty"`
		Index         uint64                         `json:"index"`
		Entry         *string                        `json:"entry,omitempty"`
		Value         *encoding.JsonUnmarshalWith[T] `json:"value,omitempty"`
		Receipt       *Receipt                       `json:"receipt,omitempty"`
		State         encoding.JsonList[*string]     `json:"state,omitempty"`
		LastBlockTime *time.Time                     `json:"lastBlockTime,omitempty"`
		ExtraData     *string                        `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.Account == nil) {
		u.Account = v.Account
	}
	if !(len(v.Name) == 0) {
		u.Name = v.Name
	}
	if !(v.Type == 0) {
		u.Type = v.Type
	}
	u.Index = v.Index
	if !(v.Entry == ([32]byte{})) {
		u.Entry = encoding.ChainToJSON(&v.Entry)
	}
	if !(EqualRecord(v.Value, nil)) {
		u.Value = &encoding.JsonUnmarshalWith[T]{Value: v.Value, Func: func(b []byte) (T, error) { return encoding.Cast[T](UnmarshalRecordJSON(b)) }}
	}
	if !(v.Receipt == nil) {
		u.Receipt = v.Receipt
	}
	if !(len(v.State) == 0) {
		u.State = make(encoding.JsonList[*string], len(v.State))
		for i, x := range v.State {
			u.State[i] = encoding.BytesToJSON(x)
		}
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ChainQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType      QueryType       `json:"queryType"`
		Name           string          `json:"name,omitempty"`
		Index          *uint64         `json:"index,omitempty"`
		Entry          *string         `json:"entry,omitempty"`
		Range          *RangeOptions   `json:"range,omitempty"`
		IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty"`
		ExtraData      *string         `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(len(v.Name) == 0) {
		u.Name = v.Name
	}
	if !(v.Index == nil) {
		u.Index = v.Index
	}
	if !(len(v.Entry) == 0) {
		u.Entry = encoding.BytesToJSON(v.Entry)
	}
	if !(v.Range == nil) {
		u.Range = v.Range
	}
	if !(v.IncludeReceipt == nil) {
		u.IncludeReceipt = v.IncludeReceipt
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ChainRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType    RecordType                 `json:"recordType"`
		Name          string                     `json:"name,omitempty"`
		Type          merkle.ChainType           `json:"type,omitempty"`
		Count         uint64                     `json:"count,omitempty"`
		State         encoding.JsonList[*string] `json:"state,omitempty"`
		LastBlockTime *time.Time                 `json:"lastBlockTime,omitempty"`
		ExtraData     *string                    `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(len(v.Name) == 0) {
		u.Name = v.Name
	}
	if !(v.Type == 0) {
		u.Type = v.Type
	}
	if !(v.Count == 0) {
		u.Count = v.Count
	}
	if !(len(v.State) == 0) {
		u.State = make(encoding.JsonList[*string], len(v.State))
		for i, x := range v.State {
			u.State[i] = encoding.BytesToJSON(x)
		}
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ConsensusStatus) MarshalJSON() ([]byte, error) {
	u := struct {
		Ok               bool                                  `json:"ok,omitempty"`
		LastBlock        *LastBlock                            `json:"lastBlock,omitempty"`
		Version          string                                `json:"version,omitempty"`
		Commit           string                                `json:"commit,omitempty"`
		NodeKeyHash      *string                               `json:"nodeKeyHash,omitempty"`
		ValidatorKeyHash *string                               `json:"validatorKeyHash,omitempty"`
		PartitionID      string                                `json:"partitionID,omitempty"`
		PartitionType    protocol.PartitionType                `json:"partitionType,omitempty"`
		Peers            encoding.JsonList[*ConsensusPeerInfo] `json:"peers,omitempty"`
		ExtraData        *string                               `json:"$epilogue,omitempty"`
	}{}
	if !(!v.Ok) {
		u.Ok = v.Ok
	}
	if !(v.LastBlock == nil) {
		u.LastBlock = v.LastBlock
	}
	if !(len(v.Version) == 0) {
		u.Version = v.Version
	}
	if !(len(v.Commit) == 0) {
		u.Commit = v.Commit
	}
	if !(v.NodeKeyHash == ([32]byte{})) {
		u.NodeKeyHash = encoding.ChainToJSON(&v.NodeKeyHash)
	}
	if !(v.ValidatorKeyHash == ([32]byte{})) {
		u.ValidatorKeyHash = encoding.ChainToJSON(&v.ValidatorKeyHash)
	}
	if !(len(v.PartitionID) == 0) {
		u.PartitionID = v.PartitionID
	}
	if !(v.PartitionType == 0) {
		u.PartitionType = v.PartitionType
	}
	if !(len(v.Peers) == 0) {
		u.Peers = v.Peers
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *DataQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType QueryType     `json:"queryType"`
		Index     *uint64       `json:"index,omitempty"`
		Entry     *string       `json:"entry,omitempty"`
		Range     *RangeOptions `json:"range,omitempty"`
		ExtraData *string       `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(v.Index == nil) {
		u.Index = v.Index
	}
	if !(len(v.Entry) == 0) {
		u.Entry = encoding.BytesToJSON(v.Entry)
	}
	if !(v.Range == nil) {
		u.Range = v.Range
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *DefaultQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType      QueryType       `json:"queryType"`
		IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty"`
		ExtraData      *string         `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(v.IncludeReceipt == nil) {
		u.IncludeReceipt = v.IncludeReceipt
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *DelegateSearchQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType QueryType `json:"queryType"`
		Delegate  *url.URL  `json:"delegate,omitempty"`
		ExtraData *string   `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(v.Delegate == nil) {
		u.Delegate = v.Delegate
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *DirectoryQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType QueryType     `json:"queryType"`
		Range     *RangeOptions `json:"range,omitempty"`
		ExtraData *string       `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(v.Range == nil) {
		u.Range = v.Range
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ErrorEvent) MarshalJSON() ([]byte, error) {
	u := struct {
		EventType EventType      `json:"eventType"`
		Err       *errors2.Error `json:"err,omitempty"`
		ExtraData *string        `json:"$epilogue,omitempty"`
	}{}
	u.EventType = v.EventType()
	if !(v.Err == nil) {
		u.Err = v.Err
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ErrorRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType     `json:"recordType"`
		Value      *errors2.Error `json:"value,omitempty"`
		ExtraData  *string        `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *FindServiceOptions) MarshalJSON() ([]byte, error) {
	u := struct {
		Network   string          `json:"network,omitempty"`
		Service   *ServiceAddress `json:"service,omitempty"`
		Known     bool            `json:"known,omitempty"`
		Timeout   interface{}     `json:"timeout,omitempty"`
		ExtraData *string         `json:"$epilogue,omitempty"`
	}{}
	if !(len(v.Network) == 0) {
		u.Network = v.Network
	}
	if !(v.Service == nil) {
		u.Service = v.Service
	}
	if !(!v.Known) {
		u.Known = v.Known
	}
	if !(v.Timeout == 0) {
		u.Timeout = encoding.DurationToJSON(v.Timeout)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *FindServiceResult) MarshalJSON() ([]byte, error) {
	u := struct {
		PeerID    *encoding.JsonUnmarshalWith[p2p.PeerID]        `json:"peerID,omitempty"`
		Status    KnownPeerStatus                                `json:"status,omitempty"`
		Addresses *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"addresses,omitempty"`
		ExtraData *string                                        `json:"$epilogue,omitempty"`
	}{}
	if !(v.PeerID == ("")) {
		u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	}
	if !(v.Status == 0) {
		u.Status = v.Status
	}
	if !(len(v.Addresses) == 0) {
		u.Addresses = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Addresses, Func: p2p.UnmarshalMultiaddrJSON}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *GlobalsEvent) MarshalJSON() ([]byte, error) {
	u := struct {
		EventType EventType          `json:"eventType"`
		Old       *core.GlobalValues `json:"old,omitempty"`
		New       *core.GlobalValues `json:"new,omitempty"`
		ExtraData *string            `json:"$epilogue,omitempty"`
	}{}
	u.EventType = v.EventType()
	if !(v.Old == nil) {
		u.Old = v.Old
	}
	if !(v.New == nil) {
		u.New = v.New
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *IndexEntryRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType           `json:"recordType"`
		Value      *protocol.IndexEntry `json:"value,omitempty"`
		ExtraData  *string              `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *KeyRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType        `json:"recordType"`
		Authority  *url.URL          `json:"authority,omitempty"`
		Signer     *url.URL          `json:"signer,omitempty"`
		Version    uint64            `json:"version,omitempty"`
		Index      uint64            `json:"index,omitempty"`
		Entry      *protocol.KeySpec `json:"entry,omitempty"`
		ExtraData  *string           `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
	}
	if !(v.Version == 0) {
		u.Version = v.Version
	}
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.Entry == nil) {
		u.Entry = v.Entry
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *LastBlock) MarshalJSON() ([]byte, error) {
	u := struct {
		Height                int64     `json:"height,omitempty"`
		Time                  time.Time `json:"time,omitempty"`
		ChainRoot             *string   `json:"chainRoot,omitempty"`
		StateRoot             *string   `json:"stateRoot,omitempty"`
		DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty"`
		ExtraData             *string   `json:"$epilogue,omitempty"`
	}{}
	if !(v.Height == 0) {
		u.Height = v.Height
	}
	if !(v.Time == (time.Time{})) {
		u.Time = v.Time
	}
	if !(v.ChainRoot == ([32]byte{})) {
		u.ChainRoot = encoding.ChainToJSON(&v.ChainRoot)
	}
	if !(v.StateRoot == ([32]byte{})) {
		u.StateRoot = encoding.ChainToJSON(&v.StateRoot)
	}
	if !(v.DirectoryAnchorHeight == 0) {
		u.DirectoryAnchorHeight = v.DirectoryAnchorHeight
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *MajorBlockRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType    RecordType                      `json:"recordType"`
		Index         uint64                          `json:"index,omitempty"`
		Time          time.Time                       `json:"time,omitempty"`
		MinorBlocks   *RecordRange[*MinorBlockRecord] `json:"minorBlocks,omitempty"`
		LastBlockTime *time.Time                      `json:"lastBlockTime,omitempty"`
		ExtraData     *string                         `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.Time == (time.Time{})) {
		u.Time = v.Time
	}
	if !(v.MinorBlocks == nil) {
		u.MinorBlocks = v.MinorBlocks
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *MessageHashSearchQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType QueryType `json:"queryType"`
		Hash      *string   `json:"hash,omitempty"`
		ExtraData *string   `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(&v.Hash)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *MessageRecord[T]) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType    RecordType                                              `json:"recordType"`
		ID            *url.TxID                                               `json:"id,omitempty"`
		Message       *encoding.JsonUnmarshalWith[T]                          `json:"message,omitempty"`
		Status        errors2.Status                                          `json:"status,omitempty"`
		StatusNo      uint64                                                  `json:"statusNo,omitempty"`
		Error         *errors2.Error                                          `json:"error,omitempty"`
		Result        *encoding.JsonUnmarshalWith[protocol.TransactionResult] `json:"result,omitempty"`
		Received      uint64                                                  `json:"received,omitempty"`
		Produced      *RecordRange[*TxIDRecord]                               `json:"produced,omitempty"`
		Cause         *RecordRange[*TxIDRecord]                               `json:"cause,omitempty"`
		Signatures    *RecordRange[*SignatureSetRecord]                       `json:"signatures,omitempty"`
		Historical    bool                                                    `json:"historical,omitempty"`
		Sequence      *messaging.SequencedMessage                             `json:"sequence,omitempty"`
		SourceReceipt *merkle.Receipt                                         `json:"sourceReceipt,omitempty"`
		LastBlockTime *time.Time                                              `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                                 `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.ID == nil) {
		u.ID = v.ID
	}
	if !(messaging.EqualMessage(v.Message, nil)) {
		u.Message = &encoding.JsonUnmarshalWith[T]{Value: v.Message, Func: func(b []byte) (T, error) { return encoding.Cast[T](messaging.UnmarshalMessageJSON(b)) }}
	}
	if !(v.Status == 0) {
		u.Status = v.Status
	}
	if !(v.StatusNo() == 0) {
		u.StatusNo = v.StatusNo()
	}
	if !(v.Error == nil) {
		u.Error = v.Error
	}
	if !(protocol.EqualTransactionResult(v.Result, nil)) {
		u.Result = &encoding.JsonUnmarshalWith[protocol.TransactionResult]{Value: v.Result, Func: protocol.UnmarshalTransactionResultJSON}
	}
	if !(v.Received == 0) {
		u.Received = v.Received
	}
	if !(v.Produced == nil) {
		u.Produced = v.Produced
	}
	if !(v.Cause == nil) {
		u.Cause = v.Cause
	}
	if !(v.Signatures == nil) {
		u.Signatures = v.Signatures
	}
	if !(!v.Historical) {
		u.Historical = v.Historical
	}
	if !(v.Sequence == nil) {
		u.Sequence = v.Sequence
	}
	if !(v.SourceReceipt == nil) {
		u.SourceReceipt = v.SourceReceipt
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *MinorBlockRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType    RecordType                              `json:"recordType"`
		Index         uint64                                  `json:"index,omitempty"`
		Time          *time.Time                              `json:"time,omitempty"`
		Source        *url.URL                                `json:"source,omitempty"`
		Entries       *RecordRange[*ChainEntryRecord[Record]] `json:"entries,omitempty"`
		Anchored      *RecordRange[*MinorBlockRecord]         `json:"anchored,omitempty"`
		LastBlockTime *time.Time                              `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.Time == nil) {
		u.Time = v.Time
	}
	if !(v.Source == nil) {
		u.Source = v.Source
	}
	if !(v.Entries == nil) {
		u.Entries = v.Entries
	}
	if !(v.Anchored == nil) {
		u.Anchored = v.Anchored
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *NetworkStatus) MarshalJSON() ([]byte, error) {
	u := struct {
		Oracle              *protocol.AcmeOracle                                  `json:"oracle,omitempty"`
		Globals             *protocol.NetworkGlobals                              `json:"globals,omitempty"`
		Network             *protocol.NetworkDefinition                           `json:"network,omitempty"`
		Routing             *protocol.RoutingTable                                `json:"routing,omitempty"`
		ExecutorVersion     protocol.ExecutorVersion                              `json:"executorVersion,omitempty"`
		DirectoryHeight     uint64                                                `json:"directoryHeight,omitempty"`
		MajorBlockHeight    uint64                                                `json:"majorBlockHeight,omitempty"`
		BvnExecutorVersions encoding.JsonList[*protocol.PartitionExecutorVersion] `json:"bvnExecutorVersions,omitempty"`
		ExtraData           *string                                               `json:"$epilogue,omitempty"`
	}{}
	if !(v.Oracle == nil) {
		u.Oracle = v.Oracle
	}
	if !(v.Globals == nil) {
		u.Globals = v.Globals
	}
	if !(v.Network == nil) {
		u.Network = v.Network
	}
	if !(v.Routing == nil) {
		u.Routing = v.Routing
	}
	if !(v.ExecutorVersion == 0) {
		u.ExecutorVersion = v.ExecutorVersion
	}
	if !(v.DirectoryHeight == 0) {
		u.DirectoryHeight = v.DirectoryHeight
	}
	if !(v.MajorBlockHeight == 0) {
		u.MajorBlockHeight = v.MajorBlockHeight
	}
	if !(len(v.BvnExecutorVersions) == 0) {
		u.BvnExecutorVersions = v.BvnExecutorVersions
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *NodeInfo) MarshalJSON() ([]byte, error) {
	u := struct {
		PeerID    *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"peerID,omitempty"`
		Network   string                                  `json:"network,omitempty"`
		Services  encoding.JsonList[*ServiceAddress]      `json:"services,omitempty"`
		Version   string                                  `json:"version,omitempty"`
		Commit    string                                  `json:"commit,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	if !(v.PeerID == ("")) {
		u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	}
	if !(len(v.Network) == 0) {
		u.Network = v.Network
	}
	if !(len(v.Services) == 0) {
		u.Services = v.Services
	}
	if !(len(v.Version) == 0) {
		u.Version = v.Version
	}
	if !(len(v.Commit) == 0) {
		u.Commit = v.Commit
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *NodeInfoOptions) MarshalJSON() ([]byte, error) {
	u := struct {
		PeerID    *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"peerID,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	if !(v.PeerID == ("")) {
		u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *PendingQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType QueryType     `json:"queryType"`
		Range     *RangeOptions `json:"range,omitempty"`
		ExtraData *string       `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(v.Range == nil) {
		u.Range = v.Range
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *PublicKeyHashSearchQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType     QueryType `json:"queryType"`
		PublicKeyHash *string   `json:"publicKeyHash,omitempty"`
		ExtraData     *string   `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(len(v.PublicKeyHash) == 0) {
		u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *PublicKeySearchQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		QueryType QueryType              `json:"queryType"`
		PublicKey *string                `json:"publicKey,omitempty"`
		Type      protocol.SignatureType `json:"type,omitempty"`
		ExtraData *string                `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(v.Type == 0) {
		u.Type = v.Type
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *Receipt) MarshalJSON() ([]byte, error) {
	u := struct {
		Start          *string                                 `json:"start,omitempty"`
		StartIndex     int64                                   `json:"startIndex,omitempty"`
		End            *string                                 `json:"end,omitempty"`
		EndIndex       int64                                   `json:"endIndex,omitempty"`
		Anchor         *string                                 `json:"anchor,omitempty"`
		Entries        encoding.JsonList[*merkle.ReceiptEntry] `json:"entries,omitempty"`
		LocalBlock     uint64                                  `json:"localBlock,omitempty"`
		LocalBlockTime time.Time                               `json:"localBlockTime,omitempty"`
		MajorBlock     uint64                                  `json:"majorBlock,omitempty"`
		ExtraData      *string                                 `json:"$epilogue,omitempty"`
	}{}
	if !(len(v.Receipt.Start) == 0) {
		u.Start = encoding.BytesToJSON(v.Receipt.Start)
	}
	if !(v.Receipt.StartIndex == 0) {
		u.StartIndex = v.Receipt.StartIndex
	}
	if !(len(v.Receipt.End) == 0) {
		u.End = encoding.BytesToJSON(v.Receipt.End)
	}
	if !(v.Receipt.EndIndex == 0) {
		u.EndIndex = v.Receipt.EndIndex
	}
	if !(len(v.Receipt.Anchor) == 0) {
		u.Anchor = encoding.BytesToJSON(v.Receipt.Anchor)
	}
	if !(len(v.Receipt.Entries) == 0) {
		u.Entries = v.Receipt.Entries
	}
	if !(v.LocalBlock == 0) {
		u.LocalBlock = v.LocalBlock
	}
	if !(v.LocalBlockTime == (time.Time{})) {
		u.LocalBlockTime = v.LocalBlockTime
	}
	if !(v.MajorBlock == 0) {
		u.MajorBlock = v.MajorBlock
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *RecordRange[T]) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType    RecordType                         `json:"recordType"`
		Records       *encoding.JsonUnmarshalListWith[T] `json:"records,omitempty"`
		Start         uint64                             `json:"start"`
		Total         uint64                             `json:"total"`
		LastBlockTime *time.Time                         `json:"lastBlockTime,omitempty"`
		ExtraData     *string                            `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(len(v.Records) == 0) {
		u.Records = &encoding.JsonUnmarshalListWith[T]{Value: v.Records, Func: func(b []byte) (T, error) { return encoding.Cast[T](UnmarshalRecordJSON(b)) }}
	}
	u.Start = v.Start
	u.Total = v.Total
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SignatureSetRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType                                      `json:"recordType"`
		Account    *encoding.JsonUnmarshalWith[protocol.Account]   `json:"account,omitempty"`
		Signatures *RecordRange[*MessageRecord[messaging.Message]] `json:"signatures,omitempty"`
		ExtraData  *string                                         `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(protocol.EqualAccount(v.Account, nil)) {
		u.Account = &encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	}
	if !(v.Signatures == nil) {
		u.Signatures = v.Signatures
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *TxIDRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType `json:"recordType"`
		Value      *url.TxID  `json:"value,omitempty"`
		ExtraData  *string    `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *UrlRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType `json:"recordType"`
		Value      *url.URL   `json:"value,omitempty"`
		ExtraData  *string    `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *AccountRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType    RecordType                                    `json:"recordType"`
		Account       *encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		Directory     *RecordRange[*UrlRecord]                      `json:"directory,omitempty"`
		Pending       *RecordRange[*TxIDRecord]                     `json:"pending,omitempty"`
		Receipt       *Receipt                                      `json:"receipt,omitempty"`
		LastBlockTime *time.Time                                    `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                       `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Account = &encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Directory = v.Directory
	u.Pending = v.Pending
	u.Receipt = v.Receipt
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	if u.Account != nil {
		v.Account = u.Account.Value
	}

	v.Directory = u.Directory
	v.Pending = u.Pending
	v.Receipt = u.Receipt
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *AnchorSearchQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType      QueryType       `json:"queryType"`
		Anchor         *string         `json:"anchor,omitempty"`
		IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty"`
		ExtraData      *string         `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.Anchor = encoding.BytesToJSON(v.Anchor)
	u.IncludeReceipt = v.IncludeReceipt
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	if x, err := encoding.BytesFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Anchor = x
	}
	v.IncludeReceipt = u.IncludeReceipt
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *BlockEvent) UnmarshalJSON(data []byte) error {
	u := struct {
		EventType EventType                                    `json:"eventType"`
		Partition string                                       `json:"partition,omitempty"`
		Index     uint64                                       `json:"index,omitempty"`
		Time      time.Time                                    `json:"time,omitempty"`
		Major     uint64                                       `json:"major,omitempty"`
		Entries   encoding.JsonList[*ChainEntryRecord[Record]] `json:"entries,omitempty"`
		ExtraData *string                                      `json:"$epilogue,omitempty"`
	}{}
	u.EventType = v.EventType()
	u.Partition = v.Partition
	u.Index = v.Index
	u.Time = v.Time
	u.Major = v.Major
	u.Entries = v.Entries
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.EventType() == u.EventType) {
		return fmt.Errorf("field EventType: not equal: want %v, got %v", v.EventType(), u.EventType)
	}
	v.Partition = u.Partition
	v.Index = u.Index
	v.Time = u.Time
	v.Major = u.Major
	v.Entries = u.Entries
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *BlockQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType  QueryType     `json:"queryType"`
		Minor      *uint64       `json:"minor,omitempty"`
		Major      *uint64       `json:"major,omitempty"`
		MinorRange *RangeOptions `json:"minorRange,omitempty"`
		MajorRange *RangeOptions `json:"majorRange,omitempty"`
		EntryRange *RangeOptions `json:"entryRange,omitempty"`
		OmitEmpty  bool          `json:"omitEmpty,omitempty"`
		ExtraData  *string       `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.Minor = v.Minor
	u.Major = v.Major
	u.MinorRange = v.MinorRange
	u.MajorRange = v.MajorRange
	u.EntryRange = v.EntryRange
	u.OmitEmpty = v.OmitEmpty
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	v.Minor = u.Minor
	v.Major = u.Major
	v.MinorRange = u.MinorRange
	v.MajorRange = u.MajorRange
	v.EntryRange = u.EntryRange
	v.OmitEmpty = u.OmitEmpty
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ChainEntryRecord[T]) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType    RecordType                     `json:"recordType"`
		Account       *url.URL                       `json:"account,omitempty"`
		Name          string                         `json:"name,omitempty"`
		Type          merkle.ChainType               `json:"type,omitempty"`
		Index         uint64                         `json:"index"`
		Entry         *string                        `json:"entry,omitempty"`
		Value         *encoding.JsonUnmarshalWith[T] `json:"value,omitempty"`
		Receipt       *Receipt                       `json:"receipt,omitempty"`
		State         encoding.JsonList[*string]     `json:"state,omitempty"`
		LastBlockTime *time.Time                     `json:"lastBlockTime,omitempty"`
		ExtraData     *string                        `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Account = v.Account
	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.Entry = encoding.ChainToJSON(&v.Entry)
	u.Value = &encoding.JsonUnmarshalWith[T]{Value: v.Value, Func: func(b []byte) (T, error) { return encoding.Cast[T](UnmarshalRecordJSON(b)) }}
	u.Receipt = v.Receipt
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Account = u.Account
	v.Name = u.Name
	v.Type = u.Type
	v.Index = u.Index
	if x, err := encoding.ChainFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = *x
	}
	if u.Value != nil {
		v.Value = u.Value.Value
	}

	v.Receipt = u.Receipt
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ChainQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType      QueryType       `json:"queryType"`
		Name           string          `json:"name,omitempty"`
		Index          *uint64         `json:"index,omitempty"`
		Entry          *string         `json:"entry,omitempty"`
		Range          *RangeOptions   `json:"range,omitempty"`
		IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty"`
		ExtraData      *string         `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.Name = v.Name
	u.Index = v.Index
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Range = v.Range
	u.IncludeReceipt = v.IncludeReceipt
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	v.Name = u.Name
	v.Index = u.Index
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.Range = u.Range
	v.IncludeReceipt = u.IncludeReceipt
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ChainRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType    RecordType                 `json:"recordType"`
		Name          string                     `json:"name,omitempty"`
		Type          merkle.ChainType           `json:"type,omitempty"`
		Count         uint64                     `json:"count,omitempty"`
		State         encoding.JsonList[*string] `json:"state,omitempty"`
		LastBlockTime *time.Time                 `json:"lastBlockTime,omitempty"`
		ExtraData     *string                    `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Name = u.Name
	v.Type = u.Type
	v.Count = u.Count
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ConsensusStatus) UnmarshalJSON(data []byte) error {
	u := struct {
		Ok               bool                                  `json:"ok,omitempty"`
		LastBlock        *LastBlock                            `json:"lastBlock,omitempty"`
		Version          string                                `json:"version,omitempty"`
		Commit           string                                `json:"commit,omitempty"`
		NodeKeyHash      *string                               `json:"nodeKeyHash,omitempty"`
		ValidatorKeyHash *string                               `json:"validatorKeyHash,omitempty"`
		PartitionID      string                                `json:"partitionID,omitempty"`
		PartitionType    protocol.PartitionType                `json:"partitionType,omitempty"`
		Peers            encoding.JsonList[*ConsensusPeerInfo] `json:"peers,omitempty"`
		ExtraData        *string                               `json:"$epilogue,omitempty"`
	}{}
	u.Ok = v.Ok
	u.LastBlock = v.LastBlock
	u.Version = v.Version
	u.Commit = v.Commit
	u.NodeKeyHash = encoding.ChainToJSON(&v.NodeKeyHash)
	u.ValidatorKeyHash = encoding.ChainToJSON(&v.ValidatorKeyHash)
	u.PartitionID = v.PartitionID
	u.PartitionType = v.PartitionType
	u.Peers = v.Peers
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Ok = u.Ok
	v.LastBlock = u.LastBlock
	v.Version = u.Version
	v.Commit = u.Commit
	if x, err := encoding.ChainFromJSON(u.NodeKeyHash); err != nil {
		return fmt.Errorf("error decoding NodeKeyHash: %w", err)
	} else {
		v.NodeKeyHash = *x
	}
	if x, err := encoding.ChainFromJSON(u.ValidatorKeyHash); err != nil {
		return fmt.Errorf("error decoding ValidatorKeyHash: %w", err)
	} else {
		v.ValidatorKeyHash = *x
	}
	v.PartitionID = u.PartitionID
	v.PartitionType = u.PartitionType
	v.Peers = u.Peers
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *DataQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType QueryType     `json:"queryType"`
		Index     *uint64       `json:"index,omitempty"`
		Entry     *string       `json:"entry,omitempty"`
		Range     *RangeOptions `json:"range,omitempty"`
		ExtraData *string       `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.Index = v.Index
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Range = v.Range
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	v.Index = u.Index
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.Range = u.Range
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *DefaultQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType      QueryType       `json:"queryType"`
		IncludeReceipt *ReceiptOptions `json:"includeReceipt,omitempty"`
		ExtraData      *string         `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.IncludeReceipt = v.IncludeReceipt
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	v.IncludeReceipt = u.IncludeReceipt
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *DelegateSearchQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType QueryType `json:"queryType"`
		Delegate  *url.URL  `json:"delegate,omitempty"`
		ExtraData *string   `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.Delegate = v.Delegate
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	v.Delegate = u.Delegate
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *DirectoryQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType QueryType     `json:"queryType"`
		Range     *RangeOptions `json:"range,omitempty"`
		ExtraData *string       `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.Range = v.Range
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	v.Range = u.Range
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ErrorEvent) UnmarshalJSON(data []byte) error {
	u := struct {
		EventType EventType      `json:"eventType"`
		Err       *errors2.Error `json:"err,omitempty"`
		ExtraData *string        `json:"$epilogue,omitempty"`
	}{}
	u.EventType = v.EventType()
	u.Err = v.Err
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.EventType() == u.EventType) {
		return fmt.Errorf("field EventType: not equal: want %v, got %v", v.EventType(), u.EventType)
	}
	v.Err = u.Err
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ErrorRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType     `json:"recordType"`
		Value      *errors2.Error `json:"value,omitempty"`
		ExtraData  *string        `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *FindServiceOptions) UnmarshalJSON(data []byte) error {
	u := struct {
		Network   string          `json:"network,omitempty"`
		Service   *ServiceAddress `json:"service,omitempty"`
		Known     bool            `json:"known,omitempty"`
		Timeout   interface{}     `json:"timeout,omitempty"`
		ExtraData *string         `json:"$epilogue,omitempty"`
	}{}
	u.Network = v.Network
	u.Service = v.Service
	u.Known = v.Known
	u.Timeout = encoding.DurationToJSON(v.Timeout)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Network = u.Network
	v.Service = u.Service
	v.Known = u.Known
	if x, err := encoding.DurationFromJSON(u.Timeout); err != nil {
		return fmt.Errorf("error decoding Timeout: %w", err)
	} else {
		v.Timeout = x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *FindServiceResult) UnmarshalJSON(data []byte) error {
	u := struct {
		PeerID    *encoding.JsonUnmarshalWith[p2p.PeerID]        `json:"peerID,omitempty"`
		Status    KnownPeerStatus                                `json:"status,omitempty"`
		Addresses *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"addresses,omitempty"`
		ExtraData *string                                        `json:"$epilogue,omitempty"`
	}{}
	u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	u.Status = v.Status
	u.Addresses = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Addresses, Func: p2p.UnmarshalMultiaddrJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if u.PeerID != nil {
		v.PeerID = u.PeerID.Value
	}

	v.Status = u.Status
	if u.Addresses != nil && u.Addresses.Value != nil {
		v.Addresses = make([]p2p.Multiaddr, len(u.Addresses.Value))
		for i, x := range u.Addresses.Value {
			v.Addresses[i] = x
		}
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *GlobalsEvent) UnmarshalJSON(data []byte) error {
	u := struct {
		EventType EventType          `json:"eventType"`
		Old       *core.GlobalValues `json:"old,omitempty"`
		New       *core.GlobalValues `json:"new,omitempty"`
		ExtraData *string            `json:"$epilogue,omitempty"`
	}{}
	u.EventType = v.EventType()
	u.Old = v.Old
	u.New = v.New
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.EventType() == u.EventType) {
		return fmt.Errorf("field EventType: not equal: want %v, got %v", v.EventType(), u.EventType)
	}
	v.Old = u.Old
	v.New = u.New
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *IndexEntryRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType           `json:"recordType"`
		Value      *protocol.IndexEntry `json:"value,omitempty"`
		ExtraData  *string              `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *KeyRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType        `json:"recordType"`
		Authority  *url.URL          `json:"authority,omitempty"`
		Signer     *url.URL          `json:"signer,omitempty"`
		Version    uint64            `json:"version,omitempty"`
		Index      uint64            `json:"index,omitempty"`
		Entry      *protocol.KeySpec `json:"entry,omitempty"`
		ExtraData  *string           `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Authority = v.Authority
	u.Signer = v.Signer
	u.Version = v.Version
	u.Index = v.Index
	u.Entry = v.Entry
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Authority = u.Authority
	v.Signer = u.Signer
	v.Version = u.Version
	v.Index = u.Index
	v.Entry = u.Entry
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *LastBlock) UnmarshalJSON(data []byte) error {
	u := struct {
		Height                int64     `json:"height,omitempty"`
		Time                  time.Time `json:"time,omitempty"`
		ChainRoot             *string   `json:"chainRoot,omitempty"`
		StateRoot             *string   `json:"stateRoot,omitempty"`
		DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty"`
		ExtraData             *string   `json:"$epilogue,omitempty"`
	}{}
	u.Height = v.Height
	u.Time = v.Time
	u.ChainRoot = encoding.ChainToJSON(&v.ChainRoot)
	u.StateRoot = encoding.ChainToJSON(&v.StateRoot)
	u.DirectoryAnchorHeight = v.DirectoryAnchorHeight
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Height = u.Height
	v.Time = u.Time
	if x, err := encoding.ChainFromJSON(u.ChainRoot); err != nil {
		return fmt.Errorf("error decoding ChainRoot: %w", err)
	} else {
		v.ChainRoot = *x
	}
	if x, err := encoding.ChainFromJSON(u.StateRoot); err != nil {
		return fmt.Errorf("error decoding StateRoot: %w", err)
	} else {
		v.StateRoot = *x
	}
	v.DirectoryAnchorHeight = u.DirectoryAnchorHeight
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *MajorBlockRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType    RecordType                      `json:"recordType"`
		Index         uint64                          `json:"index,omitempty"`
		Time          time.Time                       `json:"time,omitempty"`
		MinorBlocks   *RecordRange[*MinorBlockRecord] `json:"minorBlocks,omitempty"`
		LastBlockTime *time.Time                      `json:"lastBlockTime,omitempty"`
		ExtraData     *string                         `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Index = v.Index
	u.Time = v.Time
	u.MinorBlocks = v.MinorBlocks
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Index = u.Index
	v.Time = u.Time
	v.MinorBlocks = u.MinorBlocks
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *MessageHashSearchQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType QueryType `json:"queryType"`
		Hash      *string   `json:"hash,omitempty"`
		ExtraData *string   `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.Hash = encoding.ChainToJSON(&v.Hash)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = *x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *MessageRecord[T]) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType    RecordType                                              `json:"recordType"`
		ID            *url.TxID                                               `json:"id,omitempty"`
		Message       *encoding.JsonUnmarshalWith[T]                          `json:"message,omitempty"`
		Status        errors2.Status                                          `json:"status,omitempty"`
		StatusNo      uint64                                                  `json:"statusNo,omitempty"`
		Error         *errors2.Error                                          `json:"error,omitempty"`
		Result        *encoding.JsonUnmarshalWith[protocol.TransactionResult] `json:"result,omitempty"`
		Received      uint64                                                  `json:"received,omitempty"`
		Produced      *RecordRange[*TxIDRecord]                               `json:"produced,omitempty"`
		Cause         *RecordRange[*TxIDRecord]                               `json:"cause,omitempty"`
		Signatures    *RecordRange[*SignatureSetRecord]                       `json:"signatures,omitempty"`
		Historical    bool                                                    `json:"historical,omitempty"`
		Sequence      *messaging.SequencedMessage                             `json:"sequence,omitempty"`
		SourceReceipt *merkle.Receipt                                         `json:"sourceReceipt,omitempty"`
		LastBlockTime *time.Time                                              `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                                 `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.ID = v.ID
	u.Message = &encoding.JsonUnmarshalWith[T]{Value: v.Message, Func: func(b []byte) (T, error) { return encoding.Cast[T](messaging.UnmarshalMessageJSON(b)) }}
	u.Status = v.Status
	u.StatusNo = v.StatusNo()
	u.Error = v.Error
	u.Result = &encoding.JsonUnmarshalWith[protocol.TransactionResult]{Value: v.Result, Func: protocol.UnmarshalTransactionResultJSON}
	u.Received = v.Received
	u.Produced = v.Produced
	u.Cause = v.Cause
	u.Signatures = v.Signatures
	u.Historical = v.Historical
	u.Sequence = v.Sequence
	u.SourceReceipt = v.SourceReceipt
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.ID = u.ID
	if u.Message != nil {
		v.Message = u.Message.Value
	}

	v.Status = u.Status
	v.Error = u.Error
	if u.Result != nil {
		v.Result = u.Result.Value
	}

	v.Received = u.Received
	v.Produced = u.Produced
	v.Cause = u.Cause
	v.Signatures = u.Signatures
	v.Historical = u.Historical
	v.Sequence = u.Sequence
	v.SourceReceipt = u.SourceReceipt
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *MinorBlockRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType    RecordType                              `json:"recordType"`
		Index         uint64                                  `json:"index,omitempty"`
		Time          *time.Time                              `json:"time,omitempty"`
		Source        *url.URL                                `json:"source,omitempty"`
		Entries       *RecordRange[*ChainEntryRecord[Record]] `json:"entries,omitempty"`
		Anchored      *RecordRange[*MinorBlockRecord]         `json:"anchored,omitempty"`
		LastBlockTime *time.Time                              `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Index = v.Index
	u.Time = v.Time
	u.Source = v.Source
	u.Entries = v.Entries
	u.Anchored = v.Anchored
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Index = u.Index
	v.Time = u.Time
	v.Source = u.Source
	v.Entries = u.Entries
	v.Anchored = u.Anchored
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *NetworkStatus) UnmarshalJSON(data []byte) error {
	u := struct {
		Oracle              *protocol.AcmeOracle                                  `json:"oracle,omitempty"`
		Globals             *protocol.NetworkGlobals                              `json:"globals,omitempty"`
		Network             *protocol.NetworkDefinition                           `json:"network,omitempty"`
		Routing             *protocol.RoutingTable                                `json:"routing,omitempty"`
		ExecutorVersion     protocol.ExecutorVersion                              `json:"executorVersion,omitempty"`
		DirectoryHeight     uint64                                                `json:"directoryHeight,omitempty"`
		MajorBlockHeight    uint64                                                `json:"majorBlockHeight,omitempty"`
		BvnExecutorVersions encoding.JsonList[*protocol.PartitionExecutorVersion] `json:"bvnExecutorVersions,omitempty"`
		ExtraData           *string                                               `json:"$epilogue,omitempty"`
	}{}
	u.Oracle = v.Oracle
	u.Globals = v.Globals
	u.Network = v.Network
	u.Routing = v.Routing
	u.ExecutorVersion = v.ExecutorVersion
	u.DirectoryHeight = v.DirectoryHeight
	u.MajorBlockHeight = v.MajorBlockHeight
	u.BvnExecutorVersions = v.BvnExecutorVersions
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Oracle = u.Oracle
	v.Globals = u.Globals
	v.Network = u.Network
	v.Routing = u.Routing
	v.ExecutorVersion = u.ExecutorVersion
	v.DirectoryHeight = u.DirectoryHeight
	v.MajorBlockHeight = u.MajorBlockHeight
	v.BvnExecutorVersions = u.BvnExecutorVersions
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *NodeInfo) UnmarshalJSON(data []byte) error {
	u := struct {
		PeerID    *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"peerID,omitempty"`
		Network   string                                  `json:"network,omitempty"`
		Services  encoding.JsonList[*ServiceAddress]      `json:"services,omitempty"`
		Version   string                                  `json:"version,omitempty"`
		Commit    string                                  `json:"commit,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	u.Network = v.Network
	u.Services = v.Services
	u.Version = v.Version
	u.Commit = v.Commit
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if u.PeerID != nil {
		v.PeerID = u.PeerID.Value
	}

	v.Network = u.Network
	v.Services = u.Services
	v.Version = u.Version
	v.Commit = u.Commit
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *NodeInfoOptions) UnmarshalJSON(data []byte) error {
	u := struct {
		PeerID    *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"peerID,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if u.PeerID != nil {
		v.PeerID = u.PeerID.Value
	}

	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *PendingQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType QueryType     `json:"queryType"`
		Range     *RangeOptions `json:"range,omitempty"`
		ExtraData *string       `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.Range = v.Range
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	v.Range = u.Range
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *PublicKeyHashSearchQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType     QueryType `json:"queryType"`
		PublicKeyHash *string   `json:"publicKeyHash,omitempty"`
		ExtraData     *string   `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.PublicKeyHash = encoding.BytesToJSON(v.PublicKeyHash)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKeyHash); err != nil {
		return fmt.Errorf("error decoding PublicKeyHash: %w", err)
	} else {
		v.PublicKeyHash = x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *PublicKeySearchQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		QueryType QueryType              `json:"queryType"`
		PublicKey *string                `json:"publicKey,omitempty"`
		Type      protocol.SignatureType `json:"type,omitempty"`
		ExtraData *string                `json:"$epilogue,omitempty"`
	}{}
	u.QueryType = v.QueryType()
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Type = v.Type
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.QueryType() == u.QueryType) {
		return fmt.Errorf("field QueryType: not equal: want %v, got %v", v.QueryType(), u.QueryType)
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	v.Type = u.Type
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *Receipt) UnmarshalJSON(data []byte) error {
	u := struct {
		Start          *string                                 `json:"start,omitempty"`
		StartIndex     int64                                   `json:"startIndex,omitempty"`
		End            *string                                 `json:"end,omitempty"`
		EndIndex       int64                                   `json:"endIndex,omitempty"`
		Anchor         *string                                 `json:"anchor,omitempty"`
		Entries        encoding.JsonList[*merkle.ReceiptEntry] `json:"entries,omitempty"`
		LocalBlock     uint64                                  `json:"localBlock,omitempty"`
		LocalBlockTime time.Time                               `json:"localBlockTime,omitempty"`
		MajorBlock     uint64                                  `json:"majorBlock,omitempty"`
		ExtraData      *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Receipt.Start)
	u.StartIndex = v.Receipt.StartIndex
	u.End = encoding.BytesToJSON(v.Receipt.End)
	u.EndIndex = v.Receipt.EndIndex
	u.Anchor = encoding.BytesToJSON(v.Receipt.Anchor)
	u.Entries = v.Receipt.Entries
	u.LocalBlock = v.LocalBlock
	u.LocalBlockTime = v.LocalBlockTime
	u.MajorBlock = v.MajorBlock
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Start); err != nil {
		return fmt.Errorf("error decoding Start: %w", err)
	} else {
		v.Receipt.Start = x
	}
	v.Receipt.StartIndex = u.StartIndex
	if x, err := encoding.BytesFromJSON(u.End); err != nil {
		return fmt.Errorf("error decoding End: %w", err)
	} else {
		v.Receipt.End = x
	}
	v.Receipt.EndIndex = u.EndIndex
	if x, err := encoding.BytesFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Receipt.Anchor = x
	}
	v.Receipt.Entries = u.Entries
	v.LocalBlock = u.LocalBlock
	v.LocalBlockTime = u.LocalBlockTime
	v.MajorBlock = u.MajorBlock
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *RecordRange[T]) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType    RecordType                         `json:"recordType"`
		Records       *encoding.JsonUnmarshalListWith[T] `json:"records,omitempty"`
		Start         uint64                             `json:"start"`
		Total         uint64                             `json:"total"`
		LastBlockTime *time.Time                         `json:"lastBlockTime,omitempty"`
		ExtraData     *string                            `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Records = &encoding.JsonUnmarshalListWith[T]{Value: v.Records, Func: func(b []byte) (T, error) { return encoding.Cast[T](UnmarshalRecordJSON(b)) }}
	u.Start = v.Start
	u.Total = v.Total
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	if u.Records != nil && u.Records.Value != nil {
		v.Records = make([]T, len(u.Records.Value))
		for i, x := range u.Records.Value {
			v.Records[i] = x
		}
	}
	v.Start = u.Start
	v.Total = u.Total
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SignatureSetRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType                                      `json:"recordType"`
		Account    *encoding.JsonUnmarshalWith[protocol.Account]   `json:"account,omitempty"`
		Signatures *RecordRange[*MessageRecord[messaging.Message]] `json:"signatures,omitempty"`
		ExtraData  *string                                         `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Account = &encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Signatures = v.Signatures
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	if u.Account != nil {
		v.Account = u.Account.Value
	}

	v.Signatures = u.Signatures
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *TxIDRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType `json:"recordType"`
		Value      *url.TxID  `json:"value,omitempty"`
		ExtraData  *string    `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *UrlRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType `json:"recordType"`
		Value      *url.URL   `json:"value,omitempty"`
		ExtraData  *string    `json:"$epilogue,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}
