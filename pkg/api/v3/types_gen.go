package api

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/smt/managed"
)

type AccountRecord struct {
	fieldsSet []bool
	Account   protocol.Account          `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Directory *RecordRange[*UrlRecord]  `json:"directory,omitempty" form:"directory" query:"directory" validate:"required"`
	Pending   *RecordRange[*TxIDRecord] `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	Receipt   *Receipt                  `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	extraData []byte
}

type BlockEntry struct {
	fieldsSet []bool
	protocol.BlockEntry
	Value       []byte                `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	TxID        *url.TxID             `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Transaction *protocol.Transaction `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signature   protocol.Signature    `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	extraData   []byte
}

type BlockEvent struct {
	fieldsSet []bool
	Partition string        `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	Index     uint64        `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Time      time.Time     `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	Major     uint64        `json:"major,omitempty" form:"major" query:"major" validate:"required"`
	Entries   []*BlockEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type ChainEntryRecord[T Record] struct {
	fieldsSet []bool
	Name      string            `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      managed.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Index     uint64            `json:"index" form:"index" query:"index" validate:"required"`
	Entry     [32]byte          `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	Value     T                 `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	Receipt   *Receipt          `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	extraData []byte
}

type ChainRecord struct {
	fieldsSet []bool
	Name      string            `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      managed.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Count     uint64            `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	State     [][]byte          `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	extraData []byte
}

type IndexEntryRecord struct {
	fieldsSet []bool
	Value     *protocol.IndexEntry `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type LastBlock struct {
	fieldsSet             []bool
	Height                int64     `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Time                  time.Time `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	ChainRoot             [32]byte  `json:"chainRoot,omitempty" form:"chainRoot" query:"chainRoot" validate:"required"`
	StateRoot             [32]byte  `json:"stateRoot,omitempty" form:"stateRoot" query:"stateRoot" validate:"required"`
	DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty" form:"directoryAnchorHeight" query:"directoryAnchorHeight" validate:"required"`
	extraData             []byte
}

type NodeMetrics struct {
	fieldsSet []bool
	TPS       float64 `json:"tps" form:"tps" query:"tps" validate:"required"`
	extraData []byte
}

type NodeStatus struct {
	fieldsSet        []bool
	Ok               bool                        `json:"ok,omitempty" form:"ok" query:"ok" validate:"required"`
	LastBlock        *LastBlock                  `json:"lastBlock,omitempty" form:"lastBlock" query:"lastBlock" validate:"required"`
	Version          string                      `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Commit           string                      `json:"commit,omitempty" form:"commit" query:"commit" validate:"required"`
	NodeKeyHash      [32]byte                    `json:"nodeKeyHash,omitempty" form:"nodeKeyHash" query:"nodeKeyHash" validate:"required"`
	ValidatorKeyHash [32]byte                    `json:"validatorKeyHash,omitempty" form:"validatorKeyHash" query:"validatorKeyHash" validate:"required"`
	Network          *protocol.NetworkDefinition `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Peers            []*PeerInfo                 `json:"peers,omitempty" form:"peers" query:"peers" validate:"required"`
	extraData        []byte
}

type PeerInfo struct {
	fieldsSet []bool
	NodeID    string `json:"nodeID,omitempty" form:"nodeID" query:"nodeID" validate:"required"`
	Host      string `json:"host,omitempty" form:"host" query:"host" validate:"required"`
	Port      uint64 `json:"port,omitempty" form:"port" query:"port" validate:"required"`
	extraData []byte
}

type QueryRangeOptions struct {
	fieldsSet []bool
	// Start is the starting index.
	Start uint64 `json:"start,omitempty" form:"start" query:"start"`
	// Count is the number of requested results.
	Count *uint64 `json:"count,omitempty" form:"count" query:"count"`
	// Expand requests expanded results.
	Expand    bool `json:"expand,omitempty" form:"expand" query:"expand"`
	extraData []byte
}

type QueryRecordOptions struct {
	fieldsSet []bool
	// IncludeReceipt requests a Merkle receipt.
	IncludeReceipt bool `json:"includeReceipt,omitempty" form:"includeReceipt" query:"includeReceipt"`
	extraData      []byte
}

type Receipt struct {
	fieldsSet []bool
	managed.Receipt
	LocalBlock uint64 `json:"localBlock,omitempty" form:"localBlock" query:"localBlock" validate:"required"`
	MajorBlock uint64 `json:"majorBlock,omitempty" form:"majorBlock" query:"majorBlock" validate:"required"`
	extraData  []byte
}

type RecordRange[T Record] struct {
	fieldsSet []bool
	Records   []T    `json:"records,omitempty" form:"records" query:"records" validate:"required"`
	Start     uint64 `json:"start" form:"start" query:"start" validate:"required"`
	Total     uint64 `json:"total" form:"total" query:"total" validate:"required"`
	extraData []byte
}

type SignatureRecord struct {
	fieldsSet []bool
	Signature protocol.Signature `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	TxID      *url.TxID          `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	extraData []byte
}

type Submission struct {
	fieldsSet   []bool
	Transaction url.TxID                    `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signatures  []url.TxID                  `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	Status      *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	extraData   []byte
}

type SubmitOptions struct {
	fieldsSet []bool
	extraData []byte
}

type TransactionRecord struct {
	fieldsSet   []bool
	TxID        *url.TxID                   `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Transaction *protocol.Transaction       `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Status      *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	Produced    []*url.TxID                 `json:"produced,omitempty" form:"produced" query:"produced" validate:"required"`
	extraData   []byte
}

type TxIDRecord struct {
	fieldsSet []bool
	Value     *url.TxID `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type UrlRecord struct {
	fieldsSet []bool
	Value     *url.URL `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

func (*AccountRecord) RecordType() RecordType { return RecordTypeAccount }

func (*BlockEvent) EventType() EventType { return EventTypeBlock }

func (*ChainEntryRecord[T]) RecordType() RecordType { return RecordTypeChainEntry }

func (*ChainRecord) RecordType() RecordType { return RecordTypeChain }

func (*IndexEntryRecord) RecordType() RecordType { return RecordTypeIndexEntry }

func (*RecordRange[T]) RecordType() RecordType { return RecordTypeRange }

func (*SignatureRecord) RecordType() RecordType { return RecordTypeSignature }

func (*TransactionRecord) RecordType() RecordType { return RecordTypeTransaction }

func (*TxIDRecord) RecordType() RecordType { return RecordTypeTxID }

func (*UrlRecord) RecordType() RecordType { return RecordTypeUrl }

func (v *AccountRecord) Copy() *AccountRecord {
	u := new(AccountRecord)

	if v.Account != nil {
		u.Account = (v.Account).CopyAsInterface().(protocol.Account)
	}
	if v.Directory != nil {
		u.Directory = (v.Directory).Copy()
	}
	if v.Pending != nil {
		u.Pending = (v.Pending).Copy()
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *AccountRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockEntry) Copy() *BlockEntry {
	u := new(BlockEntry)

	u.BlockEntry = *v.BlockEntry.Copy()
	u.Value = encoding.BytesCopy(v.Value)
	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if v.Signature != nil {
		u.Signature = (v.Signature).CopyAsInterface().(protocol.Signature)
	}

	return u
}

func (v *BlockEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockEvent) Copy() *BlockEvent {
	u := new(BlockEvent)

	u.Partition = v.Partition
	u.Index = v.Index
	u.Time = v.Time
	u.Major = v.Major
	u.Entries = make([]*BlockEntry, len(v.Entries))
	for i, v := range v.Entries {
		if v != nil {
			u.Entries[i] = (v).Copy()
		}
	}

	return u
}

func (v *BlockEvent) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainEntryRecord[T]) Copy() *ChainEntryRecord[T] {
	u := new(ChainEntryRecord[T])

	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.Entry = v.Entry
	if !EqualRecord(v.Value, nil) {
		u.Value = (v.Value).CopyAsInterface().(T)
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *ChainEntryRecord[T]) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainRecord) Copy() *ChainRecord {
	u := new(ChainRecord)

	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.State = make([][]byte, len(v.State))
	for i, v := range v.State {
		u.State[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *ChainRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *IndexEntryRecord) Copy() *IndexEntryRecord {
	u := new(IndexEntryRecord)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}

	return u
}

func (v *IndexEntryRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *LastBlock) Copy() *LastBlock {
	u := new(LastBlock)

	u.Height = v.Height
	u.Time = v.Time
	u.ChainRoot = v.ChainRoot
	u.StateRoot = v.StateRoot
	u.DirectoryAnchorHeight = v.DirectoryAnchorHeight

	return u
}

func (v *LastBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeMetrics) Copy() *NodeMetrics {
	u := new(NodeMetrics)

	u.TPS = v.TPS

	return u
}

func (v *NodeMetrics) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeStatus) Copy() *NodeStatus {
	u := new(NodeStatus)

	u.Ok = v.Ok
	if v.LastBlock != nil {
		u.LastBlock = (v.LastBlock).Copy()
	}
	u.Version = v.Version
	u.Commit = v.Commit
	u.NodeKeyHash = v.NodeKeyHash
	u.ValidatorKeyHash = v.ValidatorKeyHash
	if v.Network != nil {
		u.Network = (v.Network).Copy()
	}
	u.Peers = make([]*PeerInfo, len(v.Peers))
	for i, v := range v.Peers {
		if v != nil {
			u.Peers[i] = (v).Copy()
		}
	}

	return u
}

func (v *NodeStatus) CopyAsInterface() interface{} { return v.Copy() }

func (v *PeerInfo) Copy() *PeerInfo {
	u := new(PeerInfo)

	u.NodeID = v.NodeID
	u.Host = v.Host
	u.Port = v.Port

	return u
}

func (v *PeerInfo) CopyAsInterface() interface{} { return v.Copy() }

func (v *QueryRangeOptions) Copy() *QueryRangeOptions {
	u := new(QueryRangeOptions)

	u.Start = v.Start
	if v.Count != nil {
		u.Count = new(uint64)
		*u.Count = *v.Count
	}
	u.Expand = v.Expand

	return u
}

func (v *QueryRangeOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *QueryRecordOptions) Copy() *QueryRecordOptions {
	u := new(QueryRecordOptions)

	u.IncludeReceipt = v.IncludeReceipt

	return u
}

func (v *QueryRecordOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *Receipt) Copy() *Receipt {
	u := new(Receipt)

	u.Receipt = *v.Receipt.Copy()
	u.LocalBlock = v.LocalBlock
	u.MajorBlock = v.MajorBlock

	return u
}

func (v *Receipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *RecordRange[T]) Copy() *RecordRange[T] {
	u := new(RecordRange[T])

	u.Records = make([]T, len(v.Records))
	for i, v := range v.Records {
		if !EqualRecord(v, nil) {
			u.Records[i] = (v).CopyAsInterface().(T)
		}
	}
	u.Start = v.Start
	u.Total = v.Total

	return u
}

func (v *RecordRange[T]) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureRecord) Copy() *SignatureRecord {
	u := new(SignatureRecord)

	if v.Signature != nil {
		u.Signature = (v.Signature).CopyAsInterface().(protocol.Signature)
	}
	if v.TxID != nil {
		u.TxID = v.TxID
	}

	return u
}

func (v *SignatureRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *Submission) Copy() *Submission {
	u := new(Submission)

	u.Transaction = *&v.Transaction
	u.Signatures = make([]url.TxID, len(v.Signatures))
	for i, v := range v.Signatures {
		u.Signatures[i] = *&v
	}
	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}

	return u
}

func (v *Submission) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubmitOptions) Copy() *SubmitOptions {
	u := new(SubmitOptions)

	return u
}

func (v *SubmitOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionRecord) Copy() *TransactionRecord {
	u := new(TransactionRecord)

	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}
	u.Produced = make([]*url.TxID, len(v.Produced))
	for i, v := range v.Produced {
		if v != nil {
			u.Produced[i] = v
		}
	}

	return u
}

func (v *TransactionRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *TxIDRecord) Copy() *TxIDRecord {
	u := new(TxIDRecord)

	if v.Value != nil {
		u.Value = v.Value
	}

	return u
}

func (v *TxIDRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *UrlRecord) Copy() *UrlRecord {
	u := new(UrlRecord)

	if v.Value != nil {
		u.Value = v.Value
	}

	return u
}

func (v *UrlRecord) CopyAsInterface() interface{} { return v.Copy() }

func (v *AccountRecord) Equal(u *AccountRecord) bool {
	if !(protocol.EqualAccount(v.Account, u.Account)) {
		return false
	}
	switch {
	case v.Directory == u.Directory:
		// equal
	case v.Directory == nil || u.Directory == nil:
		return false
	case !((v.Directory).Equal(u.Directory)):
		return false
	}
	switch {
	case v.Pending == u.Pending:
		// equal
	case v.Pending == nil || u.Pending == nil:
		return false
	case !((v.Pending).Equal(u.Pending)):
		return false
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

func (v *BlockEntry) Equal(u *BlockEntry) bool {
	if !v.BlockEntry.Equal(&u.BlockEntry) {
		return false
	}
	if !(bytes.Equal(v.Value, u.Value)) {
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}
	if !(protocol.EqualSignature(v.Signature, u.Signature)) {
		return false
	}

	return true
}

func (v *BlockEvent) Equal(u *BlockEvent) bool {
	if !(v.Partition == u.Partition) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !((v.Time).Equal(u.Time)) {
		return false
	}
	if !(v.Major == u.Major) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((v.Entries[i]).Equal(u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ChainEntryRecord[T]) Equal(u *ChainEntryRecord[T]) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !(v.Entry == u.Entry) {
		return false
	}
	if !(EqualRecord(v.Value, u.Value)) {
		return false
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

func (v *ChainRecord) Equal(u *ChainRecord) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}

	return true
}

func (v *IndexEntryRecord) Equal(u *IndexEntryRecord) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *LastBlock) Equal(u *LastBlock) bool {
	if !(v.Height == u.Height) {
		return false
	}
	if !((v.Time).Equal(u.Time)) {
		return false
	}
	if !(v.ChainRoot == u.ChainRoot) {
		return false
	}
	if !(v.StateRoot == u.StateRoot) {
		return false
	}
	if !(v.DirectoryAnchorHeight == u.DirectoryAnchorHeight) {
		return false
	}

	return true
}

func (v *NodeMetrics) Equal(u *NodeMetrics) bool {
	if !(v.TPS == u.TPS) {
		return false
	}

	return true
}

func (v *NodeStatus) Equal(u *NodeStatus) bool {
	if !(v.Ok == u.Ok) {
		return false
	}
	switch {
	case v.LastBlock == u.LastBlock:
		// equal
	case v.LastBlock == nil || u.LastBlock == nil:
		return false
	case !((v.LastBlock).Equal(u.LastBlock)):
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.Commit == u.Commit) {
		return false
	}
	if !(v.NodeKeyHash == u.NodeKeyHash) {
		return false
	}
	if !(v.ValidatorKeyHash == u.ValidatorKeyHash) {
		return false
	}
	switch {
	case v.Network == u.Network:
		// equal
	case v.Network == nil || u.Network == nil:
		return false
	case !((v.Network).Equal(u.Network)):
		return false
	}
	if len(v.Peers) != len(u.Peers) {
		return false
	}
	for i := range v.Peers {
		if !((v.Peers[i]).Equal(u.Peers[i])) {
			return false
		}
	}

	return true
}

func (v *PeerInfo) Equal(u *PeerInfo) bool {
	if !(v.NodeID == u.NodeID) {
		return false
	}
	if !(v.Host == u.Host) {
		return false
	}
	if !(v.Port == u.Port) {
		return false
	}

	return true
}

func (v *QueryRangeOptions) Equal(u *QueryRangeOptions) bool {
	if !(v.Start == u.Start) {
		return false
	}
	switch {
	case v.Count == u.Count:
		// equal
	case v.Count == nil || u.Count == nil:
		return false
	case !(*v.Count == *u.Count):
		return false
	}
	if !(v.Expand == u.Expand) {
		return false
	}

	return true
}

func (v *QueryRecordOptions) Equal(u *QueryRecordOptions) bool {
	if !(v.IncludeReceipt == u.IncludeReceipt) {
		return false
	}

	return true
}

func (v *Receipt) Equal(u *Receipt) bool {
	if !v.Receipt.Equal(&u.Receipt) {
		return false
	}
	if !(v.LocalBlock == u.LocalBlock) {
		return false
	}
	if !(v.MajorBlock == u.MajorBlock) {
		return false
	}

	return true
}

func (v *RecordRange[T]) Equal(u *RecordRange[T]) bool {
	if len(v.Records) != len(u.Records) {
		return false
	}
	for i := range v.Records {
		if !(EqualRecord(v.Records[i], u.Records[i])) {
			return false
		}
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *SignatureRecord) Equal(u *SignatureRecord) bool {
	if !(protocol.EqualSignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}

	return true
}

func (v *Submission) Equal(u *Submission) bool {
	if !((&v.Transaction).Equal(&u.Transaction)) {
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !((&v.Signatures[i]).Equal(&u.Signatures[i])) {
			return false
		}
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}

	return true
}

func (v *SubmitOptions) Equal(u *SubmitOptions) bool {

	return true
}

func (v *TransactionRecord) Equal(u *TransactionRecord) bool {
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}
	if len(v.Produced) != len(u.Produced) {
		return false
	}
	for i := range v.Produced {
		if !((v.Produced[i]).Equal(u.Produced[i])) {
			return false
		}
	}

	return true
}

func (v *TxIDRecord) Equal(u *TxIDRecord) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *UrlRecord) Equal(u *UrlRecord) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

var fieldNames_AccountRecord = []string{
	1: "RecordType",
	2: "Account",
	3: "Directory",
	4: "Pending",
	5: "Receipt",
}

func (v *AccountRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(protocol.EqualAccount(v.Account, nil)) {
		writer.WriteValue(2, v.Account.MarshalBinary)
	}
	if !(v.Directory == nil) {
		writer.WriteValue(3, v.Directory.MarshalBinary)
	}
	if !(v.Pending == nil) {
		writer.WriteValue(4, v.Pending.MarshalBinary)
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(5, v.Receipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_AccountRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AccountRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if protocol.EqualAccount(v.Account, nil) {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Directory is missing")
	} else if v.Directory == nil {
		errs = append(errs, "field Directory is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Pending is missing")
	} else if v.Pending == nil {
		errs = append(errs, "field Pending is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Receipt is missing")
	} else if v.Receipt == nil {
		errs = append(errs, "field Receipt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockEntry = []string{
	1: "BlockEntry",
	2: "Value",
	3: "TxID",
	4: "Transaction",
	5: "Signature",
}

func (v *BlockEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, v.BlockEntry.MarshalBinary)
	if !(len(v.Value) == 0) {
		writer.WriteBytes(2, v.Value)
	}
	if !(v.TxID == nil) {
		writer.WriteTxid(3, v.TxID)
	}
	if !(v.Transaction == nil) {
		writer.WriteValue(4, v.Transaction.MarshalBinary)
	}
	if !(protocol.EqualSignature(v.Signature, nil)) {
		writer.WriteValue(5, v.Signature.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_BlockEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockEntry) IsValid() error {
	var errs []string

	if err := v.BlockEntry.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Value is missing")
	} else if len(v.Value) == 0 {
		errs = append(errs, "field Value is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == nil {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Signature is missing")
	} else if protocol.EqualSignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockEvent = []string{
	1: "EventType",
	2: "Partition",
	3: "Index",
	4: "Time",
	5: "Major",
	6: "Entries",
}

func (v *BlockEvent) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.EventType())
	if !(len(v.Partition) == 0) {
		writer.WriteString(2, v.Partition)
	}
	if !(v.Index == 0) {
		writer.WriteUint(3, v.Index)
	}
	if !(v.Time == (time.Time{})) {
		writer.WriteTime(4, v.Time)
	}
	if !(v.Major == 0) {
		writer.WriteUint(5, v.Major)
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(6, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_BlockEvent)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockEvent) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field EventType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Partition is missing")
	} else if len(v.Partition) == 0 {
		errs = append(errs, "field Partition is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == (time.Time{}) {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Major is missing")
	} else if v.Major == 0 {
		errs = append(errs, "field Major is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainEntryRecord = []string{
	1: "RecordType",
	2: "Name",
	3: "Type",
	4: "Index",
	5: "Entry",
	6: "Value",
	7: "Receipt",
}

func (v *ChainEntryRecord[T]) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(len(v.Name) == 0) {
		writer.WriteString(2, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(3, v.Type)
	}
	writer.WriteUint(4, v.Index)
	if !(v.Entry == ([32]byte{})) {
		writer.WriteHash(5, &v.Entry)
	}
	if !(EqualRecord(v.Value, nil)) {
		writer.WriteValue(6, v.Value.MarshalBinary)
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(7, v.Receipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ChainEntryRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainEntryRecord[T]) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Index is missing")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entry is missing")
	} else if v.Entry == ([32]byte{}) {
		errs = append(errs, "field Entry is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Value is missing")
	} else if EqualRecord(v.Value, nil) {
		errs = append(errs, "field Value is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Receipt is missing")
	} else if v.Receipt == nil {
		errs = append(errs, "field Receipt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainRecord = []string{
	1: "RecordType",
	2: "Name",
	3: "Type",
	4: "Count",
	5: "State",
}

func (v *ChainRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(len(v.Name) == 0) {
		writer.WriteString(2, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(3, v.Type)
	}
	if !(v.Count == 0) {
		writer.WriteUint(4, v.Count)
	}
	if !(len(v.State) == 0) {
		for _, v := range v.State {
			writer.WriteBytes(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ChainRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field State is missing")
	} else if len(v.State) == 0 {
		errs = append(errs, "field State is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_IndexEntryRecord = []string{
	1: "RecordType",
	2: "Value",
}

func (v *IndexEntryRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_IndexEntryRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *IndexEntryRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LastBlock = []string{
	1: "Height",
	2: "Time",
	3: "ChainRoot",
	4: "StateRoot",
	5: "DirectoryAnchorHeight",
}

func (v *LastBlock) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Height == 0) {
		writer.WriteInt(1, v.Height)
	}
	if !(v.Time == (time.Time{})) {
		writer.WriteTime(2, v.Time)
	}
	if !(v.ChainRoot == ([32]byte{})) {
		writer.WriteHash(3, &v.ChainRoot)
	}
	if !(v.StateRoot == ([32]byte{})) {
		writer.WriteHash(4, &v.StateRoot)
	}
	if !(v.DirectoryAnchorHeight == 0) {
		writer.WriteUint(5, v.DirectoryAnchorHeight)
	}

	_, _, err := writer.Reset(fieldNames_LastBlock)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LastBlock) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == (time.Time{}) {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ChainRoot is missing")
	} else if v.ChainRoot == ([32]byte{}) {
		errs = append(errs, "field ChainRoot is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field StateRoot is missing")
	} else if v.StateRoot == ([32]byte{}) {
		errs = append(errs, "field StateRoot is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field DirectoryAnchorHeight is missing")
	} else if v.DirectoryAnchorHeight == 0 {
		errs = append(errs, "field DirectoryAnchorHeight is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeMetrics = []string{
	1: "TPS",
}

func (v *NodeMetrics) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteFloat(1, v.TPS)

	_, _, err := writer.Reset(fieldNames_NodeMetrics)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeMetrics) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TPS is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeStatus = []string{
	1: "Ok",
	2: "LastBlock",
	3: "Version",
	4: "Commit",
	5: "NodeKeyHash",
	6: "ValidatorKeyHash",
	7: "Network",
	8: "Peers",
}

func (v *NodeStatus) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.Ok) {
		writer.WriteBool(1, v.Ok)
	}
	if !(v.LastBlock == nil) {
		writer.WriteValue(2, v.LastBlock.MarshalBinary)
	}
	if !(len(v.Version) == 0) {
		writer.WriteString(3, v.Version)
	}
	if !(len(v.Commit) == 0) {
		writer.WriteString(4, v.Commit)
	}
	if !(v.NodeKeyHash == ([32]byte{})) {
		writer.WriteHash(5, &v.NodeKeyHash)
	}
	if !(v.ValidatorKeyHash == ([32]byte{})) {
		writer.WriteHash(6, &v.ValidatorKeyHash)
	}
	if !(v.Network == nil) {
		writer.WriteValue(7, v.Network.MarshalBinary)
	}
	if !(len(v.Peers) == 0) {
		for _, v := range v.Peers {
			writer.WriteValue(8, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_NodeStatus)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeStatus) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Ok is missing")
	} else if !v.Ok {
		errs = append(errs, "field Ok is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field LastBlock is missing")
	} else if v.LastBlock == nil {
		errs = append(errs, "field LastBlock is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Version is missing")
	} else if len(v.Version) == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Commit is missing")
	} else if len(v.Commit) == 0 {
		errs = append(errs, "field Commit is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field NodeKeyHash is missing")
	} else if v.NodeKeyHash == ([32]byte{}) {
		errs = append(errs, "field NodeKeyHash is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field ValidatorKeyHash is missing")
	} else if v.ValidatorKeyHash == ([32]byte{}) {
		errs = append(errs, "field ValidatorKeyHash is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Network is missing")
	} else if v.Network == nil {
		errs = append(errs, "field Network is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field Peers is missing")
	} else if len(v.Peers) == 0 {
		errs = append(errs, "field Peers is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PeerInfo = []string{
	1: "NodeID",
	2: "Host",
	3: "Port",
}

func (v *PeerInfo) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.NodeID) == 0) {
		writer.WriteString(1, v.NodeID)
	}
	if !(len(v.Host) == 0) {
		writer.WriteString(2, v.Host)
	}
	if !(v.Port == 0) {
		writer.WriteUint(3, v.Port)
	}

	_, _, err := writer.Reset(fieldNames_PeerInfo)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PeerInfo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field NodeID is missing")
	} else if len(v.NodeID) == 0 {
		errs = append(errs, "field NodeID is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Host is missing")
	} else if len(v.Host) == 0 {
		errs = append(errs, "field Host is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Port is missing")
	} else if v.Port == 0 {
		errs = append(errs, "field Port is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_QueryRangeOptions = []string{
	1: "Start",
	2: "Count",
	3: "Expand",
}

func (v *QueryRangeOptions) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Start == 0) {
		writer.WriteUint(1, v.Start)
	}
	if !(v.Count == nil) {
		writer.WriteUint(2, *v.Count)
	}
	if !(!v.Expand) {
		writer.WriteBool(3, v.Expand)
	}

	_, _, err := writer.Reset(fieldNames_QueryRangeOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *QueryRangeOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_QueryRecordOptions = []string{
	1: "IncludeReceipt",
}

func (v *QueryRecordOptions) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.IncludeReceipt) {
		writer.WriteBool(1, v.IncludeReceipt)
	}

	_, _, err := writer.Reset(fieldNames_QueryRecordOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *QueryRecordOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Receipt = []string{
	1: "Receipt",
	2: "LocalBlock",
	3: "MajorBlock",
}

func (v *Receipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, v.Receipt.MarshalBinary)
	if !(v.LocalBlock == 0) {
		writer.WriteUint(2, v.LocalBlock)
	}
	if !(v.MajorBlock == 0) {
		writer.WriteUint(3, v.MajorBlock)
	}

	_, _, err := writer.Reset(fieldNames_Receipt)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Receipt) IsValid() error {
	var errs []string

	if err := v.Receipt.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field LocalBlock is missing")
	} else if v.LocalBlock == 0 {
		errs = append(errs, "field LocalBlock is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field MajorBlock is missing")
	} else if v.MajorBlock == 0 {
		errs = append(errs, "field MajorBlock is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RecordRange = []string{
	1: "RecordType",
	2: "Records",
	3: "Start",
	4: "Total",
}

func (v *RecordRange[T]) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(len(v.Records) == 0) {
		for _, v := range v.Records {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	writer.WriteUint(3, v.Start)
	writer.WriteUint(4, v.Total)

	_, _, err := writer.Reset(fieldNames_RecordRange)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RecordRange[T]) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Records is missing")
	} else if len(v.Records) == 0 {
		errs = append(errs, "field Records is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Total is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SignatureRecord = []string{
	1: "RecordType",
	2: "Signature",
	3: "TxID",
}

func (v *SignatureRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(protocol.EqualSignature(v.Signature, nil)) {
		writer.WriteValue(2, v.Signature.MarshalBinary)
	}
	if !(v.TxID == nil) {
		writer.WriteTxid(3, v.TxID)
	}

	_, _, err := writer.Reset(fieldNames_SignatureRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SignatureRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if protocol.EqualSignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Submission = []string{
	1: "Transaction",
	2: "Signatures",
	3: "Status",
}

func (v *Submission) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Transaction == (url.TxID{})) {
		writer.WriteTxid(1, &v.Transaction)
	}
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteTxid(2, &v)
		}
	}
	if !(v.Status == nil) {
		writer.WriteValue(3, v.Status.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_Submission)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Submission) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == (url.TxID{}) {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubmitOptions = []string{}

func (v *SubmitOptions) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	_, _, err := writer.Reset(fieldNames_SubmitOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubmitOptions) IsValid() error {
	var errs []string

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionRecord = []string{
	1: "RecordType",
	2: "TxID",
	3: "Transaction",
	4: "Status",
	5: "Produced",
}

func (v *TransactionRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.TxID == nil) {
		writer.WriteTxid(2, v.TxID)
	}
	if !(v.Transaction == nil) {
		writer.WriteValue(3, v.Transaction.MarshalBinary)
	}
	if !(v.Status == nil) {
		writer.WriteValue(4, v.Status.MarshalBinary)
	}
	if !(len(v.Produced) == 0) {
		for _, v := range v.Produced {
			writer.WriteTxid(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_TransactionRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TransactionRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == nil {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Produced is missing")
	} else if len(v.Produced) == 0 {
		errs = append(errs, "field Produced is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TxIDRecord = []string{
	1: "RecordType",
	2: "Value",
}

func (v *TxIDRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Value == nil) {
		writer.WriteTxid(2, v.Value)
	}

	_, _, err := writer.Reset(fieldNames_TxIDRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TxIDRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UrlRecord = []string{
	1: "RecordType",
	2: "Value",
}

func (v *UrlRecord) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.RecordType())
	if !(v.Value == nil) {
		writer.WriteUrl(2, v.Value)
	}

	_, _, err := writer.Reset(fieldNames_UrlRecord)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UrlRecord) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field RecordType is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *AccountRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AccountRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	reader.ReadValue(2, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.Account = x
		}
		return err
	})
	if x := new(RecordRange[*UrlRecord]); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Directory = x
	}
	if x := new(RecordRange[*TxIDRecord]); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Pending = x
	}
	if x := new(Receipt); reader.ReadValue(5, x.UnmarshalBinary) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_AccountRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.BlockEntry.UnmarshalBinary)
	if x, ok := reader.ReadBytes(2); ok {
		v.Value = x
	}
	if x, ok := reader.ReadTxid(3); ok {
		v.TxID = x
	}
	if x := new(protocol.Transaction); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Transaction = x
	}
	reader.ReadValue(5, func(b []byte) error {
		x, err := protocol.UnmarshalSignature(b)
		if err == nil {
			v.Signature = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_BlockEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockEvent) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockEvent) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vEventType EventType
	if x := new(EventType); reader.ReadEnum(1, x) {
		vEventType = *x
	}
	if !(v.EventType() == vEventType) {
		return fmt.Errorf("field EventType: not equal: want %v, got %v", v.EventType(), vEventType)
	}
	if x, ok := reader.ReadString(2); ok {
		v.Partition = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(4); ok {
		v.Time = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Major = x
	}
	for {
		if x := new(BlockEntry); reader.ReadValue(6, x.UnmarshalBinary) {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_BlockEvent)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainEntryRecord[T]) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainEntryRecord[T]) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	if x, ok := reader.ReadString(2); ok {
		v.Name = x
	}
	if x := new(managed.ChainType); reader.ReadEnum(3, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Index = x
	}
	if x, ok := reader.ReadHash(5); ok {
		v.Entry = *x
	}
	reader.ReadValue(6, func(b []byte) error {
		x, err := encoding.UnmarshalAndCast[T](b, UnmarshalRecord)
		if err == nil {
			v.Value = x
		}
		return err
	})
	if x := new(Receipt); reader.ReadValue(7, x.UnmarshalBinary) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_ChainEntryRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	if x, ok := reader.ReadString(2); ok {
		v.Name = x
	}
	if x := new(managed.ChainType); reader.ReadEnum(3, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Count = x
	}
	for {
		if x, ok := reader.ReadBytes(5); ok {
			v.State = append(v.State, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ChainRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *IndexEntryRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *IndexEntryRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	if x := new(protocol.IndexEntry); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_IndexEntryRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LastBlock) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LastBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadInt(1); ok {
		v.Height = x
	}
	if x, ok := reader.ReadTime(2); ok {
		v.Time = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.ChainRoot = *x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.StateRoot = *x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.DirectoryAnchorHeight = x
	}

	seen, err := reader.Reset(fieldNames_LastBlock)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeMetrics) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeMetrics) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadFloat(1); ok {
		v.TPS = x
	}

	seen, err := reader.Reset(fieldNames_NodeMetrics)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeStatus) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeStatus) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Ok = x
	}
	if x := new(LastBlock); reader.ReadValue(2, x.UnmarshalBinary) {
		v.LastBlock = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Version = x
	}
	if x, ok := reader.ReadString(4); ok {
		v.Commit = x
	}
	if x, ok := reader.ReadHash(5); ok {
		v.NodeKeyHash = *x
	}
	if x, ok := reader.ReadHash(6); ok {
		v.ValidatorKeyHash = *x
	}
	if x := new(protocol.NetworkDefinition); reader.ReadValue(7, x.UnmarshalBinary) {
		v.Network = x
	}
	for {
		if x := new(PeerInfo); reader.ReadValue(8, x.UnmarshalBinary) {
			v.Peers = append(v.Peers, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_NodeStatus)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PeerInfo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PeerInfo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.NodeID = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Host = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Port = x
	}

	seen, err := reader.Reset(fieldNames_PeerInfo)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *QueryRangeOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *QueryRangeOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Count = &x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.Expand = x
	}

	seen, err := reader.Reset(fieldNames_QueryRangeOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *QueryRecordOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *QueryRecordOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.IncludeReceipt = x
	}

	seen, err := reader.Reset(fieldNames_QueryRecordOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Receipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Receipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.Receipt.UnmarshalBinary)
	if x, ok := reader.ReadUint(2); ok {
		v.LocalBlock = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.MajorBlock = x
	}

	seen, err := reader.Reset(fieldNames_Receipt)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RecordRange[T]) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RecordRange[T]) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	for {
		ok := reader.ReadValue(2, func(b []byte) error {
			x, err := encoding.UnmarshalAndCast[T](b, UnmarshalRecord)
			if err == nil {
				v.Records = append(v.Records, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_RecordRange)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SignatureRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	reader.ReadValue(2, func(b []byte) error {
		x, err := protocol.UnmarshalSignature(b)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	if x, ok := reader.ReadTxid(3); ok {
		v.TxID = x
	}

	seen, err := reader.Reset(fieldNames_SignatureRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Submission) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Submission) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadTxid(1); ok {
		v.Transaction = *x
	}
	for {
		if x, ok := reader.ReadTxid(2); ok {
			v.Signatures = append(v.Signatures, *x)
		} else {
			break
		}
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Status = x
	}

	seen, err := reader.Reset(fieldNames_Submission)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubmitOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubmitOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	seen, err := reader.Reset(fieldNames_SubmitOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TransactionRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	if x, ok := reader.ReadTxid(2); ok {
		v.TxID = x
	}
	if x := new(protocol.Transaction); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Transaction = x
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Status = x
	}
	for {
		if x, ok := reader.ReadTxid(5); ok {
			v.Produced = append(v.Produced, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_TransactionRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TxIDRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TxIDRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	if x, ok := reader.ReadTxid(2); ok {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_TxIDRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UrlRecord) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UrlRecord) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vRecordType RecordType
	if x := new(RecordType); reader.ReadEnum(1, x) {
		vRecordType = *x
	}
	if !(v.RecordType() == vRecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), vRecordType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_UrlRecord)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AccountRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType                                   `json:"recordType"`
		Account    encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		Directory  *RecordRange[*UrlRecord]                     `json:"directory,omitempty"`
		Pending    *RecordRange[*TxIDRecord]                    `json:"pending,omitempty"`
		Receipt    *Receipt                                     `json:"receipt,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Directory = v.Directory
	u.Pending = v.Pending
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *BlockEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Account     *url.URL                                       `json:"account,omitempty"`
		Chain       string                                         `json:"chain,omitempty"`
		Index       uint64                                         `json:"index"`
		Value       *string                                        `json:"value,omitempty"`
		TxID        *url.TxID                                      `json:"txID,omitempty"`
		Transaction *protocol.Transaction                          `json:"transaction,omitempty"`
		Signature   encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
	}{}
	u.Account = v.BlockEntry.Account
	u.Chain = v.BlockEntry.Chain
	u.Index = v.BlockEntry.Index
	u.Value = encoding.BytesToJSON(v.Value)
	u.TxID = v.TxID
	u.Transaction = v.Transaction
	u.Signature = encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	return json.Marshal(&u)
}

func (v *BlockEvent) MarshalJSON() ([]byte, error) {
	u := struct {
		EventType EventType                      `json:"eventType"`
		Partition string                         `json:"partition,omitempty"`
		Index     uint64                         `json:"index,omitempty"`
		Time      time.Time                      `json:"time,omitempty"`
		Major     uint64                         `json:"major,omitempty"`
		Entries   encoding.JsonList[*BlockEntry] `json:"entries,omitempty"`
	}{}
	u.EventType = v.EventType()
	u.Partition = v.Partition
	u.Index = v.Index
	u.Time = v.Time
	u.Major = v.Major
	u.Entries = v.Entries
	return json.Marshal(&u)
}

func (v *ChainEntryRecord[T]) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType                    `json:"recordType"`
		Name       string                        `json:"name,omitempty"`
		Type       managed.ChainType             `json:"type,omitempty"`
		Index      uint64                        `json:"index"`
		Entry      string                        `json:"entry,omitempty"`
		Value      encoding.JsonUnmarshalWith[T] `json:"value,omitempty"`
		Receipt    *Receipt                      `json:"receipt,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.Entry = encoding.ChainToJSON(v.Entry)
	u.Value = encoding.JsonUnmarshalWith[T]{Value: v.Value, Func: func(b []byte) (T, error) { return encoding.UnmarshalAndCast[T](b, UnmarshalRecordJSON) }}
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *ChainRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType                 `json:"recordType"`
		Name       string                     `json:"name,omitempty"`
		Type       managed.ChainType          `json:"type,omitempty"`
		Count      uint64                     `json:"count,omitempty"`
		State      encoding.JsonList[*string] `json:"state,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *IndexEntryRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType           `json:"recordType"`
		Value      *protocol.IndexEntry `json:"value,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	return json.Marshal(&u)
}

func (v *LastBlock) MarshalJSON() ([]byte, error) {
	u := struct {
		Height                int64     `json:"height,omitempty"`
		Time                  time.Time `json:"time,omitempty"`
		ChainRoot             string    `json:"chainRoot,omitempty"`
		StateRoot             string    `json:"stateRoot,omitempty"`
		DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty"`
	}{}
	u.Height = v.Height
	u.Time = v.Time
	u.ChainRoot = encoding.ChainToJSON(v.ChainRoot)
	u.StateRoot = encoding.ChainToJSON(v.StateRoot)
	u.DirectoryAnchorHeight = v.DirectoryAnchorHeight
	return json.Marshal(&u)
}

func (v *NodeStatus) MarshalJSON() ([]byte, error) {
	u := struct {
		Ok               bool                         `json:"ok,omitempty"`
		LastBlock        *LastBlock                   `json:"lastBlock,omitempty"`
		Version          string                       `json:"version,omitempty"`
		Commit           string                       `json:"commit,omitempty"`
		NodeKeyHash      string                       `json:"nodeKeyHash,omitempty"`
		ValidatorKeyHash string                       `json:"validatorKeyHash,omitempty"`
		Network          *protocol.NetworkDefinition  `json:"network,omitempty"`
		Peers            encoding.JsonList[*PeerInfo] `json:"peers,omitempty"`
	}{}
	u.Ok = v.Ok
	u.LastBlock = v.LastBlock
	u.Version = v.Version
	u.Commit = v.Commit
	u.NodeKeyHash = encoding.ChainToJSON(v.NodeKeyHash)
	u.ValidatorKeyHash = encoding.ChainToJSON(v.ValidatorKeyHash)
	u.Network = v.Network
	u.Peers = v.Peers
	return json.Marshal(&u)
}

func (v *Receipt) MarshalJSON() ([]byte, error) {
	u := struct {
		Start      *string                                  `json:"start,omitempty"`
		StartIndex int64                                    `json:"startIndex,omitempty"`
		End        *string                                  `json:"end,omitempty"`
		EndIndex   int64                                    `json:"endIndex,omitempty"`
		Anchor     *string                                  `json:"anchor,omitempty"`
		Entries    encoding.JsonList[*managed.ReceiptEntry] `json:"entries,omitempty"`
		LocalBlock uint64                                   `json:"localBlock,omitempty"`
		MajorBlock uint64                                   `json:"majorBlock,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Receipt.Start)
	u.StartIndex = v.Receipt.StartIndex
	u.End = encoding.BytesToJSON(v.Receipt.End)
	u.EndIndex = v.Receipt.EndIndex
	u.Anchor = encoding.BytesToJSON(v.Receipt.Anchor)
	u.Entries = v.Receipt.Entries
	u.LocalBlock = v.LocalBlock
	u.MajorBlock = v.MajorBlock
	return json.Marshal(&u)
}

func (v *RecordRange[T]) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType                        `json:"recordType"`
		Records    encoding.JsonUnmarshalListWith[T] `json:"records,omitempty"`
		Start      uint64                            `json:"start"`
		Total      uint64                            `json:"total"`
	}{}
	u.RecordType = v.RecordType()
	u.Records = encoding.JsonUnmarshalListWith[T]{Value: v.Records, Func: func(b []byte) (T, error) { return encoding.UnmarshalAndCast[T](b, UnmarshalRecordJSON) }}
	u.Start = v.Start
	u.Total = v.Total
	return json.Marshal(&u)
}

func (v *SignatureRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType                                     `json:"recordType"`
		Signature  encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
		TxID       *url.TxID                                      `json:"txID,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Signature = encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	u.TxID = v.TxID
	return json.Marshal(&u)
}

func (v *Submission) MarshalJSON() ([]byte, error) {
	u := struct {
		Transaction url.TxID                    `json:"transaction,omitempty"`
		Signatures  encoding.JsonList[url.TxID] `json:"signatures,omitempty"`
		Status      *protocol.TransactionStatus `json:"status,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.Signatures = v.Signatures
	u.Status = v.Status
	return json.Marshal(&u)
}

func (v *TransactionRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType  RecordType                   `json:"recordType"`
		TxID        *url.TxID                    `json:"txID,omitempty"`
		Transaction *protocol.Transaction        `json:"transaction,omitempty"`
		Status      *protocol.TransactionStatus  `json:"status,omitempty"`
		Produced    encoding.JsonList[*url.TxID] `json:"produced,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.TxID = v.TxID
	u.Transaction = v.Transaction
	u.Status = v.Status
	u.Produced = v.Produced
	return json.Marshal(&u)
}

func (v *TxIDRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType `json:"recordType"`
		Value      *url.TxID  `json:"value,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	return json.Marshal(&u)
}

func (v *UrlRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		RecordType RecordType `json:"recordType"`
		Value      *url.URL   `json:"value,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	return json.Marshal(&u)
}

func (v *AccountRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType                                   `json:"recordType"`
		Account    encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		Directory  *RecordRange[*UrlRecord]                     `json:"directory,omitempty"`
		Pending    *RecordRange[*TxIDRecord]                    `json:"pending,omitempty"`
		Receipt    *Receipt                                     `json:"receipt,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Directory = v.Directory
	u.Pending = v.Pending
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Account = u.Account.Value

	v.Directory = u.Directory
	v.Pending = u.Pending
	v.Receipt = u.Receipt
	return nil
}

func (v *BlockEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Account     *url.URL                                       `json:"account,omitempty"`
		Chain       string                                         `json:"chain,omitempty"`
		Index       uint64                                         `json:"index"`
		Value       *string                                        `json:"value,omitempty"`
		TxID        *url.TxID                                      `json:"txID,omitempty"`
		Transaction *protocol.Transaction                          `json:"transaction,omitempty"`
		Signature   encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
	}{}
	u.Account = v.BlockEntry.Account
	u.Chain = v.BlockEntry.Chain
	u.Index = v.BlockEntry.Index
	u.Value = encoding.BytesToJSON(v.Value)
	u.TxID = v.TxID
	u.Transaction = v.Transaction
	u.Signature = encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.BlockEntry.Account = u.Account
	v.BlockEntry.Chain = u.Chain
	v.BlockEntry.Index = u.Index
	if x, err := encoding.BytesFromJSON(u.Value); err != nil {
		return fmt.Errorf("error decoding Value: %w", err)
	} else {
		v.Value = x
	}
	v.TxID = u.TxID
	v.Transaction = u.Transaction
	v.Signature = u.Signature.Value

	return nil
}

func (v *BlockEvent) UnmarshalJSON(data []byte) error {
	u := struct {
		EventType EventType                      `json:"eventType"`
		Partition string                         `json:"partition,omitempty"`
		Index     uint64                         `json:"index,omitempty"`
		Time      time.Time                      `json:"time,omitempty"`
		Major     uint64                         `json:"major,omitempty"`
		Entries   encoding.JsonList[*BlockEntry] `json:"entries,omitempty"`
	}{}
	u.EventType = v.EventType()
	u.Partition = v.Partition
	u.Index = v.Index
	u.Time = v.Time
	u.Major = v.Major
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.EventType() == u.EventType) {
		return fmt.Errorf("field EventType: not equal: want %v, got %v", v.EventType(), u.EventType)
	}
	v.Partition = u.Partition
	v.Index = u.Index
	v.Time = u.Time
	v.Major = u.Major
	v.Entries = u.Entries
	return nil
}

func (v *ChainEntryRecord[T]) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType                    `json:"recordType"`
		Name       string                        `json:"name,omitempty"`
		Type       managed.ChainType             `json:"type,omitempty"`
		Index      uint64                        `json:"index"`
		Entry      string                        `json:"entry,omitempty"`
		Value      encoding.JsonUnmarshalWith[T] `json:"value,omitempty"`
		Receipt    *Receipt                      `json:"receipt,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.Entry = encoding.ChainToJSON(v.Entry)
	u.Value = encoding.JsonUnmarshalWith[T]{Value: v.Value, Func: func(b []byte) (T, error) { return encoding.UnmarshalAndCast[T](b, UnmarshalRecordJSON) }}
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Name = u.Name
	v.Type = u.Type
	v.Index = u.Index
	if x, err := encoding.ChainFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.Value = u.Value.Value

	v.Receipt = u.Receipt
	return nil
}

func (v *ChainRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType                 `json:"recordType"`
		Name       string                     `json:"name,omitempty"`
		Type       managed.ChainType          `json:"type,omitempty"`
		Count      uint64                     `json:"count,omitempty"`
		State      encoding.JsonList[*string] `json:"state,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Name = u.Name
	v.Type = u.Type
	v.Count = u.Count
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	return nil
}

func (v *IndexEntryRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType           `json:"recordType"`
		Value      *protocol.IndexEntry `json:"value,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Value = u.Value
	return nil
}

func (v *LastBlock) UnmarshalJSON(data []byte) error {
	u := struct {
		Height                int64     `json:"height,omitempty"`
		Time                  time.Time `json:"time,omitempty"`
		ChainRoot             string    `json:"chainRoot,omitempty"`
		StateRoot             string    `json:"stateRoot,omitempty"`
		DirectoryAnchorHeight uint64    `json:"directoryAnchorHeight,omitempty"`
	}{}
	u.Height = v.Height
	u.Time = v.Time
	u.ChainRoot = encoding.ChainToJSON(v.ChainRoot)
	u.StateRoot = encoding.ChainToJSON(v.StateRoot)
	u.DirectoryAnchorHeight = v.DirectoryAnchorHeight
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Height = u.Height
	v.Time = u.Time
	if x, err := encoding.ChainFromJSON(u.ChainRoot); err != nil {
		return fmt.Errorf("error decoding ChainRoot: %w", err)
	} else {
		v.ChainRoot = x
	}
	if x, err := encoding.ChainFromJSON(u.StateRoot); err != nil {
		return fmt.Errorf("error decoding StateRoot: %w", err)
	} else {
		v.StateRoot = x
	}
	v.DirectoryAnchorHeight = u.DirectoryAnchorHeight
	return nil
}

func (v *NodeStatus) UnmarshalJSON(data []byte) error {
	u := struct {
		Ok               bool                         `json:"ok,omitempty"`
		LastBlock        *LastBlock                   `json:"lastBlock,omitempty"`
		Version          string                       `json:"version,omitempty"`
		Commit           string                       `json:"commit,omitempty"`
		NodeKeyHash      string                       `json:"nodeKeyHash,omitempty"`
		ValidatorKeyHash string                       `json:"validatorKeyHash,omitempty"`
		Network          *protocol.NetworkDefinition  `json:"network,omitempty"`
		Peers            encoding.JsonList[*PeerInfo] `json:"peers,omitempty"`
	}{}
	u.Ok = v.Ok
	u.LastBlock = v.LastBlock
	u.Version = v.Version
	u.Commit = v.Commit
	u.NodeKeyHash = encoding.ChainToJSON(v.NodeKeyHash)
	u.ValidatorKeyHash = encoding.ChainToJSON(v.ValidatorKeyHash)
	u.Network = v.Network
	u.Peers = v.Peers
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Ok = u.Ok
	v.LastBlock = u.LastBlock
	v.Version = u.Version
	v.Commit = u.Commit
	if x, err := encoding.ChainFromJSON(u.NodeKeyHash); err != nil {
		return fmt.Errorf("error decoding NodeKeyHash: %w", err)
	} else {
		v.NodeKeyHash = x
	}
	if x, err := encoding.ChainFromJSON(u.ValidatorKeyHash); err != nil {
		return fmt.Errorf("error decoding ValidatorKeyHash: %w", err)
	} else {
		v.ValidatorKeyHash = x
	}
	v.Network = u.Network
	v.Peers = u.Peers
	return nil
}

func (v *Receipt) UnmarshalJSON(data []byte) error {
	u := struct {
		Start      *string                                  `json:"start,omitempty"`
		StartIndex int64                                    `json:"startIndex,omitempty"`
		End        *string                                  `json:"end,omitempty"`
		EndIndex   int64                                    `json:"endIndex,omitempty"`
		Anchor     *string                                  `json:"anchor,omitempty"`
		Entries    encoding.JsonList[*managed.ReceiptEntry] `json:"entries,omitempty"`
		LocalBlock uint64                                   `json:"localBlock,omitempty"`
		MajorBlock uint64                                   `json:"majorBlock,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Receipt.Start)
	u.StartIndex = v.Receipt.StartIndex
	u.End = encoding.BytesToJSON(v.Receipt.End)
	u.EndIndex = v.Receipt.EndIndex
	u.Anchor = encoding.BytesToJSON(v.Receipt.Anchor)
	u.Entries = v.Receipt.Entries
	u.LocalBlock = v.LocalBlock
	u.MajorBlock = v.MajorBlock
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Start); err != nil {
		return fmt.Errorf("error decoding Start: %w", err)
	} else {
		v.Receipt.Start = x
	}
	v.Receipt.StartIndex = u.StartIndex
	if x, err := encoding.BytesFromJSON(u.End); err != nil {
		return fmt.Errorf("error decoding End: %w", err)
	} else {
		v.Receipt.End = x
	}
	v.Receipt.EndIndex = u.EndIndex
	if x, err := encoding.BytesFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Receipt.Anchor = x
	}
	v.Receipt.Entries = u.Entries
	v.LocalBlock = u.LocalBlock
	v.MajorBlock = u.MajorBlock
	return nil
}

func (v *RecordRange[T]) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType                        `json:"recordType"`
		Records    encoding.JsonUnmarshalListWith[T] `json:"records,omitempty"`
		Start      uint64                            `json:"start"`
		Total      uint64                            `json:"total"`
	}{}
	u.RecordType = v.RecordType()
	u.Records = encoding.JsonUnmarshalListWith[T]{Value: v.Records, Func: func(b []byte) (T, error) { return encoding.UnmarshalAndCast[T](b, UnmarshalRecordJSON) }}
	u.Start = v.Start
	u.Total = v.Total
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Records = make([]T, len(u.Records.Value))
	for i, x := range u.Records.Value {
		v.Records[i] = x
	}
	v.Start = u.Start
	v.Total = u.Total
	return nil
}

func (v *SignatureRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType                                     `json:"recordType"`
		Signature  encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
		TxID       *url.TxID                                      `json:"txID,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Signature = encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	u.TxID = v.TxID
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Signature = u.Signature.Value

	v.TxID = u.TxID
	return nil
}

func (v *Submission) UnmarshalJSON(data []byte) error {
	u := struct {
		Transaction url.TxID                    `json:"transaction,omitempty"`
		Signatures  encoding.JsonList[url.TxID] `json:"signatures,omitempty"`
		Status      *protocol.TransactionStatus `json:"status,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.Signatures = v.Signatures
	u.Status = v.Status
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transaction = u.Transaction
	v.Signatures = u.Signatures
	v.Status = u.Status
	return nil
}

func (v *TransactionRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType  RecordType                   `json:"recordType"`
		TxID        *url.TxID                    `json:"txID,omitempty"`
		Transaction *protocol.Transaction        `json:"transaction,omitempty"`
		Status      *protocol.TransactionStatus  `json:"status,omitempty"`
		Produced    encoding.JsonList[*url.TxID] `json:"produced,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.TxID = v.TxID
	u.Transaction = v.Transaction
	u.Status = v.Status
	u.Produced = v.Produced
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.TxID = u.TxID
	v.Transaction = u.Transaction
	v.Status = u.Status
	v.Produced = u.Produced
	return nil
}

func (v *TxIDRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType `json:"recordType"`
		Value      *url.TxID  `json:"value,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Value = u.Value
	return nil
}

func (v *UrlRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		RecordType RecordType `json:"recordType"`
		Value      *url.URL   `json:"value,omitempty"`
	}{}
	u.RecordType = v.RecordType()
	u.Value = v.Value
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.RecordType() == u.RecordType) {
		return fmt.Errorf("field RecordType: not equal: want %v, got %v", v.RecordType(), u.RecordType)
	}
	v.Value = u.Value
	return nil
}
