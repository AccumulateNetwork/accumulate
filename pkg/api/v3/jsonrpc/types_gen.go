package jsonrpc

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type FaucetRequest struct {
	Account *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	SubmitOptions
}

type QueryRecordRequest struct {
	Account  *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Fragment []string `json:"fragment,omitempty" form:"fragment" query:"fragment"`
	QueryRecordOptions
}

type QueryRecordSetRequest struct {
	Account  *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Fragment []string `json:"fragment,omitempty" form:"fragment" query:"fragment"`
	QueryRecordSetOptions
}

type SubmitRequest struct {
	Envelope *protocol.Envelope `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	SubmitOptions
}

func (v *QueryRecordRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Account        *url.URL                  `json:"account,omitempty"`
		Fragment       encoding.JsonList[string] `json:"fragment,omitempty"`
		IncludeReceipt bool                      `json:"includeReceipt,omitempty"`
		WaitForRecord  interface{}               `json:"waitForRecord,omitempty"`
		OnlyDelivered  bool                      `json:"onlyDelivered,omitempty"`
	}{}
	u.Account = v.Account
	u.Fragment = v.Fragment
	u.IncludeReceipt = v.QueryRecordOptions.IncludeReceipt
	u.WaitForRecord = encoding.DurationToJSON(v.QueryRecordOptions.WaitForRecord)
	u.OnlyDelivered = v.QueryRecordOptions.OnlyDelivered
	return json.Marshal(&u)
}

func (v *QueryRecordSetRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Account  *url.URL                  `json:"account,omitempty"`
		Fragment encoding.JsonList[string] `json:"fragment,omitempty"`
		Start    bool                      `json:"start,omitempty"`
		Count    bool                      `json:"count,omitempty"`
	}{}
	u.Account = v.Account
	u.Fragment = v.Fragment
	u.Start = v.QueryRecordSetOptions.Start
	u.Count = v.QueryRecordSetOptions.Count
	return json.Marshal(&u)
}

func (v *QueryRecordRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Account        *url.URL                  `json:"account,omitempty"`
		Fragment       encoding.JsonList[string] `json:"fragment,omitempty"`
		IncludeReceipt bool                      `json:"includeReceipt,omitempty"`
		WaitForRecord  interface{}               `json:"waitForRecord,omitempty"`
		OnlyDelivered  bool                      `json:"onlyDelivered,omitempty"`
	}{}
	u.Account = v.Account
	u.Fragment = v.Fragment
	u.IncludeReceipt = v.QueryRecordOptions.IncludeReceipt
	u.WaitForRecord = encoding.DurationToJSON(v.QueryRecordOptions.WaitForRecord)
	u.OnlyDelivered = v.QueryRecordOptions.OnlyDelivered
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account
	v.Fragment = u.Fragment
	v.QueryRecordOptions.IncludeReceipt = u.IncludeReceipt
	if x, err := encoding.DurationFromJSON(u.WaitForRecord); err != nil {
		return fmt.Errorf("error decoding WaitForRecord: %w", err)
	} else {
		v.QueryRecordOptions.WaitForRecord = x
	}
	v.QueryRecordOptions.OnlyDelivered = u.OnlyDelivered
	return nil
}

func (v *QueryRecordSetRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Account  *url.URL                  `json:"account,omitempty"`
		Fragment encoding.JsonList[string] `json:"fragment,omitempty"`
		Start    bool                      `json:"start,omitempty"`
		Count    bool                      `json:"count,omitempty"`
	}{}
	u.Account = v.Account
	u.Fragment = v.Fragment
	u.Start = v.QueryRecordSetOptions.Start
	u.Count = v.QueryRecordSetOptions.Count
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account
	v.Fragment = u.Fragment
	v.QueryRecordSetOptions.Start = u.Start
	v.QueryRecordSetOptions.Count = u.Count
	return nil
}
