// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package jsonrpc

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"

	"gitlab.com/accumulatenetwork/accumulate/pkg/api/v3"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type FaucetRequest struct {
	Account *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	SubmitOptions
}

type MetricsRequest struct {
	MetricsOptions
}

type NetworkStatusRequest struct {
	NetworkStatusOptions
}

type NodeStatusRequest struct {
	NodeStatusOptions
}

type QueryRequest struct {
	Scope *url.URL  `json:"scope,omitempty" form:"scope" query:"scope" validate:"required"`
	Query api.Query `json:"query,omitempty" form:"query" query:"query" validate:"required"`
}

type SubmitRequest struct {
	Envelope *protocol.Envelope `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	SubmitOptions
}

type ValidateRequest struct {
	Envelope *protocol.Envelope `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	ValidateOptions
}

func (v *FaucetRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Account *url.URL `json:"account,omitempty"`
		Verify  *bool    `json:"verify,omitempty"`
		Wait    *bool    `json:"wait,omitempty"`
	}{}
	u.Account = v.Account
	u.Verify = v.SubmitOptions.Verify
	u.Wait = v.SubmitOptions.Wait
	return json.Marshal(&u)
}

func (v *MetricsRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Partition string `json:"partition,omitempty"`
		Span      uint64 `json:"span,omitempty"`
	}{}
	u.Partition = v.MetricsOptions.Partition
	u.Span = v.MetricsOptions.Span
	return json.Marshal(&u)
}

func (v *NetworkStatusRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Partition string `json:"partition,omitempty"`
	}{}
	u.Partition = v.NetworkStatusOptions.Partition
	return json.Marshal(&u)
}

func (v *NodeStatusRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		NodeID    string `json:"nodeID,omitempty"`
		Partition string `json:"partition,omitempty"`
	}{}
	u.NodeID = v.NodeStatusOptions.NodeID
	u.Partition = v.NodeStatusOptions.Partition
	return json.Marshal(&u)
}

func (v *QueryRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Scope *url.URL                              `json:"scope,omitempty"`
		Query encoding.JsonUnmarshalWith[api.Query] `json:"query,omitempty"`
	}{}
	u.Scope = v.Scope
	u.Query = encoding.JsonUnmarshalWith[api.Query]{Value: v.Query, Func: api.UnmarshalQueryJSON}
	return json.Marshal(&u)
}

func (v *SubmitRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Envelope *protocol.Envelope `json:"envelope,omitempty"`
		Verify   *bool              `json:"verify,omitempty"`
		Wait     *bool              `json:"wait,omitempty"`
	}{}
	u.Envelope = v.Envelope
	u.Verify = v.SubmitOptions.Verify
	u.Wait = v.SubmitOptions.Wait
	return json.Marshal(&u)
}

func (v *ValidateRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Envelope *protocol.Envelope `json:"envelope,omitempty"`
		Full     *bool              `json:"full,omitempty"`
	}{}
	u.Envelope = v.Envelope
	u.Full = v.ValidateOptions.Full
	return json.Marshal(&u)
}

func (v *FaucetRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Account *url.URL `json:"account,omitempty"`
		Verify  *bool    `json:"verify,omitempty"`
		Wait    *bool    `json:"wait,omitempty"`
	}{}
	u.Account = v.Account
	u.Verify = v.SubmitOptions.Verify
	u.Wait = v.SubmitOptions.Wait
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account
	v.SubmitOptions.Verify = u.Verify
	v.SubmitOptions.Wait = u.Wait
	return nil
}

func (v *MetricsRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Partition string `json:"partition,omitempty"`
		Span      uint64 `json:"span,omitempty"`
	}{}
	u.Partition = v.MetricsOptions.Partition
	u.Span = v.MetricsOptions.Span
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.MetricsOptions.Partition = u.Partition
	v.MetricsOptions.Span = u.Span
	return nil
}

func (v *NetworkStatusRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Partition string `json:"partition,omitempty"`
	}{}
	u.Partition = v.NetworkStatusOptions.Partition
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.NetworkStatusOptions.Partition = u.Partition
	return nil
}

func (v *NodeStatusRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		NodeID    string `json:"nodeID,omitempty"`
		Partition string `json:"partition,omitempty"`
	}{}
	u.NodeID = v.NodeStatusOptions.NodeID
	u.Partition = v.NodeStatusOptions.Partition
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.NodeStatusOptions.NodeID = u.NodeID
	v.NodeStatusOptions.Partition = u.Partition
	return nil
}

func (v *QueryRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Scope *url.URL                              `json:"scope,omitempty"`
		Query encoding.JsonUnmarshalWith[api.Query] `json:"query,omitempty"`
	}{}
	u.Scope = v.Scope
	u.Query = encoding.JsonUnmarshalWith[api.Query]{Value: v.Query, Func: api.UnmarshalQueryJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Scope = u.Scope
	v.Query = u.Query.Value

	return nil
}

func (v *SubmitRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Envelope *protocol.Envelope `json:"envelope,omitempty"`
		Verify   *bool              `json:"verify,omitempty"`
		Wait     *bool              `json:"wait,omitempty"`
	}{}
	u.Envelope = v.Envelope
	u.Verify = v.SubmitOptions.Verify
	u.Wait = v.SubmitOptions.Wait
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Envelope = u.Envelope
	v.SubmitOptions.Verify = u.Verify
	v.SubmitOptions.Wait = u.Wait
	return nil
}

func (v *ValidateRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Envelope *protocol.Envelope `json:"envelope,omitempty"`
		Full     *bool              `json:"full,omitempty"`
	}{}
	u.Envelope = v.Envelope
	u.Full = v.ValidateOptions.Full
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Envelope = u.Envelope
	v.ValidateOptions.Full = u.Full
	return nil
}
