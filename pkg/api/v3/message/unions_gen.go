// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package message

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

var messageRegistry = new(encoding.UnionRegistry[Type, Message])

// New creates a new Message for the specified Type.
func New(typ Type) (Message, error) {
	switch typ {
	case TypeAddressed:
		return new(Addressed), nil
	case TypeConsensusStatusRequest:
		return new(ConsensusStatusRequest), nil
	case TypeConsensusStatusResponse:
		return new(ConsensusStatusResponse), nil
	case TypeErrorResponse:
		return new(ErrorResponse), nil
	case TypeEvent:
		return new(EventMessage), nil
	case TypeFaucetRequest:
		return new(FaucetRequest), nil
	case TypeFaucetResponse:
		return new(FaucetResponse), nil
	case TypeFindServiceRequest:
		return new(FindServiceRequest), nil
	case TypeFindServiceResponse:
		return new(FindServiceResponse), nil
	case TypeMetricsRequest:
		return new(MetricsRequest), nil
	case TypeMetricsResponse:
		return new(MetricsResponse), nil
	case TypeNetworkStatusRequest:
		return new(NetworkStatusRequest), nil
	case TypeNetworkStatusResponse:
		return new(NetworkStatusResponse), nil
	case TypeNodeInfoRequest:
		return new(NodeInfoRequest), nil
	case TypeNodeInfoResponse:
		return new(NodeInfoResponse), nil
	case TypePrivateSequenceRequest:
		return new(PrivateSequenceRequest), nil
	case TypePrivateSequenceResponse:
		return new(PrivateSequenceResponse), nil
	case TypeQueryRequest:
		return new(QueryRequest), nil
	case TypeRecordResponse:
		return new(RecordResponse), nil
	case TypeSubmitRequest:
		return new(SubmitRequest), nil
	case TypeSubmitResponse:
		return new(SubmitResponse), nil
	case TypeSubscribeRequest:
		return new(SubscribeRequest), nil
	case TypeSubscribeResponse:
		return new(SubscribeResponse), nil
	case TypeValidateRequest:
		return new(ValidateRequest), nil
	case TypeValidateResponse:
		return new(ValidateResponse), nil
	}
	if v, ok := messageRegistry.New(typ); ok {
		return v, nil
	}
	return nil, fmt.Errorf("unknown message %v", typ)
}

// Equal is used to compare the values of the union
func Equal(a, b Message) bool {
	if a == b {
		return true
	}
	switch a := a.(type) {
	case *Addressed:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*Addressed)
		return ok && a.Equal(b)
	case *ConsensusStatusRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*ConsensusStatusRequest)
		return ok && a.Equal(b)
	case *ConsensusStatusResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*ConsensusStatusResponse)
		return ok && a.Equal(b)
	case *ErrorResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*ErrorResponse)
		return ok && a.Equal(b)
	case *EventMessage:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*EventMessage)
		return ok && a.Equal(b)
	case *FaucetRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*FaucetRequest)
		return ok && a.Equal(b)
	case *FaucetResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*FaucetResponse)
		return ok && a.Equal(b)
	case *FindServiceRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*FindServiceRequest)
		return ok && a.Equal(b)
	case *FindServiceResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*FindServiceResponse)
		return ok && a.Equal(b)
	case *MetricsRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*MetricsRequest)
		return ok && a.Equal(b)
	case *MetricsResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*MetricsResponse)
		return ok && a.Equal(b)
	case *NetworkStatusRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*NetworkStatusRequest)
		return ok && a.Equal(b)
	case *NetworkStatusResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*NetworkStatusResponse)
		return ok && a.Equal(b)
	case *NodeInfoRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*NodeInfoRequest)
		return ok && a.Equal(b)
	case *NodeInfoResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*NodeInfoResponse)
		return ok && a.Equal(b)
	case *PrivateSequenceRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*PrivateSequenceRequest)
		return ok && a.Equal(b)
	case *PrivateSequenceResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*PrivateSequenceResponse)
		return ok && a.Equal(b)
	case *QueryRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*QueryRequest)
		return ok && a.Equal(b)
	case *RecordResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*RecordResponse)
		return ok && a.Equal(b)
	case *SubmitRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*SubmitRequest)
		return ok && a.Equal(b)
	case *SubmitResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*SubmitResponse)
		return ok && a.Equal(b)
	case *SubscribeRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*SubscribeRequest)
		return ok && a.Equal(b)
	case *SubscribeResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*SubscribeResponse)
		return ok && a.Equal(b)
	case *ValidateRequest:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*ValidateRequest)
		return ok && a.Equal(b)
	case *ValidateResponse:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*ValidateResponse)
		return ok && a.Equal(b)
	}
	return messageRegistry.Equal(a, b)
}

// Copy copies a Message.
func Copy(v Message) Message {
	switch v := v.(type) {
	case *Addressed:
		return v.Copy()
	case *ConsensusStatusRequest:
		return v.Copy()
	case *ConsensusStatusResponse:
		return v.Copy()
	case *ErrorResponse:
		return v.Copy()
	case *EventMessage:
		return v.Copy()
	case *FaucetRequest:
		return v.Copy()
	case *FaucetResponse:
		return v.Copy()
	case *FindServiceRequest:
		return v.Copy()
	case *FindServiceResponse:
		return v.Copy()
	case *MetricsRequest:
		return v.Copy()
	case *MetricsResponse:
		return v.Copy()
	case *NetworkStatusRequest:
		return v.Copy()
	case *NetworkStatusResponse:
		return v.Copy()
	case *NodeInfoRequest:
		return v.Copy()
	case *NodeInfoResponse:
		return v.Copy()
	case *PrivateSequenceRequest:
		return v.Copy()
	case *PrivateSequenceResponse:
		return v.Copy()
	case *QueryRequest:
		return v.Copy()
	case *RecordResponse:
		return v.Copy()
	case *SubmitRequest:
		return v.Copy()
	case *SubmitResponse:
		return v.Copy()
	case *SubscribeRequest:
		return v.Copy()
	case *SubscribeResponse:
		return v.Copy()
	case *ValidateRequest:
		return v.Copy()
	case *ValidateResponse:
		return v.Copy()
	default:
		return v.CopyAsInterface().(Message)
	}
}

// Unmarshal unmarshals a Message.
func Unmarshal(data []byte) (Message, error) {
	return UnmarshalFrom(bytes.NewReader(data))
}

// UnmarshalFrom unmarshals a Message.
func UnmarshalFrom(rd io.Reader) (Message, error) {
	reader := encoding.NewReader(rd)

	// Read the type code
	var typ Type
	if !reader.ReadEnum(1, &typ) {
		if reader.IsEmpty() {
			return nil, nil
		}
		return nil, fmt.Errorf("field Type: missing")
	}

	// Create a new message
	v, err := New(Type(typ))
	if err != nil {
		return nil, err
	}

	// Unmarshal the rest of the message
	err = v.UnmarshalFieldsFrom(reader)
	if err != nil {
		return nil, err
	}

	return v, nil
}

// UnmarshalJson unmarshals a Message.
func UnmarshalJSON(data []byte) (Message, error) {
	var typ *struct{ Type Type }
	err := json.Unmarshal(data, &typ)
	if err != nil {
		return nil, err
	}

	if typ == nil {
		return nil, nil
	}

	acnt, err := New(typ.Type)
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(data, acnt)
	if err != nil {
		return nil, err
	}

	return acnt, nil
}
