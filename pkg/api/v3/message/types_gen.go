// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package message

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/api/private"
	"gitlab.com/accumulatenetwork/accumulate/pkg/api/v3"
	errors2 "gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/messaging"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
)

type Addressed struct {
	fieldsSet []bool
	Message   Message       `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Address   p2p.Multiaddr `json:"address,omitempty" form:"address" query:"address" validate:"required"`
	extraData []byte
}

type ConsensusStatusRequest struct {
	fieldsSet []bool
	api.ConsensusStatusOptions
	extraData []byte
}

type ConsensusStatusResponse struct {
	fieldsSet []bool
	Value     *api.ConsensusStatus `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type ErrorResponse struct {
	fieldsSet []bool
	Error     *errors2.Error `json:"error,omitempty" form:"error" query:"error" validate:"required"`
	extraData []byte
}

type EventMessage struct {
	fieldsSet []bool
	Value     []api.Event `json:"value" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type FaucetRequest struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	api.FaucetOptions
	extraData []byte
}

type FaucetResponse struct {
	fieldsSet []bool
	Value     *api.Submission `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type FindServiceRequest struct {
	fieldsSet []bool
	api.FindServiceOptions
	extraData []byte
}

type FindServiceResponse struct {
	fieldsSet []bool
	Value     []*api.FindServiceResult `json:"value" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type MetricsRequest struct {
	fieldsSet []bool
	api.MetricsOptions
	extraData []byte
}

type MetricsResponse struct {
	fieldsSet []bool
	Value     *api.Metrics `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type NetworkStatusRequest struct {
	fieldsSet []bool
	api.NetworkStatusOptions
	extraData []byte
}

type NetworkStatusResponse struct {
	fieldsSet []bool
	Value     *api.NetworkStatus `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type NodeInfoRequest struct {
	fieldsSet []bool
	api.NodeInfoOptions
	extraData []byte
}

type NodeInfoResponse struct {
	fieldsSet []bool
	Value     *api.NodeInfo `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type PrivateSequenceRequest struct {
	fieldsSet      []bool
	Source         *url.URL `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	Destination    *url.URL `json:"destination,omitempty" form:"destination" query:"destination" validate:"required"`
	SequenceNumber uint64   `json:"sequenceNumber,omitempty" form:"sequenceNumber" query:"sequenceNumber" validate:"required"`
	private.SequenceOptions
	extraData []byte
}

type PrivateSequenceResponse struct {
	fieldsSet []bool
	Value     *api.MessageRecord[messaging.Message] `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type QueryRequest struct {
	fieldsSet []bool
	Scope     *url.URL  `json:"scope,omitempty" form:"scope" query:"scope" validate:"required"`
	Query     api.Query `json:"query,omitempty" form:"query" query:"query"`
	extraData []byte
}

type RecordResponse struct {
	fieldsSet []bool
	Value     api.Record `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type SubmitRequest struct {
	fieldsSet []bool
	Envelope  *messaging.Envelope `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	api.SubmitOptions
	extraData []byte
}

type SubmitResponse struct {
	fieldsSet []bool
	Value     []*api.Submission `json:"value" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type SubscribeRequest struct {
	fieldsSet []bool
	api.SubscribeOptions
	extraData []byte
}

type SubscribeResponse struct {
	fieldsSet []bool
	extraData []byte
}

type ValidateRequest struct {
	fieldsSet []bool
	Envelope  *messaging.Envelope `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	api.ValidateOptions
	extraData []byte
}

type ValidateResponse struct {
	fieldsSet []bool
	Value     []*api.Submission `json:"value" form:"value" query:"value" validate:"required"`
	extraData []byte
}

func (*Addressed) Type() Type { return TypeAddressed }

func (*ConsensusStatusRequest) Type() Type { return TypeConsensusStatusRequest }

func (*ConsensusStatusResponse) Type() Type { return TypeConsensusStatusResponse }

func (*ErrorResponse) Type() Type { return TypeErrorResponse }

func (*EventMessage) Type() Type { return TypeEvent }

func (*FaucetRequest) Type() Type { return TypeFaucetRequest }

func (*FaucetResponse) Type() Type { return TypeFaucetResponse }

func (*FindServiceRequest) Type() Type { return TypeFindServiceRequest }

func (*FindServiceResponse) Type() Type { return TypeFindServiceResponse }

func (*MetricsRequest) Type() Type { return TypeMetricsRequest }

func (*MetricsResponse) Type() Type { return TypeMetricsResponse }

func (*NetworkStatusRequest) Type() Type { return TypeNetworkStatusRequest }

func (*NetworkStatusResponse) Type() Type { return TypeNetworkStatusResponse }

func (*NodeInfoRequest) Type() Type { return TypeNodeInfoRequest }

func (*NodeInfoResponse) Type() Type { return TypeNodeInfoResponse }

func (*PrivateSequenceRequest) Type() Type { return TypePrivateSequenceRequest }

func (*PrivateSequenceResponse) Type() Type { return TypePrivateSequenceResponse }

func (*QueryRequest) Type() Type { return TypeQueryRequest }

func (*RecordResponse) Type() Type { return TypeRecordResponse }

func (*SubmitRequest) Type() Type { return TypeSubmitRequest }

func (*SubmitResponse) Type() Type { return TypeSubmitResponse }

func (*SubscribeRequest) Type() Type { return TypeSubscribeRequest }

func (*SubscribeResponse) Type() Type { return TypeSubscribeResponse }

func (*ValidateRequest) Type() Type { return TypeValidateRequest }

func (*ValidateResponse) Type() Type { return TypeValidateResponse }

func (v *Addressed) Copy() *Addressed {
	u := new(Addressed)

	if v.Message != nil {
		u.Message = Copy(v.Message)
	}
	if v.Address != nil {
		u.Address = p2p.CopyMultiaddr(v.Address)
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *Addressed) CopyAsInterface() interface{} { return v.Copy() }

func (v *ConsensusStatusRequest) Copy() *ConsensusStatusRequest {
	u := new(ConsensusStatusRequest)

	u.ConsensusStatusOptions = *v.ConsensusStatusOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ConsensusStatusRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *ConsensusStatusResponse) Copy() *ConsensusStatusResponse {
	u := new(ConsensusStatusResponse)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ConsensusStatusResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *ErrorResponse) Copy() *ErrorResponse {
	u := new(ErrorResponse)

	if v.Error != nil {
		u.Error = (v.Error).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ErrorResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *EventMessage) Copy() *EventMessage {
	u := new(EventMessage)

	u.Value = make([]api.Event, len(v.Value))
	for i, v := range v.Value {
		v := v
		if v != nil {
			u.Value[i] = api.CopyEvent(v)
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *EventMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *FaucetRequest) Copy() *FaucetRequest {
	u := new(FaucetRequest)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.FaucetOptions = *v.FaucetOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *FaucetRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *FaucetResponse) Copy() *FaucetResponse {
	u := new(FaucetResponse)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *FaucetResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *FindServiceRequest) Copy() *FindServiceRequest {
	u := new(FindServiceRequest)

	u.FindServiceOptions = *v.FindServiceOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *FindServiceRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *FindServiceResponse) Copy() *FindServiceResponse {
	u := new(FindServiceResponse)

	u.Value = make([]*api.FindServiceResult, len(v.Value))
	for i, v := range v.Value {
		v := v
		if v != nil {
			u.Value[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *FindServiceResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *MetricsRequest) Copy() *MetricsRequest {
	u := new(MetricsRequest)

	u.MetricsOptions = *v.MetricsOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *MetricsRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *MetricsResponse) Copy() *MetricsResponse {
	u := new(MetricsResponse)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *MetricsResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkStatusRequest) Copy() *NetworkStatusRequest {
	u := new(NetworkStatusRequest)

	u.NetworkStatusOptions = *v.NetworkStatusOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NetworkStatusRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkStatusResponse) Copy() *NetworkStatusResponse {
	u := new(NetworkStatusResponse)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NetworkStatusResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeInfoRequest) Copy() *NodeInfoRequest {
	u := new(NodeInfoRequest)

	u.NodeInfoOptions = *v.NodeInfoOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NodeInfoRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeInfoResponse) Copy() *NodeInfoResponse {
	u := new(NodeInfoResponse)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NodeInfoResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *PrivateSequenceRequest) Copy() *PrivateSequenceRequest {
	u := new(PrivateSequenceRequest)

	if v.Source != nil {
		u.Source = v.Source
	}
	if v.Destination != nil {
		u.Destination = v.Destination
	}
	u.SequenceNumber = v.SequenceNumber
	u.SequenceOptions = *v.SequenceOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *PrivateSequenceRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *PrivateSequenceResponse) Copy() *PrivateSequenceResponse {
	u := new(PrivateSequenceResponse)

	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *PrivateSequenceResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *QueryRequest) Copy() *QueryRequest {
	u := new(QueryRequest)

	if v.Scope != nil {
		u.Scope = v.Scope
	}
	if v.Query != nil {
		u.Query = api.CopyQuery(v.Query)
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *QueryRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *RecordResponse) Copy() *RecordResponse {
	u := new(RecordResponse)

	if v.Value != nil {
		u.Value = api.CopyRecord(v.Value)
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *RecordResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubmitRequest) Copy() *SubmitRequest {
	u := new(SubmitRequest)

	if v.Envelope != nil {
		u.Envelope = (v.Envelope).Copy()
	}
	u.SubmitOptions = *v.SubmitOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SubmitRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubmitResponse) Copy() *SubmitResponse {
	u := new(SubmitResponse)

	u.Value = make([]*api.Submission, len(v.Value))
	for i, v := range v.Value {
		v := v
		if v != nil {
			u.Value[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SubmitResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubscribeRequest) Copy() *SubscribeRequest {
	u := new(SubscribeRequest)

	u.SubscribeOptions = *v.SubscribeOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SubscribeRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubscribeResponse) Copy() *SubscribeResponse {
	u := new(SubscribeResponse)

	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SubscribeResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *ValidateRequest) Copy() *ValidateRequest {
	u := new(ValidateRequest)

	if v.Envelope != nil {
		u.Envelope = (v.Envelope).Copy()
	}
	u.ValidateOptions = *v.ValidateOptions.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ValidateRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *ValidateResponse) Copy() *ValidateResponse {
	u := new(ValidateResponse)

	u.Value = make([]*api.Submission, len(v.Value))
	for i, v := range v.Value {
		v := v
		if v != nil {
			u.Value[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ValidateResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *Addressed) Equal(u *Addressed) bool {
	if !(Equal(v.Message, u.Message)) {
		return false
	}
	if !(p2p.EqualMultiaddr(v.Address, u.Address)) {
		return false
	}

	return true
}

func (v *ConsensusStatusRequest) Equal(u *ConsensusStatusRequest) bool {
	if !v.ConsensusStatusOptions.Equal(&u.ConsensusStatusOptions) {
		return false
	}

	return true
}

func (v *ConsensusStatusResponse) Equal(u *ConsensusStatusResponse) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *ErrorResponse) Equal(u *ErrorResponse) bool {
	switch {
	case v.Error == u.Error:
		// equal
	case v.Error == nil || u.Error == nil:
		return false
	case !((v.Error).Equal(u.Error)):
		return false
	}

	return true
}

func (v *EventMessage) Equal(u *EventMessage) bool {
	if len(v.Value) != len(u.Value) {
		return false
	}
	for i := range v.Value {
		if !(api.EqualEvent(v.Value[i], u.Value[i])) {
			return false
		}
	}

	return true
}

func (v *FaucetRequest) Equal(u *FaucetRequest) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !v.FaucetOptions.Equal(&u.FaucetOptions) {
		return false
	}

	return true
}

func (v *FaucetResponse) Equal(u *FaucetResponse) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *FindServiceRequest) Equal(u *FindServiceRequest) bool {
	if !v.FindServiceOptions.Equal(&u.FindServiceOptions) {
		return false
	}

	return true
}

func (v *FindServiceResponse) Equal(u *FindServiceResponse) bool {
	if len(v.Value) != len(u.Value) {
		return false
	}
	for i := range v.Value {
		if !((v.Value[i]).Equal(u.Value[i])) {
			return false
		}
	}

	return true
}

func (v *MetricsRequest) Equal(u *MetricsRequest) bool {
	if !v.MetricsOptions.Equal(&u.MetricsOptions) {
		return false
	}

	return true
}

func (v *MetricsResponse) Equal(u *MetricsResponse) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *NetworkStatusRequest) Equal(u *NetworkStatusRequest) bool {
	if !v.NetworkStatusOptions.Equal(&u.NetworkStatusOptions) {
		return false
	}

	return true
}

func (v *NetworkStatusResponse) Equal(u *NetworkStatusResponse) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *NodeInfoRequest) Equal(u *NodeInfoRequest) bool {
	if !v.NodeInfoOptions.Equal(&u.NodeInfoOptions) {
		return false
	}

	return true
}

func (v *NodeInfoResponse) Equal(u *NodeInfoResponse) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *PrivateSequenceRequest) Equal(u *PrivateSequenceRequest) bool {
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	switch {
	case v.Destination == u.Destination:
		// equal
	case v.Destination == nil || u.Destination == nil:
		return false
	case !((v.Destination).Equal(u.Destination)):
		return false
	}
	if !(v.SequenceNumber == u.SequenceNumber) {
		return false
	}
	if !v.SequenceOptions.Equal(&u.SequenceOptions) {
		return false
	}

	return true
}

func (v *PrivateSequenceResponse) Equal(u *PrivateSequenceResponse) bool {
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}

	return true
}

func (v *QueryRequest) Equal(u *QueryRequest) bool {
	switch {
	case v.Scope == u.Scope:
		// equal
	case v.Scope == nil || u.Scope == nil:
		return false
	case !((v.Scope).Equal(u.Scope)):
		return false
	}
	if !(api.EqualQuery(v.Query, u.Query)) {
		return false
	}

	return true
}

func (v *RecordResponse) Equal(u *RecordResponse) bool {
	if !(api.EqualRecord(v.Value, u.Value)) {
		return false
	}

	return true
}

func (v *SubmitRequest) Equal(u *SubmitRequest) bool {
	switch {
	case v.Envelope == u.Envelope:
		// equal
	case v.Envelope == nil || u.Envelope == nil:
		return false
	case !((v.Envelope).Equal(u.Envelope)):
		return false
	}
	if !v.SubmitOptions.Equal(&u.SubmitOptions) {
		return false
	}

	return true
}

func (v *SubmitResponse) Equal(u *SubmitResponse) bool {
	if len(v.Value) != len(u.Value) {
		return false
	}
	for i := range v.Value {
		if !((v.Value[i]).Equal(u.Value[i])) {
			return false
		}
	}

	return true
}

func (v *SubscribeRequest) Equal(u *SubscribeRequest) bool {
	if !v.SubscribeOptions.Equal(&u.SubscribeOptions) {
		return false
	}

	return true
}

func (v *SubscribeResponse) Equal(u *SubscribeResponse) bool {

	return true
}

func (v *ValidateRequest) Equal(u *ValidateRequest) bool {
	switch {
	case v.Envelope == u.Envelope:
		// equal
	case v.Envelope == nil || u.Envelope == nil:
		return false
	case !((v.Envelope).Equal(u.Envelope)):
		return false
	}
	if !v.ValidateOptions.Equal(&u.ValidateOptions) {
		return false
	}

	return true
}

func (v *ValidateResponse) Equal(u *ValidateResponse) bool {
	if len(v.Value) != len(u.Value) {
		return false
	}
	for i := range v.Value {
		if !((v.Value[i]).Equal(u.Value[i])) {
			return false
		}
	}

	return true
}

var fieldNames_Addressed = []string{
	1: "Type",
	2: "Message",
	3: "Address",
}

func (v *Addressed) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(Equal(v.Message, nil)) {
		writer.WriteValue(2, v.Message.MarshalBinary)
	}
	if !(p2p.EqualMultiaddr(v.Address, nil)) {
		writer.WriteValue(3, v.Address.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_Addressed)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Addressed) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Message is missing")
	} else if Equal(v.Message, nil) {
		errs = append(errs, "field Message is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Address is missing")
	} else if p2p.EqualMultiaddr(v.Address, nil) {
		errs = append(errs, "field Address is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ConsensusStatusRequest = []string{
	1: "Type",
	2: "ConsensusStatusOptions",
}

func (v *ConsensusStatusRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.ConsensusStatusOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_ConsensusStatusRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ConsensusStatusRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.ConsensusStatusOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ConsensusStatusResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *ConsensusStatusResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ConsensusStatusResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ConsensusStatusResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ErrorResponse = []string{
	1: "Type",
	2: "Error",
}

func (v *ErrorResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Error == nil) {
		writer.WriteValue(2, v.Error.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ErrorResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ErrorResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Error is missing")
	} else if v.Error == nil {
		errs = append(errs, "field Error is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_EventMessage = []string{
	1: "Type",
	2: "Value",
}

func (v *EventMessage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	for _, v := range v.Value {
		writer.WriteValue(2, v.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_EventMessage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *EventMessage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FaucetRequest = []string{
	1: "Type",
	2: "Account",
	3: "FaucetOptions",
}

func (v *FaucetRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	writer.WriteValue(3, v.FaucetOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_FaucetRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FaucetRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if err := v.FaucetOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FaucetResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *FaucetResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_FaucetResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FaucetResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FindServiceRequest = []string{
	1: "Type",
	2: "FindServiceOptions",
}

func (v *FindServiceRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.FindServiceOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_FindServiceRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FindServiceRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.FindServiceOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FindServiceResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *FindServiceResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	for _, v := range v.Value {
		writer.WriteValue(2, v.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_FindServiceResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FindServiceResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MetricsRequest = []string{
	1: "Type",
	2: "MetricsOptions",
}

func (v *MetricsRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.MetricsOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_MetricsRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MetricsRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.MetricsOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MetricsResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *MetricsResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_MetricsResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MetricsResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkStatusRequest = []string{
	1: "Type",
	2: "NetworkStatusOptions",
}

func (v *NetworkStatusRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.NetworkStatusOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_NetworkStatusRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkStatusRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.NetworkStatusOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkStatusResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *NetworkStatusResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_NetworkStatusResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkStatusResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeInfoRequest = []string{
	1: "Type",
	2: "NodeInfoOptions",
}

func (v *NodeInfoRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.NodeInfoOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_NodeInfoRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeInfoRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.NodeInfoOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeInfoResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *NodeInfoResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_NodeInfoResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeInfoResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PrivateSequenceRequest = []string{
	1: "Type",
	2: "Source",
	3: "Destination",
	4: "SequenceNumber",
	5: "SequenceOptions",
}

func (v *PrivateSequenceRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Source == nil) {
		writer.WriteUrl(2, v.Source)
	}
	if !(v.Destination == nil) {
		writer.WriteUrl(3, v.Destination)
	}
	if !(v.SequenceNumber == 0) {
		writer.WriteUint(4, v.SequenceNumber)
	}
	writer.WriteValue(5, v.SequenceOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_PrivateSequenceRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PrivateSequenceRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Source is missing")
	} else if v.Source == nil {
		errs = append(errs, "field Source is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Destination is missing")
	} else if v.Destination == nil {
		errs = append(errs, "field Destination is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field SequenceNumber is missing")
	} else if v.SequenceNumber == 0 {
		errs = append(errs, "field SequenceNumber is not set")
	}
	if err := v.SequenceOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PrivateSequenceResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *PrivateSequenceResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_PrivateSequenceResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PrivateSequenceResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_QueryRequest = []string{
	1: "Type",
	2: "Scope",
	3: "Query",
}

func (v *QueryRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Scope == nil) {
		writer.WriteUrl(2, v.Scope)
	}
	if !(api.EqualQuery(v.Query, nil)) {
		writer.WriteValue(3, v.Query.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_QueryRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *QueryRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Scope is missing")
	} else if v.Scope == nil {
		errs = append(errs, "field Scope is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RecordResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *RecordResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(api.EqualRecord(v.Value, nil)) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_RecordResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RecordResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if api.EqualRecord(v.Value, nil) {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubmitRequest = []string{
	1: "Type",
	2: "Envelope",
	3: "SubmitOptions",
}

func (v *SubmitRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Envelope == nil) {
		writer.WriteValue(2, v.Envelope.MarshalBinary)
	}
	writer.WriteValue(3, v.SubmitOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_SubmitRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubmitRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Envelope is missing")
	} else if v.Envelope == nil {
		errs = append(errs, "field Envelope is not set")
	}
	if err := v.SubmitOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubmitResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *SubmitResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	for _, v := range v.Value {
		writer.WriteValue(2, v.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_SubmitResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubmitResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubscribeRequest = []string{
	1: "Type",
	2: "SubscribeOptions",
}

func (v *SubscribeRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.SubscribeOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_SubscribeRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubscribeRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.SubscribeOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubscribeResponse = []string{
	1: "Type",
}

func (v *SubscribeResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_SubscribeResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubscribeResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ValidateRequest = []string{
	1: "Type",
	2: "Envelope",
	3: "ValidateOptions",
}

func (v *ValidateRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Envelope == nil) {
		writer.WriteValue(2, v.Envelope.MarshalBinary)
	}
	writer.WriteValue(3, v.ValidateOptions.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_ValidateRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ValidateRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Envelope is missing")
	} else if v.Envelope == nil {
		errs = append(errs, "field Envelope is not set")
	}
	if err := v.ValidateOptions.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ValidateResponse = []string{
	1: "Type",
	2: "Value",
}

func (v *ValidateResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	for _, v := range v.Value {
		writer.WriteValue(2, v.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ValidateResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ValidateResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *Addressed) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Addressed) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *Addressed) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalFrom(r)
		if err == nil {
			v.Message = x
		}
		return err
	})
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := p2p.UnmarshalMultiaddrFrom(r)
		if err == nil {
			v.Address = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_Addressed)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ConsensusStatusRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ConsensusStatusRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ConsensusStatusRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.ConsensusStatusOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_ConsensusStatusRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ConsensusStatusResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ConsensusStatusResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ConsensusStatusResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(api.ConsensusStatus); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_ConsensusStatusResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ErrorResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ErrorResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ErrorResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(errors2.Error); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Error = x
	}

	seen, err := reader.Reset(fieldNames_ErrorResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *EventMessage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *EventMessage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *EventMessage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		ok := reader.ReadValue(2, func(r io.Reader) error {
			x, err := api.UnmarshalEventFrom(r)
			if err == nil {
				v.Value = append(v.Value, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_EventMessage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FaucetRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FaucetRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *FaucetRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	reader.ReadValue(3, v.FaucetOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_FaucetRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FaucetResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FaucetResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *FaucetResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(api.Submission); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_FaucetResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FindServiceRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FindServiceRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *FindServiceRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.FindServiceOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_FindServiceRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FindServiceResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FindServiceResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *FindServiceResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		if x := new(api.FindServiceResult); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Value = append(v.Value, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_FindServiceResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MetricsRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MetricsRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *MetricsRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.MetricsOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_MetricsRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MetricsResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MetricsResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *MetricsResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(api.Metrics); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_MetricsResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkStatusRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkStatusRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *NetworkStatusRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.NetworkStatusOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_NetworkStatusRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkStatusResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkStatusResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *NetworkStatusResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(api.NetworkStatus); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_NetworkStatusResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeInfoRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeInfoRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *NodeInfoRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.NodeInfoOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_NodeInfoRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeInfoResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeInfoResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *NodeInfoResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(api.NodeInfo); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_NodeInfoResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PrivateSequenceRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PrivateSequenceRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *PrivateSequenceRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Source = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Destination = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.SequenceNumber = x
	}
	reader.ReadValue(5, v.SequenceOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_PrivateSequenceRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PrivateSequenceResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PrivateSequenceResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *PrivateSequenceResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(api.MessageRecord[messaging.Message]); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_PrivateSequenceResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *QueryRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *QueryRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *QueryRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Scope = x
	}
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := api.UnmarshalQueryFrom(r)
		if err == nil {
			v.Query = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_QueryRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RecordResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RecordResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *RecordResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := api.UnmarshalRecordFrom(r)
		if err == nil {
			v.Value = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_RecordResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubmitRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubmitRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SubmitRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(messaging.Envelope); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Envelope = x
	}
	reader.ReadValue(3, v.SubmitOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_SubmitRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubmitResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubmitResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SubmitResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		if x := new(api.Submission); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Value = append(v.Value, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SubmitResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubscribeRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubscribeRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SubscribeRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.SubscribeOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_SubscribeRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubscribeResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubscribeResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SubscribeResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_SubscribeResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ValidateRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ValidateRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ValidateRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(messaging.Envelope); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Envelope = x
	}
	reader.ReadValue(3, v.ValidateOptions.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_ValidateRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ValidateResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ValidateResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType Type
	if x := new(Type); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ValidateResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		if x := new(api.Submission); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Value = append(v.Value, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ValidateResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func init() {

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("message", "Message"),
		encoding.NewTypeField("address", "p2p.Multiaddr"),
	}, "Addressed", "addressed")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("nodeID", "string"),
		encoding.NewTypeField("partition", "string"),
		encoding.NewTypeField("includePeers", "bool"),
		encoding.NewTypeField("includeAccumulate", "bool"),
	}, "ConsensusStatusRequest", "consensusStatusRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.ConsensusStatus"),
	}, "ConsensusStatusResponse", "consensusStatusResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("error", "errors2.Error"),
	}, "ErrorResponse", "errorResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.Event[]"),
	}, "EventMessage", "eventMessage")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("account", "string"),
		encoding.NewTypeField("token", "string"),
	}, "FaucetRequest", "faucetRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.Submission"),
	}, "FaucetResponse", "faucetResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("service", "api.ServiceAddress"),
		encoding.NewTypeField("known", "bool"),
		encoding.NewTypeField("timeout", "string"),
	}, "FindServiceRequest", "findServiceRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.FindServiceResult[]"),
	}, "FindServiceResponse", "findServiceResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("partition", "string"),
		encoding.NewTypeField("span", "uint64"),
	}, "MetricsRequest", "metricsRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.Metrics"),
	}, "MetricsResponse", "metricsResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("partition", "string"),
	}, "NetworkStatusRequest", "networkStatusRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.NetworkStatus"),
	}, "NetworkStatusResponse", "networkStatusResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("peerID", "p2p.PeerID"),
	}, "NodeInfoRequest", "nodeInfoRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.NodeInfo"),
	}, "NodeInfoResponse", "nodeInfoResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("source", "string"),
		encoding.NewTypeField("destination", "string"),
		encoding.NewTypeField("sequenceNumber", "uint64"),
		encoding.NewTypeField("nodeID", "p2p.PeerID"),
	}, "PrivateSequenceRequest", "privateSequenceRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.MessageRecord[messaging.Message]"),
	}, "PrivateSequenceResponse", "privateSequenceResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("scope", "string"),
		encoding.NewTypeField("query", "api.Query"),
	}, "QueryRequest", "queryRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.Record"),
	}, "RecordResponse", "recordResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("envelope", "messaging.Envelope"),
		encoding.NewTypeField("verify", "bool"),
		encoding.NewTypeField("wait", "bool"),
	}, "SubmitRequest", "submitRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.Submission[]"),
	}, "SubmitResponse", "submitResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("partition", "string"),
		encoding.NewTypeField("account", "string"),
	}, "SubscribeRequest", "subscribeRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
	}, "SubscribeResponse", "subscribeResponse")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("envelope", "messaging.Envelope"),
		encoding.NewTypeField("full", "bool"),
	}, "ValidateRequest", "validateRequest")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("value", "api.Submission[]"),
	}, "ValidateResponse", "validateResponse")

}

func (v *Addressed) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                                       `json:"type"`
		Message   *encoding.JsonUnmarshalWith[Message]       `json:"message,omitempty"`
		Address   *encoding.JsonUnmarshalWith[p2p.Multiaddr] `json:"address,omitempty"`
		ExtraData *string                                    `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(Equal(v.Message, nil)) {
		u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalJSON}
	}
	if !(p2p.EqualMultiaddr(v.Address, nil)) {
		u.Address = &encoding.JsonUnmarshalWith[p2p.Multiaddr]{Value: v.Address, Func: p2p.UnmarshalMultiaddrJSON}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ConsensusStatusRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type              Type    `json:"type"`
		NodeID            string  `json:"nodeID,omitempty"`
		Partition         string  `json:"partition,omitempty"`
		IncludePeers      *bool   `json:"includePeers,omitempty"`
		IncludeAccumulate *bool   `json:"includeAccumulate,omitempty"`
		ExtraData         *string `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.ConsensusStatusOptions.NodeID) == 0) {
		u.NodeID = v.ConsensusStatusOptions.NodeID
	}
	if !(len(v.ConsensusStatusOptions.Partition) == 0) {
		u.Partition = v.ConsensusStatusOptions.Partition
	}
	if !(v.ConsensusStatusOptions.IncludePeers == nil) {
		u.IncludePeers = v.ConsensusStatusOptions.IncludePeers
	}
	if !(v.ConsensusStatusOptions.IncludeAccumulate == nil) {
		u.IncludeAccumulate = v.ConsensusStatusOptions.IncludeAccumulate
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ConsensusStatusResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                 `json:"type"`
		Value     *api.ConsensusStatus `json:"value,omitempty"`
		ExtraData *string              `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ErrorResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type           `json:"type"`
		Error     *errors2.Error `json:"error,omitempty"`
		ExtraData *string        `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Error == nil) {
		u.Error = v.Error
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *EventMessage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                                       `json:"type"`
		Value     *encoding.JsonUnmarshalListWith[api.Event] `json:"value"`
		ExtraData *string                                    `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = &encoding.JsonUnmarshalListWith[api.Event]{Value: v.Value, Func: api.UnmarshalEventJSON}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *FaucetRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type     `json:"type"`
		Account   *url.URL `json:"account,omitempty"`
		Token     *url.URL `json:"token,omitempty"`
		ExtraData *string  `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Account == nil) {
		u.Account = v.Account
	}
	if !(v.FaucetOptions.Token == nil) {
		u.Token = v.FaucetOptions.Token
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *FaucetResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type            `json:"type"`
		Value     *api.Submission `json:"value,omitempty"`
		ExtraData *string         `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *FindServiceRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                `json:"type"`
		Network   string              `json:"network,omitempty"`
		Service   *api.ServiceAddress `json:"service,omitempty"`
		Known     bool                `json:"known,omitempty"`
		Timeout   interface{}         `json:"timeout,omitempty"`
		ExtraData *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.FindServiceOptions.Network) == 0) {
		u.Network = v.FindServiceOptions.Network
	}
	if !(v.FindServiceOptions.Service == nil) {
		u.Service = v.FindServiceOptions.Service
	}
	if !(!v.FindServiceOptions.Known) {
		u.Known = v.FindServiceOptions.Known
	}
	if !(v.FindServiceOptions.Timeout == 0) {
		u.Timeout = encoding.DurationToJSON(v.FindServiceOptions.Timeout)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *FindServiceResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                                      `json:"type"`
		Value     encoding.JsonList[*api.FindServiceResult] `json:"value"`
		ExtraData *string                                   `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *MetricsRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type    `json:"type"`
		Partition string  `json:"partition,omitempty"`
		Span      uint64  `json:"span,omitempty"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.MetricsOptions.Partition) == 0) {
		u.Partition = v.MetricsOptions.Partition
	}
	if !(v.MetricsOptions.Span == 0) {
		u.Span = v.MetricsOptions.Span
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *MetricsResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type         `json:"type"`
		Value     *api.Metrics `json:"value,omitempty"`
		ExtraData *string      `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *NetworkStatusRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type    `json:"type"`
		Partition string  `json:"partition,omitempty"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.NetworkStatusOptions.Partition) == 0) {
		u.Partition = v.NetworkStatusOptions.Partition
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *NetworkStatusResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type               `json:"type"`
		Value     *api.NetworkStatus `json:"value,omitempty"`
		ExtraData *string            `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *NodeInfoRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                                    `json:"type"`
		PeerID    *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"peerID,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.NodeInfoOptions.PeerID == ("")) {
		u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.NodeInfoOptions.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *NodeInfoResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type          `json:"type"`
		Value     *api.NodeInfo `json:"value,omitempty"`
		ExtraData *string       `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *PrivateSequenceRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type           Type                                    `json:"type"`
		Source         *url.URL                                `json:"source,omitempty"`
		Destination    *url.URL                                `json:"destination,omitempty"`
		SequenceNumber uint64                                  `json:"sequenceNumber,omitempty"`
		NodeID         *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"nodeID,omitempty"`
		ExtraData      *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Source == nil) {
		u.Source = v.Source
	}
	if !(v.Destination == nil) {
		u.Destination = v.Destination
	}
	if !(v.SequenceNumber == 0) {
		u.SequenceNumber = v.SequenceNumber
	}
	if !(v.SequenceOptions.NodeID == ("")) {
		u.NodeID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.SequenceOptions.NodeID, Func: p2p.UnmarshalPeerIDJSON}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *PrivateSequenceResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                                  `json:"type"`
		Value     *api.MessageRecord[messaging.Message] `json:"value,omitempty"`
		ExtraData *string                               `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Value == nil) {
		u.Value = v.Value
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *QueryRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                                   `json:"type"`
		Scope     *url.URL                               `json:"scope,omitempty"`
		Query     *encoding.JsonUnmarshalWith[api.Query] `json:"query,omitempty"`
		ExtraData *string                                `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Scope == nil) {
		u.Scope = v.Scope
	}
	if !(api.EqualQuery(v.Query, nil)) {
		u.Query = &encoding.JsonUnmarshalWith[api.Query]{Value: v.Query, Func: api.UnmarshalQueryJSON}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *RecordResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                                    `json:"type"`
		Value     *encoding.JsonUnmarshalWith[api.Record] `json:"value,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(api.EqualRecord(v.Value, nil)) {
		u.Value = &encoding.JsonUnmarshalWith[api.Record]{Value: v.Value, Func: api.UnmarshalRecordJSON}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SubmitRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                `json:"type"`
		Envelope  *messaging.Envelope `json:"envelope,omitempty"`
		Verify    *bool               `json:"verify,omitempty"`
		Wait      *bool               `json:"wait,omitempty"`
		ExtraData *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Envelope == nil) {
		u.Envelope = v.Envelope
	}
	if !(v.SubmitOptions.Verify == nil) {
		u.Verify = v.SubmitOptions.Verify
	}
	if !(v.SubmitOptions.Wait == nil) {
		u.Wait = v.SubmitOptions.Wait
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SubmitResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                               `json:"type"`
		Value     encoding.JsonList[*api.Submission] `json:"value"`
		ExtraData *string                            `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SubscribeRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type     `json:"type"`
		Partition string   `json:"partition,omitempty"`
		Account   *url.URL `json:"account,omitempty"`
		ExtraData *string  `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.SubscribeOptions.Partition) == 0) {
		u.Partition = v.SubscribeOptions.Partition
	}
	if !(v.SubscribeOptions.Account == nil) {
		u.Account = v.SubscribeOptions.Account
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SubscribeResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type    `json:"type"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ValidateRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                `json:"type"`
		Envelope  *messaging.Envelope `json:"envelope,omitempty"`
		Full      *bool               `json:"full,omitempty"`
		ExtraData *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Envelope == nil) {
		u.Envelope = v.Envelope
	}
	if !(v.ValidateOptions.Full == nil) {
		u.Full = v.ValidateOptions.Full
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ValidateResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      Type                               `json:"type"`
		Value     encoding.JsonList[*api.Submission] `json:"value"`
		ExtraData *string                            `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *Addressed) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                                       `json:"type"`
		Message   *encoding.JsonUnmarshalWith[Message]       `json:"message,omitempty"`
		Address   *encoding.JsonUnmarshalWith[p2p.Multiaddr] `json:"address,omitempty"`
		ExtraData *string                                    `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalJSON}
	u.Address = &encoding.JsonUnmarshalWith[p2p.Multiaddr]{Value: v.Address, Func: p2p.UnmarshalMultiaddrJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Message != nil {
		v.Message = u.Message.Value
	}

	if u.Address != nil {
		v.Address = u.Address.Value
	}

	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ConsensusStatusRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type              Type    `json:"type"`
		NodeID            string  `json:"nodeID,omitempty"`
		Partition         string  `json:"partition,omitempty"`
		IncludePeers      *bool   `json:"includePeers,omitempty"`
		IncludeAccumulate *bool   `json:"includeAccumulate,omitempty"`
		ExtraData         *string `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.NodeID = v.ConsensusStatusOptions.NodeID
	u.Partition = v.ConsensusStatusOptions.Partition
	u.IncludePeers = v.ConsensusStatusOptions.IncludePeers
	u.IncludeAccumulate = v.ConsensusStatusOptions.IncludeAccumulate
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.ConsensusStatusOptions.NodeID = u.NodeID
	v.ConsensusStatusOptions.Partition = u.Partition
	v.ConsensusStatusOptions.IncludePeers = u.IncludePeers
	v.ConsensusStatusOptions.IncludeAccumulate = u.IncludeAccumulate
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ConsensusStatusResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                 `json:"type"`
		Value     *api.ConsensusStatus `json:"value,omitempty"`
		ExtraData *string              `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ErrorResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type           `json:"type"`
		Error     *errors2.Error `json:"error,omitempty"`
		ExtraData *string        `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Error = v.Error
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Error = u.Error
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *EventMessage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                                       `json:"type"`
		Value     *encoding.JsonUnmarshalListWith[api.Event] `json:"value"`
		ExtraData *string                                    `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = &encoding.JsonUnmarshalListWith[api.Event]{Value: v.Value, Func: api.UnmarshalEventJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Value != nil && u.Value.Value != nil {
		v.Value = make([]api.Event, len(u.Value.Value))
		for i, x := range u.Value.Value {
			v.Value[i] = x
		}
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *FaucetRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type     `json:"type"`
		Account   *url.URL `json:"account,omitempty"`
		Token     *url.URL `json:"token,omitempty"`
		ExtraData *string  `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Account = v.Account
	u.Token = v.FaucetOptions.Token
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Account = u.Account
	v.FaucetOptions.Token = u.Token
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *FaucetResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type            `json:"type"`
		Value     *api.Submission `json:"value,omitempty"`
		ExtraData *string         `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *FindServiceRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                `json:"type"`
		Network   string              `json:"network,omitempty"`
		Service   *api.ServiceAddress `json:"service,omitempty"`
		Known     bool                `json:"known,omitempty"`
		Timeout   interface{}         `json:"timeout,omitempty"`
		ExtraData *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Network = v.FindServiceOptions.Network
	u.Service = v.FindServiceOptions.Service
	u.Known = v.FindServiceOptions.Known
	u.Timeout = encoding.DurationToJSON(v.FindServiceOptions.Timeout)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.FindServiceOptions.Network = u.Network
	v.FindServiceOptions.Service = u.Service
	v.FindServiceOptions.Known = u.Known
	if x, err := encoding.DurationFromJSON(u.Timeout); err != nil {
		return fmt.Errorf("error decoding Timeout: %w", err)
	} else {
		v.FindServiceOptions.Timeout = x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *FindServiceResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                                      `json:"type"`
		Value     encoding.JsonList[*api.FindServiceResult] `json:"value"`
		ExtraData *string                                   `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *MetricsRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type    `json:"type"`
		Partition string  `json:"partition,omitempty"`
		Span      uint64  `json:"span,omitempty"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.MetricsOptions.Partition
	u.Span = v.MetricsOptions.Span
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.MetricsOptions.Partition = u.Partition
	v.MetricsOptions.Span = u.Span
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *MetricsResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type         `json:"type"`
		Value     *api.Metrics `json:"value,omitempty"`
		ExtraData *string      `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *NetworkStatusRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type    `json:"type"`
		Partition string  `json:"partition,omitempty"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.NetworkStatusOptions.Partition
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.NetworkStatusOptions.Partition = u.Partition
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *NetworkStatusResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type               `json:"type"`
		Value     *api.NetworkStatus `json:"value,omitempty"`
		ExtraData *string            `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *NodeInfoRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                                    `json:"type"`
		PeerID    *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"peerID,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.NodeInfoOptions.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.PeerID != nil {
		v.NodeInfoOptions.PeerID = u.PeerID.Value
	}

	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *NodeInfoResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type          `json:"type"`
		Value     *api.NodeInfo `json:"value,omitempty"`
		ExtraData *string       `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *PrivateSequenceRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type           Type                                    `json:"type"`
		Source         *url.URL                                `json:"source,omitempty"`
		Destination    *url.URL                                `json:"destination,omitempty"`
		SequenceNumber uint64                                  `json:"sequenceNumber,omitempty"`
		NodeID         *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"nodeID,omitempty"`
		ExtraData      *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.Source
	u.Destination = v.Destination
	u.SequenceNumber = v.SequenceNumber
	u.NodeID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.SequenceOptions.NodeID, Func: p2p.UnmarshalPeerIDJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Source = u.Source
	v.Destination = u.Destination
	v.SequenceNumber = u.SequenceNumber
	if u.NodeID != nil {
		v.SequenceOptions.NodeID = u.NodeID.Value
	}

	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *PrivateSequenceResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                                  `json:"type"`
		Value     *api.MessageRecord[messaging.Message] `json:"value,omitempty"`
		ExtraData *string                               `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *QueryRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                                   `json:"type"`
		Scope     *url.URL                               `json:"scope,omitempty"`
		Query     *encoding.JsonUnmarshalWith[api.Query] `json:"query,omitempty"`
		ExtraData *string                                `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Scope = v.Scope
	u.Query = &encoding.JsonUnmarshalWith[api.Query]{Value: v.Query, Func: api.UnmarshalQueryJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Scope = u.Scope
	if u.Query != nil {
		v.Query = u.Query.Value
	}

	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *RecordResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                                    `json:"type"`
		Value     *encoding.JsonUnmarshalWith[api.Record] `json:"value,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = &encoding.JsonUnmarshalWith[api.Record]{Value: v.Value, Func: api.UnmarshalRecordJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Value != nil {
		v.Value = u.Value.Value
	}

	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SubmitRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                `json:"type"`
		Envelope  *messaging.Envelope `json:"envelope,omitempty"`
		Verify    *bool               `json:"verify,omitempty"`
		Wait      *bool               `json:"wait,omitempty"`
		ExtraData *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Envelope = v.Envelope
	u.Verify = v.SubmitOptions.Verify
	u.Wait = v.SubmitOptions.Wait
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Envelope = u.Envelope
	v.SubmitOptions.Verify = u.Verify
	v.SubmitOptions.Wait = u.Wait
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SubmitResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                               `json:"type"`
		Value     encoding.JsonList[*api.Submission] `json:"value"`
		ExtraData *string                            `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SubscribeRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type     `json:"type"`
		Partition string   `json:"partition,omitempty"`
		Account   *url.URL `json:"account,omitempty"`
		ExtraData *string  `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.SubscribeOptions.Partition
	u.Account = v.SubscribeOptions.Account
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.SubscribeOptions.Partition = u.Partition
	v.SubscribeOptions.Account = u.Account
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SubscribeResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type    `json:"type"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ValidateRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                `json:"type"`
		Envelope  *messaging.Envelope `json:"envelope,omitempty"`
		Full      *bool               `json:"full,omitempty"`
		ExtraData *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Envelope = v.Envelope
	u.Full = v.ValidateOptions.Full
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Envelope = u.Envelope
	v.ValidateOptions.Full = u.Full
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ValidateResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      Type                               `json:"type"`
		Value     encoding.JsonList[*api.Submission] `json:"value"`
		ExtraData *string                            `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Value = v.Value
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Value = u.Value
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}
