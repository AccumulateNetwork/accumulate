// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package p2p

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/pkg/api/v3"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
)

type serviceRegisteredEvent struct {
	fieldsSet []bool
	PeerID    p2p.PeerID          `json:"peerID,omitempty" form:"peerID" query:"peerID" validate:"required"`
	Network   string              `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Address   *api.ServiceAddress `json:"address,omitempty" form:"address" query:"address" validate:"required"`
	extraData []byte
}

func (*serviceRegisteredEvent) Type() eventType { return eventTypeServiceRegistered }

func (v *serviceRegisteredEvent) Copy() *serviceRegisteredEvent {
	u := new(serviceRegisteredEvent)

	if v.PeerID != "" {
		u.PeerID = p2p.CopyPeerID(v.PeerID)
	}
	u.Network = v.Network
	if v.Address != nil {
		u.Address = (v.Address).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *serviceRegisteredEvent) CopyAsInterface() interface{} { return v.Copy() }

func (v *serviceRegisteredEvent) Equal(u *serviceRegisteredEvent) bool {
	if !(p2p.EqualPeerID(v.PeerID, u.PeerID)) {
		return false
	}
	if !(v.Network == u.Network) {
		return false
	}
	switch {
	case v.Address == u.Address:
		// equal
	case v.Address == nil || u.Address == nil:
		return false
	case !((v.Address).Equal(u.Address)):
		return false
	}

	return true
}

var fieldNames_serviceRegisteredEvent = []string{
	1: "Type",
	2: "PeerID",
	3: "Network",
	4: "Address",
}

func (v *serviceRegisteredEvent) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.PeerID == ("")) {
		writer.WriteValue(2, v.PeerID.MarshalBinary)
	}
	if !(len(v.Network) == 0) {
		writer.WriteString(3, v.Network)
	}
	if !(v.Address == nil) {
		writer.WriteValue(4, v.Address.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_serviceRegisteredEvent)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *serviceRegisteredEvent) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PeerID is missing")
	} else if v.PeerID == ("") {
		errs = append(errs, "field PeerID is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Network is missing")
	} else if len(v.Network) == 0 {
		errs = append(errs, "field Network is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Address is missing")
	} else if v.Address == nil {
		errs = append(errs, "field Address is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *serviceRegisteredEvent) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *serviceRegisteredEvent) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType eventType
	if x := new(eventType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *serviceRegisteredEvent) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := p2p.UnmarshalPeerIDFrom(r)
		if err == nil {
			v.PeerID = x
		}
		return err
	})
	if x, ok := reader.ReadString(3); ok {
		v.Network = x
	}
	if x := new(api.ServiceAddress); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.Address = x
	}

	seen, err := reader.Reset(fieldNames_serviceRegisteredEvent)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *serviceRegisteredEvent) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    eventType                               `json:"type"`
		PeerID  *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"peerID,omitempty"`
		Network string                                  `json:"network,omitempty"`
		Address *api.ServiceAddress                     `json:"address,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.PeerID == ("")) {
		u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	}
	if !(len(v.Network) == 0) {
		u.Network = v.Network
	}
	if !(v.Address == nil) {
		u.Address = v.Address
	}
	return json.Marshal(&u)
}

func (v *serviceRegisteredEvent) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    eventType                               `json:"type"`
		PeerID  *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"peerID,omitempty"`
		Network string                                  `json:"network,omitempty"`
		Address *api.ServiceAddress                     `json:"address,omitempty"`
	}{}
	u.Type = v.Type()
	u.PeerID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.PeerID, Func: p2p.UnmarshalPeerIDJSON}
	u.Network = v.Network
	u.Address = v.Address
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.PeerID != nil {
		v.PeerID = u.PeerID.Value
	}

	v.Network = u.Network
	v.Address = u.Address
	return nil
}
