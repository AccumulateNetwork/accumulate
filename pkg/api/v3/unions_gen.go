package api

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

// NewRecord creates a new Record for the specified RecordType.
func NewRecord(typ RecordType) (Record, error) {
	switch typ {
	case RecordTypeAccount:
		return new(AccountRecord), nil
	case RecordTypeChainEntry:
		return new(ChainEntryRecord[Record]), nil
	case RecordTypeChain:
		return new(ChainRecord), nil
	case RecordTypeIndexEntry:
		return new(IndexEntryRecord), nil
	case RecordTypeRange:
		return new(RecordRange[Record]), nil
	case RecordTypeSignature:
		return new(SignatureRecord), nil
	case RecordTypeTransaction:
		return new(TransactionRecord), nil
	case RecordTypeTxID:
		return new(TxIDRecord), nil
	case RecordTypeUrl:
		return new(UrlRecord), nil
	default:
		return nil, fmt.Errorf("unknown record %v", typ)
	}
}

//EqualRecord is used to compare the values of the union
func EqualRecord(a, b Record) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	switch a := a.(type) {
	case *AccountRecord:
		b, ok := b.(*AccountRecord)
		return ok && a.Equal(b)
	case *ChainEntryRecord[Record]:
		b, ok := b.(*ChainEntryRecord[Record])
		return ok && a.Equal(b)
	case *ChainRecord:
		b, ok := b.(*ChainRecord)
		return ok && a.Equal(b)
	case *IndexEntryRecord:
		b, ok := b.(*IndexEntryRecord)
		return ok && a.Equal(b)
	case *RecordRange[Record]:
		b, ok := b.(*RecordRange[Record])
		return ok && a.Equal(b)
	case *SignatureRecord:
		b, ok := b.(*SignatureRecord)
		return ok && a.Equal(b)
	case *TransactionRecord:
		b, ok := b.(*TransactionRecord)
		return ok && a.Equal(b)
	case *TxIDRecord:
		b, ok := b.(*TxIDRecord)
		return ok && a.Equal(b)
	case *UrlRecord:
		b, ok := b.(*UrlRecord)
		return ok && a.Equal(b)
	default:
		return false
	}
}

// UnmarshalRecordType unmarshals the RecordType from the start of a Record.
func UnmarshalRecordType(r io.Reader) (RecordType, error) {
	var typ RecordType
	err := encoding.UnmarshalEnumType(r, &typ)
	return typ, err
}

// UnmarshalRecord unmarshals a Record.
func UnmarshalRecord(data []byte) (Record, error) {
	typ, err := UnmarshalRecordType(bytes.NewReader(data))
	if err != nil {
		return nil, err
	}

	v, err := NewRecord(typ)
	if err != nil {
		return nil, err
	}

	err = v.UnmarshalBinary(data)
	if err != nil {
		return nil, err
	}

	return v, nil
}

// UnmarshalRecordFrom unmarshals a Record.
func UnmarshalRecordFrom(rd io.ReadSeeker) (Record, error) {
	// Get the reader's current position
	pos, err := rd.Seek(0, io.SeekCurrent)
	if err != nil {
		return nil, err
	}

	// Read the type code
	typ, err := UnmarshalRecordType(rd)
	if err != nil {
		return nil, err
	}

	// Reset the reader's position
	_, err = rd.Seek(pos, io.SeekStart)
	if err != nil {
		return nil, err
	}

	// Create a new transaction result
	v, err := NewRecord(RecordType(typ))
	if err != nil {
		return nil, err
	}

	// Unmarshal the result
	err = v.UnmarshalBinaryFrom(rd)
	if err != nil {
		return nil, err
	}

	return v, nil
}

// UnmarshalRecordJson unmarshals a Record.
func UnmarshalRecordJSON(data []byte) (Record, error) {
	var typ *struct{ Type RecordType }
	err := json.Unmarshal(data, &typ)
	if err != nil {
		return nil, err
	}

	if typ == nil {
		return nil, nil
	}

	acnt, err := NewRecord(typ.Type)
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(data, acnt)
	if err != nil {
		return nil, err
	}

	return acnt, nil
}

// NewEvent creates a new Event for the specified EventType.
func NewEvent(typ EventType) (Event, error) {
	switch typ {
	case EventTypeBlock:
		return new(BlockEvent), nil
	default:
		return nil, fmt.Errorf("unknown event %v", typ)
	}
}

//EqualEvent is used to compare the values of the union
func EqualEvent(a, b Event) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	switch a := a.(type) {
	case *BlockEvent:
		b, ok := b.(*BlockEvent)
		return ok && a.Equal(b)
	default:
		return false
	}
}

// UnmarshalEventType unmarshals the EventType from the start of a Event.
func UnmarshalEventType(r io.Reader) (EventType, error) {
	var typ EventType
	err := encoding.UnmarshalEnumType(r, &typ)
	return typ, err
}

// UnmarshalEvent unmarshals a Event.
func UnmarshalEvent(data []byte) (Event, error) {
	typ, err := UnmarshalEventType(bytes.NewReader(data))
	if err != nil {
		return nil, err
	}

	v, err := NewEvent(typ)
	if err != nil {
		return nil, err
	}

	err = v.UnmarshalBinary(data)
	if err != nil {
		return nil, err
	}

	return v, nil
}

// UnmarshalEventFrom unmarshals a Event.
func UnmarshalEventFrom(rd io.ReadSeeker) (Event, error) {
	// Get the reader's current position
	pos, err := rd.Seek(0, io.SeekCurrent)
	if err != nil {
		return nil, err
	}

	// Read the type code
	typ, err := UnmarshalEventType(rd)
	if err != nil {
		return nil, err
	}

	// Reset the reader's position
	_, err = rd.Seek(pos, io.SeekStart)
	if err != nil {
		return nil, err
	}

	// Create a new transaction result
	v, err := NewEvent(EventType(typ))
	if err != nil {
		return nil, err
	}

	// Unmarshal the result
	err = v.UnmarshalBinaryFrom(rd)
	if err != nil {
		return nil, err
	}

	return v, nil
}

// UnmarshalEventJson unmarshals a Event.
func UnmarshalEventJSON(data []byte) (Event, error) {
	var typ *struct{ Type EventType }
	err := json.Unmarshal(data, &typ)
	if err != nil {
		return nil, err
	}

	if typ == nil {
		return nil, nil
	}

	acnt, err := NewEvent(typ.Type)
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(data, acnt)
	if err != nil {
		return nil, err
	}

	return acnt, nil
}
