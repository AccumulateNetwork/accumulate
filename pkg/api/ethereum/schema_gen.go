// Code generated by gitlab.com/accumulatenetwork/core/schema. DO NOT EDIT.

package ethrpc

import (
	json "encoding/json"
	"fmt"
	"gitlab.com/accumulatenetwork/core/schema"
)

var (
	sBlockData schema.Methods[*BlockData, *BlockData, *schema.CompositeType]
)

func init() {
	var deferredTypes schema.ResolverSet

	sBlockData = schema.WithMethods[*BlockData, *BlockData](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "BlockData",
		},
		Fields: []*schema.Field{
			{
				Name: "Number",
				Type: schema.TypeReferenceFor[Number](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "Hash",
				Type: schema.TypeReferenceFor[Bytes32](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "ParentHash",
				Type: schema.TypeReferenceFor[Bytes32](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "Nonce",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBytes},
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "SHA3Uncles",
				Type: schema.TypeReferenceFor[Bytes32](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "LogsBloom",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBytes},
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "TransactionsRoot",
				Type: schema.TypeReferenceFor[Bytes32](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "StateRoot",
				Type: schema.TypeReferenceFor[Bytes32](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "ReceiptsRoot",
				Type: schema.TypeReferenceFor[Bytes32](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "Miner",
				Type: schema.TypeReferenceFor[Address](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "Difficulty",
				Type: schema.TypeReferenceFor[Number](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "TotalDifficulty",
				Type: schema.TypeReferenceFor[Number](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "ExtraData",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBytes},
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "Size",
				Type: schema.TypeReferenceFor[Number](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "GasLimit",
				Type: schema.TypeReferenceFor[Number](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "GasUsed",
				Type: schema.TypeReferenceFor[Number](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "GasTimestamp",
				Type: schema.TypeReferenceFor[Number](),
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "Transactions",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[json.RawMessage](),
				},
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
			{
				Name: "Uncles",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[Bytes32](),
				},
				Encode: schema.MapValue{
					"keepEmpty": schema.BooleanValue(true),
				},
			},
		},
	}).SetGoType()

	s, err := schema.New(
		sBlockData.Type,
	)
	if err != nil {
		panic(fmt.Errorf("invalid embedded schema: %w", err))
	}

	s.Generate = schema.MapValue{
		"encode": schema.MapValue{
			"keepEmpty": schema.BooleanValue(true),
		},
		"import": schema.MapValue{
			"json": schema.StringValue("encoding/json"),
		},
		"methods": schema.MapValue{
			"json": schema.BooleanValue(true),
		},
		"varPrefix": schema.MapValue{
			"schema": schema.StringValue("s"),
		},
	}

	deferredTypes.Resolve(s)
	err = s.Validate()
	if err != nil {
		panic(fmt.Errorf("invalid embedded schema: %w", err))
	}
}
