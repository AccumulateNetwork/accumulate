package proxy

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"encoding/json"

	"gitlab.com/accumulatenetwork/accumulate/config"
	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

type NetworkConfigRequest struct {
	Network   string `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	extraData []byte
}

type NetworkConfigResponse struct {
	Network   config.Network `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	extraData []byte
}

type PartitionListRequest struct {
	Network   string `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	extraData []byte
}

type PartitionListResponse struct {
	Partitions []string `json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required"`
	extraData  []byte
}

type SeedCountRequest struct {
	Network   string `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	extraData []byte
}

type SeedCountResponse struct {
	Count     int64 `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	extraData []byte
}

type SeedListRequest struct {
	Network   string `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	Count     int64  `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	extraData []byte
}

type SeedListResponse struct {
	Addresses []string `json:"addresses,omitempty" form:"addresses" query:"addresses" validate:"required"`
	extraData []byte
}

func (v *NetworkConfigRequest) Copy() *NetworkConfigRequest {
	u := new(NetworkConfigRequest)

	u.Network = v.Network

	return u
}

func (v *NetworkConfigRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkConfigResponse) Copy() *NetworkConfigResponse {
	u := new(NetworkConfigResponse)

	u.Network = *(&v.Network).Copy()

	return u
}

func (v *NetworkConfigResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *PartitionListRequest) Copy() *PartitionListRequest {
	u := new(PartitionListRequest)

	u.Network = v.Network

	return u
}

func (v *PartitionListRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *PartitionListResponse) Copy() *PartitionListResponse {
	u := new(PartitionListResponse)

	u.Partitions = make([]string, len(v.Partitions))
	for i, v := range v.Partitions {
		u.Partitions[i] = v
	}

	return u
}

func (v *PartitionListResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *SeedCountRequest) Copy() *SeedCountRequest {
	u := new(SeedCountRequest)

	u.Network = v.Network
	u.Partition = v.Partition

	return u
}

func (v *SeedCountRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *SeedCountResponse) Copy() *SeedCountResponse {
	u := new(SeedCountResponse)

	u.Count = v.Count

	return u
}

func (v *SeedCountResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *SeedListRequest) Copy() *SeedListRequest {
	u := new(SeedListRequest)

	u.Network = v.Network
	u.Partition = v.Partition
	u.Count = v.Count

	return u
}

func (v *SeedListRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *SeedListResponse) Copy() *SeedListResponse {
	u := new(SeedListResponse)

	u.Addresses = make([]string, len(v.Addresses))
	for i, v := range v.Addresses {
		u.Addresses[i] = v
	}

	return u
}

func (v *SeedListResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkConfigRequest) Equal(u *NetworkConfigRequest) bool {
	if !(v.Network == u.Network) {
		return false
	}

	return true
}

func (v *NetworkConfigResponse) Equal(u *NetworkConfigResponse) bool {
	if !((&v.Network).Equal(&u.Network)) {
		return false
	}

	return true
}

func (v *PartitionListRequest) Equal(u *PartitionListRequest) bool {
	if !(v.Network == u.Network) {
		return false
	}

	return true
}

func (v *PartitionListResponse) Equal(u *PartitionListResponse) bool {
	if len(v.Partitions) != len(u.Partitions) {
		return false
	}
	for i := range v.Partitions {
		if !(v.Partitions[i] == u.Partitions[i]) {
			return false
		}
	}

	return true
}

func (v *SeedCountRequest) Equal(u *SeedCountRequest) bool {
	if !(v.Network == u.Network) {
		return false
	}
	if !(v.Partition == u.Partition) {
		return false
	}

	return true
}

func (v *SeedCountResponse) Equal(u *SeedCountResponse) bool {
	if !(v.Count == u.Count) {
		return false
	}

	return true
}

func (v *SeedListRequest) Equal(u *SeedListRequest) bool {
	if !(v.Network == u.Network) {
		return false
	}
	if !(v.Partition == u.Partition) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}

	return true
}

func (v *SeedListResponse) Equal(u *SeedListResponse) bool {
	if len(v.Addresses) != len(u.Addresses) {
		return false
	}
	for i := range v.Addresses {
		if !(v.Addresses[i] == u.Addresses[i]) {
			return false
		}
	}

	return true
}

func (v *PartitionListResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Partitions encoding.JsonList[string] `json:"partitions,omitempty"`
	}{}
	u.Partitions = v.Partitions
	return json.Marshal(&u)
}

func (v *SeedListResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Addresses encoding.JsonList[string] `json:"addresses,omitempty"`
	}{}
	u.Addresses = v.Addresses
	return json.Marshal(&u)
}

func (v *PartitionListResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Partitions encoding.JsonList[string] `json:"partitions,omitempty"`
	}{}
	u.Partitions = v.Partitions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Partitions = u.Partitions
	return nil
}

func (v *SeedListResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Addresses encoding.JsonList[string] `json:"addresses,omitempty"`
	}{}
	u.Addresses = v.Addresses
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Addresses = u.Addresses
	return nil
}
