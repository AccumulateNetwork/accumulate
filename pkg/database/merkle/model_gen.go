// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package merkle

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

//lint:file-ignore S1008,U1000 generated code

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	record "gitlab.com/accumulatenetwork/accumulate/pkg/database"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/values"
	"gitlab.com/accumulatenetwork/accumulate/pkg/errors"
)

type Chain struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       *record.Key
	typ       ChainType
	name      string
	markPower int64
	markFreq  int64
	markMask  int64

	head         values.Value[*State]
	states       map[chainStatesMapKey]values.Value[*State]
	elementIndex map[chainElementIndexMapKey]values.Value[uint64]
	element      map[chainElementMapKey]values.Value[[]byte]
}

func (c *Chain) Key() *record.Key { return c.key }

type chainStatesKey struct {
	Index uint64
}

type chainStatesMapKey struct {
	Index uint64
}

func (k chainStatesKey) ForMap() chainStatesMapKey {
	return chainStatesMapKey{k.Index}
}

type chainElementIndexKey struct {
	Hash []byte
}

type chainElementIndexMapKey struct {
	Hash [32]byte
}

func (k chainElementIndexKey) ForMap() chainElementIndexMapKey {
	return chainElementIndexMapKey{values.MapKeyBytes(k.Hash)}
}

type chainElementKey struct {
	Index uint64
}

type chainElementMapKey struct {
	Index uint64
}

func (k chainElementKey) ForMap() chainElementMapKey {
	return chainElementMapKey{k.Index}
}

func (c *Chain) Head() values.Value[*State] {
	return values.GetOrCreate(c, &c.head, (*Chain).newHead)
}

func (c *Chain) newHead() values.Value[*State] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Head"), true, values.Struct[State]())
}

func (c *Chain) States(index uint64) values.Value[*State] {
	return values.GetOrCreateMap(c, &c.states, chainStatesKey{index}, (*Chain).newStates)
}

func (c *Chain) newStates(k chainStatesKey) values.Value[*State] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("States", k.Index), false, values.Struct[State]())
}

func (c *Chain) ElementIndex(hash []byte) values.Value[uint64] {
	return values.GetOrCreateMap(c, &c.elementIndex, chainElementIndexKey{hash}, (*Chain).newElementIndex)
}

func (c *Chain) newElementIndex(k chainElementIndexKey) values.Value[uint64] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("ElementIndex", k.Hash), false, values.Wrapped(values.UintWrapper))
}

func (c *Chain) Element(index uint64) values.Value[[]byte] {
	return values.GetOrCreateMap(c, &c.element, chainElementKey{index}, (*Chain).newElement)
}

func (c *Chain) newElement(k chainElementKey) values.Value[[]byte] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Element", k.Index), false, values.Wrapped(values.BytesWrapper))
}

func (c *Chain) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for chain (1)")
	}

	switch key.Get(0) {
	case "Head":
		return c.Head(), key.SliceI(1), nil
	case "States":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for chain (2)")
		}
		index, okIndex := key.Get(1).(uint64)
		if !okIndex {
			return nil, nil, errors.InternalError.With("bad key for chain (3)")
		}
		v := c.States(index)
		return v, key.SliceI(2), nil
	case "ElementIndex":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for chain (4)")
		}
		hash, okHash := key.Get(1).([]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for chain (5)")
		}
		v := c.ElementIndex(hash)
		return v, key.SliceI(2), nil
	case "Element":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for chain (6)")
		}
		index, okIndex := key.Get(1).(uint64)
		if !okIndex {
			return nil, nil, errors.InternalError.With("bad key for chain (7)")
		}
		v := c.Element(index)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for chain (8)")
	}
}

func (c *Chain) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.head) {
		return true
	}
	for _, v := range c.states {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.elementIndex {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.element {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *Chain) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.head, c.newHead, opts, fn)
	values.WalkMap(&err, c.states, c.newStates, c.getMarkPoints, opts, fn)
	if !opts.IgnoreIndices {
		values.WalkMap(&err, c.elementIndex, c.newElementIndex, nil, opts, fn)
	}
	if !opts.IgnoreIndices {
		values.WalkMap(&err, c.element, c.newElement, nil, opts, fn)
	}
	return err
}

func (c *Chain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.head)
	for _, v := range c.states {
		values.Commit(&err, v)
	}
	for _, v := range c.elementIndex {
		values.Commit(&err, v)
	}
	for _, v := range c.element {
		values.Commit(&err, v)
	}

	return err
}

type ChainIndex struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       *record.Key
	blockSize uint64

	head  values.Value[*chainIndexBlock]
	block map[chainIndexBlockMapKey]values.Value[*chainIndexBlock]
}

func (c *ChainIndex) Key() *record.Key { return c.key }

type chainIndexBlockKey struct {
	Level uint64
	Index uint64
}

type chainIndexBlockMapKey struct {
	Level uint64
	Index uint64
}

func (k chainIndexBlockKey) ForMap() chainIndexBlockMapKey {
	return chainIndexBlockMapKey{k.Level, k.Index}
}

func (c *ChainIndex) getHead() values.Value[*chainIndexBlock] {
	return values.GetOrCreate(c, &c.head, (*ChainIndex).newHead)
}

func (c *ChainIndex) newHead() values.Value[*chainIndexBlock] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Head"), true, values.Struct[chainIndexBlock]())
}

func (c *ChainIndex) getBlock(level uint64, index uint64) values.Value[*chainIndexBlock] {
	return values.GetOrCreateMap(c, &c.block, chainIndexBlockKey{level, index}, (*ChainIndex).newBlock)
}

func (c *ChainIndex) newBlock(k chainIndexBlockKey) values.Value[*chainIndexBlock] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Block", k.Level, k.Index), false, values.Struct[chainIndexBlock]())
}

func (c *ChainIndex) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for chain index (1)")
	}

	switch key.Get(0) {
	case "Head":
		return c.getHead(), key.SliceI(1), nil
	case "Block":
		if key.Len() < 3 {
			return nil, nil, errors.InternalError.With("bad key for chain index (2)")
		}
		level, okLevel := key.Get(1).(uint64)
		index, okIndex := key.Get(2).(uint64)
		if !okLevel || !okIndex {
			return nil, nil, errors.InternalError.With("bad key for chain index (3)")
		}
		v := c.getBlock(level, index)
		return v, key.SliceI(3), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for chain index (4)")
	}
}

func (c *ChainIndex) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.head) {
		return true
	}
	for _, v := range c.block {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *ChainIndex) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.head, c.newHead, opts, fn)
	values.WalkMap(&err, c.block, c.newBlock, nil, opts, fn)
	return err
}

func (c *ChainIndex) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.head)
	for _, v := range c.block {
		values.Commit(&err, v)
	}

	return err
}
