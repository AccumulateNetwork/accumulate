// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package merkle

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

//lint:file-ignore S1008,U1000 generated code

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	record "gitlab.com/accumulatenetwork/accumulate/pkg/database"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/values"
	"gitlab.com/accumulatenetwork/accumulate/pkg/errors"
)

type MerkleManager struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       *record.Key
	typ       ChainType
	name      string
	markPower int64
	markFreq  int64
	markMask  int64

	head         values.Value[*State]
	states       map[merkleManagerStatesMapKey]values.Value[*State]
	elementIndex map[merkleManagerElementIndexMapKey]values.Value[uint64]
	element      map[merkleManagerElementMapKey]values.Value[[]byte]
}

func (c *MerkleManager) Key() *record.Key { return c.key }

type merkleManagerStatesKey struct {
	Index uint64
}

type merkleManagerStatesMapKey struct {
	Index uint64
}

func (k merkleManagerStatesKey) ForMap() merkleManagerStatesMapKey {
	return merkleManagerStatesMapKey{k.Index}
}

type merkleManagerElementIndexKey struct {
	Hash []byte
}

type merkleManagerElementIndexMapKey struct {
	Hash [32]byte
}

func (k merkleManagerElementIndexKey) ForMap() merkleManagerElementIndexMapKey {
	return merkleManagerElementIndexMapKey{values.MapKeyBytes(k.Hash)}
}

type merkleManagerElementKey struct {
	Index uint64
}

type merkleManagerElementMapKey struct {
	Index uint64
}

func (k merkleManagerElementKey) ForMap() merkleManagerElementMapKey {
	return merkleManagerElementMapKey{k.Index}
}

func (c *MerkleManager) Head() values.Value[*State] {
	return values.GetOrCreate(c, &c.head, (*MerkleManager).newHead)
}

func (c *MerkleManager) newHead() values.Value[*State] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Head"), true, values.Struct[State]())
}

func (c *MerkleManager) States(index uint64) values.Value[*State] {
	return values.GetOrCreateMap(c, &c.states, merkleManagerStatesKey{index}, (*MerkleManager).newStates)
}

func (c *MerkleManager) newStates(k merkleManagerStatesKey) values.Value[*State] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("States", k.Index), false, values.Struct[State]())
}

func (c *MerkleManager) ElementIndex(hash []byte) values.Value[uint64] {
	return values.GetOrCreateMap(c, &c.elementIndex, merkleManagerElementIndexKey{hash}, (*MerkleManager).newElementIndex)
}

func (c *MerkleManager) newElementIndex(k merkleManagerElementIndexKey) values.Value[uint64] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("ElementIndex", k.Hash), false, values.Wrapped(values.UintWrapper))
}

func (c *MerkleManager) Element(index uint64) values.Value[[]byte] {
	return values.GetOrCreateMap(c, &c.element, merkleManagerElementKey{index}, (*MerkleManager).newElement)
}

func (c *MerkleManager) newElement(k merkleManagerElementKey) values.Value[[]byte] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Element", k.Index), false, values.Wrapped(values.BytesWrapper))
}

func (c *MerkleManager) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for merkle manager (1)")
	}

	switch key.Get(0) {
	case "Head":
		return c.Head(), key.SliceI(1), nil
	case "States":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (2)")
		}
		index, okIndex := key.Get(1).(uint64)
		if !okIndex {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (3)")
		}
		v := c.States(index)
		return v, key.SliceI(2), nil
	case "ElementIndex":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (4)")
		}
		hash, okHash := key.Get(1).([]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (5)")
		}
		v := c.ElementIndex(hash)
		return v, key.SliceI(2), nil
	case "Element":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (6)")
		}
		index, okIndex := key.Get(1).(uint64)
		if !okIndex {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (7)")
		}
		v := c.Element(index)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for merkle manager (8)")
	}
}

func (c *MerkleManager) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.head) {
		return true
	}
	for _, v := range c.states {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.elementIndex {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.element {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *MerkleManager) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.head, c.newHead, opts, fn)
	values.WalkMap(&err, c.states, c.newStates, c.getMarkPoints, opts, fn)
	if !opts.IgnoreIndices {
		values.WalkMap(&err, c.elementIndex, c.newElementIndex, nil, opts, fn)
	}
	if !opts.IgnoreIndices {
		values.WalkMap(&err, c.element, c.newElement, nil, opts, fn)
	}
	return err
}

func (c *MerkleManager) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.head)
	for _, v := range c.states {
		values.Commit(&err, v)
	}
	for _, v := range c.elementIndex {
		values.Commit(&err, v)
	}
	for _, v := range c.element {
		values.Commit(&err, v)
	}

	return err
}
