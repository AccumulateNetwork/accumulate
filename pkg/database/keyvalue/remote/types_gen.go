// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package remote

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"strings"

	errors2 "gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
)

type batchCall struct {
	fieldsSet []bool
	Calls     []call `json:"calls,omitempty" form:"calls" query:"calls" validate:"required"`
	extraData []byte
}

type batchResponse struct {
	fieldsSet []bool
	Responses []response `json:"responses,omitempty" form:"responses" query:"responses" validate:"required"`
	extraData []byte
}

type commitCall struct {
	fieldsSet []bool
	extraData []byte
}

type deleteCall struct {
	fieldsSet []bool
	keyOrHash
	extraData []byte
}

type entryResponse struct {
	fieldsSet []bool
	keyOrHash
	Value     []byte `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type errorResponse struct {
	fieldsSet []bool
	Error     *errors2.Error `json:"error,omitempty" form:"error" query:"error" validate:"required"`
	extraData []byte
}

type forEachCall struct {
	fieldsSet []bool
	Hash      bool `json:"hash,omitempty" form:"hash" query:"hash"`
	extraData []byte
}

type getCall struct {
	fieldsSet []bool
	keyOrHash
	extraData []byte
}

type keyOrHash struct {
	fieldsSet []bool
	Key       *record.Key `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Hash      [32]byte    `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	extraData []byte
}

type notFoundResponse struct {
	fieldsSet []bool
	keyOrHash
	extraData []byte
}

type okResponse struct {
	fieldsSet []bool
	extraData []byte
}

type putCall struct {
	fieldsSet []bool
	keyOrHash
	Value     []byte `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type unsupportedCallResponse struct {
	fieldsSet []bool
	CallType  callType `json:"callType,omitempty" form:"callType" query:"callType" validate:"required"`
	extraData []byte
}

type valueResponse struct {
	fieldsSet []bool
	Value     []byte `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

func (*batchCall) Type() callType { return callTypeBatch }

func (*batchResponse) Type() responseType { return responseTypeBatch }

func (*commitCall) Type() callType { return callTypeCommit }

func (*deleteCall) Type() callType { return callTypeDelete }

func (*entryResponse) Type() responseType { return responseTypeEntry }

func (*errorResponse) Type() responseType { return responseTypeError }

func (*forEachCall) Type() callType { return callTypeForEach }

func (*getCall) Type() callType { return callTypeGet }

func (*notFoundResponse) Type() responseType { return responseTypeNotFound }

func (*okResponse) Type() responseType { return responseTypeOk }

func (*putCall) Type() callType { return callTypePut }

func (*unsupportedCallResponse) Type() responseType { return responseTypeUnsupportedCall }

func (*valueResponse) Type() responseType { return responseTypeValue }

func (v *batchCall) Copy() *batchCall {
	u := new(batchCall)

	u.Calls = make([]call, len(v.Calls))
	for i, v := range v.Calls {
		v := v
		if v != nil {
			u.Calls[i] = copyCall(v)
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *batchCall) CopyAsInterface() interface{} { return v.Copy() }

func (v *batchResponse) Copy() *batchResponse {
	u := new(batchResponse)

	u.Responses = make([]response, len(v.Responses))
	for i, v := range v.Responses {
		v := v
		if v != nil {
			u.Responses[i] = copyResponse(v)
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *batchResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *commitCall) Copy() *commitCall {
	u := new(commitCall)

	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *commitCall) CopyAsInterface() interface{} { return v.Copy() }

func (v *deleteCall) Copy() *deleteCall {
	u := new(deleteCall)

	u.keyOrHash = *v.keyOrHash.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *deleteCall) CopyAsInterface() interface{} { return v.Copy() }

func (v *entryResponse) Copy() *entryResponse {
	u := new(entryResponse)

	u.keyOrHash = *v.keyOrHash.Copy()
	u.Value = encoding.BytesCopy(v.Value)
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *entryResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *errorResponse) Copy() *errorResponse {
	u := new(errorResponse)

	if v.Error != nil {
		u.Error = (v.Error).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *errorResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *forEachCall) Copy() *forEachCall {
	u := new(forEachCall)

	u.Hash = v.Hash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *forEachCall) CopyAsInterface() interface{} { return v.Copy() }

func (v *getCall) Copy() *getCall {
	u := new(getCall)

	u.keyOrHash = *v.keyOrHash.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *getCall) CopyAsInterface() interface{} { return v.Copy() }

func (v *keyOrHash) Copy() *keyOrHash {
	u := new(keyOrHash)

	if v.Key != nil {
		u.Key = (v.Key).Copy()
	}
	u.Hash = v.Hash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *keyOrHash) CopyAsInterface() interface{} { return v.Copy() }

func (v *notFoundResponse) Copy() *notFoundResponse {
	u := new(notFoundResponse)

	u.keyOrHash = *v.keyOrHash.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *notFoundResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *okResponse) Copy() *okResponse {
	u := new(okResponse)

	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *okResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *putCall) Copy() *putCall {
	u := new(putCall)

	u.keyOrHash = *v.keyOrHash.Copy()
	u.Value = encoding.BytesCopy(v.Value)
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *putCall) CopyAsInterface() interface{} { return v.Copy() }

func (v *unsupportedCallResponse) Copy() *unsupportedCallResponse {
	u := new(unsupportedCallResponse)

	u.CallType = v.CallType
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *unsupportedCallResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *valueResponse) Copy() *valueResponse {
	u := new(valueResponse)

	u.Value = encoding.BytesCopy(v.Value)
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *valueResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *batchCall) Equal(u *batchCall) bool {
	if len(v.Calls) != len(u.Calls) {
		return false
	}
	for i := range v.Calls {
		if !(equalCall(v.Calls[i], u.Calls[i])) {
			return false
		}
	}

	return true
}

func (v *batchResponse) Equal(u *batchResponse) bool {
	if len(v.Responses) != len(u.Responses) {
		return false
	}
	for i := range v.Responses {
		if !(equalResponse(v.Responses[i], u.Responses[i])) {
			return false
		}
	}

	return true
}

func (v *commitCall) Equal(u *commitCall) bool {

	return true
}

func (v *deleteCall) Equal(u *deleteCall) bool {
	if !v.keyOrHash.Equal(&u.keyOrHash) {
		return false
	}

	return true
}

func (v *entryResponse) Equal(u *entryResponse) bool {
	if !v.keyOrHash.Equal(&u.keyOrHash) {
		return false
	}
	if !(bytes.Equal(v.Value, u.Value)) {
		return false
	}

	return true
}

func (v *errorResponse) Equal(u *errorResponse) bool {
	switch {
	case v.Error == u.Error:
		// equal
	case v.Error == nil || u.Error == nil:
		return false
	case !((v.Error).Equal(u.Error)):
		return false
	}

	return true
}

func (v *forEachCall) Equal(u *forEachCall) bool {
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *getCall) Equal(u *getCall) bool {
	if !v.keyOrHash.Equal(&u.keyOrHash) {
		return false
	}

	return true
}

func (v *keyOrHash) Equal(u *keyOrHash) bool {
	switch {
	case v.Key == u.Key:
		// equal
	case v.Key == nil || u.Key == nil:
		return false
	case !((v.Key).Equal(u.Key)):
		return false
	}
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *notFoundResponse) Equal(u *notFoundResponse) bool {
	if !v.keyOrHash.Equal(&u.keyOrHash) {
		return false
	}

	return true
}

func (v *okResponse) Equal(u *okResponse) bool {

	return true
}

func (v *putCall) Equal(u *putCall) bool {
	if !v.keyOrHash.Equal(&u.keyOrHash) {
		return false
	}
	if !(bytes.Equal(v.Value, u.Value)) {
		return false
	}

	return true
}

func (v *unsupportedCallResponse) Equal(u *unsupportedCallResponse) bool {
	if !(v.CallType == u.CallType) {
		return false
	}

	return true
}

func (v *valueResponse) Equal(u *valueResponse) bool {
	if !(bytes.Equal(v.Value, u.Value)) {
		return false
	}

	return true
}

var fieldNames_batchCall = []string{
	1: "Type",
	2: "Calls",
}

var fieldTypes_batchCall = []string{
	1: "string",
	2: "call[]",
}

func (v *batchCall) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Calls) == 0) {
		for _, v := range v.Calls {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_batchCall)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *batchCall) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Calls is missing")
	} else if len(v.Calls) == 0 {
		errs = append(errs, "field Calls is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_batchResponse = []string{
	1: "Type",
	2: "Responses",
}

var fieldTypes_batchResponse = []string{
	1: "string",
	2: "response[]",
}

func (v *batchResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Responses) == 0) {
		for _, v := range v.Responses {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_batchResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *batchResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Responses is missing")
	} else if len(v.Responses) == 0 {
		errs = append(errs, "field Responses is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_commitCall = []string{
	1: "Type",
}

var fieldTypes_commitCall = []string{
	1: "string",
}

func (v *commitCall) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_commitCall)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *commitCall) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_deleteCall = []string{
	1: "Type",
	2: "keyOrHash",
}

var fieldTypes_deleteCall = []string{
	1: "string",
	2: "keyOrHash",
}

func (v *deleteCall) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.keyOrHash.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_deleteCall)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *deleteCall) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.keyOrHash.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_entryResponse = []string{
	1: "Type",
	2: "keyOrHash",
	3: "Value",
}

var fieldTypes_entryResponse = []string{
	1: "string",
	2: "keyOrHash",
	3: "bytes",
}

func (v *entryResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.keyOrHash.MarshalBinary)
	if !(len(v.Value) == 0) {
		writer.WriteBytes(3, v.Value)
	}

	_, _, err := writer.Reset(fieldNames_entryResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *entryResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.keyOrHash.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Value is missing")
	} else if len(v.Value) == 0 {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_errorResponse = []string{
	1: "Type",
	2: "Error",
}

var fieldTypes_errorResponse = []string{
	1: "string",
	2: "errors2.Error",
}

func (v *errorResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Error == nil) {
		writer.WriteValue(2, v.Error.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_errorResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *errorResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Error is missing")
	} else if v.Error == nil {
		errs = append(errs, "field Error is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_forEachCall = []string{
	1: "Type",
	2: "Hash",
}

var fieldTypes_forEachCall = []string{
	1: "string",
	2: "bool",
}

func (v *forEachCall) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(!v.Hash) {
		writer.WriteBool(2, v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_forEachCall)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *forEachCall) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_getCall = []string{
	1: "Type",
	2: "keyOrHash",
}

var fieldTypes_getCall = []string{
	1: "string",
	2: "keyOrHash",
}

func (v *getCall) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.keyOrHash.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_getCall)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *getCall) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.keyOrHash.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_keyOrHash = []string{
	1: "Key",
	2: "Hash",
}

var fieldTypes_keyOrHash = []string{
	1: "record.Key",
	2: "bytes32",
}

func (v *keyOrHash) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Key == nil) {
		writer.WriteValue(1, v.Key.MarshalBinary)
	}
	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(2, &v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_keyOrHash)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *keyOrHash) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Key is missing")
	} else if v.Key == nil {
		errs = append(errs, "field Key is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Hash is missing")
	} else if v.Hash == ([32]byte{}) {
		errs = append(errs, "field Hash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_notFoundResponse = []string{
	1: "Type",
	2: "keyOrHash",
}

var fieldTypes_notFoundResponse = []string{
	1: "string",
	2: "keyOrHash",
}

func (v *notFoundResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.keyOrHash.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_notFoundResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *notFoundResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.keyOrHash.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_okResponse = []string{
	1: "Type",
}

var fieldTypes_okResponse = []string{
	1: "string",
}

func (v *okResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_okResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *okResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_putCall = []string{
	1: "Type",
	2: "keyOrHash",
	3: "Value",
}

var fieldTypes_putCall = []string{
	1: "string",
	2: "keyOrHash",
	3: "bytes",
}

func (v *putCall) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.keyOrHash.MarshalBinary)
	if !(len(v.Value) == 0) {
		writer.WriteBytes(3, v.Value)
	}

	_, _, err := writer.Reset(fieldNames_putCall)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *putCall) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.keyOrHash.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Value is missing")
	} else if len(v.Value) == 0 {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_unsupportedCallResponse = []string{
	1: "Type",
	2: "CallType",
}

var fieldTypes_unsupportedCallResponse = []string{
	1: "string",
	2: "string",
}

func (v *unsupportedCallResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.CallType == 0) {
		writer.WriteEnum(2, v.CallType)
	}

	_, _, err := writer.Reset(fieldNames_unsupportedCallResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *unsupportedCallResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field CallType is missing")
	} else if v.CallType == 0 {
		errs = append(errs, "field CallType is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_valueResponse = []string{
	1: "Type",
	2: "Value",
}

var fieldTypes_valueResponse = []string{
	1: "string",
	2: "bytes",
}

func (v *valueResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Value) == 0) {
		writer.WriteBytes(2, v.Value)
	}

	_, _, err := writer.Reset(fieldNames_valueResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *valueResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if len(v.Value) == 0 {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *batchCall) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *batchCall) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType callType
	if x := new(callType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *batchCall) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		ok := reader.ReadValue(2, func(r io.Reader) error {
			x, err := unmarshalCallFrom(r)
			if err == nil {
				v.Calls = append(v.Calls, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_batchCall)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *batchResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *batchResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType responseType
	if x := new(responseType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *batchResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		ok := reader.ReadValue(2, func(r io.Reader) error {
			x, err := unmarshalResponseFrom(r)
			if err == nil {
				v.Responses = append(v.Responses, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_batchResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *commitCall) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *commitCall) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType callType
	if x := new(callType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *commitCall) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_commitCall)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *deleteCall) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *deleteCall) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType callType
	if x := new(callType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *deleteCall) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.keyOrHash.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_deleteCall)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *entryResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *entryResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType responseType
	if x := new(responseType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *entryResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.keyOrHash.UnmarshalBinaryFrom)
	if x, ok := reader.ReadBytes(3); ok {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_entryResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *errorResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *errorResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType responseType
	if x := new(responseType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *errorResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(errors2.Error); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Error = x
	}

	seen, err := reader.Reset(fieldNames_errorResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *forEachCall) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *forEachCall) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType callType
	if x := new(callType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *forEachCall) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBool(2); ok {
		v.Hash = x
	}

	seen, err := reader.Reset(fieldNames_forEachCall)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *getCall) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *getCall) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType callType
	if x := new(callType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *getCall) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.keyOrHash.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_getCall)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *keyOrHash) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *keyOrHash) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(record.Key); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Key = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.Hash = *x
	}

	seen, err := reader.Reset(fieldNames_keyOrHash)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *notFoundResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *notFoundResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType responseType
	if x := new(responseType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *notFoundResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.keyOrHash.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_notFoundResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *okResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *okResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType responseType
	if x := new(responseType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *okResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_okResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *putCall) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *putCall) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType callType
	if x := new(callType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *putCall) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.keyOrHash.UnmarshalBinaryFrom)
	if x, ok := reader.ReadBytes(3); ok {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_putCall)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *unsupportedCallResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *unsupportedCallResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType responseType
	if x := new(responseType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *unsupportedCallResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(callType); reader.ReadEnum(2, x) {
		v.CallType = *x
	}

	seen, err := reader.Reset(fieldNames_unsupportedCallResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *valueResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *valueResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType responseType
	if x := new(responseType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *valueResponse) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadBytes(2); ok {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_valueResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func initEip712TypeDictionary() {

	encoding.SchemaDictionary["batchCall"] = &[]encoding.TypeField{
		{"type", "string"},
		{"calls", "call[]"},
	}

	encoding.SchemaDictionary["batchResponse"] = &[]encoding.TypeField{
		{"type", "string"},
		{"responses", "response[]"},
	}

	encoding.SchemaDictionary["commitCall"] = &[]encoding.TypeField{
		{"type", "string"},
	}

	encoding.SchemaDictionary["deleteCall"] = &[]encoding.TypeField{
		{"type", "string"},
		{"key", "record.Key"},
		{"hash", "bytes32"},
	}

	encoding.SchemaDictionary["entryResponse"] = &[]encoding.TypeField{
		{"type", "string"},
		{"key", "record.Key"},
		{"hash", "bytes32"},
		{"value", "bytes"},
	}

	encoding.SchemaDictionary["errorResponse"] = &[]encoding.TypeField{
		{"type", "string"},
		{"error", "errors2.Error"},
	}

	encoding.SchemaDictionary["forEachCall"] = &[]encoding.TypeField{
		{"type", "string"},
		{"hash", "bool"},
	}

	encoding.SchemaDictionary["getCall"] = &[]encoding.TypeField{
		{"type", "string"},
		{"key", "record.Key"},
		{"hash", "bytes32"},
	}

	encoding.SchemaDictionary["keyOrHash"] = &[]encoding.TypeField{
		{"key", "record.Key"},
		{"hash", "bytes32"},
	}

	encoding.SchemaDictionary["notFoundResponse"] = &[]encoding.TypeField{
		{"type", "string"},
		{"key", "record.Key"},
		{"hash", "bytes32"},
	}

	encoding.SchemaDictionary["okResponse"] = &[]encoding.TypeField{
		{"type", "string"},
	}

	encoding.SchemaDictionary["putCall"] = &[]encoding.TypeField{
		{"type", "string"},
		{"key", "record.Key"},
		{"hash", "bytes32"},
		{"value", "bytes"},
	}

	encoding.SchemaDictionary["unsupportedCallResponse"] = &[]encoding.TypeField{
		{"type", "string"},
		{"callType", "string"},
	}

	encoding.SchemaDictionary["valueResponse"] = &[]encoding.TypeField{
		{"type", "string"},
		{"value", "bytes"},
	}

	encoding.ResolveTypeDefinitions()
}
