// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package block

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
)

type endBlockEntry struct {
	fieldsSet []bool
	extraData []byte
}

type recordEntry struct {
	fieldsSet []bool
	Key       *record.Key `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Length    int64       `json:"length,omitempty" form:"length" query:"length" validate:"required"`
	extraData []byte
}

type startBlockEntry struct {
	fieldsSet []bool
	ID        uint64 `json:"id,omitempty" form:"id" query:"id" validate:"required"`
	Parent    uint64 `json:"parent,omitempty" form:"parent" query:"parent" validate:"required"`
	extraData []byte
}

func (*endBlockEntry) Type() entryType { return entryTypeEndBlock }

func (*recordEntry) Type() entryType { return entryTypeRecord }

func (*startBlockEntry) Type() entryType { return entryTypeStartBlock }

func (v *endBlockEntry) Copy() *endBlockEntry {
	u := new(endBlockEntry)

	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *endBlockEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *recordEntry) Copy() *recordEntry {
	u := new(recordEntry)

	if v.Key != nil {
		u.Key = (v.Key).Copy()
	}
	u.Length = v.Length
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *recordEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *startBlockEntry) Copy() *startBlockEntry {
	u := new(startBlockEntry)

	u.ID = v.ID
	u.Parent = v.Parent
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *startBlockEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *endBlockEntry) Equal(u *endBlockEntry) bool {

	return true
}

func (v *recordEntry) Equal(u *recordEntry) bool {
	switch {
	case v.Key == u.Key:
		// equal
	case v.Key == nil || u.Key == nil:
		return false
	case !((v.Key).Equal(u.Key)):
		return false
	}
	if !(v.Length == u.Length) {
		return false
	}

	return true
}

func (v *startBlockEntry) Equal(u *startBlockEntry) bool {
	if !(v.ID == u.ID) {
		return false
	}
	if !(v.Parent == u.Parent) {
		return false
	}

	return true
}

var fieldNames_endBlockEntry = []string{
	1: "Type",
}

func (v *endBlockEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_endBlockEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *endBlockEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_recordEntry = []string{
	1: "Type",
	2: "Key",
	3: "Length",
}

func (v *recordEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Key == nil) {
		writer.WriteValue(2, v.Key.MarshalBinary)
	}
	if !(v.Length == 0) {
		writer.WriteInt(3, v.Length)
	}

	_, _, err := writer.Reset(fieldNames_recordEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *recordEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Key is missing")
	} else if v.Key == nil {
		errs = append(errs, "field Key is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Length is missing")
	} else if v.Length == 0 {
		errs = append(errs, "field Length is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_startBlockEntry = []string{
	1: "Type",
	2: "ID",
	3: "Parent",
}

func (v *startBlockEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.ID == 0) {
		writer.WriteUint(2, v.ID)
	}
	if !(v.Parent == 0) {
		writer.WriteUint(3, v.Parent)
	}

	_, _, err := writer.Reset(fieldNames_startBlockEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *startBlockEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field ID is missing")
	} else if v.ID == 0 {
		errs = append(errs, "field ID is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Parent is missing")
	} else if v.Parent == 0 {
		errs = append(errs, "field Parent is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *endBlockEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *endBlockEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType entryType
	if x := new(entryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *endBlockEntry) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_endBlockEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *recordEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *recordEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType entryType
	if x := new(entryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *recordEntry) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(record.Key); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Key = x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.Length = x
	}

	seen, err := reader.Reset(fieldNames_recordEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *startBlockEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *startBlockEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType entryType
	if x := new(entryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *startBlockEntry) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUint(2); ok {
		v.ID = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Parent = x
	}

	seen, err := reader.Reset(fieldNames_startBlockEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *endBlockEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      entryType `json:"type"`
		ExtraData *string   `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *recordEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      entryType   `json:"type"`
		Key       *record.Key `json:"key,omitempty"`
		Length    int64       `json:"length,omitempty"`
		ExtraData *string     `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Key == nil) {
		u.Key = v.Key
	}
	if !(v.Length == 0) {
		u.Length = v.Length
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *startBlockEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      entryType `json:"type"`
		ID        uint64    `json:"id,omitempty"`
		Parent    uint64    `json:"parent,omitempty"`
		ExtraData *string   `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.ID == 0) {
		u.ID = v.ID
	}
	if !(v.Parent == 0) {
		u.Parent = v.Parent
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *endBlockEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      entryType `json:"type"`
		ExtraData *string   `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *recordEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      entryType   `json:"type"`
		Key       *record.Key `json:"key,omitempty"`
		Length    int64       `json:"length,omitempty"`
		ExtraData *string     `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = v.Key
	u.Length = v.Length
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Key = u.Key
	v.Length = u.Length
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *startBlockEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      entryType `json:"type"`
		ID        uint64    `json:"id,omitempty"`
		Parent    uint64    `json:"parent,omitempty"`
		ExtraData *string   `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.ID = v.ID
	u.Parent = v.Parent
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.ID = u.ID
	v.Parent = u.Parent
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}
