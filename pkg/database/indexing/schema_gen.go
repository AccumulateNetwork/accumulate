// Code generated by gitlab.com/accumulatenetwork/core/schema. DO NOT EDIT.

package indexing

import (
	"fmt"

	record "gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
	"gitlab.com/accumulatenetwork/core/schema"
)

var (
	sBlock    schema.UnsafeMethods[*Block[any], *schema.CompositeType]
	sEntry    schema.UnsafeMethods[*Entry[any], *schema.CompositeType]
	sRange    schema.Methods[*Range, *Range, *schema.CompositeType]
	sRangeSet schema.Methods[RangeSet, *RangeSet, *schema.ArrayType]
	sValue    schema.UnsafeMethods[*Value[any], *schema.CompositeType]
)

func init() {
	var deferredTypes schema.ResolverSet

	sBlock = schema.WithUnsafeMethods[*Block[any]](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Block",
			Parameters: []*schema.TypeParameter{
				{
					Name:       "V",
					Constraint: schema.TypeReferenceFor[any](),
				}},
		},
		Fields: []*schema.Field{
			{
				Name: "Level",
				Type: &schema.SimpleType{Type: schema.SimpleTypeUint},
			},
			{
				Name: "Index",
				Type: &schema.SimpleType{Type: schema.SimpleTypeUint},
			},
			{
				Name: "Entries",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "Entry"),
				},
			},
		},
	}).SetGoType()

	sEntry = schema.WithUnsafeMethods[*Entry[any]](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Entry",
			Parameters: []*schema.TypeParameter{
				{
					Name:       "V",
					Constraint: schema.TypeReferenceFor[any](),
				}},
		},
		Fields: []*schema.Field{
			{
				Name:        "Index",
				Description: "is used internally for multi-level indices",
				Type:        &schema.SimpleType{Type: schema.SimpleTypeUint},
			},
			{
				Name:        "Key",
				Description: "is the key being indexed",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[record.Key](),
				},
			},
			{
				Name:        "Value",
				Description: "is the value being indexed",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Value"),
			},
		},
	}).SetGoType()

	sRange = schema.WithMethods[*Range, *Range](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Range",
		},
		Fields: []*schema.Field{
			{
				Name: "Start",
				Type: &schema.SimpleType{Type: schema.SimpleTypeUint},
			},
			{
				Name: "End",
				Type: &schema.SimpleType{Type: schema.SimpleTypeUint},
			},
		},
	}).SetGoType()

	sRangeSet = schema.WithMethods[RangeSet, *RangeSet]((&schema.ArrayType{
		TypeBase: schema.TypeBase{
			Name: "RangeSet",
		},
	}).
		ResolveElemTo(&deferredTypes, "Range")).SetGoType()

	sValue = schema.WithUnsafeMethods[*Value[any]](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Value",
			Encode: schema.MapValue{
				"withWidget": schema.StringValue("wValue"),
			},
			Generate: schema.MapValue{
				"methods": schema.MapValue{
					"binary": schema.BooleanValue(false),
					"json":   schema.BooleanValue(false),
				},
				"widgets": schema.BooleanValue(false),
			},
			Parameters: []*schema.TypeParameter{
				{
					Name:       "V",
					Constraint: schema.TypeReferenceFor[any](),
				}},
		},
		Fields: []*schema.Field{
			{
				Name: "data",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBytes},
			},
			{
				Name: "dataOk",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBool},
			},
			{
				Name: "value",
				Type: (&schema.TypeArgument{
					Value: schema.TypeReferenceFor[any](),
				}).
					ResolveParameterTo(&deferredTypes, "Value", "V"),
			},
			{
				Name: "valueOk",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBool},
			},
		},
	}).SetGoType()

	s, err := schema.New(
		sBlock.Type,
		sEntry.Type,
		sRange.Type,
		sRangeSet.Type,
		sValue.Type,
	)
	if err != nil {
		panic(fmt.Errorf("invalid embedded schema: %w", err))
	}

	s.Generate = schema.MapValue{
		"import": schema.MapValue{
			"record": schema.StringValue("gitlab.com/accumulatenetwork/accumulate/pkg/types/record"),
		},
		"methods": schema.MapValue{
			"binary": schema.BooleanValue(true),
			"json":   schema.BooleanValue(true),
		},
		"varPrefix": schema.MapValue{
			"schema": schema.StringValue("s"),
			"widget": schema.StringValue("w"),
		},
		"widgets": schema.BooleanValue(true),
	}

	deferredTypes.Resolve(s)
	err = s.Validate()
	if err != nil {
		panic(fmt.Errorf("invalid embedded schema: %w", err))
	}
}
