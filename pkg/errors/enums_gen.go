// Copyright 2024 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package errors

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	"strings"
)

// OK means the request completed successfully.
const OK Status = 200

// Delivered means the transaction has been delivered.
const Delivered Status = 201

// Pending means the transaction is pending.
const Pending Status = 202

// Remote means the transaction is a local reference to a remote.
const Remote Status = 203

// WrongPartition means the requested resource is assigned to a different network partition.
const WrongPartition Status = 301

// BadRequest means the request was invalid.
const BadRequest Status = 400

// Unauthenticated means the signature could not be validated.
const Unauthenticated Status = 401

// InsufficientCredits means the signer does not have sufficient credits to execute the transaction.
const InsufficientCredits Status = 402

// Unauthorized means the signer is not authorized to sign the transaction.
const Unauthorized Status = 403

// NotFound means a record could not be found.
const NotFound Status = 404

// NotAllowed means the requested action could not be performed.
const NotAllowed Status = 405

// Rejected is returned when a transaction is rejected.
const Rejected Status = 406

// Expired is returned when a transaction has expired.
const Expired Status = 407

// Conflict means the request failed due to a conflict.
const Conflict Status = 409

// BadSignerVersion means the signer version does not match.
const BadSignerVersion Status = 411

// BadTimestamp means the timestamp is invalid.
const BadTimestamp Status = 412

// BadUrlLength means the url length is too big.
const BadUrlLength Status = 413

// IncompleteChain means the chain does not include the full history.
const IncompleteChain Status = 414

// InsufficientBalance means the account balance is insufficient to satisfy the request.
const InsufficientBalance Status = 415

// InternalError means an internal error occurred.
const InternalError Status = 500

// UnknownError means an unknown error occurred.
const UnknownError Status = 501

// EncodingError means encoding or decoding failed.
const EncodingError Status = 502

// FatalError means something has gone seriously wrong.
const FatalError Status = 503

// NotReady means the receiver is not ready to satisfy the request.
const NotReady Status = 504

// WrongType means the record is not the expected type.
const WrongType Status = 505

// NoPeer means the receiver cannot find a peer to satisfy the request.
const NoPeer Status = 506

// PeerMisbehaved means a peer behaved incorrectly.
const PeerMisbehaved Status = 507

// InvalidRecord means the database has one or more invalid records.
const InvalidRecord Status = 508

// StreamAborted is equivalent to [io.ErrUnexpectedEOF].
const StreamAborted Status = 509

// GetEnumValue returns the value of the Status
func (v Status) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *Status) SetEnumValue(id uint64) bool {
	u := Status(id)
	switch u {
	case OK, Delivered, Pending, Remote, WrongPartition, BadRequest, Unauthenticated, InsufficientCredits, Unauthorized, NotFound, NotAllowed, Rejected, Expired, Conflict, BadSignerVersion, BadTimestamp, BadUrlLength, IncompleteChain, InsufficientBalance, InternalError, UnknownError, EncodingError, FatalError, NotReady, WrongType, NoPeer, PeerMisbehaved, InvalidRecord, StreamAborted:
		*v = u
		return true
	}
	return false
}

// String returns the name of the Status.
func (v Status) String() string {
	switch v {
	case OK:
		return "ok"
	case Delivered:
		return "delivered"
	case Pending:
		return "pending"
	case Remote:
		return "remote"
	case WrongPartition:
		return "wrongPartition"
	case BadRequest:
		return "badRequest"
	case Unauthenticated:
		return "unauthenticated"
	case InsufficientCredits:
		return "insufficientCredits"
	case Unauthorized:
		return "unauthorized"
	case NotFound:
		return "notFound"
	case NotAllowed:
		return "notAllowed"
	case Rejected:
		return "rejected"
	case Expired:
		return "expired"
	case Conflict:
		return "conflict"
	case BadSignerVersion:
		return "badSignerVersion"
	case BadTimestamp:
		return "badTimestamp"
	case BadUrlLength:
		return "badUrlLength"
	case IncompleteChain:
		return "incompleteChain"
	case InsufficientBalance:
		return "insufficientBalance"
	case InternalError:
		return "internalError"
	case UnknownError:
		return "unknownError"
	case EncodingError:
		return "encodingError"
	case FatalError:
		return "fatalError"
	case NotReady:
		return "notReady"
	case WrongType:
		return "wrongType"
	case NoPeer:
		return "noPeer"
	case PeerMisbehaved:
		return "peerMisbehaved"
	case InvalidRecord:
		return "invalidRecord"
	case StreamAborted:
		return "streamAborted"
	}
	return fmt.Sprintf("Status:%d", v)
}

// StatusByName returns the named Status.
func StatusByName(name string) (Status, bool) {
	switch strings.ToLower(name) {
	case "ok":
		return OK, true
	case "delivered":
		return Delivered, true
	case "pending":
		return Pending, true
	case "remote":
		return Remote, true
	case "wrongpartition":
		return WrongPartition, true
	case "badrequest":
		return BadRequest, true
	case "unauthenticated":
		return Unauthenticated, true
	case "insufficientcredits":
		return InsufficientCredits, true
	case "unauthorized":
		return Unauthorized, true
	case "notfound":
		return NotFound, true
	case "notallowed":
		return NotAllowed, true
	case "rejected":
		return Rejected, true
	case "expired":
		return Expired, true
	case "conflict":
		return Conflict, true
	case "badsignerversion":
		return BadSignerVersion, true
	case "badtimestamp":
		return BadTimestamp, true
	case "badurllength":
		return BadUrlLength, true
	case "incompletechain":
		return IncompleteChain, true
	case "insufficientbalance":
		return InsufficientBalance, true
	case "internalerror":
		return InternalError, true
	case "unknownerror":
		return UnknownError, true
	case "encodingerror":
		return EncodingError, true
	case "fatalerror":
		return FatalError, true
	case "notready":
		return NotReady, true
	case "wrongtype":
		return WrongType, true
	case "nopeer":
		return NoPeer, true
	case "peermisbehaved":
		return PeerMisbehaved, true
	case "invalidrecord":
		return InvalidRecord, true
	case "streamaborted":
		return StreamAborted, true
	}
	return 0, false
}

// MarshalJSON marshals the Status to JSON as a string.
func (v Status) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Status from JSON as a string.
func (v *Status) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = StatusByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Status %q", s)
	}
	return nil
}
