// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package messaging

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	"strings"
)

// MessageTypeLegacy is used for the V1 executor.
const MessageTypeLegacy MessageType = 1

// MessageTypeUserTransaction is a transaction from a user.
const MessageTypeUserTransaction MessageType = 2

// MessageTypeSyntheticTransaction is a transaction produced by the protocol.
const MessageTypeSyntheticTransaction MessageType = 3

// MessageTypeUserSignature is a key signature from a user.
const MessageTypeUserSignature MessageType = 4

// MessageTypeValidatorSignature is a key signature from a core protocol validator.
const MessageTypeValidatorSignature MessageType = 5

// MessageTypeAuthoritySignature is a signature from an authority who's signing requirements have been met.
const MessageTypeAuthoritySignature MessageType = 6

// GetEnumValue returns the value of the Message Type
func (v MessageType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *MessageType) SetEnumValue(id uint64) bool {
	u := MessageType(id)
	switch u {
	case MessageTypeLegacy, MessageTypeUserTransaction, MessageTypeSyntheticTransaction, MessageTypeUserSignature, MessageTypeValidatorSignature, MessageTypeAuthoritySignature:
		*v = u
		return true
	default:
		return false
	}
}

// String returns the name of the Message Type.
func (v MessageType) String() string {
	switch v {
	case MessageTypeLegacy:
		return "legacy"
	case MessageTypeUserTransaction:
		return "userTransaction"
	case MessageTypeSyntheticTransaction:
		return "syntheticTransaction"
	case MessageTypeUserSignature:
		return "userSignature"
	case MessageTypeValidatorSignature:
		return "validatorSignature"
	case MessageTypeAuthoritySignature:
		return "authoritySignature"
	default:
		return fmt.Sprintf("MessageType:%d", v)
	}
}

// MessageTypeByName returns the named Message Type.
func MessageTypeByName(name string) (MessageType, bool) {
	switch strings.ToLower(name) {
	case "legacy":
		return MessageTypeLegacy, true
	case "usertransaction":
		return MessageTypeUserTransaction, true
	case "synthetictransaction":
		return MessageTypeSyntheticTransaction, true
	case "usersignature":
		return MessageTypeUserSignature, true
	case "validatorsignature":
		return MessageTypeValidatorSignature, true
	case "authoritysignature":
		return MessageTypeAuthoritySignature, true
	default:
		return 0, false
	}
}

// MarshalJSON marshals the Message Type to JSON as a string.
func (v MessageType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the Message Type from JSON as a string.
func (v *MessageType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = MessageTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid Message Type %q", s)
	}
	return nil
}
