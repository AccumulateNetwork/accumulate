// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package messaging

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/libp2p/go-libp2p/core/peer"
	"gitlab.com/accumulatenetwork/accumulate/internal/node/config"
	"gitlab.com/accumulatenetwork/accumulate/pkg/api/v3/message"
	errors2 "gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"io"
	"math/big"
	"strings"
	"time"
)

type BadSyntheticMessage struct {
	fieldsSet []bool
	Message   Message                    `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Signature protocol.KeySignature      `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Proof     *protocol.AnnotatedReceipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	extraData []byte
}

type BlockAnchor struct {
	fieldsSet []bool
	Signature protocol.KeySignature `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Anchor    Message               `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	extraData []byte
}

type BlockSummary struct {
	fieldsSet []bool
	// Partition is the ID of the partition of the block.
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	// Index is the index of the block.
	Index uint64 `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	// StateTreeHash is the state tree hash after the block.
	StateTreeHash [32]byte `json:"stateTreeHash,omitempty" form:"stateTreeHash" query:"stateTreeHash" validate:"required"`
	// PreviousBlock is the index of the previous block (excludes any empty blocks).
	PreviousBlock    uint64             `json:"previousBlock,omitempty" form:"previousBlock" query:"previousBlock" validate:"required"`
	RecordUpdates    []*RecordUpdate    `json:"recordUpdates,omitempty" form:"recordUpdates" query:"recordUpdates" validate:"required"`
	StateTreeUpdates []*StateTreeUpdate `json:"stateTreeUpdates,omitempty" form:"stateTreeUpdates" query:"stateTreeUpdates" validate:"required"`
	extraData        []byte
}

type CreditPayment struct {
	fieldsSet []bool
	Paid      protocol.Fee `json:"paid,omitempty" form:"paid" query:"paid" validate:"required"`
	Payer     *url.URL     `json:"payer,omitempty" form:"payer" query:"payer" validate:"required"`
	// Initiator indicates whether the signature initiated the transaction.
	Initiator bool      `json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	TxID      *url.TxID `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Cause     *url.TxID `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	extraData []byte
}

type DidUpdateExecutorVersion struct {
	fieldsSet []bool
	Partition string                   `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	Version   protocol.ExecutorVersion `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	extraData []byte
}

type Envelope struct {
	fieldsSet   []bool
	Signatures  []protocol.Signature    `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	TxHash      []byte                  `json:"txHash,omitempty" form:"txHash" query:"txHash"`
	Transaction []*protocol.Transaction `json:"transaction,omitempty" form:"transaction" query:"transaction"`
	Messages    []Message               `json:"messages,omitempty" form:"messages" query:"messages"`
	extraData   []byte
}

type MakeMajorBlock struct {
	fieldsSet []bool
	// MajorBlockIndex is the major block index.
	MajorBlockIndex uint64 `json:"majorBlockIndex,omitempty" form:"majorBlockIndex" query:"majorBlockIndex" validate:"required"`
	// MinorBlockIndex is the minor block index.
	MinorBlockIndex uint64 `json:"minorBlockIndex,omitempty" form:"minorBlockIndex" query:"minorBlockIndex" validate:"required"`
	// MajorBlockTime is the timestamp of the major block.
	MajorBlockTime time.Time `json:"majorBlockTime,omitempty" form:"majorBlockTime" query:"majorBlockTime" validate:"required"`
	extraData      []byte
}

type NetworkUpdate struct {
	fieldsSet []bool
	Accounts  []*protocol.NetworkAccountUpdate `json:"accounts,omitempty" form:"accounts" query:"accounts" validate:"required"`
	extraData []byte
}

type RecordUpdate struct {
	fieldsSet []bool
	Key       *record.Key `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Value     []byte      `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type SequencedMessage struct {
	fieldsSet []bool
	Message   Message `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	// Source is the source that produced the transaction.
	Source *url.URL `json:"source,omitempty" form:"source" query:"source"`
	// Destination is the destination that the transaction is sent to.
	Destination *url.URL `json:"destination,omitempty" form:"destination" query:"destination"`
	// Number is the sequence number of the transaction.
	Number    uint64 `json:"number,omitempty" form:"number" query:"number"`
	extraData []byte
}

type SignatureMessage struct {
	fieldsSet []bool
	Signature protocol.Signature `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	TxID      *url.TxID          `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	extraData []byte
}

type SignatureRequest struct {
	fieldsSet []bool
	Authority *url.URL  `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	TxID      *url.TxID `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Cause     *url.TxID `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	extraData []byte
}

type StateTreeUpdate struct {
	fieldsSet []bool
	Key       *record.Key `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Hash      [32]byte    `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	extraData []byte
}

// SynthFields contains the fields of a synthetic message.
type SynthFields struct {
	Message   Message                    `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Signature protocol.KeySignature      `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Proof     *protocol.AnnotatedReceipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
}

type SyntheticMessage struct {
	fieldsSet []bool
	Message   Message                    `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Signature protocol.KeySignature      `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Proof     *protocol.AnnotatedReceipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	extraData []byte
}

type TransactionMessage struct {
	fieldsSet   []bool
	Transaction *protocol.Transaction `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	extraData   []byte
}

func (*BadSyntheticMessage) Type() MessageType { return MessageTypeBadSynthetic }

func (*BlockAnchor) Type() MessageType { return MessageTypeBlockAnchor }

func (*BlockSummary) Type() MessageType { return MessageTypeBlockSummary }

func (*CreditPayment) Type() MessageType { return MessageTypeCreditPayment }

func (*DidUpdateExecutorVersion) Type() MessageType { return MessageTypeDidUpdateExecutorVersion }

func (*MakeMajorBlock) Type() MessageType { return MessageTypeMakeMajorBlock }

func (*NetworkUpdate) Type() MessageType { return MessageTypeNetworkUpdate }

func (*SequencedMessage) Type() MessageType { return MessageTypeSequenced }

func (*SignatureMessage) Type() MessageType { return MessageTypeSignature }

func (*SignatureRequest) Type() MessageType { return MessageTypeSignatureRequest }

func (*SyntheticMessage) Type() MessageType { return MessageTypeSynthetic }

func (*TransactionMessage) Type() MessageType { return MessageTypeTransaction }

func (v *BadSyntheticMessage) Copy() *BadSyntheticMessage {
	u := new(BadSyntheticMessage)

	if v.Message != nil {
		u.Message = CopyMessage(v.Message)
	}
	if v.Signature != nil {
		u.Signature = protocol.CopyKeySignature(v.Signature)
	}
	if v.Proof != nil {
		u.Proof = (v.Proof).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BadSyntheticMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockAnchor) Copy() *BlockAnchor {
	u := new(BlockAnchor)

	if v.Signature != nil {
		u.Signature = protocol.CopyKeySignature(v.Signature)
	}
	if v.Anchor != nil {
		u.Anchor = CopyMessage(v.Anchor)
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockAnchor) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockSummary) Copy() *BlockSummary {
	u := new(BlockSummary)

	u.Partition = v.Partition
	u.Index = v.Index
	u.StateTreeHash = v.StateTreeHash
	u.PreviousBlock = v.PreviousBlock
	u.RecordUpdates = make([]*RecordUpdate, len(v.RecordUpdates))
	for i, v := range v.RecordUpdates {
		v := v
		if v != nil {
			u.RecordUpdates[i] = (v).Copy()
		}
	}
	u.StateTreeUpdates = make([]*StateTreeUpdate, len(v.StateTreeUpdates))
	for i, v := range v.StateTreeUpdates {
		v := v
		if v != nil {
			u.StateTreeUpdates[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockSummary) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreditPayment) Copy() *CreditPayment {
	u := new(CreditPayment)

	u.Paid = v.Paid
	if v.Payer != nil {
		u.Payer = v.Payer
	}
	u.Initiator = v.Initiator
	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if v.Cause != nil {
		u.Cause = v.Cause
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *CreditPayment) CopyAsInterface() interface{} { return v.Copy() }

func (v *DidUpdateExecutorVersion) Copy() *DidUpdateExecutorVersion {
	u := new(DidUpdateExecutorVersion)

	u.Partition = v.Partition
	u.Version = v.Version
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *DidUpdateExecutorVersion) CopyAsInterface() interface{} { return v.Copy() }

func (v *Envelope) Copy() *Envelope {
	u := new(Envelope)

	u.Signatures = make([]protocol.Signature, len(v.Signatures))
	for i, v := range v.Signatures {
		v := v
		if v != nil {
			u.Signatures[i] = protocol.CopySignature(v)
		}
	}
	u.TxHash = encoding.BytesCopy(v.TxHash)
	u.Transaction = make([]*protocol.Transaction, len(v.Transaction))
	for i, v := range v.Transaction {
		v := v
		if v != nil {
			u.Transaction[i] = (v).Copy()
		}
	}
	u.Messages = make([]Message, len(v.Messages))
	for i, v := range v.Messages {
		v := v
		if v != nil {
			u.Messages[i] = CopyMessage(v)
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *Envelope) CopyAsInterface() interface{} { return v.Copy() }

func (v *MakeMajorBlock) Copy() *MakeMajorBlock {
	u := new(MakeMajorBlock)

	u.MajorBlockIndex = v.MajorBlockIndex
	u.MinorBlockIndex = v.MinorBlockIndex
	u.MajorBlockTime = v.MajorBlockTime
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *MakeMajorBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkUpdate) Copy() *NetworkUpdate {
	u := new(NetworkUpdate)

	u.Accounts = make([]*protocol.NetworkAccountUpdate, len(v.Accounts))
	for i, v := range v.Accounts {
		v := v
		if v != nil {
			u.Accounts[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NetworkUpdate) CopyAsInterface() interface{} { return v.Copy() }

func (v *RecordUpdate) Copy() *RecordUpdate {
	u := new(RecordUpdate)

	if v.Key != nil {
		u.Key = (v.Key).Copy()
	}
	u.Value = encoding.BytesCopy(v.Value)
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *RecordUpdate) CopyAsInterface() interface{} { return v.Copy() }

func (v *SequencedMessage) Copy() *SequencedMessage {
	u := new(SequencedMessage)

	if v.Message != nil {
		u.Message = CopyMessage(v.Message)
	}
	if v.Source != nil {
		u.Source = v.Source
	}
	if v.Destination != nil {
		u.Destination = v.Destination
	}
	u.Number = v.Number
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SequencedMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureMessage) Copy() *SignatureMessage {
	u := new(SignatureMessage)

	if v.Signature != nil {
		u.Signature = protocol.CopySignature(v.Signature)
	}
	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SignatureMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureRequest) Copy() *SignatureRequest {
	u := new(SignatureRequest)

	if v.Authority != nil {
		u.Authority = v.Authority
	}
	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if v.Cause != nil {
		u.Cause = v.Cause
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SignatureRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *StateTreeUpdate) Copy() *StateTreeUpdate {
	u := new(StateTreeUpdate)

	if v.Key != nil {
		u.Key = (v.Key).Copy()
	}
	u.Hash = v.Hash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *StateTreeUpdate) CopyAsInterface() interface{} { return v.Copy() }

func (v *SynthFields) Copy() *SynthFields {
	u := new(SynthFields)

	if v.Message != nil {
		u.Message = CopyMessage(v.Message)
	}
	if v.Signature != nil {
		u.Signature = protocol.CopyKeySignature(v.Signature)
	}
	if v.Proof != nil {
		u.Proof = (v.Proof).Copy()
	}

	return u
}

func (v *SynthFields) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticMessage) Copy() *SyntheticMessage {
	u := new(SyntheticMessage)

	if v.Message != nil {
		u.Message = CopyMessage(v.Message)
	}
	if v.Signature != nil {
		u.Signature = protocol.CopyKeySignature(v.Signature)
	}
	if v.Proof != nil {
		u.Proof = (v.Proof).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SyntheticMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionMessage) Copy() *TransactionMessage {
	u := new(TransactionMessage)

	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *TransactionMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *BadSyntheticMessage) Equal(u *BadSyntheticMessage) bool {
	if !(EqualMessage(v.Message, u.Message)) {
		return false
	}
	if !(protocol.EqualKeySignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Proof == u.Proof:
		// equal
	case v.Proof == nil || u.Proof == nil:
		return false
	case !((v.Proof).Equal(u.Proof)):
		return false
	}

	return true
}

func (v *BlockAnchor) Equal(u *BlockAnchor) bool {
	if !(protocol.EqualKeySignature(v.Signature, u.Signature)) {
		return false
	}
	if !(EqualMessage(v.Anchor, u.Anchor)) {
		return false
	}

	return true
}

func (v *BlockSummary) Equal(u *BlockSummary) bool {
	if !(v.Partition == u.Partition) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !(v.StateTreeHash == u.StateTreeHash) {
		return false
	}
	if !(v.PreviousBlock == u.PreviousBlock) {
		return false
	}
	if len(v.RecordUpdates) != len(u.RecordUpdates) {
		return false
	}
	for i := range v.RecordUpdates {
		if !((v.RecordUpdates[i]).Equal(u.RecordUpdates[i])) {
			return false
		}
	}
	if len(v.StateTreeUpdates) != len(u.StateTreeUpdates) {
		return false
	}
	for i := range v.StateTreeUpdates {
		if !((v.StateTreeUpdates[i]).Equal(u.StateTreeUpdates[i])) {
			return false
		}
	}

	return true
}

func (v *CreditPayment) Equal(u *CreditPayment) bool {
	if !(v.Paid == u.Paid) {
		return false
	}
	switch {
	case v.Payer == u.Payer:
		// equal
	case v.Payer == nil || u.Payer == nil:
		return false
	case !((v.Payer).Equal(u.Payer)):
		return false
	}
	if !(v.Initiator == u.Initiator) {
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	switch {
	case v.Cause == u.Cause:
		// equal
	case v.Cause == nil || u.Cause == nil:
		return false
	case !((v.Cause).Equal(u.Cause)):
		return false
	}

	return true
}

func (v *DidUpdateExecutorVersion) Equal(u *DidUpdateExecutorVersion) bool {
	if !(v.Partition == u.Partition) {
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}

	return true
}

func (v *Envelope) Equal(u *Envelope) bool {
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(protocol.EqualSignature(v.Signatures[i], u.Signatures[i])) {
			return false
		}
	}
	if !(bytes.Equal(v.TxHash, u.TxHash)) {
		return false
	}
	if len(v.Transaction) != len(u.Transaction) {
		return false
	}
	for i := range v.Transaction {
		if !((v.Transaction[i]).Equal(u.Transaction[i])) {
			return false
		}
	}
	if len(v.Messages) != len(u.Messages) {
		return false
	}
	for i := range v.Messages {
		if !(EqualMessage(v.Messages[i], u.Messages[i])) {
			return false
		}
	}

	return true
}

func (v *MakeMajorBlock) Equal(u *MakeMajorBlock) bool {
	if !(v.MajorBlockIndex == u.MajorBlockIndex) {
		return false
	}
	if !(v.MinorBlockIndex == u.MinorBlockIndex) {
		return false
	}
	if !((v.MajorBlockTime).Equal(u.MajorBlockTime)) {
		return false
	}

	return true
}

func (v *NetworkUpdate) Equal(u *NetworkUpdate) bool {
	if len(v.Accounts) != len(u.Accounts) {
		return false
	}
	for i := range v.Accounts {
		if !((v.Accounts[i]).Equal(u.Accounts[i])) {
			return false
		}
	}

	return true
}

func (v *RecordUpdate) Equal(u *RecordUpdate) bool {
	switch {
	case v.Key == u.Key:
		// equal
	case v.Key == nil || u.Key == nil:
		return false
	case !((v.Key).Equal(u.Key)):
		return false
	}
	if !(bytes.Equal(v.Value, u.Value)) {
		return false
	}

	return true
}

func (v *SequencedMessage) Equal(u *SequencedMessage) bool {
	if !(EqualMessage(v.Message, u.Message)) {
		return false
	}
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	switch {
	case v.Destination == u.Destination:
		// equal
	case v.Destination == nil || u.Destination == nil:
		return false
	case !((v.Destination).Equal(u.Destination)):
		return false
	}
	if !(v.Number == u.Number) {
		return false
	}

	return true
}

func (v *SignatureMessage) Equal(u *SignatureMessage) bool {
	if !(protocol.EqualSignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}

	return true
}

func (v *SignatureRequest) Equal(u *SignatureRequest) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	switch {
	case v.Cause == u.Cause:
		// equal
	case v.Cause == nil || u.Cause == nil:
		return false
	case !((v.Cause).Equal(u.Cause)):
		return false
	}

	return true
}

func (v *StateTreeUpdate) Equal(u *StateTreeUpdate) bool {
	switch {
	case v.Key == u.Key:
		// equal
	case v.Key == nil || u.Key == nil:
		return false
	case !((v.Key).Equal(u.Key)):
		return false
	}
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *SynthFields) Equal(u *SynthFields) bool {
	if !(EqualMessage(v.Message, u.Message)) {
		return false
	}
	if !(protocol.EqualKeySignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Proof == u.Proof:
		// equal
	case v.Proof == nil || u.Proof == nil:
		return false
	case !((v.Proof).Equal(u.Proof)):
		return false
	}

	return true
}

func (v *SyntheticMessage) Equal(u *SyntheticMessage) bool {
	if !(EqualMessage(v.Message, u.Message)) {
		return false
	}
	if !(protocol.EqualKeySignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Proof == u.Proof:
		// equal
	case v.Proof == nil || u.Proof == nil:
		return false
	case !((v.Proof).Equal(u.Proof)):
		return false
	}

	return true
}

func (v *TransactionMessage) Equal(u *TransactionMessage) bool {
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case 