// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package messaging

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type BadSyntheticMessage struct {
	fieldsSet []bool
	Message   Message                    `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Signature protocol.KeySignature      `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Proof     *protocol.AnnotatedReceipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	extraData []byte
}

type BlockAnchor struct {
	fieldsSet []bool
	Signature protocol.KeySignature `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Anchor    Message               `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	extraData []byte
}

type BlockSummary struct {
	fieldsSet []bool
	// Partition is the ID of the partition of the block.
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	// Index is the index of the block.
	Index uint64 `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	// StateTreeHash is the state tree hash after the block.
	StateTreeHash [32]byte `json:"stateTreeHash,omitempty" form:"stateTreeHash" query:"stateTreeHash" validate:"required"`
	// PreviousBlock is the index of the previous block (excludes any empty blocks).
	PreviousBlock    uint64             `json:"previousBlock,omitempty" form:"previousBlock" query:"previousBlock" validate:"required"`
	RecordUpdates    []*RecordUpdate    `json:"recordUpdates,omitempty" form:"recordUpdates" query:"recordUpdates" validate:"required"`
	StateTreeUpdates []*StateTreeUpdate `json:"stateTreeUpdates,omitempty" form:"stateTreeUpdates" query:"stateTreeUpdates" validate:"required"`
	extraData        []byte
}

type CreditPayment struct {
	fieldsSet []bool
	Paid      protocol.Fee `json:"paid,omitempty" form:"paid" query:"paid" validate:"required"`
	Payer     *url.URL     `json:"payer,omitempty" form:"payer" query:"payer" validate:"required"`
	// Initiator indicates whether the signature initiated the transaction.
	Initiator bool      `json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	TxID      *url.TxID `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Cause     *url.TxID `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	extraData []byte
}

type Envelope struct {
	fieldsSet   []bool
	Signatures  []protocol.Signature    `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	TxHash      []byte                  `json:"txHash,omitempty" form:"txHash" query:"txHash"`
	Transaction []*protocol.Transaction `json:"transaction,omitempty" form:"transaction" query:"transaction"`
	Messages    []Message               `json:"messages,omitempty" form:"messages" query:"messages"`
	extraData   []byte
}

type RecordUpdate struct {
	fieldsSet []bool
	Key       *record.Key `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Value     []byte      `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	extraData []byte
}

type SequencedMessage struct {
	fieldsSet []bool
	Message   Message `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	// Source is the source that produced the transaction.
	Source *url.URL `json:"source,omitempty" form:"source" query:"source"`
	// Destination is the destination that the transaction is sent to.
	Destination *url.URL `json:"destination,omitempty" form:"destination" query:"destination"`
	// Number is the sequence number of the transaction.
	Number    uint64 `json:"number,omitempty" form:"number" query:"number"`
	extraData []byte
}

type SignatureMessage struct {
	fieldsSet []bool
	Signature protocol.Signature `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	TxID      *url.TxID          `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	extraData []byte
}

type SignatureRequest struct {
	fieldsSet []bool
	Authority *url.URL  `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	TxID      *url.TxID `json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Cause     *url.TxID `json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	extraData []byte
}

type StateTreeUpdate struct {
	fieldsSet []bool
	Key       *record.Key `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Hash      [32]byte    `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	extraData []byte
}

// SynthFields contains the fields of a synthetic message.
type SynthFields struct {
	Message   Message                    `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Signature protocol.KeySignature      `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Proof     *protocol.AnnotatedReceipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
}

type SyntheticMessage struct {
	fieldsSet []bool
	Message   Message                    `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Signature protocol.KeySignature      `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Proof     *protocol.AnnotatedReceipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	extraData []byte
}

type TransactionMessage struct {
	fieldsSet   []bool
	Transaction *protocol.Transaction `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	extraData   []byte
}

func (*BadSyntheticMessage) Type() MessageType { return MessageTypeBadSynthetic }

func (*BlockAnchor) Type() MessageType { return MessageTypeBlockAnchor }

func (*BlockSummary) Type() MessageType { return MessageTypeBlockSummary }

func (*CreditPayment) Type() MessageType { return MessageTypeCreditPayment }

func (*SequencedMessage) Type() MessageType { return MessageTypeSequenced }

func (*SignatureMessage) Type() MessageType { return MessageTypeSignature }

func (*SignatureRequest) Type() MessageType { return MessageTypeSignatureRequest }

func (*SyntheticMessage) Type() MessageType { return MessageTypeSynthetic }

func (*TransactionMessage) Type() MessageType { return MessageTypeTransaction }

func (v *BadSyntheticMessage) Copy() *BadSyntheticMessage {
	u := new(BadSyntheticMessage)

	if v.Message != nil {
		u.Message = CopyMessage(v.Message)
	}
	if v.Signature != nil {
		u.Signature = protocol.CopyKeySignature(v.Signature)
	}
	if v.Proof != nil {
		u.Proof = (v.Proof).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BadSyntheticMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockAnchor) Copy() *BlockAnchor {
	u := new(BlockAnchor)

	if v.Signature != nil {
		u.Signature = protocol.CopyKeySignature(v.Signature)
	}
	if v.Anchor != nil {
		u.Anchor = CopyMessage(v.Anchor)
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockAnchor) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockSummary) Copy() *BlockSummary {
	u := new(BlockSummary)

	u.Partition = v.Partition
	u.Index = v.Index
	u.StateTreeHash = v.StateTreeHash
	u.PreviousBlock = v.PreviousBlock
	u.RecordUpdates = make([]*RecordUpdate, len(v.RecordUpdates))
	for i, v := range v.RecordUpdates {
		v := v
		if v != nil {
			u.RecordUpdates[i] = (v).Copy()
		}
	}
	u.StateTreeUpdates = make([]*StateTreeUpdate, len(v.StateTreeUpdates))
	for i, v := range v.StateTreeUpdates {
		v := v
		if v != nil {
			u.StateTreeUpdates[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockSummary) CopyAsInterface() interface{} { return v.Copy() }

func (v *CreditPayment) Copy() *CreditPayment {
	u := new(CreditPayment)

	u.Paid = v.Paid
	if v.Payer != nil {
		u.Payer = v.Payer
	}
	u.Initiator = v.Initiator
	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if v.Cause != nil {
		u.Cause = v.Cause
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *CreditPayment) CopyAsInterface() interface{} { return v.Copy() }

func (v *Envelope) Copy() *Envelope {
	u := new(Envelope)

	u.Signatures = make([]protocol.Signature, len(v.Signatures))
	for i, v := range v.Signatures {
		v := v
		if v != nil {
			u.Signatures[i] = protocol.CopySignature(v)
		}
	}
	u.TxHash = encoding.BytesCopy(v.TxHash)
	u.Transaction = make([]*protocol.Transaction, len(v.Transaction))
	for i, v := range v.Transaction {
		v := v
		if v != nil {
			u.Transaction[i] = (v).Copy()
		}
	}
	u.Messages = make([]Message, len(v.Messages))
	for i, v := range v.Messages {
		v := v
		if v != nil {
			u.Messages[i] = CopyMessage(v)
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *Envelope) CopyAsInterface() interface{} { return v.Copy() }

func (v *RecordUpdate) Copy() *RecordUpdate {
	u := new(RecordUpdate)

	if v.Key != nil {
		u.Key = (v.Key).Copy()
	}
	u.Value = encoding.BytesCopy(v.Value)
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *RecordUpdate) CopyAsInterface() interface{} { return v.Copy() }

func (v *SequencedMessage) Copy() *SequencedMessage {
	u := new(SequencedMessage)

	if v.Message != nil {
		u.Message = CopyMessage(v.Message)
	}
	if v.Source != nil {
		u.Source = v.Source
	}
	if v.Destination != nil {
		u.Destination = v.Destination
	}
	u.Number = v.Number
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SequencedMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureMessage) Copy() *SignatureMessage {
	u := new(SignatureMessage)

	if v.Signature != nil {
		u.Signature = protocol.CopySignature(v.Signature)
	}
	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SignatureMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureRequest) Copy() *SignatureRequest {
	u := new(SignatureRequest)

	if v.Authority != nil {
		u.Authority = v.Authority
	}
	if v.TxID != nil {
		u.TxID = v.TxID
	}
	if v.Cause != nil {
		u.Cause = v.Cause
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SignatureRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *StateTreeUpdate) Copy() *StateTreeUpdate {
	u := new(StateTreeUpdate)

	if v.Key != nil {
		u.Key = (v.Key).Copy()
	}
	u.Hash = v.Hash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *StateTreeUpdate) CopyAsInterface() interface{} { return v.Copy() }

func (v *SynthFields) Copy() *SynthFields {
	u := new(SynthFields)

	if v.Message != nil {
		u.Message = CopyMessage(v.Message)
	}
	if v.Signature != nil {
		u.Signature = protocol.CopyKeySignature(v.Signature)
	}
	if v.Proof != nil {
		u.Proof = (v.Proof).Copy()
	}

	return u
}

func (v *SynthFields) CopyAsInterface() interface{} { return v.Copy() }

func (v *SyntheticMessage) Copy() *SyntheticMessage {
	u := new(SyntheticMessage)

	if v.Message != nil {
		u.Message = CopyMessage(v.Message)
	}
	if v.Signature != nil {
		u.Signature = protocol.CopyKeySignature(v.Signature)
	}
	if v.Proof != nil {
		u.Proof = (v.Proof).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SyntheticMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionMessage) Copy() *TransactionMessage {
	u := new(TransactionMessage)

	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *TransactionMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *BadSyntheticMessage) Equal(u *BadSyntheticMessage) bool {
	if !(EqualMessage(v.Message, u.Message)) {
		return false
	}
	if !(protocol.EqualKeySignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Proof == u.Proof:
		// equal
	case v.Proof == nil || u.Proof == nil:
		return false
	case !((v.Proof).Equal(u.Proof)):
		return false
	}

	return true
}

func (v *BlockAnchor) Equal(u *BlockAnchor) bool {
	if !(protocol.EqualKeySignature(v.Signature, u.Signature)) {
		return false
	}
	if !(EqualMessage(v.Anchor, u.Anchor)) {
		return false
	}

	return true
}

func (v *BlockSummary) Equal(u *BlockSummary) bool {
	if !(v.Partition == u.Partition) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !(v.StateTreeHash == u.StateTreeHash) {
		return false
	}
	if !(v.PreviousBlock == u.PreviousBlock) {
		return false
	}
	if len(v.RecordUpdates) != len(u.RecordUpdates) {
		return false
	}
	for i := range v.RecordUpdates {
		if !((v.RecordUpdates[i]).Equal(u.RecordUpdates[i])) {
			return false
		}
	}
	if len(v.StateTreeUpdates) != len(u.StateTreeUpdates) {
		return false
	}
	for i := range v.StateTreeUpdates {
		if !((v.StateTreeUpdates[i]).Equal(u.StateTreeUpdates[i])) {
			return false
		}
	}

	return true
}

func (v *CreditPayment) Equal(u *CreditPayment) bool {
	if !(v.Paid == u.Paid) {
		return false
	}
	switch {
	case v.Payer == u.Payer:
		// equal
	case v.Payer == nil || u.Payer == nil:
		return false
	case !((v.Payer).Equal(u.Payer)):
		return false
	}
	if !(v.Initiator == u.Initiator) {
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	switch {
	case v.Cause == u.Cause:
		// equal
	case v.Cause == nil || u.Cause == nil:
		return false
	case !((v.Cause).Equal(u.Cause)):
		return false
	}

	return true
}

func (v *Envelope) Equal(u *Envelope) bool {
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(protocol.EqualSignature(v.Signatures[i], u.Signatures[i])) {
			return false
		}
	}
	if !(bytes.Equal(v.TxHash, u.TxHash)) {
		return false
	}
	if len(v.Transaction) != len(u.Transaction) {
		return false
	}
	for i := range v.Transaction {
		if !((v.Transaction[i]).Equal(u.Transaction[i])) {
			return false
		}
	}
	if len(v.Messages) != len(u.Messages) {
		return false
	}
	for i := range v.Messages {
		if !(EqualMessage(v.Messages[i], u.Messages[i])) {
			return false
		}
	}

	return true
}

func (v *RecordUpdate) Equal(u *RecordUpdate) bool {
	switch {
	case v.Key == u.Key:
		// equal
	case v.Key == nil || u.Key == nil:
		return false
	case !((v.Key).Equal(u.Key)):
		return false
	}
	if !(bytes.Equal(v.Value, u.Value)) {
		return false
	}

	return true
}

func (v *SequencedMessage) Equal(u *SequencedMessage) bool {
	if !(EqualMessage(v.Message, u.Message)) {
		return false
	}
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	switch {
	case v.Destination == u.Destination:
		// equal
	case v.Destination == nil || u.Destination == nil:
		return false
	case !((v.Destination).Equal(u.Destination)):
		return false
	}
	if !(v.Number == u.Number) {
		return false
	}

	return true
}

func (v *SignatureMessage) Equal(u *SignatureMessage) bool {
	if !(protocol.EqualSignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}

	return true
}

func (v *SignatureRequest) Equal(u *SignatureRequest) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	switch {
	case v.TxID == u.TxID:
		// equal
	case v.TxID == nil || u.TxID == nil:
		return false
	case !((v.TxID).Equal(u.TxID)):
		return false
	}
	switch {
	case v.Cause == u.Cause:
		// equal
	case v.Cause == nil || u.Cause == nil:
		return false
	case !((v.Cause).Equal(u.Cause)):
		return false
	}

	return true
}

func (v *StateTreeUpdate) Equal(u *StateTreeUpdate) bool {
	switch {
	case v.Key == u.Key:
		// equal
	case v.Key == nil || u.Key == nil:
		return false
	case !((v.Key).Equal(u.Key)):
		return false
	}
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *SynthFields) Equal(u *SynthFields) bool {
	if !(EqualMessage(v.Message, u.Message)) {
		return false
	}
	if !(protocol.EqualKeySignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Proof == u.Proof:
		// equal
	case v.Proof == nil || u.Proof == nil:
		return false
	case !((v.Proof).Equal(u.Proof)):
		return false
	}

	return true
}

func (v *SyntheticMessage) Equal(u *SyntheticMessage) bool {
	if !(EqualMessage(v.Message, u.Message)) {
		return false
	}
	if !(protocol.EqualKeySignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Proof == u.Proof:
		// equal
	case v.Proof == nil || u.Proof == nil:
		return false
	case !((v.Proof).Equal(u.Proof)):
		return false
	}

	return true
}

func (v *TransactionMessage) Equal(u *TransactionMessage) bool {
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}

	return true
}

var fieldNames_BadSyntheticMessage = []string{
	1: "Type",
	2: "Message",
	3: "Signature",
	4: "Proof",
}

func (v *BadSyntheticMessage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(EqualMessage(v.Message, nil)) {
		writer.WriteValue(2, v.Message.MarshalBinary)
	}
	if !(protocol.EqualKeySignature(v.Signature, nil)) {
		writer.WriteValue(3, v.Signature.MarshalBinary)
	}
	if !(v.Proof == nil) {
		writer.WriteValue(4, v.Proof.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_BadSyntheticMessage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BadSyntheticMessage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Message is missing")
	} else if EqualMessage(v.Message, nil) {
		errs = append(errs, "field Message is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if protocol.EqualKeySignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Proof is missing")
	} else if v.Proof == nil {
		errs = append(errs, "field Proof is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockAnchor = []string{
	1: "Type",
	2: "Signature",
	3: "Anchor",
}

func (v *BlockAnchor) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(protocol.EqualKeySignature(v.Signature, nil)) {
		writer.WriteValue(2, v.Signature.MarshalBinary)
	}
	if !(EqualMessage(v.Anchor, nil)) {
		writer.WriteValue(3, v.Anchor.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_BlockAnchor)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockAnchor) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signature is missing")
	} else if protocol.EqualKeySignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Anchor is missing")
	} else if EqualMessage(v.Anchor, nil) {
		errs = append(errs, "field Anchor is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockSummary = []string{
	1: "Type",
	2: "Partition",
	3: "Index",
	4: "StateTreeHash",
	5: "PreviousBlock",
	6: "RecordUpdates",
	7: "StateTreeUpdates",
}

func (v *BlockSummary) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Partition) == 0) {
		writer.WriteString(2, v.Partition)
	}
	if !(v.Index == 0) {
		writer.WriteUint(3, v.Index)
	}
	if !(v.StateTreeHash == ([32]byte{})) {
		writer.WriteHash(4, &v.StateTreeHash)
	}
	if !(v.PreviousBlock == 0) {
		writer.WriteUint(5, v.PreviousBlock)
	}
	if !(len(v.RecordUpdates) == 0) {
		for _, v := range v.RecordUpdates {
			writer.WriteValue(6, v.MarshalBinary)
		}
	}
	if !(len(v.StateTreeUpdates) == 0) {
		for _, v := range v.StateTreeUpdates {
			writer.WriteValue(7, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_BlockSummary)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockSummary) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Partition is missing")
	} else if len(v.Partition) == 0 {
		errs = append(errs, "field Partition is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field StateTreeHash is missing")
	} else if v.StateTreeHash == ([32]byte{}) {
		errs = append(errs, "field StateTreeHash is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field PreviousBlock is missing")
	} else if v.PreviousBlock == 0 {
		errs = append(errs, "field PreviousBlock is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field RecordUpdates is missing")
	} else if len(v.RecordUpdates) == 0 {
		errs = append(errs, "field RecordUpdates is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field StateTreeUpdates is missing")
	} else if len(v.StateTreeUpdates) == 0 {
		errs = append(errs, "field StateTreeUpdates is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CreditPayment = []string{
	1: "Type",
	2: "Paid",
	3: "Payer",
	4: "Initiator",
	5: "TxID",
	6: "Cause",
}

func (v *CreditPayment) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Paid == 0) {
		writer.WriteEnum(2, v.Paid)
	}
	if !(v.Payer == nil) {
		writer.WriteUrl(3, v.Payer)
	}
	if !(!v.Initiator) {
		writer.WriteBool(4, v.Initiator)
	}
	if !(v.TxID == nil) {
		writer.WriteTxid(5, v.TxID)
	}
	if !(v.Cause == nil) {
		writer.WriteTxid(6, v.Cause)
	}

	_, _, err := writer.Reset(fieldNames_CreditPayment)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CreditPayment) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Paid is missing")
	} else if v.Paid == 0 {
		errs = append(errs, "field Paid is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Payer is missing")
	} else if v.Payer == nil {
		errs = append(errs, "field Payer is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Initiator is missing")
	} else if !v.Initiator {
		errs = append(errs, "field Initiator is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Cause is missing")
	} else if v.Cause == nil {
		errs = append(errs, "field Cause is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Envelope = []string{
	1: "Signatures",
	2: "TxHash",
	3: "Transaction",
	4: "Messages",
}

func (v *Envelope) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}
	if !(len(v.TxHash) == 0) {
		writer.WriteBytes(2, v.TxHash)
	}
	if !(len(v.Transaction) == 0) {
		for _, v := range v.Transaction {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}
	if !(len(v.Messages) == 0) {
		for _, v := range v.Messages {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_Envelope)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Envelope) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RecordUpdate = []string{
	1: "Key",
	2: "Value",
}

func (v *RecordUpdate) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Key == nil) {
		writer.WriteValue(1, v.Key.MarshalBinary)
	}
	if !(len(v.Value) == 0) {
		writer.WriteBytes(2, v.Value)
	}

	_, _, err := writer.Reset(fieldNames_RecordUpdate)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RecordUpdate) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Key is missing")
	} else if v.Key == nil {
		errs = append(errs, "field Key is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Value is missing")
	} else if len(v.Value) == 0 {
		errs = append(errs, "field Value is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SequencedMessage = []string{
	1: "Type",
	2: "Message",
	3: "Source",
	4: "Destination",
	5: "Number",
}

func (v *SequencedMessage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(EqualMessage(v.Message, nil)) {
		writer.WriteValue(2, v.Message.MarshalBinary)
	}
	if !(v.Source == nil) {
		writer.WriteUrl(3, v.Source)
	}
	if !(v.Destination == nil) {
		writer.WriteUrl(4, v.Destination)
	}
	if !(v.Number == 0) {
		writer.WriteUint(5, v.Number)
	}

	_, _, err := writer.Reset(fieldNames_SequencedMessage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SequencedMessage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Message is missing")
	} else if EqualMessage(v.Message, nil) {
		errs = append(errs, "field Message is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SignatureMessage = []string{
	1: "Type",
	2: "Signature",
	3: "TxID",
}

func (v *SignatureMessage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(protocol.EqualSignature(v.Signature, nil)) {
		writer.WriteValue(2, v.Signature.MarshalBinary)
	}
	if !(v.TxID == nil) {
		writer.WriteTxid(3, v.TxID)
	}

	_, _, err := writer.Reset(fieldNames_SignatureMessage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SignatureMessage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signature is missing")
	} else if protocol.EqualSignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SignatureRequest = []string{
	1: "Type",
	2: "Authority",
	3: "TxID",
	4: "Cause",
}

func (v *SignatureRequest) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Authority == nil) {
		writer.WriteUrl(2, v.Authority)
	}
	if !(v.TxID == nil) {
		writer.WriteTxid(3, v.TxID)
	}
	if !(v.Cause == nil) {
		writer.WriteTxid(4, v.Cause)
	}

	_, _, err := writer.Reset(fieldNames_SignatureRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SignatureRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TxID is missing")
	} else if v.TxID == nil {
		errs = append(errs, "field TxID is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Cause is missing")
	} else if v.Cause == nil {
		errs = append(errs, "field Cause is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_StateTreeUpdate = []string{
	1: "Key",
	2: "Hash",
}

func (v *StateTreeUpdate) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Key == nil) {
		writer.WriteValue(1, v.Key.MarshalBinary)
	}
	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(2, &v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_StateTreeUpdate)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *StateTreeUpdate) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Key is missing")
	} else if v.Key == nil {
		errs = append(errs, "field Key is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Hash is missing")
	} else if v.Hash == ([32]byte{}) {
		errs = append(errs, "field Hash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SyntheticMessage = []string{
	1: "Type",
	2: "Message",
	3: "Signature",
	4: "Proof",
}

func (v *SyntheticMessage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(EqualMessage(v.Message, nil)) {
		writer.WriteValue(2, v.Message.MarshalBinary)
	}
	if !(protocol.EqualKeySignature(v.Signature, nil)) {
		writer.WriteValue(3, v.Signature.MarshalBinary)
	}
	if !(v.Proof == nil) {
		writer.WriteValue(4, v.Proof.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_SyntheticMessage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SyntheticMessage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Message is missing")
	} else if EqualMessage(v.Message, nil) {
		errs = append(errs, "field Message is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if protocol.EqualKeySignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Proof is missing")
	} else if v.Proof == nil {
		errs = append(errs, "field Proof is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionMessage = []string{
	1: "Type",
	2: "Transaction",
}

func (v *TransactionMessage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Transaction == nil) {
		writer.WriteValue(2, v.Transaction.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_TransactionMessage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TransactionMessage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == nil {
		errs = append(errs, "field Transaction is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *BadSyntheticMessage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BadSyntheticMessage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BadSyntheticMessage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalMessageFrom(r)
		if err == nil {
			v.Message = x
		}
		return err
	})
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := protocol.UnmarshalKeySignatureFrom(r)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	if x := new(protocol.AnnotatedReceipt); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.Proof = x
	}

	seen, err := reader.Reset(fieldNames_BadSyntheticMessage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockAnchor) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockAnchor) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BlockAnchor) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := protocol.UnmarshalKeySignatureFrom(r)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := UnmarshalMessageFrom(r)
		if err == nil {
			v.Anchor = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_BlockAnchor)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockSummary) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockSummary) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *BlockSummary) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadString(2); ok {
		v.Partition = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.StateTreeHash = *x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.PreviousBlock = x
	}
	for {
		if x := new(RecordUpdate); reader.ReadValue(6, x.UnmarshalBinaryFrom) {
			v.RecordUpdates = append(v.RecordUpdates, x)
		} else {
			break
		}
	}
	for {
		if x := new(StateTreeUpdate); reader.ReadValue(7, x.UnmarshalBinaryFrom) {
			v.StateTreeUpdates = append(v.StateTreeUpdates, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_BlockSummary)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CreditPayment) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CreditPayment) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *CreditPayment) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(protocol.Fee); reader.ReadEnum(2, x) {
		v.Paid = *x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Payer = x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.Initiator = x
	}
	if x, ok := reader.ReadTxid(5); ok {
		v.TxID = x
	}
	if x, ok := reader.ReadTxid(6); ok {
		v.Cause = x
	}

	seen, err := reader.Reset(fieldNames_CreditPayment)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Envelope) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Envelope) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		ok := reader.ReadValue(1, func(r io.Reader) error {
			x, err := protocol.UnmarshalSignatureFrom(r)
			if err == nil {
				v.Signatures = append(v.Signatures, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.TxHash = x
	}
	for {
		if x := new(protocol.Transaction); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
			v.Transaction = append(v.Transaction, x)
		} else {
			break
		}
	}
	for {
		ok := reader.ReadValue(4, func(r io.Reader) error {
			x, err := UnmarshalMessageFrom(r)
			if err == nil {
				v.Messages = append(v.Messages, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_Envelope)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RecordUpdate) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RecordUpdate) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(record.Key); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Key = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Value = x
	}

	seen, err := reader.Reset(fieldNames_RecordUpdate)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SequencedMessage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SequencedMessage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SequencedMessage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalMessageFrom(r)
		if err == nil {
			v.Message = x
		}
		return err
	})
	if x, ok := reader.ReadUrl(3); ok {
		v.Source = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Destination = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Number = x
	}

	seen, err := reader.Reset(fieldNames_SequencedMessage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SignatureMessage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureMessage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SignatureMessage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := protocol.UnmarshalSignatureFrom(r)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	if x, ok := reader.ReadTxid(3); ok {
		v.TxID = x
	}

	seen, err := reader.Reset(fieldNames_SignatureMessage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SignatureRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SignatureRequest) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadUrl(2); ok {
		v.Authority = x
	}
	if x, ok := reader.ReadTxid(3); ok {
		v.TxID = x
	}
	if x, ok := reader.ReadTxid(4); ok {
		v.Cause = x
	}

	seen, err := reader.Reset(fieldNames_SignatureRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *StateTreeUpdate) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *StateTreeUpdate) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(record.Key); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Key = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.Hash = *x
	}

	seen, err := reader.Reset(fieldNames_StateTreeUpdate)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SyntheticMessage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SyntheticMessage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SyntheticMessage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalMessageFrom(r)
		if err == nil {
			v.Message = x
		}
		return err
	})
	reader.ReadValue(3, func(r io.Reader) error {
		x, err := protocol.UnmarshalKeySignatureFrom(r)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	if x := new(protocol.AnnotatedReceipt); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.Proof = x
	}

	seen, err := reader.Reset(fieldNames_SyntheticMessage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TransactionMessage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionMessage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType MessageType
	if x := new(MessageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *TransactionMessage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x := new(protocol.Transaction); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
		v.Transaction = x
	}

	seen, err := reader.Reset(fieldNames_TransactionMessage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BadSyntheticMessage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      MessageType                                        `json:"type"`
		Message   *encoding.JsonUnmarshalWith[Message]               `json:"message,omitempty"`
		Signature *encoding.JsonUnmarshalWith[protocol.KeySignature] `json:"signature,omitempty"`
		Proof     *protocol.AnnotatedReceipt                         `json:"proof,omitempty"`
	}{}
	u.Type = v.Type()
	if !(EqualMessage(v.Message, nil)) {
		u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalMessageJSON}
	}
	if !(protocol.EqualKeySignature(v.Signature, nil)) {
		u.Signature = &encoding.JsonUnmarshalWith[protocol.KeySignature]{Value: v.Signature, Func: protocol.UnmarshalKeySignatureJSON}
	}
	if !(v.Proof == nil) {
		u.Proof = v.Proof
	}
	return json.Marshal(&u)
}

func (v *BlockAnchor) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      MessageType                                        `json:"type"`
		Signature *encoding.JsonUnmarshalWith[protocol.KeySignature] `json:"signature,omitempty"`
		Anchor    *encoding.JsonUnmarshalWith[Message]               `json:"anchor,omitempty"`
	}{}
	u.Type = v.Type()
	if !(protocol.EqualKeySignature(v.Signature, nil)) {
		u.Signature = &encoding.JsonUnmarshalWith[protocol.KeySignature]{Value: v.Signature, Func: protocol.UnmarshalKeySignatureJSON}
	}
	if !(EqualMessage(v.Anchor, nil)) {
		u.Anchor = &encoding.JsonUnmarshalWith[Message]{Value: v.Anchor, Func: UnmarshalMessageJSON}
	}
	return json.Marshal(&u)
}

func (v *BlockSummary) MarshalJSON() ([]byte, error) {
	u := struct {
		Type             MessageType                         `json:"type"`
		Partition        string                              `json:"partition,omitempty"`
		Index            uint64                              `json:"index,omitempty"`
		StateTreeHash    string                              `json:"stateTreeHash,omitempty"`
		PreviousBlock    uint64                              `json:"previousBlock,omitempty"`
		RecordUpdates    encoding.JsonList[*RecordUpdate]    `json:"recordUpdates,omitempty"`
		StateTreeUpdates encoding.JsonList[*StateTreeUpdate] `json:"stateTreeUpdates,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Partition) == 0) {
		u.Partition = v.Partition
	}
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.StateTreeHash == ([32]byte{})) {
		u.StateTreeHash = encoding.ChainToJSON(v.StateTreeHash)
	}
	if !(v.PreviousBlock == 0) {
		u.PreviousBlock = v.PreviousBlock
	}
	if !(len(v.RecordUpdates) == 0) {
		u.RecordUpdates = v.RecordUpdates
	}
	if !(len(v.StateTreeUpdates) == 0) {
		u.StateTreeUpdates = v.StateTreeUpdates
	}
	return json.Marshal(&u)
}

func (v *CreditPayment) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      MessageType  `json:"type"`
		Paid      protocol.Fee `json:"paid,omitempty"`
		Payer     *url.URL     `json:"payer,omitempty"`
		Initiator bool         `json:"initiator,omitempty"`
		TxID      *url.TxID    `json:"txID,omitempty"`
		Cause     *url.TxID    `json:"cause,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Paid == 0) {
		u.Paid = v.Paid
	}
	if !(v.Payer == nil) {
		u.Payer = v.Payer
	}
	if !(!v.Initiator) {
		u.Initiator = v.Initiator
	}
	if !(v.TxID == nil) {
		u.TxID = v.TxID
	}
	if !(v.Cause == nil) {
		u.Cause = v.Cause
	}
	return json.Marshal(&u)
}

func (v *Envelope) MarshalJSON() ([]byte, error) {
	u := struct {
		Signatures  *encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
		TxHash      *string                                             `json:"txHash,omitempty"`
		Transaction encoding.JsonList[*protocol.Transaction]            `json:"transaction,omitempty"`
		Messages    *encoding.JsonUnmarshalListWith[Message]            `json:"messages,omitempty"`
	}{}
	if !(len(v.Signatures) == 0) {
		u.Signatures = &encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	}
	if !(len(v.TxHash) == 0) {
		u.TxHash = encoding.BytesToJSON(v.TxHash)
	}
	if !(len(v.Transaction) == 0) {
		u.Transaction = v.Transaction
	}
	if !(len(v.Messages) == 0) {
		u.Messages = &encoding.JsonUnmarshalListWith[Message]{Value: v.Messages, Func: UnmarshalMessageJSON}
	}
	return json.Marshal(&u)
}

func (v *RecordUpdate) MarshalJSON() ([]byte, error) {
	u := struct {
		Key   *record.Key `json:"key,omitempty"`
		Value *string     `json:"value,omitempty"`
	}{}
	if !(v.Key == nil) {
		u.Key = v.Key
	}
	if !(len(v.Value) == 0) {
		u.Value = encoding.BytesToJSON(v.Value)
	}
	return json.Marshal(&u)
}

func (v *SequencedMessage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        MessageType                          `json:"type"`
		Message     *encoding.JsonUnmarshalWith[Message] `json:"message,omitempty"`
		Source      *url.URL                             `json:"source,omitempty"`
		Destination *url.URL                             `json:"destination,omitempty"`
		Number      uint64                               `json:"number,omitempty"`
	}{}
	u.Type = v.Type()
	if !(EqualMessage(v.Message, nil)) {
		u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalMessageJSON}
	}
	if !(v.Source == nil) {
		u.Source = v.Source
	}
	if !(v.Destination == nil) {
		u.Destination = v.Destination
	}
	if !(v.Number == 0) {
		u.Number = v.Number
	}
	return json.Marshal(&u)
}

func (v *SignatureMessage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      MessageType                                     `json:"type"`
		Signature *encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
		TxID      *url.TxID                                       `json:"txID,omitempty"`
	}{}
	u.Type = v.Type()
	if !(protocol.EqualSignature(v.Signature, nil)) {
		u.Signature = &encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	}
	if !(v.TxID == nil) {
		u.TxID = v.TxID
	}
	return json.Marshal(&u)
}

func (v *SignatureRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      MessageType `json:"type"`
		Authority *url.URL    `json:"authority,omitempty"`
		TxID      *url.TxID   `json:"txID,omitempty"`
		Cause     *url.TxID   `json:"cause,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	if !(v.TxID == nil) {
		u.TxID = v.TxID
	}
	if !(v.Cause == nil) {
		u.Cause = v.Cause
	}
	return json.Marshal(&u)
}

func (v *StateTreeUpdate) MarshalJSON() ([]byte, error) {
	u := struct {
		Key  *record.Key `json:"key,omitempty"`
		Hash string      `json:"hash,omitempty"`
	}{}
	if !(v.Key == nil) {
		u.Key = v.Key
	}
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(v.Hash)
	}
	return json.Marshal(&u)
}

func (v *SynthFields) MarshalJSON() ([]byte, error) {
	u := struct {
		Message   *encoding.JsonUnmarshalWith[Message]               `json:"message,omitempty"`
		Signature *encoding.JsonUnmarshalWith[protocol.KeySignature] `json:"signature,omitempty"`
		Proof     *protocol.AnnotatedReceipt                         `json:"proof,omitempty"`
	}{}
	if !(EqualMessage(v.Message, nil)) {
		u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalMessageJSON}
	}
	if !(protocol.EqualKeySignature(v.Signature, nil)) {
		u.Signature = &encoding.JsonUnmarshalWith[protocol.KeySignature]{Value: v.Signature, Func: protocol.UnmarshalKeySignatureJSON}
	}
	if !(v.Proof == nil) {
		u.Proof = v.Proof
	}
	return json.Marshal(&u)
}

func (v *SyntheticMessage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      MessageType                                        `json:"type"`
		Message   *encoding.JsonUnmarshalWith[Message]               `json:"message,omitempty"`
		Signature *encoding.JsonUnmarshalWith[protocol.KeySignature] `json:"signature,omitempty"`
		Proof     *protocol.AnnotatedReceipt                         `json:"proof,omitempty"`
	}{}
	u.Type = v.Type()
	if !(EqualMessage(v.Message, nil)) {
		u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalMessageJSON}
	}
	if !(protocol.EqualKeySignature(v.Signature, nil)) {
		u.Signature = &encoding.JsonUnmarshalWith[protocol.KeySignature]{Value: v.Signature, Func: protocol.UnmarshalKeySignatureJSON}
	}
	if !(v.Proof == nil) {
		u.Proof = v.Proof
	}
	return json.Marshal(&u)
}

func (v *TransactionMessage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        MessageType           `json:"type"`
		Transaction *protocol.Transaction `json:"transaction,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Transaction == nil) {
		u.Transaction = v.Transaction
	}
	return json.Marshal(&u)
}

func (v *BadSyntheticMessage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      MessageType                                        `json:"type"`
		Message   *encoding.JsonUnmarshalWith[Message]               `json:"message,omitempty"`
		Signature *encoding.JsonUnmarshalWith[protocol.KeySignature] `json:"signature,omitempty"`
		Proof     *protocol.AnnotatedReceipt                         `json:"proof,omitempty"`
	}{}
	u.Type = v.Type()
	u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalMessageJSON}
	u.Signature = &encoding.JsonUnmarshalWith[protocol.KeySignature]{Value: v.Signature, Func: protocol.UnmarshalKeySignatureJSON}
	u.Proof = v.Proof
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Message != nil {
		v.Message = u.Message.Value
	}

	if u.Signature != nil {
		v.Signature = u.Signature.Value
	}

	v.Proof = u.Proof
	return nil
}

func (v *BlockAnchor) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      MessageType                                        `json:"type"`
		Signature *encoding.JsonUnmarshalWith[protocol.KeySignature] `json:"signature,omitempty"`
		Anchor    *encoding.JsonUnmarshalWith[Message]               `json:"anchor,omitempty"`
	}{}
	u.Type = v.Type()
	u.Signature = &encoding.JsonUnmarshalWith[protocol.KeySignature]{Value: v.Signature, Func: protocol.UnmarshalKeySignatureJSON}
	u.Anchor = &encoding.JsonUnmarshalWith[Message]{Value: v.Anchor, Func: UnmarshalMessageJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Signature != nil {
		v.Signature = u.Signature.Value
	}

	if u.Anchor != nil {
		v.Anchor = u.Anchor.Value
	}

	return nil
}

func (v *BlockSummary) UnmarshalJSON(data []byte) error {
	u := struct {
		Type             MessageType                         `json:"type"`
		Partition        string                              `json:"partition,omitempty"`
		Index            uint64                              `json:"index,omitempty"`
		StateTreeHash    string                              `json:"stateTreeHash,omitempty"`
		PreviousBlock    uint64                              `json:"previousBlock,omitempty"`
		RecordUpdates    encoding.JsonList[*RecordUpdate]    `json:"recordUpdates,omitempty"`
		StateTreeUpdates encoding.JsonList[*StateTreeUpdate] `json:"stateTreeUpdates,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.Partition
	u.Index = v.Index
	u.StateTreeHash = encoding.ChainToJSON(v.StateTreeHash)
	u.PreviousBlock = v.PreviousBlock
	u.RecordUpdates = v.RecordUpdates
	u.StateTreeUpdates = v.StateTreeUpdates
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Partition = u.Partition
	v.Index = u.Index
	if x, err := encoding.ChainFromJSON(u.StateTreeHash); err != nil {
		return fmt.Errorf("error decoding StateTreeHash: %w", err)
	} else {
		v.StateTreeHash = x
	}
	v.PreviousBlock = u.PreviousBlock
	v.RecordUpdates = u.RecordUpdates
	v.StateTreeUpdates = u.StateTreeUpdates
	return nil
}

func (v *CreditPayment) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      MessageType  `json:"type"`
		Paid      protocol.Fee `json:"paid,omitempty"`
		Payer     *url.URL     `json:"payer,omitempty"`
		Initiator bool         `json:"initiator,omitempty"`
		TxID      *url.TxID    `json:"txID,omitempty"`
		Cause     *url.TxID    `json:"cause,omitempty"`
	}{}
	u.Type = v.Type()
	u.Paid = v.Paid
	u.Payer = v.Payer
	u.Initiator = v.Initiator
	u.TxID = v.TxID
	u.Cause = v.Cause
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Paid = u.Paid
	v.Payer = u.Payer
	v.Initiator = u.Initiator
	v.TxID = u.TxID
	v.Cause = u.Cause
	return nil
}

func (v *Envelope) UnmarshalJSON(data []byte) error {
	u := struct {
		Signatures  *encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
		TxHash      *string                                             `json:"txHash,omitempty"`
		Transaction encoding.JsonList[*protocol.Transaction]            `json:"transaction,omitempty"`
		Messages    *encoding.JsonUnmarshalListWith[Message]            `json:"messages,omitempty"`
	}{}
	u.Signatures = &encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	u.TxHash = encoding.BytesToJSON(v.TxHash)
	u.Transaction = v.Transaction
	u.Messages = &encoding.JsonUnmarshalListWith[Message]{Value: v.Messages, Func: UnmarshalMessageJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Signatures != nil {
		v.Signatures = make([]protocol.Signature, len(u.Signatures.Value))
		for i, x := range u.Signatures.Value {
			v.Signatures[i] = x
		}
	}
	if x, err := encoding.BytesFromJSON(u.TxHash); err != nil {
		return fmt.Errorf("error decoding TxHash: %w", err)
	} else {
		v.TxHash = x
	}
	v.Transaction = u.Transaction
	if u.Messages != nil {
		v.Messages = make([]Message, len(u.Messages.Value))
		for i, x := range u.Messages.Value {
			v.Messages[i] = x
		}
	}
	return nil
}

func (v *RecordUpdate) UnmarshalJSON(data []byte) error {
	u := struct {
		Key   *record.Key `json:"key,omitempty"`
		Value *string     `json:"value,omitempty"`
	}{}
	u.Key = v.Key
	u.Value = encoding.BytesToJSON(v.Value)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Key = u.Key
	if x, err := encoding.BytesFromJSON(u.Value); err != nil {
		return fmt.Errorf("error decoding Value: %w", err)
	} else {
		v.Value = x
	}
	return nil
}

func (v *SequencedMessage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        MessageType                          `json:"type"`
		Message     *encoding.JsonUnmarshalWith[Message] `json:"message,omitempty"`
		Source      *url.URL                             `json:"source,omitempty"`
		Destination *url.URL                             `json:"destination,omitempty"`
		Number      uint64                               `json:"number,omitempty"`
	}{}
	u.Type = v.Type()
	u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalMessageJSON}
	u.Source = v.Source
	u.Destination = v.Destination
	u.Number = v.Number
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Message != nil {
		v.Message = u.Message.Value
	}

	v.Source = u.Source
	v.Destination = u.Destination
	v.Number = u.Number
	return nil
}

func (v *SignatureMessage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      MessageType                                     `json:"type"`
		Signature *encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
		TxID      *url.TxID                                       `json:"txID,omitempty"`
	}{}
	u.Type = v.Type()
	u.Signature = &encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	u.TxID = v.TxID
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Signature != nil {
		v.Signature = u.Signature.Value
	}

	v.TxID = u.TxID
	return nil
}

func (v *SignatureRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      MessageType `json:"type"`
		Authority *url.URL    `json:"authority,omitempty"`
		TxID      *url.TxID   `json:"txID,omitempty"`
		Cause     *url.TxID   `json:"cause,omitempty"`
	}{}
	u.Type = v.Type()
	u.Authority = v.Authority
	u.TxID = v.TxID
	u.Cause = v.Cause
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Authority = u.Authority
	v.TxID = u.TxID
	v.Cause = u.Cause
	return nil
}

func (v *StateTreeUpdate) UnmarshalJSON(data []byte) error {
	u := struct {
		Key  *record.Key `json:"key,omitempty"`
		Hash string      `json:"hash,omitempty"`
	}{}
	u.Key = v.Key
	u.Hash = encoding.ChainToJSON(v.Hash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Key = u.Key
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	return nil
}

func (v *SynthFields) UnmarshalJSON(data []byte) error {
	u := struct {
		Message   *encoding.JsonUnmarshalWith[Message]               `json:"message,omitempty"`
		Signature *encoding.JsonUnmarshalWith[protocol.KeySignature] `json:"signature,omitempty"`
		Proof     *protocol.AnnotatedReceipt                         `json:"proof,omitempty"`
	}{}
	u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalMessageJSON}
	u.Signature = &encoding.JsonUnmarshalWith[protocol.KeySignature]{Value: v.Signature, Func: protocol.UnmarshalKeySignatureJSON}
	u.Proof = v.Proof
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Message != nil {
		v.Message = u.Message.Value
	}

	if u.Signature != nil {
		v.Signature = u.Signature.Value
	}

	v.Proof = u.Proof
	return nil
}

func (v *SyntheticMessage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      MessageType                                        `json:"type"`
		Message   *encoding.JsonUnmarshalWith[Message]               `json:"message,omitempty"`
		Signature *encoding.JsonUnmarshalWith[protocol.KeySignature] `json:"signature,omitempty"`
		Proof     *protocol.AnnotatedReceipt                         `json:"proof,omitempty"`
	}{}
	u.Type = v.Type()
	u.Message = &encoding.JsonUnmarshalWith[Message]{Value: v.Message, Func: UnmarshalMessageJSON}
	u.Signature = &encoding.JsonUnmarshalWith[protocol.KeySignature]{Value: v.Signature, Func: protocol.UnmarshalKeySignatureJSON}
	u.Proof = v.Proof
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Message != nil {
		v.Message = u.Message.Value
	}

	if u.Signature != nil {
		v.Signature = u.Signature.Value
	}

	v.Proof = u.Proof
	return nil
}

func (v *TransactionMessage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        MessageType           `json:"type"`
		Transaction *protocol.Transaction `json:"transaction,omitempty"`
	}{}
	u.Type = v.Type()
	u.Transaction = v.Transaction
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Transaction = u.Transaction
	return nil
}
