package staking

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"errors"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
)

type Account struct {
	fieldsSet []bool
	// Type is the type of staking account.
	Type AccountType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	// Identity is the URL of the staker's ADI.
	Identity *url.URL `json:"identity,omitempty" form:"identity" query:"identity" validate:"required"`
	// Stake is the URL of the staked token account.
	Stake *url.URL `json:"stake,omitempty" form:"stake" query:"stake" validate:"required"`
	// Rewards is the URL of the rewards token account.
	Rewards *url.URL `json:"rewards,omitempty" form:"rewards" query:"rewards" validate:"required"`
	// Delegate is the URL of an account this stake is delegated to.
	Delegate  *url.URL `json:"delegate,omitempty" form:"delegate" query:"delegate"`
	extraData []byte
}

func (v *Account) Copy() *Account {
	u := new(Account)

	u.Type = v.Type
	if v.Identity != nil {
		u.Identity = v.Identity
	}
	if v.Stake != nil {
		u.Stake = v.Stake
	}
	if v.Rewards != nil {
		u.Rewards = v.Rewards
	}
	if v.Delegate != nil {
		u.Delegate = v.Delegate
	}

	return u
}

func (v *Account) CopyAsInterface() interface{} { return v.Copy() }

func (v *Account) Equal(u *Account) bool {
	if !(v.Type == u.Type) {
		return false
	}
	switch {
	case v.Identity == u.Identity:
		// equal
	case v.Identity == nil || u.Identity == nil:
		return false
	case !((v.Identity).Equal(u.Identity)):
		return false
	}
	switch {
	case v.Stake == u.Stake:
		// equal
	case v.Stake == nil || u.Stake == nil:
		return false
	case !((v.Stake).Equal(u.Stake)):
		return false
	}
	switch {
	case v.Rewards == u.Rewards:
		// equal
	case v.Rewards == nil || u.Rewards == nil:
		return false
	case !((v.Rewards).Equal(u.Rewards)):
		return false
	}
	switch {
	case v.Delegate == u.Delegate:
		// equal
	case v.Delegate == nil || u.Delegate == nil:
		return false
	case !((v.Delegate).Equal(u.Delegate)):
		return false
	}

	return true
}

var fieldNames_Account = []string{
	1: "Type",
	2: "Identity",
	3: "Stake",
	4: "Rewards",
	5: "Delegate",
}

func (v *Account) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	if !(v.Identity == nil) {
		writer.WriteUrl(2, v.Identity)
	}
	if !(v.Stake == nil) {
		writer.WriteUrl(3, v.Stake)
	}
	if !(v.Rewards == nil) {
		writer.WriteUrl(4, v.Rewards)
	}
	if !(v.Delegate == nil) {
		writer.WriteUrl(5, v.Delegate)
	}

	_, _, err := writer.Reset(fieldNames_Account)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Account) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Identity is missing")
	} else if v.Identity == nil {
		errs = append(errs, "field Identity is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Stake is missing")
	} else if v.Stake == nil {
		errs = append(errs, "field Stake is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Rewards is missing")
	} else if v.Rewards == nil {
		errs = append(errs, "field Rewards is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *Account) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Account) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(AccountType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Identity = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Stake = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Rewards = x
	}
	if x, ok := reader.ReadUrl(5); ok {
		v.Delegate = x
	}

	seen, err := reader.Reset(fieldNames_Account)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}
