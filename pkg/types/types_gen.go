package types

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

type MerkleState struct {
	fieldsSet []bool
	Count     uint64     `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	Pending   [][32]byte `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	HashList  [][32]byte `json:"hashList,omitempty" form:"hashList" query:"hashList" validate:"required"`
	extraData []byte
}

type Receipt struct {
	fieldsSet   []bool
	Start       []byte         `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	StartIndex  uint64         `json:"startIndex,omitempty" form:"startIndex" query:"startIndex" validate:"required"`
	Anchor      []byte         `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	AnchorIndex uint64         `json:"anchorIndex,omitempty" form:"anchorIndex" query:"anchorIndex" validate:"required"`
	Result      []byte         `json:"result,omitempty" form:"result" query:"result" validate:"required"`
	Entries     []ReceiptEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData   []byte
}

type ReceiptEntry struct {
	fieldsSet []bool
	Right     bool   `json:"right,omitempty" form:"right" query:"right" validate:"required"`
	Hash      []byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	extraData []byte
}

func (v *MerkleState) Copy() *MerkleState {
	u := new(MerkleState)

	u.Count = v.Count
	u.Pending = make([][32]byte, len(v.Pending))
	for i, v := range v.Pending {
		u.Pending[i] = v
	}
	u.HashList = make([][32]byte, len(v.HashList))
	for i, v := range v.HashList {
		u.HashList[i] = v
	}

	return u
}

func (v *MerkleState) CopyAsInterface() interface{} { return v.Copy() }

func (v *Receipt) Copy() *Receipt {
	u := new(Receipt)

	u.Start = encoding.BytesCopy(v.Start)
	u.StartIndex = v.StartIndex
	u.Anchor = encoding.BytesCopy(v.Anchor)
	u.AnchorIndex = v.AnchorIndex
	u.Result = encoding.BytesCopy(v.Result)
	u.Entries = make([]ReceiptEntry, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = *(&v).Copy()
	}

	return u
}

func (v *Receipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *ReceiptEntry) Copy() *ReceiptEntry {
	u := new(ReceiptEntry)

	u.Right = v.Right
	u.Hash = encoding.BytesCopy(v.Hash)

	return u
}

func (v *ReceiptEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *MerkleState) Equal(u *MerkleState) bool {
	if !(v.Count == u.Count) {
		return false
	}
	if len(v.Pending) != len(u.Pending) {
		return false
	}
	for i := range v.Pending {
		if !(v.Pending[i] == u.Pending[i]) {
			return false
		}
	}
	if len(v.HashList) != len(u.HashList) {
		return false
	}
	for i := range v.HashList {
		if !(v.HashList[i] == u.HashList[i]) {
			return false
		}
	}

	return true
}

func (v *Receipt) Equal(u *Receipt) bool {
	if !(bytes.Equal(v.Start, u.Start)) {
		return false
	}
	if !(v.StartIndex == u.StartIndex) {
		return false
	}
	if !(bytes.Equal(v.Anchor, u.Anchor)) {
		return false
	}
	if !(v.AnchorIndex == u.AnchorIndex) {
		return false
	}
	if !(bytes.Equal(v.Result, u.Result)) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((&v.Entries[i]).Equal(&u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ReceiptEntry) Equal(u *ReceiptEntry) bool {
	if !(v.Right == u.Right) {
		return false
	}
	if !(bytes.Equal(v.Hash, u.Hash)) {
		return false
	}

	return true
}

var fieldNames_MerkleState = []string{
	1: "Count",
	2: "Pending",
	3: "HashList",
}

func (v *MerkleState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Count == 0) {
		writer.WriteUint(1, v.Count)
	}
	if !(len(v.Pending) == 0) {
		for _, v := range v.Pending {
			writer.WriteHash(2, &v)
		}
	}
	if !(len(v.HashList) == 0) {
		for _, v := range v.HashList {
			writer.WriteHash(3, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_MerkleState)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *MerkleState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Pending is missing")
	} else if len(v.Pending) == 0 {
		errs = append(errs, "field Pending is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field HashList is missing")
	} else if len(v.HashList) == 0 {
		errs = append(errs, "field HashList is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Receipt = []string{
	1: "Start",
	2: "StartIndex",
	3: "Anchor",
	4: "AnchorIndex",
	5: "Result",
	6: "Entries",
}

func (v *Receipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Start) == 0) {
		writer.WriteBytes(1, v.Start)
	}
	if !(v.StartIndex == 0) {
		writer.WriteUint(2, v.StartIndex)
	}
	if !(len(v.Anchor) == 0) {
		writer.WriteBytes(3, v.Anchor)
	}
	if !(v.AnchorIndex == 0) {
		writer.WriteUint(4, v.AnchorIndex)
	}
	if !(len(v.Result) == 0) {
		writer.WriteBytes(5, v.Result)
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(6, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_Receipt)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *Receipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Start is missing")
	} else if len(v.Start) == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field StartIndex is missing")
	} else if v.StartIndex == 0 {
		errs = append(errs, "field StartIndex is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Anchor is missing")
	} else if len(v.Anchor) == 0 {
		errs = append(errs, "field Anchor is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field AnchorIndex is missing")
	} else if v.AnchorIndex == 0 {
		errs = append(errs, "field AnchorIndex is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Result is missing")
	} else if len(v.Result) == 0 {
		errs = append(errs, "field Result is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ReceiptEntry = []string{
	1: "Right",
	2: "Hash",
}

func (v *ReceiptEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.Right) {
		writer.WriteBool(1, v.Right)
	}
	if !(len(v.Hash) == 0) {
		writer.WriteBytes(2, v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_ReceiptEntry)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ReceiptEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Right is missing")
	} else if !v.Right {
		errs = append(errs, "field Right is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Hash is missing")
	} else if len(v.Hash) == 0 {
		errs = append(errs, "field Hash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *MerkleState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MerkleState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Count = x
	}
	for {
		if x, ok := reader.ReadHash(2); ok {
			v.Pending = append(v.Pending, *x)
		} else {
			break
		}
	}
	for {
		if x, ok := reader.ReadHash(3); ok {
			v.HashList = append(v.HashList, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_MerkleState)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *Receipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Receipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.StartIndex = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Anchor = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.AnchorIndex = x
	}
	if x, ok := reader.ReadBytes(5); ok {
		v.Result = x
	}
	for {
		if x := new(ReceiptEntry); reader.ReadValue(6, x.UnmarshalBinary) {
			v.Entries = append(v.Entries, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_Receipt)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ReceiptEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ReceiptEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.Right = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Hash = x
	}

	seen, err := reader.Reset(fieldNames_ReceiptEntry)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *MerkleState) MarshalJSON() ([]byte, error) {
	u := struct {
		Count    uint64                    `json:"count,omitempty"`
		Pending  encoding.JsonList[string] `json:"pending,omitempty"`
		HashList encoding.JsonList[string] `json:"hashList,omitempty"`
	}{}
	u.Count = v.Count
	u.Pending = make(encoding.JsonList[string], len(v.Pending))
	for i, x := range v.Pending {
		u.Pending[i] = encoding.ChainToJSON(x)
	}
	u.HashList = make(encoding.JsonList[string], len(v.HashList))
	for i, x := range v.HashList {
		u.HashList[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *Receipt) MarshalJSON() ([]byte, error) {
	u := struct {
		Start       *string                         `json:"start,omitempty"`
		StartIndex  uint64                          `json:"startIndex,omitempty"`
		Anchor      *string                         `json:"anchor,omitempty"`
		AnchorIndex uint64                          `json:"anchorIndex,omitempty"`
		Result      *string                         `json:"result,omitempty"`
		Entries     encoding.JsonList[ReceiptEntry] `json:"entries,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Start)
	u.StartIndex = v.StartIndex
	u.Anchor = encoding.BytesToJSON(v.Anchor)
	u.AnchorIndex = v.AnchorIndex
	u.Result = encoding.BytesToJSON(v.Result)
	u.Entries = v.Entries
	return json.Marshal(&u)
}

func (v *ReceiptEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Right bool    `json:"right,omitempty"`
		Hash  *string `json:"hash,omitempty"`
	}{}
	u.Right = v.Right
	u.Hash = encoding.BytesToJSON(v.Hash)
	return json.Marshal(&u)
}

func (v *MerkleState) UnmarshalJSON(data []byte) error {
	u := struct {
		Count    uint64                    `json:"count,omitempty"`
		Pending  encoding.JsonList[string] `json:"pending,omitempty"`
		HashList encoding.JsonList[string] `json:"hashList,omitempty"`
	}{}
	u.Count = v.Count
	u.Pending = make(encoding.JsonList[string], len(v.Pending))
	for i, x := range v.Pending {
		u.Pending[i] = encoding.ChainToJSON(x)
	}
	u.HashList = make(encoding.JsonList[string], len(v.HashList))
	for i, x := range v.HashList {
		u.HashList[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Count = u.Count
	v.Pending = make([][32]byte, len(u.Pending))
	for i, x := range u.Pending {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Pending: %w", err)
		} else {
			v.Pending[i] = x
		}
	}
	v.HashList = make([][32]byte, len(u.HashList))
	for i, x := range u.HashList {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding HashList: %w", err)
		} else {
			v.HashList[i] = x
		}
	}
	return nil
}

func (v *Receipt) UnmarshalJSON(data []byte) error {
	u := struct {
		Start       *string                         `json:"start,omitempty"`
		StartIndex  uint64                          `json:"startIndex,omitempty"`
		Anchor      *string                         `json:"anchor,omitempty"`
		AnchorIndex uint64                          `json:"anchorIndex,omitempty"`
		Result      *string                         `json:"result,omitempty"`
		Entries     encoding.JsonList[ReceiptEntry] `json:"entries,omitempty"`
	}{}
	u.Start = encoding.BytesToJSON(v.Start)
	u.StartIndex = v.StartIndex
	u.Anchor = encoding.BytesToJSON(v.Anchor)
	u.AnchorIndex = v.AnchorIndex
	u.Result = encoding.BytesToJSON(v.Result)
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Start); err != nil {
		return fmt.Errorf("error decoding Start: %w", err)
	} else {
		v.Start = x
	}
	v.StartIndex = u.StartIndex
	if x, err := encoding.BytesFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Anchor = x
	}
	v.AnchorIndex = u.AnchorIndex
	if x, err := encoding.BytesFromJSON(u.Result); err != nil {
		return fmt.Errorf("error decoding Result: %w", err)
	} else {
		v.Result = x
	}
	v.Entries = u.Entries
	return nil
}

func (v *ReceiptEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Right bool    `json:"right,omitempty"`
		Hash  *string `json:"hash,omitempty"`
	}{}
	u.Right = v.Right
	u.Hash = encoding.BytesToJSON(v.Hash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Right = u.Right
	if x, err := encoding.BytesFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	return nil
}
