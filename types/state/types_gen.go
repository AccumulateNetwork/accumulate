package state

// GENERATED BY go run ./internal/cmd/genmarshal. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"

	"github.com/AccumulateNetwork/accumulate/internal/encoding"
	"github.com/AccumulateNetwork/accumulate/types"
	"github.com/AccumulateNetwork/accumulate/types/api/transactions"
)

type Object struct {
	Entry  []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	Height uint64   `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots  [][]byte `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
}

type PendingTransaction struct {
	ChainHeader
	Signature        []*transactions.ED25519Sig `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	TransactionState *TxState                   `json:"transactionState,omitempty" form:"transactionState" query:"transactionState" validate:"required"`
	Status           json.RawMessage            `json:"status,omitempty" form:"status" query:"status" validate:"required"`
}

type Transaction struct {
	ChainHeader
	TxState
}

type TxState struct {
	SigInfo         *transactions.Header `json:"sigInfo,omitempty" form:"sigInfo" query:"sigInfo" validate:"required"`
	Transaction     []byte               `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	transactionHash [32]byte
}

func (v *Object) Equal(u *Object) bool {
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}

	if !(v.Height == u.Height) {
		return false
	}

	if !(len(v.Roots) == len(u.Roots)) {
		return false
	}

	for i := range v.Roots {
		v, u := v.Roots[i], u.Roots[i]
		if !(bytes.Equal(v, u)) {
			return false
		}

	}

	return true
}

func (v *PendingTransaction) Equal(u *PendingTransaction) bool {
	if !v.ChainHeader.Equal(&u.ChainHeader) {
		return false
	}

	if !(len(v.Signature) == len(u.Signature)) {
		return false
	}

	for i := range v.Signature {
		v, u := v.Signature[i], u.Signature[i]
		if !(v.Equal(u)) {
			return false
		}

	}

	if !(v.TransactionState.Equal(u.TransactionState)) {
		return false
	}

	if !(bytes.Equal(v.Status, u.Status)) {
		return false
	}

	return true
}

func (v *Transaction) Equal(u *Transaction) bool {
	if !v.ChainHeader.Equal(&u.ChainHeader) {
		return false
	}

	return true
}

func (v *TxState) Equal(u *TxState) bool {
	if !(v.SigInfo.Equal(u.SigInfo)) {
		return false
	}

	if !(bytes.Equal(v.Transaction, u.Transaction)) {
		return false
	}

	return true
}

func (v *Object) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.Entry)

	n += encoding.UvarintBinarySize(v.Height)

	n += encoding.UvarintBinarySize(uint64(len(v.Roots)))

	for _, v := range v.Roots {
		n += encoding.BytesBinarySize(v)

	}

	return n
}

func (v *PendingTransaction) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = types.ChainTypePendingTransaction

	n += v.ChainHeader.GetHeaderSize()

	n += encoding.UvarintBinarySize(uint64(len(v.Signature)))

	for _, v := range v.Signature {
		n += v.BinarySize()

	}

	n += v.TransactionState.BinarySize()

	n += encoding.BytesBinarySize(v.Status)

	return n
}

func (v *Transaction) BinarySize() int {
	var n int

	// Enforce sanity
	v.Type = types.ChainTypeTransaction

	n += v.ChainHeader.GetHeaderSize()

	n += v.TxState.BinarySize()

	return n
}

func (v *TxState) BinarySize() int {
	var n int

	n += v.SigInfo.BinarySize()

	n += encoding.BytesBinarySize(v.Transaction)

	return n
}

func (v *Object) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.Entry))

	buffer.Write(encoding.UvarintMarshalBinary(v.Height))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Roots))))
	for i, v := range v.Roots {
		_ = i
		buffer.Write(encoding.BytesMarshalBinary(v))

	}

	return buffer.Bytes(), nil
}

func (v *PendingTransaction) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = types.ChainTypePendingTransaction

	if b, err := v.ChainHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Signature))))
	for i, v := range v.Signature {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Signature[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	if b, err := v.TransactionState.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding TransactionState: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.BytesMarshalBinary(v.Status))

	return buffer.Bytes(), nil
}

func (v *Transaction) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	// Enforce sanity
	v.Type = types.ChainTypeTransaction

	if b, err := v.ChainHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	if b, err := v.TxState.MarshalBinary(); err != nil {
		return nil, err
	} else {
		buffer.Write(b)
	}

	return buffer.Bytes(), nil
}

func (v *TxState) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	if b, err := v.SigInfo.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding SigInfo: %w", err)
	} else {
		buffer.Write(b)
	}

	buffer.Write(encoding.BytesMarshalBinary(v.Transaction))

	return buffer.Bytes(), nil
}

func (v *Object) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	data = data[encoding.BytesBinarySize(v.Entry):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Height: %w", err)
	} else {
		v.Height = x
	}
	data = data[encoding.UvarintBinarySize(v.Height):]

	var lenRoots uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Roots: %w", err)
	} else {
		lenRoots = x
	}
	data = data[encoding.UvarintBinarySize(lenRoots):]

	v.Roots = make([][]byte, lenRoots)
	for i := range v.Roots {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Roots[%d]: %w", i, err)
		} else {
			v.Roots[i] = x
		}
		data = data[encoding.BytesBinarySize(v.Roots[i]):]

	}

	return nil
}

func (v *PendingTransaction) UnmarshalBinary(data []byte) error {
	typ := types.ChainTypePendingTransaction
	if err := v.ChainHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid chain type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	var lenSignature uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		lenSignature = x
	}
	data = data[encoding.UvarintBinarySize(lenSignature):]

	v.Signature = make([]*transactions.ED25519Sig, lenSignature)
	for i := range v.Signature {
		var x *transactions.ED25519Sig
		x = new(transactions.ED25519Sig)
		if err := x.UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Signature[%d]: %w", i, err)
		}
		data = data[x.BinarySize():]

		v.Signature[i] = x
	}

	v.TransactionState = new(TxState)
	if err := v.TransactionState.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TransactionState: %w", err)
	}
	data = data[v.TransactionState.BinarySize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Status: %w", err)
	} else {
		v.Status = x
	}
	data = data[encoding.BytesBinarySize(v.Status):]

	return nil
}

func (v *Transaction) UnmarshalBinary(data []byte) error {
	typ := types.ChainTypeTransaction
	if err := v.ChainHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid chain type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]

	if err := v.TxState.UnmarshalBinary(data); err != nil {
		return err
	}
	data = data[v.TxState.BinarySize():]

	return nil
}

func (v *TxState) UnmarshalBinary(data []byte) error {
	v.SigInfo = new(transactions.Header)
	if err := v.SigInfo.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding SigInfo: %w", err)
	}
	data = data[v.SigInfo.BinarySize():]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	data = data[encoding.BytesBinarySize(v.Transaction):]

	return nil
}

func (v *Object) MarshalJSON() ([]byte, error) {
	u := struct {
		Entry  *string   `json:"entry,omitempty"`
		Height uint64    `json:"height,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Height = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *TxState) MarshalJSON() ([]byte, error) {
	u := struct {
		SigInfo         *transactions.Header `json:"sigInfo,omitempty"`
		Transaction     *string              `json:"transaction,omitempty"`
		transactionHash string
	}{}
	u.SigInfo = v.SigInfo
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	return json.Marshal(&u)
}

func (v *Object) UnmarshalJSON(data []byte) error {
	u := struct {
		Entry  *string   `json:"entry,omitempty"`
		Height uint64    `json:"height,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Height = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.Height = u.Height
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots[%d]: %w", i, err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}

func (v *TxState) UnmarshalJSON(data []byte) error {
	u := struct {
		SigInfo         *transactions.Header `json:"sigInfo,omitempty"`
		Transaction     *string              `json:"transaction,omitempty"`
		transactionHash string
	}{}
	u.SigInfo = v.SigInfo
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.SigInfo = u.SigInfo
	if x, err := encoding.BytesFromJSON(u.Transaction); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	return nil
}
