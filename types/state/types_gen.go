package state

// GENERATED BY go run ./internal/cmd/genmarshal. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/AccumulateNetwork/accumulate/internal/encoding"
)

type AnchorMetadata struct {
	Index          int64      `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	PreviousHeight int64      `json:"previousHeight,omitempty" form:"previousHeight" query:"previousHeight" validate:"required"`
	Timestamp      time.Time  `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	Chains         [][32]byte `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
}

type Object struct {
	Entry  []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	Height uint64   `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots  [][]byte `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
}

type SyntheticSignature struct {
	Txid      [32]byte `json:"txid,omitempty" form:"txid" query:"txid" validate:"required"`
	Signature []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	PublicKey []byte   `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Nonce     uint64   `json:"nonce,omitempty" form:"nonce" query:"nonce" validate:"required"`
}

type SyntheticSignatures struct {
	Signatures []SyntheticSignature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
}

func (v *AnchorMetadata) Equal(u *AnchorMetadata) bool {
	if !(v.Index == u.Index) {
		return false
	}

	if !(v.PreviousHeight == u.PreviousHeight) {
		return false
	}

	if !(v.Timestamp == u.Timestamp) {
		return false
	}

	if !(len(v.Chains) == len(u.Chains)) {
		return false
	}

	for i := range v.Chains {
		if v.Chains[i] != u.Chains[i] {
			return false
		}
	}

	return true
}

func (v *Object) Equal(u *Object) bool {
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}

	if !(v.Height == u.Height) {
		return false
	}

	if !(len(v.Roots) == len(u.Roots)) {
		return false
	}

	for i := range v.Roots {
		v, u := v.Roots[i], u.Roots[i]
		if !(bytes.Equal(v, u)) {
			return false
		}

	}

	return true
}

func (v *AnchorMetadata) BinarySize() int {
	var n int

	n += encoding.VarintBinarySize(v.Index)

	n += encoding.VarintBinarySize(v.PreviousHeight)

	n += encoding.TimeBinarySize(v.Timestamp)

	n += encoding.ChainSetBinarySize(v.Chains)

	return n
}

func (v *Object) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.Entry)

	n += encoding.UvarintBinarySize(v.Height)

	n += encoding.UvarintBinarySize(uint64(len(v.Roots)))

	for _, v := range v.Roots {
		n += encoding.BytesBinarySize(v)

	}

	return n
}

func (v *SyntheticSignature) BinarySize() int {
	var n int

	n += encoding.ChainBinarySize(&v.Txid)

	n += encoding.BytesBinarySize(v.Signature)

	n += encoding.BytesBinarySize(v.PublicKey)

	n += encoding.UvarintBinarySize(v.Nonce)

	return n
}

func (v *SyntheticSignatures) BinarySize() int {
	var n int

	n += encoding.UvarintBinarySize(uint64(len(v.Signatures)))

	for _, v := range v.Signatures {
		n += v.BinarySize()

	}

	return n
}

func (v *AnchorMetadata) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.VarintMarshalBinary(v.Index))

	buffer.Write(encoding.VarintMarshalBinary(v.PreviousHeight))

	buffer.Write(encoding.TimeMarshalBinary(v.Timestamp))

	buffer.Write(encoding.ChainSetMarshalBinary(v.Chains))

	return buffer.Bytes(), nil
}

func (v *Object) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.Entry))

	buffer.Write(encoding.UvarintMarshalBinary(v.Height))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Roots))))
	for i, v := range v.Roots {
		_ = i
		buffer.Write(encoding.BytesMarshalBinary(v))

	}

	return buffer.Bytes(), nil
}

func (v *SyntheticSignature) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.ChainMarshalBinary(&v.Txid))

	buffer.Write(encoding.BytesMarshalBinary(v.Signature))

	buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))

	buffer.Write(encoding.UvarintMarshalBinary(v.Nonce))

	return buffer.Bytes(), nil
}

func (v *SyntheticSignatures) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Signatures))))
	for i, v := range v.Signatures {
		_ = i
		if b, err := v.MarshalBinary(); err != nil {
			return nil, fmt.Errorf("error encoding Signatures[%d]: %w", i, err)
		} else {
			buffer.Write(b)
		}

	}

	return buffer.Bytes(), nil
}

func (v *AnchorMetadata) UnmarshalBinary(data []byte) error {
	if x, err := encoding.VarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Index: %w", err)
	} else {
		v.Index = x
	}
	data = data[encoding.VarintBinarySize(v.Index):]

	if x, err := encoding.VarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PreviousHeight: %w", err)
	} else {
		v.PreviousHeight = x
	}
	data = data[encoding.VarintBinarySize(v.PreviousHeight):]

	if x, err := encoding.TimeUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Timestamp: %w", err)
	} else {
		v.Timestamp = x
	}
	data = data[encoding.TimeBinarySize(v.Timestamp):]

	if x, err := encoding.ChainSetUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Chains: %w", err)
	} else {
		v.Chains = x
	}
	data = data[encoding.ChainSetBinarySize(v.Chains):]

	return nil
}

func (v *Object) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	data = data[encoding.BytesBinarySize(v.Entry):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Height: %w", err)
	} else {
		v.Height = x
	}
	data = data[encoding.UvarintBinarySize(v.Height):]

	var lenRoots uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Roots: %w", err)
	} else {
		lenRoots = x
	}
	data = data[encoding.UvarintBinarySize(lenRoots):]

	v.Roots = make([][]byte, lenRoots)
	for i := range v.Roots {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Roots[%d]: %w", i, err)
		} else {
			v.Roots[i] = x
		}
		data = data[encoding.BytesBinarySize(v.Roots[i]):]

	}

	return nil
}

func (v *SyntheticSignature) UnmarshalBinary(data []byte) error {
	if x, err := encoding.ChainUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Txid: %w", err)
	} else {
		v.Txid = x
	}
	data = data[encoding.ChainBinarySize(&v.Txid):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	data = data[encoding.BytesBinarySize(v.Signature):]

	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	data = data[encoding.BytesBinarySize(v.PublicKey):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Nonce: %w", err)
	} else {
		v.Nonce = x
	}
	data = data[encoding.UvarintBinarySize(v.Nonce):]

	return nil
}

func (v *SyntheticSignatures) UnmarshalBinary(data []byte) error {
	var lenSignatures uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Signatures: %w", err)
	} else {
		lenSignatures = x
	}
	data = data[encoding.UvarintBinarySize(lenSignatures):]

	v.Signatures = make([]SyntheticSignature, lenSignatures)
	for i := range v.Signatures {
		if err := v.Signatures[i].UnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Signatures[%d]: %w", i, err)
		}
		data = data[v.Signatures[i].BinarySize():]

	}

	return nil
}

func (v *AnchorMetadata) MarshalJSON() ([]byte, error) {
	u := struct {
		Index          int64     `json:"index,omitempty"`
		PreviousHeight int64     `json:"previousHeight,omitempty"`
		Timestamp      time.Time `json:"timestamp,omitempty"`
		Chains         []string  `json:"chains,omitempty"`
	}{}
	u.Index = v.Index
	u.PreviousHeight = v.PreviousHeight
	u.Timestamp = v.Timestamp
	u.Chains = encoding.ChainSetToJSON(v.Chains)
	return json.Marshal(&u)
}

func (v *Object) MarshalJSON() ([]byte, error) {
	u := struct {
		Entry  *string   `json:"entry,omitempty"`
		Height uint64    `json:"height,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Height = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *SyntheticSignature) MarshalJSON() ([]byte, error) {
	u := struct {
		Txid      string  `json:"txid,omitempty"`
		Signature *string `json:"signature,omitempty"`
		PublicKey *string `json:"publicKey,omitempty"`
		Nonce     uint64  `json:"nonce,omitempty"`
	}{}
	u.Txid = encoding.ChainToJSON(v.Txid)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Nonce = v.Nonce
	return json.Marshal(&u)
}

func (v *AnchorMetadata) UnmarshalJSON(data []byte) error {
	u := struct {
		Index          int64     `json:"index,omitempty"`
		PreviousHeight int64     `json:"previousHeight,omitempty"`
		Timestamp      time.Time `json:"timestamp,omitempty"`
		Chains         []string  `json:"chains,omitempty"`
	}{}
	u.Index = v.Index
	u.PreviousHeight = v.PreviousHeight
	u.Timestamp = v.Timestamp
	u.Chains = encoding.ChainSetToJSON(v.Chains)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Index = u.Index
	v.PreviousHeight = u.PreviousHeight
	v.Timestamp = u.Timestamp
	if x, err := encoding.ChainSetFromJSON(u.Chains); err != nil {
		return fmt.Errorf("error decoding Chains: %w", err)
	} else {
		v.Chains = x
	}
	return nil
}

func (v *Object) UnmarshalJSON(data []byte) error {
	u := struct {
		Entry  *string   `json:"entry,omitempty"`
		Height uint64    `json:"height,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Height = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.Height = u.Height
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots[%d]: %w", i, err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}

func (v *SyntheticSignature) UnmarshalJSON(data []byte) error {
	u := struct {
		Txid      string  `json:"txid,omitempty"`
		Signature *string `json:"signature,omitempty"`
		PublicKey *string `json:"publicKey,omitempty"`
		Nonce     uint64  `json:"nonce,omitempty"`
	}{}
	u.Txid = encoding.ChainToJSON(v.Txid)
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Nonce = v.Nonce
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Txid); err != nil {
		return fmt.Errorf("error decoding Txid: %w", err)
	} else {
		v.Txid = x
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	v.Nonce = u.Nonce
	return nil
}
