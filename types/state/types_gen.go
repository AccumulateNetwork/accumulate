package state

// GENERATED BY go run ./internal/cmd/genmarshal. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/AccumulateNetwork/accumulate/internal/encoding"
)

type AnchorMetadata struct {
	Index          int64      `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	PreviousHeight int64      `json:"previousHeight,omitempty" form:"previousHeight" query:"previousHeight" validate:"required"`
	Timestamp      time.Time  `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	Chains         [][32]byte `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
}

type Object struct {
	Entry  []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	Height uint64   `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots  [][]byte `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
}

func (v *AnchorMetadata) BinarySize() int {
	var n int

	n += encoding.VarintBinarySize(v.Index)

	n += encoding.VarintBinarySize(v.PreviousHeight)

	n += encoding.TimeBinarySize(v.Timestamp)

	n += encoding.ChainSetBinarySize(v.Chains)

	return n
}

func (v *Object) BinarySize() int {
	var n int

	n += encoding.BytesBinarySize(v.Entry)

	n += encoding.UvarintBinarySize(v.Height)

	n += encoding.UvarintBinarySize(uint64(len(v.Roots)))

	for _, v := range v.Roots {
		n += encoding.BytesBinarySize(v)

	}

	return n
}

func (v *AnchorMetadata) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.VarintMarshalBinary(v.Index))

	buffer.Write(encoding.VarintMarshalBinary(v.PreviousHeight))

	buffer.Write(encoding.TimeMarshalBinary(v.Timestamp))

	buffer.Write(encoding.ChainSetMarshalBinary(v.Chains))

	return buffer.Bytes(), nil
}

func (v *Object) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.Write(encoding.BytesMarshalBinary(v.Entry))

	buffer.Write(encoding.UvarintMarshalBinary(v.Height))

	buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Roots))))
	for i, v := range v.Roots {
		_ = i
		buffer.Write(encoding.BytesMarshalBinary(v))

	}

	return buffer.Bytes(), nil
}

func (v *AnchorMetadata) UnmarshalBinary(data []byte) error {
	if x, err := encoding.VarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Index: %w", err)
	} else {
		v.Index = x
	}
	data = data[encoding.VarintBinarySize(v.Index):]

	if x, err := encoding.VarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding PreviousHeight: %w", err)
	} else {
		v.PreviousHeight = x
	}
	data = data[encoding.VarintBinarySize(v.PreviousHeight):]

	if x, err := encoding.TimeUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Timestamp: %w", err)
	} else {
		v.Timestamp = x
	}
	data = data[encoding.TimeBinarySize(v.Timestamp):]

	if x, err := encoding.ChainSetUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Chains: %w", err)
	} else {
		v.Chains = x
	}
	data = data[encoding.ChainSetBinarySize(v.Chains):]

	return nil
}

func (v *Object) UnmarshalBinary(data []byte) error {
	if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	data = data[encoding.BytesBinarySize(v.Entry):]

	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Height: %w", err)
	} else {
		v.Height = x
	}
	data = data[encoding.UvarintBinarySize(v.Height):]

	var lenRoots uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding Roots: %w", err)
	} else {
		lenRoots = x
	}
	data = data[encoding.UvarintBinarySize(lenRoots):]

	v.Roots = make([][]byte, lenRoots)
	for i := range v.Roots {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil {
			return fmt.Errorf("error decoding Roots[%d]: %w", i, err)
		} else {
			v.Roots[i] = x
		}
		data = data[encoding.BytesBinarySize(v.Roots[i]):]

	}

	return nil
}

func (v *AnchorMetadata) MarshalJSON() ([]byte, error) {
	u := struct {
		Index          int64     `json:"index,omitempty"`
		PreviousHeight int64     `json:"previousHeight,omitempty"`
		Timestamp      time.Time `json:"timestamp,omitempty"`
		Chains         []string  `json:"chains,omitempty"`
	}{}
	u.Index = v.Index
	u.PreviousHeight = v.PreviousHeight
	u.Timestamp = v.Timestamp
	u.Chains = encoding.ChainSetToJSON(v.Chains)
	return json.Marshal(&u)
}

func (v *Object) MarshalJSON() ([]byte, error) {
	u := struct {
		Entry  *string   `json:"entry,omitempty"`
		Height uint64    `json:"height,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Height = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *AnchorMetadata) UnmarshalJSON(data []byte) error {
	u := struct {
		Index          int64     `json:"index,omitempty"`
		PreviousHeight int64     `json:"previousHeight,omitempty"`
		Timestamp      time.Time `json:"timestamp,omitempty"`
		Chains         []string  `json:"chains,omitempty"`
	}{}
	u.Index = v.Index
	u.PreviousHeight = v.PreviousHeight
	u.Timestamp = v.Timestamp
	u.Chains = encoding.ChainSetToJSON(v.Chains)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Index = u.Index
	v.PreviousHeight = u.PreviousHeight
	v.Timestamp = u.Timestamp
	if x, err := encoding.ChainSetFromJSON(u.Chains); err != nil {
		return fmt.Errorf("error decoding Chains: %w", err)
	} else {
		v.Chains = x
	}
	return nil
}

func (v *Object) UnmarshalJSON(data []byte) error {
	u := struct {
		Entry  *string   `json:"entry,omitempty"`
		Height uint64    `json:"height,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.Height = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.Height = u.Height
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots[%d]: %w", i, err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}
