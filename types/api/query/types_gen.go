package query

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type ChainState struct {
	fieldsSet []bool
	Name      string             `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Height    uint64             `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots     [][]byte           `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
	extraData []byte
}

type DirectoryQueryResult struct {
	fieldsSet       []bool
	Entries         []string           `json:"entries,omitempty" form:"entries" query:"entries"`
	ExpandedEntries []protocol.Account `json:"expandedEntries,omitempty" form:"expandedEntries" query:"expandedEntries"`
	Total           uint64             `json:"total" form:"total" query:"total" validate:"required"`
	extraData       []byte
}

type GeneralReceipt struct {
	fieldsSet      []bool
	LocalBlock     uint64           `json:"localBlock,omitempty" form:"localBlock" query:"localBlock" validate:"required"`
	DirectoryBlock uint64           `json:"directoryBlock,omitempty" form:"directoryBlock" query:"directoryBlock" validate:"required"`
	Receipt        protocol.Receipt `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	Error          string           `json:"error,omitempty" form:"error" query:"error" validate:"required"`
	extraData      []byte
}

type MultiResponse struct {
	fieldsSet []bool
	Type      string   `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Items     []string `json:"items,omitempty" form:"items" query:"items" validate:"required"`
	Start     uint64   `json:"start" form:"start" query:"start" validate:"required"`
	Count     uint64   `json:"count" form:"count" query:"count" validate:"required"`
	Total     uint64   `json:"total" form:"total" query:"total" validate:"required"`
	extraData []byte
}

type RequestDataEntry struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	EntryHash [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash"`
	extraData []byte
}

type RequestDataEntrySet struct {
	fieldsSet    []bool
	Url          *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Start        uint64   `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Count        uint64   `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	ExpandChains bool     `json:"expandChains,omitempty" form:"expandChains" query:"expandChains"`
	extraData    []byte
}

type RequestKeyPageIndex struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Key       []byte   `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	extraData []byte
}

type RequestMinorBlocks struct {
	fieldsSet                    []bool
	Account                      *url.URL    `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Start                        uint64      `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Limit                        uint64      `json:"limit,omitempty" form:"limit" query:"limit" validate:"required"`
	TxFetchMode                  TxFetchMode `json:"txFetchMode,omitempty" form:"txFetchMode" query:"txFetchMode" validate:"required"`
	FilterSynthAnchorsOnlyBlocks bool        `json:"filterSynthAnchorsOnlyBlocks,omitempty" form:"filterSynthAnchorsOnlyBlocks" query:"filterSynthAnchorsOnlyBlocks" validate:"required"`
	extraData                    []byte
}

type RequestTxHistory struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Start     uint64   `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Limit     uint64   `json:"limit,omitempty" form:"limit" query:"limit" validate:"required"`
	extraData []byte
}

type ResponseAccount struct {
	fieldsSet  []bool
	Account    protocol.Account `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	ChainState []ChainState     `json:"chainState,omitempty" form:"chainState" query:"chainState" validate:"required"`
	Receipt    *GeneralReceipt  `json:"receipt,omitempty" form:"receipt" query:"receipt"`
	extraData  []byte
}

type ResponseByTxId struct {
	fieldsSet    []bool
	TxId         [32]byte                    `json:"txId,omitempty" form:"txId" query:"txId" validate:"required"`
	Envelope     *protocol.Envelope          `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	Status       *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	TxSynthTxIds []byte                      `json:"txSynthTxIds,omitempty" form:"txSynthTxIds" query:"txSynthTxIds" validate:"required"`
	Height       int64                       `json:"height" form:"height" query:"height" validate:"required"`
	ChainState   [][]byte                    `json:"chainState,omitempty" form:"chainState" query:"chainState" validate:"required"`
	Receipts     []*TxReceipt                `json:"receipts,omitempty" form:"receipts" query:"receipts" validate:"required"`
	Signers      []SignatureSet              `json:"signers,omitempty" form:"signers" query:"signers" validate:"required"`
	extraData    []byte
}

type ResponseChainEntry struct {
	fieldsSet []bool
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Height    int64              `json:"height" form:"height" query:"height" validate:"required"`
	Entry     []byte             `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	State     [][]byte           `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	Receipt   *GeneralReceipt    `json:"receipt,omitempty" form:"receipt" query:"receipt"`
	extraData []byte
}

type ResponseChainRange struct {
	fieldsSet []bool
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Start     int64              `json:"start" form:"start" query:"start" validate:"required"`
	End       int64              `json:"end" form:"end" query:"end" validate:"required"`
	Total     int64              `json:"total" form:"total" query:"total" validate:"required"`
	Entries   [][]byte           `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type ResponseDataEntry struct {
	fieldsSet []bool
	EntryHash [32]byte           `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	Entry     protocol.DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData []byte
}

type ResponseDataEntrySet struct {
	fieldsSet   []bool
	DataEntries []ResponseDataEntry `json:"dataEntries,omitempty" form:"dataEntries" query:"dataEntries" validate:"required"`
	Total       uint64              `json:"total,omitempty" form:"total" query:"total" validate:"required"`
	extraData   []byte
}

type ResponseKeyPageIndex struct {
	fieldsSet []bool
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	Signer    *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	Index     uint64   `json:"index" form:"index" query:"index" validate:"required"`
	extraData []byte
}

type ResponseMinorBlocks struct {
	fieldsSet   []bool
	TotalBlocks uint64                `json:"totalBlocks" form:"totalBlocks" query:"totalBlocks" validate:"required"`
	Entries     []*ResponseMinorEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData   []byte
}

type ResponseMinorEntry struct {
	fieldsSet []bool
	// BlockIndex is the index of the block. Only include when indexing the root anchor chain.
	BlockIndex uint64 `json:"blockIndex,omitempty" form:"blockIndex" query:"blockIndex" validate:"required"`
	// BlockTime is the start time of the block..
	BlockTime *time.Time `json:"blockTime,omitempty" form:"blockTime" query:"blockTime" validate:"required"`
	// TxCount shows how many transactions this block contains.
	TxCount uint64   `json:"txCount,omitempty" form:"txCount" query:"txCount" validate:"required"`
	TxIds   [][]byte `json:"txIds,omitempty" form:"txIds" query:"txIds" validate:"required"`
	// Transactions the transactions within this block.
	Transactions []*ResponseByTxId `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	extraData    []byte
}

type ResponsePending struct {
	fieldsSet    []bool
	Transactions [][32]byte `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	extraData    []byte
}

type ResponseTxHistory struct {
	fieldsSet    []bool
	Start        uint64           `json:"start" form:"start" query:"start" validate:"required"`
	End          uint64           `json:"end" form:"end" query:"end" validate:"required"`
	Total        uint64           `json:"total" form:"total" query:"total" validate:"required"`
	Transactions []ResponseByTxId `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	extraData    []byte
}

type SignatureSet struct {
	fieldsSet  []bool
	Account    protocol.Account     `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Signatures []protocol.Signature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	extraData  []byte
}

type TxReceipt struct {
	fieldsSet []bool
	GeneralReceipt
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Chain     string   `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	extraData []byte
}

func (v *ChainState) Copy() *ChainState {
	u := new(ChainState)

	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Roots = make([][]byte, len(v.Roots))
	for i, v := range v.Roots {
		u.Roots[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *ChainState) CopyAsInterface() interface{} { return v.Copy() }

func (v *DirectoryQueryResult) Copy() *DirectoryQueryResult {
	u := new(DirectoryQueryResult)

	u.Entries = make([]string, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = v
	}
	u.ExpandedEntries = make([]protocol.Account, len(v.ExpandedEntries))
	for i, v := range v.ExpandedEntries {
		if v != nil {
			u.ExpandedEntries[i] = (v).CopyAsInterface().(protocol.Account)
		}
	}
	u.Total = v.Total

	return u
}

func (v *DirectoryQueryResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *GeneralReceipt) Copy() *GeneralReceipt {
	u := new(GeneralReceipt)

	u.LocalBlock = v.LocalBlock
	u.DirectoryBlock = v.DirectoryBlock
	u.Receipt = *(&v.Receipt).Copy()
	u.Error = v.Error

	return u
}

func (v *GeneralReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestDataEntry) Copy() *RequestDataEntry {
	u := new(RequestDataEntry)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.EntryHash = v.EntryHash

	return u
}

func (v *RequestDataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestDataEntrySet) Copy() *RequestDataEntrySet {
	u := new(RequestDataEntrySet)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.Start = v.Start
	u.Count = v.Count
	u.ExpandChains = v.ExpandChains

	return u
}

func (v *RequestDataEntrySet) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestKeyPageIndex) Copy() *RequestKeyPageIndex {
	u := new(RequestKeyPageIndex)

	if v.Url != nil {
		u.Url = (v.Url).Copy()
	}
	u.Key = encoding.BytesCopy(v.Key)

	return u
}

func (v *RequestKeyPageIndex) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestMinorBlocks) Copy() *RequestMinorBlocks {
	u := new(RequestMinorBlocks)

	if v.Account != nil {
		u.Account = (v.Account).Copy()
	}
	u.Start = v.Start
	u.Limit = v.Limit
	u.TxFetchMode = v.TxFetchMode
	u.FilterSynthAnchorsOnlyBlocks = v.FilterSynthAnchorsOnlyBlocks

	return u
}

func (v *RequestMinorBlocks) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestTxHistory) Copy() *RequestTxHistory {
	u := new(RequestTxHistory)

	if v.Account != nil {
		u.Account = (v.Account).Copy()
	}
	u.Start = v.Start
	u.Limit = v.Limit

	return u
}

func (v *RequestTxHistory) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseAccount) Copy() *ResponseAccount {
	u := new(ResponseAccount)

	if v.Account != nil {
		u.Account = (v.Account).CopyAsInterface().(protocol.Account)
	}
	u.ChainState = make([]ChainState, len(v.ChainState))
	for i, v := range v.ChainState {
		u.ChainState[i] = *(&v).Copy()
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *ResponseAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseByTxId) Copy() *ResponseByTxId {
	u := new(ResponseByTxId)

	u.TxId = v.TxId
	if v.Envelope != nil {
		u.Envelope = (v.Envelope).Copy()
	}
	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}
	u.TxSynthTxIds = encoding.BytesCopy(v.TxSynthTxIds)
	u.Height = v.Height
	u.ChainState = make([][]byte, len(v.ChainState))
	for i, v := range v.ChainState {
		u.ChainState[i] = encoding.BytesCopy(v)
	}
	u.Receipts = make([]*TxReceipt, len(v.Receipts))
	for i, v := range v.Receipts {
		if v != nil {
			u.Receipts[i] = (v).Copy()
		}
	}
	u.Signers = make([]SignatureSet, len(v.Signers))
	for i, v := range v.Signers {
		u.Signers[i] = *(&v).Copy()
	}

	return u
}

func (v *ResponseByTxId) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseChainEntry) Copy() *ResponseChainEntry {
	u := new(ResponseChainEntry)

	u.Type = v.Type
	u.Height = v.Height
	u.Entry = encoding.BytesCopy(v.Entry)
	u.State = make([][]byte, len(v.State))
	for i, v := range v.State {
		u.State[i] = encoding.BytesCopy(v)
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *ResponseChainEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseChainRange) Copy() *ResponseChainRange {
	u := new(ResponseChainRange)

	u.Type = v.Type
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make([][]byte, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *ResponseChainRange) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseDataEntry) Copy() *ResponseDataEntry {
	u := new(ResponseDataEntry)

	u.EntryHash = v.EntryHash
	u.Entry = *(&v.Entry).Copy()

	return u
}

func (v *ResponseDataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseDataEntrySet) Copy() *ResponseDataEntrySet {
	u := new(ResponseDataEntrySet)

	u.DataEntries = make([]ResponseDataEntry, len(v.DataEntries))
	for i, v := range v.DataEntries {
		u.DataEntries[i] = *(&v).Copy()
	}
	u.Total = v.Total

	return u
}

func (v *ResponseDataEntrySet) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseKeyPageIndex) Copy() *ResponseKeyPageIndex {
	u := new(ResponseKeyPageIndex)

	if v.Authority != nil {
		u.Authority = (v.Authority).Copy()
	}
	if v.Signer != nil {
		u.Signer = (v.Signer).Copy()
	}
	u.Index = v.Index

	return u
}

func (v *ResponseKeyPageIndex) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseMinorBlocks) Copy() *ResponseMinorBlocks {
	u := new(ResponseMinorBlocks)

	u.TotalBlocks = v.TotalBlocks
	u.Entries = make([]*ResponseMinorEntry, len(v.Entries))
	for i, v := range v.Entries {
		if v != nil {
			u.Entries[i] = (v).Copy()
		}
	}

	return u
}

func (v *ResponseMinorBlocks) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseMinorEntry) Copy() *ResponseMinorEntry {
	u := new(ResponseMinorEntry)

	u.BlockIndex = v.BlockIndex
	if v.BlockTime != nil {
		u.BlockTime = new(time.Time)
		*u.BlockTime = *v.BlockTime
	}
	u.TxCount = v.TxCount
	u.TxIds = make([][]byte, len(v.TxIds))
	for i, v := range v.TxIds {
		u.TxIds[i] = encoding.BytesCopy(v)
	}
	u.Transactions = make([]*ResponseByTxId, len(v.Transactions))
	for i, v := range v.Transactions {
		if v != nil {
			u.Transactions[i] = (v).Copy()
		}
	}

	return u
}

func (v *ResponseMinorEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponsePending) Copy() *ResponsePending {
	u := new(ResponsePending)

	u.Transactions = make([][32]byte, len(v.Transactions))
	for i, v := range v.Transactions {
		u.Transactions[i] = v
	}

	return u
}

func (v *ResponsePending) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseTxHistory) Copy() *ResponseTxHistory {
	u := new(ResponseTxHistory)

	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Transactions = make([]ResponseByTxId, len(v.Transactions))
	for i, v := range v.Transactions {
		u.Transactions[i] = *(&v).Copy()
	}

	return u
}

func (v *ResponseTxHistory) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureSet) Copy() *SignatureSet {
	u := new(SignatureSet)

	if v.Account != nil {
		u.Account = (v.Account).CopyAsInterface().(protocol.Account)
	}
	u.Signatures = make([]protocol.Signature, len(v.Signatures))
	for i, v := range v.Signatures {
		if v != nil {
			u.Signatures[i] = (v).CopyAsInterface().(protocol.Signature)
		}
	}

	return u
}

func (v *SignatureSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *TxReceipt) Copy() *TxReceipt {
	u := new(TxReceipt)

	u.GeneralReceipt = *v.GeneralReceipt.Copy()
	if v.Account != nil {
		u.Account = (v.Account).Copy()
	}
	u.Chain = v.Chain

	return u
}

func (v *TxReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainState) Equal(u *ChainState) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.Roots) != len(u.Roots) {
		return false
	}
	for i := range v.Roots {
		if !(bytes.Equal(v.Roots[i], u.Roots[i])) {
			return false
		}
	}

	return true
}

func (v *DirectoryQueryResult) Equal(u *DirectoryQueryResult) bool {
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(v.Entries[i] == u.Entries[i]) {
			return false
		}
	}
	if len(v.ExpandedEntries) != len(u.ExpandedEntries) {
		return false
	}
	for i := range v.ExpandedEntries {
		if !(protocol.EqualAccount(v.ExpandedEntries[i], u.ExpandedEntries[i])) {
			return false
		}
	}
	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *GeneralReceipt) Equal(u *GeneralReceipt) bool {
	if !(v.LocalBlock == u.LocalBlock) {
		return false
	}
	if !(v.DirectoryBlock == u.DirectoryBlock) {
		return false
	}
	if !((&v.Receipt).Equal(&u.Receipt)) {
		return false
	}
	if !(v.Error == u.Error) {
		return false
	}

	return true
}

func (v *RequestDataEntry) Equal(u *RequestDataEntry) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	return true
}

func (v *RequestDataEntrySet) Equal(u *RequestDataEntrySet) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if !(v.ExpandChains == u.ExpandChains) {
		return false
	}

	return true
}

func (v *RequestKeyPageIndex) Equal(u *RequestKeyPageIndex) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}

	return true
}

func (v *RequestMinorBlocks) Equal(u *RequestMinorBlocks) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Limit == u.Limit) {
		return false
	}
	if !(v.TxFetchMode == u.TxFetchMode) {
		return false
	}
	if !(v.FilterSynthAnchorsOnlyBlocks == u.FilterSynthAnchorsOnlyBlocks) {
		return false
	}

	return true
}

func (v *RequestTxHistory) Equal(u *RequestTxHistory) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Limit == u.Limit) {
		return false
	}

	return true
}

func (v *ResponseAccount) Equal(u *ResponseAccount) bool {
	if !(protocol.EqualAccount(v.Account, u.Account)) {
		return false
	}
	if len(v.ChainState) != len(u.ChainState) {
		return false
	}
	for i := range v.ChainState {
		if !((&v.ChainState[i]).Equal(&u.ChainState[i])) {
			return false
		}
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

func (v *ResponseByTxId) Equal(u *ResponseByTxId) bool {
	if !(v.TxId == u.TxId) {
		return false
	}
	switch {
	case v.Envelope == u.Envelope:
		// equal
	case v.Envelope == nil || u.Envelope == nil:
		return false
	case !((v.Envelope).Equal(u.Envelope)):
		return false
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}
	if !(bytes.Equal(v.TxSynthTxIds, u.TxSynthTxIds)) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.ChainState) != len(u.ChainState) {
		return false
	}
	for i := range v.ChainState {
		if !(bytes.Equal(v.ChainState[i], u.ChainState[i])) {
			return false
		}
	}
	if len(v.Receipts) != len(u.Receipts) {
		return false
	}
	for i := range v.Receipts {
		if !((v.Receipts[i]).Equal(u.Receipts[i])) {
			return false
		}
	}
	if len(v.Signers) != len(u.Signers) {
		return false
	}
	for i := range v.Signers {
		if !((&v.Signers[i]).Equal(&u.Signers[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseChainEntry) Equal(u *ResponseChainEntry) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

func (v *ResponseChainRange) Equal(u *ResponseChainRange) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.End == u.End) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(bytes.Equal(v.Entries[i], u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseDataEntry) Equal(u *ResponseDataEntry) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *ResponseDataEntrySet) Equal(u *ResponseDataEntrySet) bool {
	if len(v.DataEntries) != len(u.DataEntries) {
		return false
	}
	for i := range v.DataEntries {
		if !((&v.DataEntries[i]).Equal(&u.DataEntries[i])) {
			return false
		}
	}
	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *ResponseKeyPageIndex) Equal(u *ResponseKeyPageIndex) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}

	return true
}

func (v *ResponseMinorBlocks) Equal(u *ResponseMinorBlocks) bool {
	if !(v.TotalBlocks == u.TotalBlocks) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((v.Entries[i]).Equal(u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseMinorEntry) Equal(u *ResponseMinorEntry) bool {
	if !(v.BlockIndex == u.BlockIndex) {
		return false
	}
	switch {
	case v.BlockTime == u.BlockTime:
		// equal
	case v.BlockTime == nil || u.BlockTime == nil:
		return false
	case !(*v.BlockTime == *u.BlockTime):
		return false
	}
	if !(v.TxCount == u.TxCount) {
		return false
	}
	if len(v.TxIds) != len(u.TxIds) {
		return false
	}
	for i := range v.TxIds {
		if !(bytes.Equal(v.TxIds[i], u.TxIds[i])) {
			return false
		}
	}
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((v.Transactions[i]).Equal(u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *ResponsePending) Equal(u *ResponsePending) bool {
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !(v.Transactions[i] == u.Transactions[i]) {
			return false
		}
	}

	return true
}

func (v *ResponseTxHistory) Equal(u *ResponseTxHistory) bool {
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.End == u.End) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((&v.Transactions[i]).Equal(&u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *SignatureSet) Equal(u *SignatureSet) bool {
	if !(protocol.EqualAccount(v.Account, u.Account)) {
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(protocol.EqualSignature(v.Signatures[i], u.Signatures[i])) {
			return false
		}
	}

	return true
}

func (v *TxReceipt) Equal(u *TxReceipt) bool {
	if !v.GeneralReceipt.Equal(&u.GeneralReceipt) {
		return false
	}
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}

	return true
}

var fieldNames_ChainState = []string{
	1: "Name",
	2: "Type",
	3: "Height",
	4: "Roots",
}

func (v *ChainState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.Height == 0) {
		writer.WriteUint(3, v.Height)
	}
	if !(len(v.Roots) == 0) {
		for _, v := range v.Roots {
			writer.WriteBytes(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ChainState)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ChainState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Roots is missing")
	} else if len(v.Roots) == 0 {
		errs = append(errs, "field Roots is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DirectoryQueryResult = []string{
	1: "Entries",
	2: "ExpandedEntries",
	3: "Total",
}

func (v *DirectoryQueryResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteString(1, v)
		}
	}
	if !(len(v.ExpandedEntries) == 0) {
		for _, v := range v.ExpandedEntries {
			writer.WriteValue(2, v)
		}
	}
	writer.WriteUint(3, v.Total)

	_, _, err := writer.Reset(fieldNames_DirectoryQueryResult)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *DirectoryQueryResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_GeneralReceipt = []string{
	1: "LocalBlock",
	2: "DirectoryBlock",
	3: "Receipt",
	4: "Error",
}

func (v *GeneralReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.LocalBlock == 0) {
		writer.WriteUint(1, v.LocalBlock)
	}
	if !(v.DirectoryBlock == 0) {
		writer.WriteUint(2, v.DirectoryBlock)
	}
	if !((v.Receipt).Equal(new(protocol.Receipt))) {
		writer.WriteValue(3, &v.Receipt)
	}
	if !(len(v.Error) == 0) {
		writer.WriteString(4, v.Error)
	}

	_, _, err := writer.Reset(fieldNames_GeneralReceipt)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *GeneralReceipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field LocalBlock is missing")
	} else if v.LocalBlock == 0 {
		errs = append(errs, "field LocalBlock is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field DirectoryBlock is missing")
	} else if v.DirectoryBlock == 0 {
		errs = append(errs, "field DirectoryBlock is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Receipt is missing")
	} else if (v.Receipt).Equal(new(protocol.Receipt)) {
		errs = append(errs, "field Receipt is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Error is missing")
	} else if len(v.Error) == 0 {
		errs = append(errs, "field Error is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MultiResponse = []string{
	1: "Type",
	2: "Items",
	3: "Start",
	4: "Count",
	5: "Total",
}

func (v *MultiResponse) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Type) == 0) {
		writer.WriteString(1, v.Type)
	}
	if !(len(v.Items) == 0) {
		for _, v := range v.Items {
			writer.WriteString(2, v)
		}
	}
	writer.WriteUint(3, v.Start)
	writer.WriteUint(4, v.Count)
	writer.WriteUint(5, v.Total)

	_, _, err := writer.Reset(fieldNames_MultiResponse)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *MultiResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if len(v.Type) == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Items is missing")
	} else if len(v.Items) == 0 {
		errs = append(errs, "field Items is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Count is missing")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Total is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestDataEntry = []string{
	1: "Url",
	2: "EntryHash",
}

func (v *RequestDataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(2, &v.EntryHash)
	}

	_, _, err := writer.Reset(fieldNames_RequestDataEntry)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *RequestDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestDataEntrySet = []string{
	1: "Url",
	2: "Start",
	3: "Count",
	4: "ExpandChains",
}

func (v *RequestDataEntrySet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(v.Start == 0) {
		writer.WriteUint(2, v.Start)
	}
	if !(v.Count == 0) {
		writer.WriteUint(3, v.Count)
	}
	if !(!v.ExpandChains) {
		writer.WriteBool(4, v.ExpandChains)
	}

	_, _, err := writer.Reset(fieldNames_RequestDataEntrySet)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *RequestDataEntrySet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestKeyPageIndex = []string{
	1: "Url",
	2: "Key",
}

func (v *RequestKeyPageIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(len(v.Key) == 0) {
		writer.WriteBytes(2, v.Key)
	}

	_, _, err := writer.Reset(fieldNames_RequestKeyPageIndex)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *RequestKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Key is missing")
	} else if len(v.Key) == 0 {
		errs = append(errs, "field Key is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestMinorBlocks = []string{
	1: "Account",
	2: "Start",
	3: "Limit",
	4: "TxFetchMode",
	5: "FilterSynthAnchorsOnlyBlocks",
}

func (v *RequestMinorBlocks) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(v.Start == 0) {
		writer.WriteUint(2, v.Start)
	}
	if !(v.Limit == 0) {
		writer.WriteUint(3, v.Limit)
	}
	if !(v.TxFetchMode == 0) {
		writer.WriteEnum(4, v.TxFetchMode)
	}
	if !(!v.FilterSynthAnchorsOnlyBlocks) {
		writer.WriteBool(5, v.FilterSynthAnchorsOnlyBlocks)
	}

	_, _, err := writer.Reset(fieldNames_RequestMinorBlocks)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *RequestMinorBlocks) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Limit is missing")
	} else if v.Limit == 0 {
		errs = append(errs, "field Limit is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TxFetchMode is missing")
	} else if v.TxFetchMode == 0 {
		errs = append(errs, "field TxFetchMode is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field FilterSynthAnchorsOnlyBlocks is missing")
	} else if !v.FilterSynthAnchorsOnlyBlocks {
		errs = append(errs, "field FilterSynthAnchorsOnlyBlocks is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestTxHistory = []string{
	1: "Account",
	2: "Start",
	3: "Limit",
}

func (v *RequestTxHistory) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(v.Start == 0) {
		writer.WriteUint(2, v.Start)
	}
	if !(v.Limit == 0) {
		writer.WriteUint(3, v.Limit)
	}

	_, _, err := writer.Reset(fieldNames_RequestTxHistory)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *RequestTxHistory) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Limit is missing")
	} else if v.Limit == 0 {
		errs = append(errs, "field Limit is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseAccount = []string{
	1: "Account",
	2: "ChainState",
	3: "Receipt",
}

func (v *ResponseAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteValue(1, v.Account)
	}
	if !(len(v.ChainState) == 0) {
		for _, v := range v.ChainState {
			writer.WriteValue(2, &v)
		}
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(3, v.Receipt)
	}

	_, _, err := writer.Reset(fieldNames_ResponseAccount)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ChainState is missing")
	} else if len(v.ChainState) == 0 {
		errs = append(errs, "field ChainState is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseByTxId = []string{
	1: "TxId",
	2: "Envelope",
	3: "Status",
	4: "TxSynthTxIds",
	5: "Height",
	6: "ChainState",
	7: "Receipts",
	8: "Signers",
}

func (v *ResponseByTxId) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.TxId == ([32]byte{})) {
		writer.WriteHash(1, &v.TxId)
	}
	if !(v.Envelope == nil) {
		writer.WriteValue(2, v.Envelope)
	}
	if !(v.Status == nil) {
		writer.WriteValue(3, v.Status)
	}
	if !(len(v.TxSynthTxIds) == 0) {
		writer.WriteBytes(4, v.TxSynthTxIds)
	}
	writer.WriteInt(5, v.Height)
	if !(len(v.ChainState) == 0) {
		for _, v := range v.ChainState {
			writer.WriteBytes(6, v)
		}
	}
	if !(len(v.Receipts) == 0) {
		for _, v := range v.Receipts {
			writer.WriteValue(7, v)
		}
	}
	if !(len(v.Signers) == 0) {
		for _, v := range v.Signers {
			writer.WriteValue(8, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseByTxId)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseByTxId) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TxId is missing")
	} else if v.TxId == ([32]byte{}) {
		errs = append(errs, "field TxId is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Envelope is missing")
	} else if v.Envelope == nil {
		errs = append(errs, "field Envelope is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TxSynthTxIds is missing")
	} else if len(v.TxSynthTxIds) == 0 {
		errs = append(errs, "field TxSynthTxIds is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Height is missing")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field ChainState is missing")
	} else if len(v.ChainState) == 0 {
		errs = append(errs, "field ChainState is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Receipts is missing")
	} else if len(v.Receipts) == 0 {
		errs = append(errs, "field Receipts is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field Signers is missing")
	} else if len(v.Signers) == 0 {
		errs = append(errs, "field Signers is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseChainEntry = []string{
	1: "Type",
	2: "Height",
	3: "Entry",
	4: "State",
	5: "Receipt",
}

func (v *ResponseChainEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	writer.WriteInt(2, v.Height)
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(3, v.Entry)
	}
	if !(len(v.State) == 0) {
		for _, v := range v.State {
			writer.WriteBytes(4, v)
		}
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(5, v.Receipt)
	}

	_, _, err := writer.Reset(fieldNames_ResponseChainEntry)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseChainEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Height is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Entry is missing")
	} else if len(v.Entry) == 0 {
		errs = append(errs, "field Entry is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field State is missing")
	} else if len(v.State) == 0 {
		errs = append(errs, "field State is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseChainRange = []string{
	1: "Type",
	2: "Start",
	3: "End",
	4: "Total",
	5: "Entries",
}

func (v *ResponseChainRange) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	writer.WriteInt(2, v.Start)
	writer.WriteInt(3, v.End)
	writer.WriteInt(4, v.Total)
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteBytes(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseChainRange)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseChainRange) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Start is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field End is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Total is missing")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseDataEntry = []string{
	1: "EntryHash",
	2: "Entry",
}

func (v *ResponseDataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(1, &v.EntryHash)
	}
	if !((v.Entry).Equal(new(protocol.DataEntry))) {
		writer.WriteValue(2, &v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_ResponseDataEntry)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(protocol.DataEntry)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseDataEntrySet = []string{
	1: "DataEntries",
	2: "Total",
}

func (v *ResponseDataEntrySet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.DataEntries) == 0) {
		for _, v := range v.DataEntries {
			writer.WriteValue(1, &v)
		}
	}
	if !(v.Total == 0) {
		writer.WriteUint(2, v.Total)
	}

	_, _, err := writer.Reset(fieldNames_ResponseDataEntrySet)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseDataEntrySet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field DataEntries is missing")
	} else if len(v.DataEntries) == 0 {
		errs = append(errs, "field DataEntries is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseKeyPageIndex = []string{
	1: "Authority",
	2: "Signer",
	3: "Index",
}

func (v *ResponseKeyPageIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Authority == nil) {
		writer.WriteUrl(1, v.Authority)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(2, v.Signer)
	}
	writer.WriteUint(3, v.Index)

	_, _, err := writer.Reset(fieldNames_ResponseKeyPageIndex)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Index is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseMinorBlocks = []string{
	1: "TotalBlocks",
	2: "Entries",
}

func (v *ResponseMinorBlocks) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteUint(1, v.TotalBlocks)
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(2, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseMinorBlocks)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseMinorBlocks) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TotalBlocks is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseMinorEntry = []string{
	1: "BlockIndex",
	2: "BlockTime",
	3: "TxCount",
	4: "TxIds",
	5: "Transactions",
}

func (v *ResponseMinorEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.BlockIndex == 0) {
		writer.WriteUint(1, v.BlockIndex)
	}
	if !(v.BlockTime == nil) {
		writer.WriteTime(2, *v.BlockTime)
	}
	if !(v.TxCount == 0) {
		writer.WriteUint(3, v.TxCount)
	}
	if !(len(v.TxIds) == 0) {
		for _, v := range v.TxIds {
			writer.WriteBytes(4, v)
		}
	}
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseMinorEntry)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseMinorEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field BlockIndex is missing")
	} else if v.BlockIndex == 0 {
		errs = append(errs, "field BlockIndex is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field BlockTime is missing")
	} else if v.BlockTime == nil {
		errs = append(errs, "field BlockTime is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field TxCount is missing")
	} else if v.TxCount == 0 {
		errs = append(errs, "field TxCount is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TxIds is missing")
	} else if len(v.TxIds) == 0 {
		errs = append(errs, "field TxIds is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponsePending = []string{
	1: "Transactions",
}

func (v *ResponsePending) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteHash(1, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponsePending)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponsePending) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseTxHistory = []string{
	1: "Start",
	2: "End",
	3: "Total",
	4: "Transactions",
}

func (v *ResponseTxHistory) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteUint(1, v.Start)
	writer.WriteUint(2, v.End)
	writer.WriteUint(3, v.Total)
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(4, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseTxHistory)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *ResponseTxHistory) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Start is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field End is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SignatureSet = []string{
	1: "Account",
	2: "Signatures",
}

func (v *SignatureSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteValue(1, v.Account)
	}
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(2, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_SignatureSet)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *SignatureSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TxReceipt = []string{
	1: "GeneralReceipt",
	2: "Account",
	3: "Chain",
}

func (v *TxReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, &v.GeneralReceipt)
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(3, v.Chain)
	}

	_, _, err := writer.Reset(fieldNames_TxReceipt)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *TxReceipt) IsValid() error {
	var errs []string

	if err := v.GeneralReceipt.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *ChainState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x := new(protocol.ChainType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Height = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.Roots = append(v.Roots, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ChainState)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *DirectoryQueryResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DirectoryQueryResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadString(1); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}
	for {
		ok := reader.ReadValue(2, func(b []byte) error {
			x, err := protocol.UnmarshalAccount(b)
			if err == nil {
				v.ExpandedEntries = append(v.ExpandedEntries, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_DirectoryQueryResult)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *GeneralReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *GeneralReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.LocalBlock = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.DirectoryBlock = x
	}
	if x := new(protocol.Receipt); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Receipt = *x
	}
	if x, ok := reader.ReadString(4); ok {
		v.Error = x
	}

	seen, err := reader.Reset(fieldNames_GeneralReceipt)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *MultiResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MultiResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Type = x
	}
	for {
		if x, ok := reader.ReadString(2); ok {
			v.Items = append(v.Items, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Count = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_MultiResponse)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *RequestDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.EntryHash = *x
	}

	seen, err := reader.Reset(fieldNames_RequestDataEntry)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *RequestDataEntrySet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestDataEntrySet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Count = x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.ExpandChains = x
	}

	seen, err := reader.Reset(fieldNames_RequestDataEntrySet)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *RequestKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Key = x
	}

	seen, err := reader.Reset(fieldNames_RequestKeyPageIndex)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *RequestMinorBlocks) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestMinorBlocks) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Limit = x
	}
	if x := new(TxFetchMode); reader.ReadEnum(4, x) {
		v.TxFetchMode = *x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.FilterSynthAnchorsOnlyBlocks = x
	}

	seen, err := reader.Reset(fieldNames_RequestMinorBlocks)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *RequestTxHistory) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestTxHistory) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Limit = x
	}

	seen, err := reader.Reset(fieldNames_RequestTxHistory)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.Account = x
		}
		return err
	})
	for {
		if x := new(ChainState); reader.ReadValue(2, x.UnmarshalBinary) {
			v.ChainState = append(v.ChainState, *x)
		} else {
			break
		}
	}
	if x := new(GeneralReceipt); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_ResponseAccount)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseByTxId) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseByTxId) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.TxId = *x
	}
	if x := new(protocol.Envelope); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Envelope = x
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Status = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.TxSynthTxIds = x
	}
	if x, ok := reader.ReadInt(5); ok {
		v.Height = x
	}
	for {
		if x, ok := reader.ReadBytes(6); ok {
			v.ChainState = append(v.ChainState, x)
		} else {
			break
		}
	}
	for {
		if x := new(TxReceipt); reader.ReadValue(7, x.UnmarshalBinary) {
			v.Receipts = append(v.Receipts, x)
		} else {
			break
		}
	}
	for {
		if x := new(SignatureSet); reader.ReadValue(8, x.UnmarshalBinary) {
			v.Signers = append(v.Signers, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseByTxId)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseChainEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseChainEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.ChainType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadInt(2); ok {
		v.Height = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Entry = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.State = append(v.State, x)
		} else {
			break
		}
	}
	if x := new(GeneralReceipt); reader.ReadValue(5, x.UnmarshalBinary) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_ResponseChainEntry)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseChainRange) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseChainRange) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.ChainType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadInt(2); ok {
		v.Start = x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.End = x
	}
	if x, ok := reader.ReadInt(4); ok {
		v.Total = x
	}
	for {
		if x, ok := reader.ReadBytes(5); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseChainRange)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.EntryHash = *x
	}
	if x := new(protocol.DataEntry); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_ResponseDataEntry)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseDataEntrySet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseDataEntrySet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(ResponseDataEntry); reader.ReadValue(1, x.UnmarshalBinary) {
			v.DataEntries = append(v.DataEntries, *x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_ResponseDataEntrySet)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Authority = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}

	seen, err := reader.Reset(fieldNames_ResponseKeyPageIndex)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseMinorBlocks) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseMinorBlocks) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.TotalBlocks = x
	}
	for {
		if x := new(ResponseMinorEntry); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseMinorBlocks)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseMinorEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseMinorEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.BlockIndex = x
	}
	if x, ok := reader.ReadTime(2); ok {
		v.BlockTime = &x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.TxCount = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.TxIds = append(v.TxIds, x)
		} else {
			break
		}
	}
	for {
		if x := new(ResponseByTxId); reader.ReadValue(5, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseMinorEntry)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponsePending) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponsePending) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadHash(1); ok {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponsePending)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ResponseTxHistory) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseTxHistory) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.End = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Total = x
	}
	for {
		if x := new(ResponseByTxId); reader.ReadValue(4, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseTxHistory)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *SignatureSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.Account = x
		}
		return err
	})
	for {
		ok := reader.ReadValue(2, func(b []byte) error {
			x, err := protocol.UnmarshalSignature(b)
			if err == nil {
				v.Signatures = append(v.Signatures, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SignatureSet)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *TxReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TxReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.GeneralReceipt.UnmarshalBinary)
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Chain = x
	}

	seen, err := reader.Reset(fieldNames_TxReceipt)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *ChainState) MarshalJSON() ([]byte, error) {
	u := struct {
		Name   string                     `json:"name,omitempty"`
		Type   protocol.ChainType         `json:"type,omitempty"`
		Height uint64                     `json:"height,omitempty"`
		Count  uint64                     `json:"count,omitempty"`
		Roots  encoding.JsonList[*string] `json:"roots,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make(encoding.JsonList[*string], len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *DirectoryQueryResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Entries         encoding.JsonList[string]                        `json:"entries,omitempty"`
		ExpandedEntries encoding.JsonUnmarshalListWith[protocol.Account] `json:"expandedEntries,omitempty"`
		Total           uint64                                           `json:"total"`
	}{}
	u.Entries = v.Entries
	u.ExpandedEntries = encoding.JsonUnmarshalListWith[protocol.Account]{Value: v.ExpandedEntries, Func: protocol.UnmarshalAccountJSON}
	u.Total = v.Total
	return json.Marshal(&u)
}

func (v *MultiResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  string                    `json:"type,omitempty"`
		Items encoding.JsonList[string] `json:"items,omitempty"`
		Start uint64                    `json:"start"`
		Count uint64                    `json:"count"`
		Total uint64                    `json:"total"`
	}{}
	u.Type = v.Type
	u.Items = v.Items
	u.Start = v.Start
	u.Count = v.Count
	u.Total = v.Total
	return json.Marshal(&u)
}

func (v *RequestDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Url       *url.URL `json:"url,omitempty"`
		EntryHash string   `json:"entryHash,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}

func (v *RequestKeyPageIndex) MarshalJSON() ([]byte, error) {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.Url
	u.Key = encoding.BytesToJSON(v.Key)
	return json.Marshal(&u)
}

func (v *ResponseAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Account    encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		ChainState encoding.JsonList[ChainState]                `json:"chainState,omitempty"`
		Receipt    *GeneralReceipt                              `json:"receipt,omitempty"`
	}{}
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.ChainState = v.ChainState
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *ResponseByTxId) MarshalJSON() ([]byte, error) {
	u := struct {
		TxId         string                          `json:"txId,omitempty"`
		Envelope     *protocol.Envelope              `json:"envelope,omitempty"`
		Status       *protocol.TransactionStatus     `json:"status,omitempty"`
		TxSynthTxIds *string                         `json:"txSynthTxIds,omitempty"`
		Height       int64                           `json:"height"`
		ChainState   encoding.JsonList[*string]      `json:"chainState,omitempty"`
		Receipts     encoding.JsonList[*TxReceipt]   `json:"receipts,omitempty"`
		Signers      encoding.JsonList[SignatureSet] `json:"signers,omitempty"`
	}{}
	u.TxId = encoding.ChainToJSON(v.TxId)
	u.Envelope = v.Envelope
	u.Status = v.Status
	u.TxSynthTxIds = encoding.BytesToJSON(v.TxSynthTxIds)
	u.Height = v.Height
	u.ChainState = make(encoding.JsonList[*string], len(v.ChainState))
	for i, x := range v.ChainState {
		u.ChainState[i] = encoding.BytesToJSON(x)
	}
	u.Receipts = v.Receipts
	u.Signers = v.Signers
	return json.Marshal(&u)
}

func (v *ResponseChainEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    protocol.ChainType         `json:"type,omitempty"`
		Height  int64                      `json:"height"`
		Entry   *string                    `json:"entry,omitempty"`
		State   encoding.JsonList[*string] `json:"state,omitempty"`
		Receipt *GeneralReceipt            `json:"receipt,omitempty"`
	}{}
	u.Type = v.Type
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *ResponseChainRange) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    protocol.ChainType         `json:"type,omitempty"`
		Start   int64                      `json:"start"`
		End     int64                      `json:"end"`
		Total   int64                      `json:"total"`
		Entries encoding.JsonList[*string] `json:"entries,omitempty"`
	}{}
	u.Type = v.Type
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make(encoding.JsonList[*string], len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ResponseDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		EntryHash string             `json:"entryHash,omitempty"`
		Entry     protocol.DataEntry `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *ResponseDataEntrySet) MarshalJSON() ([]byte, error) {
	u := struct {
		DataEntries encoding.JsonList[ResponseDataEntry] `json:"dataEntries,omitempty"`
		Total       uint64                               `json:"total,omitempty"`
	}{}
	u.DataEntries = v.DataEntries
	u.Total = v.Total
	return json.Marshal(&u)
}

func (v *ResponseKeyPageIndex) MarshalJSON() ([]byte, error) {
	u := struct {
		Authority *url.URL `json:"authority,omitempty"`
		KeyBook   *url.URL `json:"keyBook,omitempty"`
		Signer    *url.URL `json:"signer,omitempty"`
		KeyPage   *url.URL `json:"keyPage,omitempty"`
		Index     uint64   `json:"index"`
	}{}
	u.Authority = v.Authority
	u.KeyBook = v.Authority
	u.Signer = v.Signer
	u.KeyPage = v.Signer
	u.Index = v.Index
	return json.Marshal(&u)
}

func (v *ResponseMinorBlocks) MarshalJSON() ([]byte, error) {
	u := struct {
		TotalBlocks uint64                                 `json:"totalBlocks"`
		Entries     encoding.JsonList[*ResponseMinorEntry] `json:"entries,omitempty"`
	}{}
	u.TotalBlocks = v.TotalBlocks
	u.Entries = v.Entries
	return json.Marshal(&u)
}

func (v *ResponseMinorEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		BlockIndex   uint64                             `json:"blockIndex,omitempty"`
		BlockTime    *time.Time                         `json:"blockTime,omitempty"`
		TxCount      uint64                             `json:"txCount,omitempty"`
		TxIds        encoding.JsonList[*string]         `json:"txIds,omitempty"`
		Transactions encoding.JsonList[*ResponseByTxId] `json:"transactions,omitempty"`
	}{}
	u.BlockIndex = v.BlockIndex
	u.BlockTime = v.BlockTime
	u.TxCount = v.TxCount
	u.TxIds = make(encoding.JsonList[*string], len(v.TxIds))
	for i, x := range v.TxIds {
		u.TxIds[i] = encoding.BytesToJSON(x)
	}
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *ResponsePending) MarshalJSON() ([]byte, error) {
	u := struct {
		Transactions encoding.JsonList[string] `json:"transactions,omitempty"`
	}{}
	u.Transactions = make(encoding.JsonList[string], len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ResponseTxHistory) MarshalJSON() ([]byte, error) {
	u := struct {
		Start        uint64                            `json:"start"`
		End          uint64                            `json:"end"`
		Total        uint64                            `json:"total"`
		Transactions encoding.JsonList[ResponseByTxId] `json:"transactions,omitempty"`
	}{}
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *SignatureSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Account    encoding.JsonUnmarshalWith[protocol.Account]       `json:"account,omitempty"`
		Signatures encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
	}{}
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Signatures = encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	return json.Marshal(&u)
}

func (v *TxReceipt) MarshalJSON() ([]byte, error) {
	u := struct {
		LocalBlock     uint64           `json:"localBlock,omitempty"`
		DirectoryBlock uint64           `json:"directoryBlock,omitempty"`
		Receipt        protocol.Receipt `json:"receipt,omitempty"`
		Error          string           `json:"error,omitempty"`
		Account        *url.URL         `json:"account,omitempty"`
		Chain          string           `json:"chain,omitempty"`
	}{}
	u.LocalBlock = v.GeneralReceipt.LocalBlock
	u.DirectoryBlock = v.GeneralReceipt.DirectoryBlock
	u.Receipt = v.GeneralReceipt.Receipt
	u.Error = v.GeneralReceipt.Error
	u.Account = v.Account
	u.Chain = v.Chain
	return json.Marshal(&u)
}

func (v *ChainState) UnmarshalJSON(data []byte) error {
	u := struct {
		Name   string                     `json:"name,omitempty"`
		Type   protocol.ChainType         `json:"type,omitempty"`
		Height uint64                     `json:"height,omitempty"`
		Count  uint64                     `json:"count,omitempty"`
		Roots  encoding.JsonList[*string] `json:"roots,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make(encoding.JsonList[*string], len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Name = u.Name
	v.Type = u.Type
	if u.Height != 0 {
		v.Height = u.Height
	} else {
		v.Height = u.Count
	}
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots: %w", err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}

func (v *DirectoryQueryResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Entries         encoding.JsonList[string]                        `json:"entries,omitempty"`
		ExpandedEntries encoding.JsonUnmarshalListWith[protocol.Account] `json:"expandedEntries,omitempty"`
		Total           uint64                                           `json:"total"`
	}{}
	u.Entries = v.Entries
	u.ExpandedEntries = encoding.JsonUnmarshalListWith[protocol.Account]{Value: v.ExpandedEntries, Func: protocol.UnmarshalAccountJSON}
	u.Total = v.Total
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Entries = u.Entries
	v.ExpandedEntries = make([]protocol.Account, len(u.ExpandedEntries.Value))
	for i, x := range u.ExpandedEntries.Value {
		v.ExpandedEntries[i] = x
	}
	v.Total = u.Total
	return nil
}

func (v *MultiResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  string                    `json:"type,omitempty"`
		Items encoding.JsonList[string] `json:"items,omitempty"`
		Start uint64                    `json:"start"`
		Count uint64                    `json:"count"`
		Total uint64                    `json:"total"`
	}{}
	u.Type = v.Type
	u.Items = v.Items
	u.Start = v.Start
	u.Count = v.Count
	u.Total = v.Total
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.Items = u.Items
	v.Start = u.Start
	v.Count = u.Count
	v.Total = u.Total
	return nil
}

func (v *RequestDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Url       *url.URL `json:"url,omitempty"`
		EntryHash string   `json:"entryHash,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}

func (v *RequestKeyPageIndex) UnmarshalJSON(data []byte) error {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.Url
	u.Key = encoding.BytesToJSON(v.Key)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	return nil
}

func (v *ResponseAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Account    encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		ChainState encoding.JsonList[ChainState]                `json:"chainState,omitempty"`
		Receipt    *GeneralReceipt                              `json:"receipt,omitempty"`
	}{}
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.ChainState = v.ChainState
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account.Value

	v.ChainState = u.ChainState
	v.Receipt = u.Receipt
	return nil
}

func (v *ResponseByTxId) UnmarshalJSON(data []byte) error {
	u := struct {
		TxId         string                          `json:"txId,omitempty"`
		Envelope     *protocol.Envelope              `json:"envelope,omitempty"`
		Status       *protocol.TransactionStatus     `json:"status,omitempty"`
		TxSynthTxIds *string                         `json:"txSynthTxIds,omitempty"`
		Height       int64                           `json:"height"`
		ChainState   encoding.JsonList[*string]      `json:"chainState,omitempty"`
		Receipts     encoding.JsonList[*TxReceipt]   `json:"receipts,omitempty"`
		Signers      encoding.JsonList[SignatureSet] `json:"signers,omitempty"`
	}{}
	u.TxId = encoding.ChainToJSON(v.TxId)
	u.Envelope = v.Envelope
	u.Status = v.Status
	u.TxSynthTxIds = encoding.BytesToJSON(v.TxSynthTxIds)
	u.Height = v.Height
	u.ChainState = make(encoding.JsonList[*string], len(v.ChainState))
	for i, x := range v.ChainState {
		u.ChainState[i] = encoding.BytesToJSON(x)
	}
	u.Receipts = v.Receipts
	u.Signers = v.Signers
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.TxId); err != nil {
		return fmt.Errorf("error decoding TxId: %w", err)
	} else {
		v.TxId = x
	}
	v.Envelope = u.Envelope
	v.Status = u.Status
	if x, err := encoding.BytesFromJSON(u.TxSynthTxIds); err != nil {
		return fmt.Errorf("error decoding TxSynthTxIds: %w", err)
	} else {
		v.TxSynthTxIds = x
	}
	v.Height = u.Height
	v.ChainState = make([][]byte, len(u.ChainState))
	for i, x := range u.ChainState {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding ChainState: %w", err)
		} else {
			v.ChainState[i] = x
		}
	}
	v.Receipts = u.Receipts
	v.Signers = u.Signers
	return nil
}

func (v *ResponseChainEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    protocol.ChainType         `json:"type,omitempty"`
		Height  int64                      `json:"height"`
		Entry   *string                    `json:"entry,omitempty"`
		State   encoding.JsonList[*string] `json:"state,omitempty"`
		Receipt *GeneralReceipt            `json:"receipt,omitempty"`
	}{}
	u.Type = v.Type
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.Height = u.Height
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	v.Receipt = u.Receipt
	return nil
}

func (v *ResponseChainRange) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    protocol.ChainType         `json:"type,omitempty"`
		Start   int64                      `json:"start"`
		End     int64                      `json:"end"`
		Total   int64                      `json:"total"`
		Entries encoding.JsonList[*string] `json:"entries,omitempty"`
	}{}
	u.Type = v.Type
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make(encoding.JsonList[*string], len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.Start = u.Start
	v.End = u.End
	v.Total = u.Total
	v.Entries = make([][]byte, len(u.Entries))
	for i, x := range u.Entries {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Entries: %w", err)
		} else {
			v.Entries[i] = x
		}
	}
	return nil
}

func (v *ResponseDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		EntryHash string             `json:"entryHash,omitempty"`
		Entry     protocol.DataEntry `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	v.Entry = u.Entry
	return nil
}

func (v *ResponseDataEntrySet) UnmarshalJSON(data []byte) error {
	u := struct {
		DataEntries encoding.JsonList[ResponseDataEntry] `json:"dataEntries,omitempty"`
		Total       uint64                               `json:"total,omitempty"`
	}{}
	u.DataEntries = v.DataEntries
	u.Total = v.Total
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.DataEntries = u.DataEntries
	v.Total = u.Total
	return nil
}

func (v *ResponseKeyPageIndex) UnmarshalJSON(data []byte) error {
	u := struct {
		Authority *url.URL `json:"authority,omitempty"`
		KeyBook   *url.URL `json:"keyBook,omitempty"`
		Signer    *url.URL `json:"signer,omitempty"`
		KeyPage   *url.URL `json:"keyPage,omitempty"`
		Index     uint64   `json:"index"`
	}{}
	u.Authority = v.Authority
	u.KeyBook = v.Authority
	u.Signer = v.Signer
	u.KeyPage = v.Signer
	u.Index = v.Index
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Authority != nil {
		v.Authority = u.Authority
	} else {
		v.Authority = u.KeyBook
	}
	if u.Signer != nil {
		v.Signer = u.Signer
	} else {
		v.Signer = u.KeyPage
	}
	v.Index = u.Index
	return nil
}

func (v *ResponseMinorBlocks) UnmarshalJSON(data []byte) error {
	u := struct {
		TotalBlocks uint64                                 `json:"totalBlocks"`
		Entries     encoding.JsonList[*ResponseMinorEntry] `json:"entries,omitempty"`
	}{}
	u.TotalBlocks = v.TotalBlocks
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.TotalBlocks = u.TotalBlocks
	v.Entries = u.Entries
	return nil
}

func (v *ResponseMinorEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		BlockIndex   uint64                             `json:"blockIndex,omitempty"`
		BlockTime    *time.Time                         `json:"blockTime,omitempty"`
		TxCount      uint64                             `json:"txCount,omitempty"`
		TxIds        encoding.JsonList[*string]         `json:"txIds,omitempty"`
		Transactions encoding.JsonList[*ResponseByTxId] `json:"transactions,omitempty"`
	}{}
	u.BlockIndex = v.BlockIndex
	u.BlockTime = v.BlockTime
	u.TxCount = v.TxCount
	u.TxIds = make(encoding.JsonList[*string], len(v.TxIds))
	for i, x := range v.TxIds {
		u.TxIds[i] = encoding.BytesToJSON(x)
	}
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.BlockIndex = u.BlockIndex
	v.BlockTime = u.BlockTime
	v.TxCount = u.TxCount
	v.TxIds = make([][]byte, len(u.TxIds))
	for i, x := range u.TxIds {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding TxIds: %w", err)
		} else {
			v.TxIds[i] = x
		}
	}
	v.Transactions = u.Transactions
	return nil
}

func (v *ResponsePending) UnmarshalJSON(data []byte) error {
	u := struct {
		Transactions encoding.JsonList[string] `json:"transactions,omitempty"`
	}{}
	u.Transactions = make(encoding.JsonList[string], len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transactions = make([][32]byte, len(u.Transactions))
	for i, x := range u.Transactions {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Transactions: %w", err)
		} else {
			v.Transactions[i] = x
		}
	}
	return nil
}

func (v *ResponseTxHistory) UnmarshalJSON(data []byte) error {
	u := struct {
		Start        uint64                            `json:"start"`
		End          uint64                            `json:"end"`
		Total        uint64                            `json:"total"`
		Transactions encoding.JsonList[ResponseByTxId] `json:"transactions,omitempty"`
	}{}
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Start = u.Start
	v.End = u.End
	v.Total = u.Total
	v.Transactions = u.Transactions
	return nil
}

func (v *SignatureSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Account    encoding.JsonUnmarshalWith[protocol.Account]       `json:"account,omitempty"`
		Signatures encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
	}{}
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Signatures = encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account.Value

	v.Signatures = make([]protocol.Signature, len(u.Signatures.Value))
	for i, x := range u.Signatures.Value {
		v.Signatures[i] = x
	}
	return nil
}

func (v *TxReceipt) UnmarshalJSON(data []byte) error {
	u := struct {
		LocalBlock     uint64           `json:"localBlock,omitempty"`
		DirectoryBlock uint64           `json:"directoryBlock,omitempty"`
		Receipt        protocol.Receipt `json:"receipt,omitempty"`
		Error          string           `json:"error,omitempty"`
		Account        *url.URL         `json:"account,omitempty"`
		Chain          string           `json:"chain,omitempty"`
	}{}
	u.LocalBlock = v.GeneralReceipt.LocalBlock
	u.DirectoryBlock = v.GeneralReceipt.DirectoryBlock
	u.Receipt = v.GeneralReceipt.Receipt
	u.Error = v.GeneralReceipt.Error
	u.Account = v.Account
	u.Chain = v.Chain
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.GeneralReceipt.LocalBlock = u.LocalBlock
	v.GeneralReceipt.DirectoryBlock = u.DirectoryBlock
	v.GeneralReceipt.Receipt = u.Receipt
	v.GeneralReceipt.Error = u.Error
	v.Account = u.Account
	v.Chain = u.Chain
	return nil
}
