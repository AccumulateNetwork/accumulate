package query

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type ChainState struct {
	fieldsSet []bool
	Name      string             `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Height    uint64             `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots     [][]byte           `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
}

type DirectoryQueryResult struct {
	fieldsSet       []bool
	Entries         []string           `json:"entries,omitempty" form:"entries" query:"entries"`
	ExpandedEntries []protocol.Account `json:"expandedEntries,omitempty" form:"expandedEntries" query:"expandedEntries"`
	Total           uint64             `json:"total" form:"total" query:"total" validate:"required"`
}

type MultiResponse struct {
	fieldsSet []bool
	Type      string   `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Items     []string `json:"items,omitempty" form:"items" query:"items" validate:"required"`
	Start     uint64   `json:"start" form:"start" query:"start" validate:"required"`
	Count     uint64   `json:"count" form:"count" query:"count" validate:"required"`
	Total     uint64   `json:"total" form:"total" query:"total" validate:"required"`
}

type RequestDataEntry struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	EntryHash [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash"`
}

type RequestDataEntrySet struct {
	fieldsSet    []bool
	Url          *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Start        uint64   `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Count        uint64   `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	ExpandChains bool     `json:"expandChains,omitempty" form:"expandChains" query:"expandChains"`
}

type RequestKeyPageIndex struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Key       []byte   `json:"key,omitempty" form:"key" query:"key" validate:"required"`
}

type RequestTxHistory struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Start     uint64   `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Limit     uint64   `json:"limit,omitempty" form:"limit" query:"limit" validate:"required"`
}

type ResponseAccount struct {
	fieldsSet  []bool
	Account    protocol.Account `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	ChainState []ChainState     `json:"chainState,omitempty" form:"chainState" query:"chainState" validate:"required"`
}

type ResponseByTxId struct {
	fieldsSet          []bool
	TxId               [32]byte                    `json:"txId,omitempty" form:"txId" query:"txId" validate:"required"`
	Envelope           *protocol.Envelope          `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	Status             *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	TxSynthTxIds       []byte                      `json:"txSynthTxIds,omitempty" form:"txSynthTxIds" query:"txSynthTxIds" validate:"required"`
	Height             int64                       `json:"height" form:"height" query:"height" validate:"required"`
	ChainState         [][]byte                    `json:"chainState,omitempty" form:"chainState" query:"chainState" validate:"required"`
	Receipts           []*TxReceipt                `json:"receipts,omitempty" form:"receipts" query:"receipts" validate:"required"`
	SignatureThreshold uint64                      `json:"signatureThreshold,omitempty" form:"signatureThreshold" query:"signatureThreshold" validate:"required"`
	Invalidated        bool                        `json:"invalidated,omitempty" form:"invalidated" query:"invalidated" validate:"required"`
}

type ResponseChainEntry struct {
	fieldsSet []bool
	Height    int64    `json:"height" form:"height" query:"height" validate:"required"`
	Entry     []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	State     [][]byte `json:"state,omitempty" form:"state" query:"state" validate:"required"`
}

type ResponseChainRange struct {
	fieldsSet []bool
	Start     int64    `json:"start" form:"start" query:"start" validate:"required"`
	End       int64    `json:"end" form:"end" query:"end" validate:"required"`
	Total     int64    `json:"total" form:"total" query:"total" validate:"required"`
	Entries   [][]byte `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
}

type ResponseDataEntry struct {
	fieldsSet []bool
	EntryHash [32]byte           `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	Entry     protocol.DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type ResponseDataEntrySet struct {
	fieldsSet   []bool
	DataEntries []ResponseDataEntry `json:"dataEntries,omitempty" form:"dataEntries" query:"dataEntries" validate:"required"`
	Total       uint64              `json:"total,omitempty" form:"total" query:"total" validate:"required"`
}

type ResponseKeyPageIndex struct {
	fieldsSet []bool
	KeyBook   *url.URL `json:"keyBook,omitempty" form:"keyBook" query:"keyBook" validate:"required"`
	KeyPage   *url.URL `json:"keyPage,omitempty" form:"keyPage" query:"keyPage" validate:"required"`
	Index     uint64   `json:"index" form:"index" query:"index" validate:"required"`
}

type ResponsePending struct {
	fieldsSet    []bool
	Transactions [][32]byte `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type ResponseTxHistory struct {
	fieldsSet    []bool
	Start        uint64           `json:"start" form:"start" query:"start" validate:"required"`
	End          uint64           `json:"end" form:"end" query:"end" validate:"required"`
	Total        uint64           `json:"total" form:"total" query:"total" validate:"required"`
	Transactions []ResponseByTxId `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type TxReceipt struct {
	fieldsSet []bool
	Account   *url.URL         `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Chain     string           `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	Receipt   protocol.Receipt `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	Error     string           `json:"error,omitempty" form:"error" query:"error" validate:"required"`
}

func (v *ChainState) Equal(u *ChainState) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.Roots) != len(u.Roots) {
		return false
	}
	for i := range v.Roots {
		if !(bytes.Equal(v.Roots[i], u.Roots[i])) {
			return false
		}
	}

	return true
}

func (v *DirectoryQueryResult) Equal(u *DirectoryQueryResult) bool {
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(v.Entries[i] == u.Entries[i]) {
			return false
		}
	}
	if len(v.ExpandedEntries) != len(u.ExpandedEntries) {
		return false
	}
	for i := range v.ExpandedEntries {
		if !(v.ExpandedEntries[i] == u.ExpandedEntries[i]) {
			return false
		}
	}
	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *RequestDataEntry) Equal(u *RequestDataEntry) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	return true
}

func (v *RequestDataEntrySet) Equal(u *RequestDataEntrySet) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if !(v.ExpandChains == u.ExpandChains) {
		return false
	}

	return true
}

func (v *RequestKeyPageIndex) Equal(u *RequestKeyPageIndex) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}

	return true
}

func (v *RequestTxHistory) Equal(u *RequestTxHistory) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Limit == u.Limit) {
		return false
	}

	return true
}

func (v *ResponseAccount) Equal(u *ResponseAccount) bool {
	if !(v.Account == u.Account) {
		return false
	}
	if len(v.ChainState) != len(u.ChainState) {
		return false
	}
	for i := range v.ChainState {
		if !((&v.ChainState[i]).Equal(&u.ChainState[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseByTxId) Equal(u *ResponseByTxId) bool {
	if !(v.TxId == u.TxId) {
		return false
	}
	switch {
	case v.Envelope == u.Envelope:
		// equal
	case v.Envelope == nil || u.Envelope == nil:
		return false
	case !((v.Envelope).Equal(u.Envelope)):
		return false
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}
	if !(bytes.Equal(v.TxSynthTxIds, u.TxSynthTxIds)) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.ChainState) != len(u.ChainState) {
		return false
	}
	for i := range v.ChainState {
		if !(bytes.Equal(v.ChainState[i], u.ChainState[i])) {
			return false
		}
	}
	if len(v.Receipts) != len(u.Receipts) {
		return false
	}
	for i := range v.Receipts {
		if !((v.Receipts[i]).Equal(u.Receipts[i])) {
			return false
		}
	}
	if !(v.SignatureThreshold == u.SignatureThreshold) {
		return false
	}
	if !(v.Invalidated == u.Invalidated) {
		return false
	}

	return true
}

func (v *ResponseChainEntry) Equal(u *ResponseChainEntry) bool {
	if !(v.Height == u.Height) {
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseChainRange) Equal(u *ResponseChainRange) bool {
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.End == u.End) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(bytes.Equal(v.Entries[i], u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseDataEntry) Equal(u *ResponseDataEntry) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

func (v *ResponseDataEntrySet) Equal(u *ResponseDataEntrySet) bool {
	if len(v.DataEntries) != len(u.DataEntries) {
		return false
	}
	for i := range v.DataEntries {
		if !((&v.DataEntries[i]).Equal(&u.DataEntries[i])) {
			return false
		}
	}
	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *ResponseKeyPageIndex) Equal(u *ResponseKeyPageIndex) bool {
	switch {
	case v.KeyBook == u.KeyBook:
		// equal
	case v.KeyBook == nil || u.KeyBook == nil:
		return false
	case !((v.KeyBook).Equal(u.KeyBook)):
		return false
	}
	switch {
	case v.KeyPage == u.KeyPage:
		// equal
	case v.KeyPage == nil || u.KeyPage == nil:
		return false
	case !((v.KeyPage).Equal(u.KeyPage)):
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}

	return true
}

func (v *ResponsePending) Equal(u *ResponsePending) bool {
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !(v.Transactions[i] == u.Transactions[i]) {
			return false
		}
	}

	return true
}

func (v *ResponseTxHistory) Equal(u *ResponseTxHistory) bool {
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.End == u.End) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((&v.Transactions[i]).Equal(&u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *TxReceipt) Equal(u *TxReceipt) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}
	if !((&v.Receipt).Equal(&u.Receipt)) {
		return false
	}
	if !(v.Error == u.Error) {
		return false
	}

	return true
}

var fieldNames_ChainState = []string{
	1: "Name",
	2: "Type",
	3: "Height",
	4: "Roots",
}

func (v *ChainState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.Height == 0) {
		writer.WriteUint(3, v.Height)
	}
	if !(len(v.Roots) == 0) {
		for _, v := range v.Roots {
			writer.WriteBytes(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ChainState)
	return buffer.Bytes(), err
}

func (v *ChainState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Roots is missing")
	} else if len(v.Roots) == 0 {
		errs = append(errs, "field Roots is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DirectoryQueryResult = []string{
	1: "Entries",
	2: "ExpandedEntries",
	3: "Total",
}

func (v *DirectoryQueryResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteString(1, v)
		}
	}
	if !(len(v.ExpandedEntries) == 0) {
		for _, v := range v.ExpandedEntries {
			writer.WriteValue(2, v)
		}
	}
	writer.WriteUint(3, v.Total)

	_, _, err := writer.Reset(fieldNames_DirectoryQueryResult)
	return buffer.Bytes(), err
}

func (v *DirectoryQueryResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MultiResponse = []string{
	1: "Type",
	2: "Items",
	3: "Start",
	4: "Count",
	5: "Total",
}

func (v *MultiResponse) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Type) == 0) {
		writer.WriteString(1, v.Type)
	}
	if !(len(v.Items) == 0) {
		for _, v := range v.Items {
			writer.WriteString(2, v)
		}
	}
	writer.WriteUint(3, v.Start)
	writer.WriteUint(4, v.Count)
	writer.WriteUint(5, v.Total)

	_, _, err := writer.Reset(fieldNames_MultiResponse)
	return buffer.Bytes(), err
}

func (v *MultiResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if len(v.Type) == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Items is missing")
	} else if len(v.Items) == 0 {
		errs = append(errs, "field Items is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestDataEntry = []string{
	1: "Url",
	2: "EntryHash",
}

func (v *RequestDataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(2, &v.EntryHash)
	}

	_, _, err := writer.Reset(fieldNames_RequestDataEntry)
	return buffer.Bytes(), err
}

func (v *RequestDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestDataEntrySet = []string{
	1: "Url",
	2: "Start",
	3: "Count",
	4: "ExpandChains",
}

func (v *RequestDataEntrySet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(v.Start == 0) {
		writer.WriteUint(2, v.Start)
	}
	if !(v.Count == 0) {
		writer.WriteUint(3, v.Count)
	}
	if !(!v.ExpandChains) {
		writer.WriteBool(4, v.ExpandChains)
	}

	_, _, err := writer.Reset(fieldNames_RequestDataEntrySet)
	return buffer.Bytes(), err
}

func (v *RequestDataEntrySet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestKeyPageIndex = []string{
	1: "Url",
	2: "Key",
}

func (v *RequestKeyPageIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(len(v.Key) == 0) {
		writer.WriteBytes(2, v.Key)
	}

	_, _, err := writer.Reset(fieldNames_RequestKeyPageIndex)
	return buffer.Bytes(), err
}

func (v *RequestKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Key is missing")
	} else if len(v.Key) == 0 {
		errs = append(errs, "field Key is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestTxHistory = []string{
	1: "Account",
	2: "Start",
	3: "Limit",
}

func (v *RequestTxHistory) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(v.Start == 0) {
		writer.WriteUint(2, v.Start)
	}
	if !(v.Limit == 0) {
		writer.WriteUint(3, v.Limit)
	}

	_, _, err := writer.Reset(fieldNames_RequestTxHistory)
	return buffer.Bytes(), err
}

func (v *RequestTxHistory) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Limit is missing")
	} else if v.Limit == 0 {
		errs = append(errs, "field Limit is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseAccount = []string{
	1: "Account",
	2: "ChainState",
}

func (v *ResponseAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == (nil)) {
		writer.WriteValue(1, v.Account)
	}
	if !(len(v.ChainState) == 0) {
		for _, v := range v.ChainState {
			writer.WriteValue(2, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseAccount)
	return buffer.Bytes(), err
}

func (v *ResponseAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == (nil) {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ChainState is missing")
	} else if len(v.ChainState) == 0 {
		errs = append(errs, "field ChainState is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseByTxId = []string{
	1: "TxId",
	2: "Envelope",
	3: "Status",
	4: "TxSynthTxIds",
	5: "Height",
	6: "ChainState",
	7: "Receipts",
	8: "SignatureThreshold",
	9: "Invalidated",
}

func (v *ResponseByTxId) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.TxId == ([32]byte{})) {
		writer.WriteHash(1, &v.TxId)
	}
	if !(v.Envelope == nil) {
		writer.WriteValue(2, v.Envelope)
	}
	if !(v.Status == nil) {
		writer.WriteValue(3, v.Status)
	}
	if !(len(v.TxSynthTxIds) == 0) {
		writer.WriteBytes(4, v.TxSynthTxIds)
	}
	writer.WriteInt(5, v.Height)
	if !(len(v.ChainState) == 0) {
		for _, v := range v.ChainState {
			writer.WriteBytes(6, v)
		}
	}
	if !(len(v.Receipts) == 0) {
		for _, v := range v.Receipts {
			writer.WriteValue(7, v)
		}
	}
	if !(v.SignatureThreshold == 0) {
		writer.WriteUint(8, v.SignatureThreshold)
	}
	if !(!v.Invalidated) {
		writer.WriteBool(9, v.Invalidated)
	}

	_, _, err := writer.Reset(fieldNames_ResponseByTxId)
	return buffer.Bytes(), err
}

func (v *ResponseByTxId) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TxId is missing")
	} else if v.TxId == ([32]byte{}) {
		errs = append(errs, "field TxId is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Envelope is missing")
	} else if v.Envelope == nil {
		errs = append(errs, "field Envelope is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TxSynthTxIds is missing")
	} else if len(v.TxSynthTxIds) == 0 {
		errs = append(errs, "field TxSynthTxIds is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field ChainState is missing")
	} else if len(v.ChainState) == 0 {
		errs = append(errs, "field ChainState is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Receipts is missing")
	} else if len(v.Receipts) == 0 {
		errs = append(errs, "field Receipts is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field SignatureThreshold is missing")
	} else if v.SignatureThreshold == 0 {
		errs = append(errs, "field SignatureThreshold is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field Invalidated is missing")
	} else if !v.Invalidated {
		errs = append(errs, "field Invalidated is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseChainEntry = []string{
	1: "Height",
	2: "Entry",
	3: "State",
}

func (v *ResponseChainEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteInt(1, v.Height)
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(2, v.Entry)
	}
	if !(len(v.State) == 0) {
		for _, v := range v.State {
			writer.WriteBytes(3, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseChainEntry)
	return buffer.Bytes(), err
}

func (v *ResponseChainEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if len(v.Entry) == 0 {
		errs = append(errs, "field Entry is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field State is missing")
	} else if len(v.State) == 0 {
		errs = append(errs, "field State is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseChainRange = []string{
	1: "Start",
	2: "End",
	3: "Total",
	4: "Entries",
}

func (v *ResponseChainRange) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteInt(1, v.Start)
	writer.WriteInt(2, v.End)
	writer.WriteInt(3, v.Total)
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteBytes(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseChainRange)
	return buffer.Bytes(), err
}

func (v *ResponseChainRange) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field End is missing")
	} else if v.End == 0 {
		errs = append(errs, "field End is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseDataEntry = []string{
	1: "EntryHash",
	2: "Entry",
}

func (v *ResponseDataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(1, &v.EntryHash)
	}
	if !((v.Entry).Equal(new(protocol.DataEntry))) {
		writer.WriteValue(2, &v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_ResponseDataEntry)
	return buffer.Bytes(), err
}

func (v *ResponseDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(protocol.DataEntry)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseDataEntrySet = []string{
	1: "DataEntries",
	2: "Total",
}

func (v *ResponseDataEntrySet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.DataEntries) == 0) {
		for _, v := range v.DataEntries {
			writer.WriteValue(1, &v)
		}
	}
	if !(v.Total == 0) {
		writer.WriteUint(2, v.Total)
	}

	_, _, err := writer.Reset(fieldNames_ResponseDataEntrySet)
	return buffer.Bytes(), err
}

func (v *ResponseDataEntrySet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field DataEntries is missing")
	} else if len(v.DataEntries) == 0 {
		errs = append(errs, "field DataEntries is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseKeyPageIndex = []string{
	1: "KeyBook",
	2: "KeyPage",
	3: "Index",
}

func (v *ResponseKeyPageIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.KeyBook == nil) {
		writer.WriteUrl(1, v.KeyBook)
	}
	if !(v.KeyPage == nil) {
		writer.WriteUrl(2, v.KeyPage)
	}
	writer.WriteUint(3, v.Index)

	_, _, err := writer.Reset(fieldNames_ResponseKeyPageIndex)
	return buffer.Bytes(), err
}

func (v *ResponseKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field KeyBook is missing")
	} else if v.KeyBook == nil {
		errs = append(errs, "field KeyBook is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field KeyPage is missing")
	} else if v.KeyPage == nil {
		errs = append(errs, "field KeyPage is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponsePending = []string{
	1: "Transactions",
}

func (v *ResponsePending) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteHash(1, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponsePending)
	return buffer.Bytes(), err
}

func (v *ResponsePending) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseTxHistory = []string{
	1: "Start",
	2: "End",
	3: "Total",
	4: "Transactions",
}

func (v *ResponseTxHistory) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteUint(1, v.Start)
	writer.WriteUint(2, v.End)
	writer.WriteUint(3, v.Total)
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(4, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseTxHistory)
	return buffer.Bytes(), err
}

func (v *ResponseTxHistory) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field End is missing")
	} else if v.End == 0 {
		errs = append(errs, "field End is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TxReceipt = []string{
	1: "Account",
	2: "Chain",
	3: "Receipt",
	4: "Error",
}

func (v *TxReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(2, v.Chain)
	}
	if !((v.Receipt).Equal(new(protocol.Receipt))) {
		writer.WriteValue(3, &v.Receipt)
	}
	if !(len(v.Error) == 0) {
		writer.WriteString(4, v.Error)
	}

	_, _, err := writer.Reset(fieldNames_TxReceipt)
	return buffer.Bytes(), err
}

func (v *TxReceipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Receipt is missing")
	} else if (v.Receipt).Equal(new(protocol.Receipt)) {
		errs = append(errs, "field Receipt is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Error is missing")
	} else if len(v.Error) == 0 {
		errs = append(errs, "field Error is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *ChainState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x := new(protocol.ChainType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Height = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.Roots = append(v.Roots, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ChainState)
	v.fieldsSet = seen
	return err
}

func (v *DirectoryQueryResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DirectoryQueryResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadString(1); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}
	for {
		ok := reader.ReadValue(2, func(b []byte) error {
			x, err := protocol.UnmarshalAccount(b)
			if err == nil {
				v.ExpandedEntries = append(v.ExpandedEntries, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_DirectoryQueryResult)
	v.fieldsSet = seen
	return err
}

func (v *MultiResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MultiResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Type = x
	}
	for {
		if x, ok := reader.ReadString(2); ok {
			v.Items = append(v.Items, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Count = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_MultiResponse)
	v.fieldsSet = seen
	return err
}

func (v *RequestDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.EntryHash = *x
	}

	seen, err := reader.Reset(fieldNames_RequestDataEntry)
	v.fieldsSet = seen
	return err
}

func (v *RequestDataEntrySet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestDataEntrySet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Count = x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.ExpandChains = x
	}

	seen, err := reader.Reset(fieldNames_RequestDataEntrySet)
	v.fieldsSet = seen
	return err
}

func (v *RequestKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Key = x
	}

	seen, err := reader.Reset(fieldNames_RequestKeyPageIndex)
	v.fieldsSet = seen
	return err
}

func (v *RequestTxHistory) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestTxHistory) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Limit = x
	}

	seen, err := reader.Reset(fieldNames_RequestTxHistory)
	v.fieldsSet = seen
	return err
}

func (v *ResponseAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.Account = x
		}
		return err
	})
	for {
		if x := new(ChainState); reader.ReadValue(2, x.UnmarshalBinary) {
			v.ChainState = append(v.ChainState, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseAccount)
	v.fieldsSet = seen
	return err
}

func (v *ResponseByTxId) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseByTxId) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.TxId = *x
	}
	if x := new(protocol.Envelope); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Envelope = x
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Status = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.TxSynthTxIds = x
	}
	if x, ok := reader.ReadInt(5); ok {
		v.Height = x
	}
	for {
		if x, ok := reader.ReadBytes(6); ok {
			v.ChainState = append(v.ChainState, x)
		} else {
			break
		}
	}
	for {
		if x := new(TxReceipt); reader.ReadValue(7, x.UnmarshalBinary) {
			v.Receipts = append(v.Receipts, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(8); ok {
		v.SignatureThreshold = x
	}
	if x, ok := reader.ReadBool(9); ok {
		v.Invalidated = x
	}

	seen, err := reader.Reset(fieldNames_ResponseByTxId)
	v.fieldsSet = seen
	return err
}

func (v *ResponseChainEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseChainEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadInt(1); ok {
		v.Height = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Entry = x
	}
	for {
		if x, ok := reader.ReadBytes(3); ok {
			v.State = append(v.State, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseChainEntry)
	v.fieldsSet = seen
	return err
}

func (v *ResponseChainRange) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseChainRange) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadInt(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadInt(2); ok {
		v.End = x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.Total = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseChainRange)
	v.fieldsSet = seen
	return err
}

func (v *ResponseDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.EntryHash = *x
	}
	if x := new(protocol.DataEntry); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_ResponseDataEntry)
	v.fieldsSet = seen
	return err
}

func (v *ResponseDataEntrySet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseDataEntrySet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(ResponseDataEntry); reader.ReadValue(1, x.UnmarshalBinary) {
			v.DataEntries = append(v.DataEntries, *x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_ResponseDataEntrySet)
	v.fieldsSet = seen
	return err
}

func (v *ResponseKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.KeyBook = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.KeyPage = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}

	seen, err := reader.Reset(fieldNames_ResponseKeyPageIndex)
	v.fieldsSet = seen
	return err
}

func (v *ResponsePending) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponsePending) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadHash(1); ok {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponsePending)
	v.fieldsSet = seen
	return err
}

func (v *ResponseTxHistory) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseTxHistory) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.End = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Total = x
	}
	for {
		if x := new(ResponseByTxId); reader.ReadValue(4, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseTxHistory)
	v.fieldsSet = seen
	return err
}

func (v *TxReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TxReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Chain = x
	}
	if x := new(protocol.Receipt); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Receipt = *x
	}
	if x, ok := reader.ReadString(4); ok {
		v.Error = x
	}

	seen, err := reader.Reset(fieldNames_TxReceipt)
	v.fieldsSet = seen
	return err
}

func (v *ChainState) MarshalJSON() ([]byte, error) {
	u := struct {
		Name   string             `json:"name,omitempty"`
		Type   protocol.ChainType `json:"type,omitempty"`
		Height uint64             `json:"height,omitempty"`
		Count  uint64             `json:"count,omitempty"`
		Roots  []*string          `json:"roots,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *DirectoryQueryResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Entries         []string          `json:"entries,omitempty"`
		ExpandedEntries []json.RawMessage `json:"expandedEntries,omitempty"`
		Total           uint64            `json:"total"`
	}{}
	u.Entries = v.Entries
	u.ExpandedEntries = make([]json.RawMessage, len(v.ExpandedEntries))
	for i, x := range v.ExpandedEntries {
		if y, err := json.Marshal(x); err != nil {
			return nil, fmt.Errorf("error encoding ExpandedEntries: %w", err)
		} else {
			u.ExpandedEntries[i] = y
		}
	}
	u.Total = v.Total
	return json.Marshal(&u)
}

func (v *RequestDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Url       *url.URL `json:"url,omitempty"`
		EntryHash string   `json:"entryHash,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}

func (v *RequestKeyPageIndex) MarshalJSON() ([]byte, error) {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.Url
	u.Key = encoding.BytesToJSON(v.Key)
	return json.Marshal(&u)
}

func (v *ResponseAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Account    json.RawMessage `json:"account,omitempty"`
		ChainState []ChainState    `json:"chainState,omitempty"`
	}{}
	if x, err := json.Marshal(v.Account); err != nil {
		return nil, fmt.Errorf("error encoding Account: %w", err)
	} else {
		u.Account = x
	}
	u.ChainState = v.ChainState
	return json.Marshal(&u)
}

func (v *ResponseByTxId) MarshalJSON() ([]byte, error) {
	u := struct {
		TxId               string                      `json:"txId,omitempty"`
		Envelope           *protocol.Envelope          `json:"envelope,omitempty"`
		Status             *protocol.TransactionStatus `json:"status,omitempty"`
		TxSynthTxIds       *string                     `json:"txSynthTxIds,omitempty"`
		Height             int64                       `json:"height"`
		ChainState         []*string                   `json:"chainState,omitempty"`
		Receipts           []*TxReceipt                `json:"receipts,omitempty"`
		SignatureThreshold uint64                      `json:"signatureThreshold,omitempty"`
		Invalidated        bool                        `json:"invalidated,omitempty"`
	}{}
	u.TxId = encoding.ChainToJSON(v.TxId)
	u.Envelope = v.Envelope
	u.Status = v.Status
	u.TxSynthTxIds = encoding.BytesToJSON(v.TxSynthTxIds)
	u.Height = v.Height
	u.ChainState = make([]*string, len(v.ChainState))
	for i, x := range v.ChainState {
		u.ChainState[i] = encoding.BytesToJSON(x)
	}
	u.Receipts = v.Receipts
	u.SignatureThreshold = v.SignatureThreshold
	u.Invalidated = v.Invalidated
	return json.Marshal(&u)
}

func (v *ResponseChainEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Height int64     `json:"height"`
		Entry  *string   `json:"entry,omitempty"`
		State  []*string `json:"state,omitempty"`
	}{}
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make([]*string, len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ResponseChainRange) MarshalJSON() ([]byte, error) {
	u := struct {
		Start   int64     `json:"start"`
		End     int64     `json:"end"`
		Total   int64     `json:"total"`
		Entries []*string `json:"entries,omitempty"`
	}{}
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make([]*string, len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ResponseDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		EntryHash string             `json:"entryHash,omitempty"`
		Entry     protocol.DataEntry `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *ResponsePending) MarshalJSON() ([]byte, error) {
	u := struct {
		Transactions []string `json:"transactions,omitempty"`
	}{}
	u.Transactions = make([]string, len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ChainState) UnmarshalJSON(data []byte) error {
	u := struct {
		Name   string             `json:"name,omitempty"`
		Type   protocol.ChainType `json:"type,omitempty"`
		Height uint64             `json:"height,omitempty"`
		Count  uint64             `json:"count,omitempty"`
		Roots  []*string          `json:"roots,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Name = u.Name
	v.Type = u.Type
	if u.Height != 0 {
		v.Height = u.Height
	} else {
		v.Height = u.Count
	}
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots: %w", err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}

func (v *DirectoryQueryResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Entries         []string          `json:"entries,omitempty"`
		ExpandedEntries []json.RawMessage `json:"expandedEntries,omitempty"`
		Total           uint64            `json:"total"`
	}{}
	u.Entries = v.Entries
	u.ExpandedEntries = make([]json.RawMessage, len(v.ExpandedEntries))
	for i, x := range v.ExpandedEntries {
		if y, err := json.Marshal(x); err != nil {
			return fmt.Errorf("error encoding ExpandedEntries: %w", err)
		} else {
			u.ExpandedEntries[i] = y
		}
	}
	u.Total = v.Total
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Entries = u.Entries
	v.ExpandedEntries = make([]protocol.Account, len(u.ExpandedEntries))
	for i, x := range u.ExpandedEntries {
		if y, err := protocol.UnmarshalAccountJSON(x); err != nil {
			return fmt.Errorf("error decoding ExpandedEntries: %w", err)
		} else {
			v.ExpandedEntries[i] = y
		}
	}
	v.Total = u.Total
	return nil
}

func (v *RequestDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Url       *url.URL `json:"url,omitempty"`
		EntryHash string   `json:"entryHash,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}

func (v *RequestKeyPageIndex) UnmarshalJSON(data []byte) error {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.Url
	u.Key = encoding.BytesToJSON(v.Key)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	return nil
}

func (v *ResponseAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Account    json.RawMessage `json:"account,omitempty"`
		ChainState []ChainState    `json:"chainState,omitempty"`
	}{}
	if x, err := json.Marshal(v.Account); err != nil {
		return fmt.Errorf("error encoding Account: %w", err)
	} else {
		u.Account = x
	}
	u.ChainState = v.ChainState
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := protocol.UnmarshalAccountJSON(u.Account); err != nil {
		return fmt.Errorf("error decoding Account: %w", err)
	} else {
		v.Account = x
	}

	v.ChainState = u.ChainState
	return nil
}

func (v *ResponseByTxId) UnmarshalJSON(data []byte) error {
	u := struct {
		TxId               string                      `json:"txId,omitempty"`
		Envelope           *protocol.Envelope          `json:"envelope,omitempty"`
		Status             *protocol.TransactionStatus `json:"status,omitempty"`
		TxSynthTxIds       *string                     `json:"txSynthTxIds,omitempty"`
		Height             int64                       `json:"height"`
		ChainState         []*string                   `json:"chainState,omitempty"`
		Receipts           []*TxReceipt                `json:"receipts,omitempty"`
		SignatureThreshold uint64                      `json:"signatureThreshold,omitempty"`
		Invalidated        bool                        `json:"invalidated,omitempty"`
	}{}
	u.TxId = encoding.ChainToJSON(v.TxId)
	u.Envelope = v.Envelope
	u.Status = v.Status
	u.TxSynthTxIds = encoding.BytesToJSON(v.TxSynthTxIds)
	u.Height = v.Height
	u.ChainState = make([]*string, len(v.ChainState))
	for i, x := range v.ChainState {
		u.ChainState[i] = encoding.BytesToJSON(x)
	}
	u.Receipts = v.Receipts
	u.SignatureThreshold = v.SignatureThreshold
	u.Invalidated = v.Invalidated
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.TxId); err != nil {
		return fmt.Errorf("error decoding TxId: %w", err)
	} else {
		v.TxId = x
	}
	v.Envelope = u.Envelope
	v.Status = u.Status
	if x, err := encoding.BytesFromJSON(u.TxSynthTxIds); err != nil {
		return fmt.Errorf("error decoding TxSynthTxIds: %w", err)
	} else {
		v.TxSynthTxIds = x
	}
	v.Height = u.Height
	v.ChainState = make([][]byte, len(u.ChainState))
	for i, x := range u.ChainState {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding ChainState: %w", err)
		} else {
			v.ChainState[i] = x
		}
	}
	v.Receipts = u.Receipts
	v.SignatureThreshold = u.SignatureThreshold
	v.Invalidated = u.Invalidated
	return nil
}

func (v *ResponseChainEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Height int64     `json:"height"`
		Entry  *string   `json:"entry,omitempty"`
		State  []*string `json:"state,omitempty"`
	}{}
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make([]*string, len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Height = u.Height
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	return nil
}

func (v *ResponseChainRange) UnmarshalJSON(data []byte) error {
	u := struct {
		Start   int64     `json:"start"`
		End     int64     `json:"end"`
		Total   int64     `json:"total"`
		Entries []*string `json:"entries,omitempty"`
	}{}
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make([]*string, len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Start = u.Start
	v.End = u.End
	v.Total = u.Total
	v.Entries = make([][]byte, len(u.Entries))
	for i, x := range u.Entries {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Entries: %w", err)
		} else {
			v.Entries[i] = x
		}
	}
	return nil
}

func (v *ResponseDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		EntryHash string             `json:"entryHash,omitempty"`
		Entry     protocol.DataEntry `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	v.Entry = u.Entry
	return nil
}

func (v *ResponsePending) UnmarshalJSON(data []byte) error {
	u := struct {
		Transactions []string `json:"transactions,omitempty"`
	}{}
	u.Transactions = make([]string, len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transactions = make([][32]byte, len(u.Transactions))
	for i, x := range u.Transactions {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Transactions: %w", err)
		} else {
			v.Transactions[i] = x
		}
	}
	return nil
}
