package query

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type MultiResponse struct {
	fieldsSet []bool
	Type      string   `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Items     []string `json:"items,omitempty" form:"items" query:"items" validate:"required"`
	Start     uint64   `json:"start" form:"start" query:"start" validate:"required"`
	Count     uint64   `json:"count" form:"count" query:"count" validate:"required"`
	Total     uint64   `json:"total" form:"total" query:"total" validate:"required"`
}

type RequestKeyPageIndex struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Key       []byte   `json:"key,omitempty" form:"key" query:"key" validate:"required"`
}

type ResponseByTxId struct {
	fieldsSet          []bool
	TxId               [32]byte                    `json:"txId,omitempty" form:"txId" query:"txId" validate:"required"`
	Envelope           *protocol.Envelope          `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	Status             *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	TxSynthTxIds       []byte                      `json:"txSynthTxIds,omitempty" form:"txSynthTxIds" query:"txSynthTxIds" validate:"required"`
	Height             int64                       `json:"height" form:"height" query:"height" validate:"required"`
	ChainState         [][]byte                    `json:"chainState,omitempty" form:"chainState" query:"chainState" validate:"required"`
	Receipts           []*TxReceipt                `json:"receipts,omitempty" form:"receipts" query:"receipts" validate:"required"`
	SignatureThreshold uint64                      `json:"signatureThreshold,omitempty" form:"signatureThreshold" query:"signatureThreshold" validate:"required"`
	Invalidated        bool                        `json:"invalidated,omitempty" form:"invalidated" query:"invalidated" validate:"required"`
}

type ResponseChainEntry struct {
	fieldsSet []bool
	Height    int64    `json:"height" form:"height" query:"height" validate:"required"`
	Entry     []byte   `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	State     [][]byte `json:"state,omitempty" form:"state" query:"state" validate:"required"`
}

type ResponseChainRange struct {
	fieldsSet []bool
	Start     int64    `json:"start" form:"start" query:"start" validate:"required"`
	End       int64    `json:"end" form:"end" query:"end" validate:"required"`
	Total     int64    `json:"total" form:"total" query:"total" validate:"required"`
	Entries   [][]byte `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
}

type ResponseKeyPageIndex struct {
	fieldsSet []bool
	KeyBook   *url.URL `json:"keyBook,omitempty" form:"keyBook" query:"keyBook" validate:"required"`
	KeyPage   *url.URL `json:"keyPage,omitempty" form:"keyPage" query:"keyPage" validate:"required"`
	Index     uint64   `json:"index" form:"index" query:"index" validate:"required"`
}

type ResponsePending struct {
	fieldsSet    []bool
	Transactions [][32]byte `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type ResponseTxHistory struct {
	fieldsSet    []bool
	Start        int64            `json:"start" form:"start" query:"start" validate:"required"`
	End          int64            `json:"end" form:"end" query:"end" validate:"required"`
	Total        int64            `json:"total" form:"total" query:"total" validate:"required"`
	Transactions []ResponseByTxId `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type TxReceipt struct {
	fieldsSet      []bool
	Account        *url.URL         `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Chain          string           `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	DirectoryBlock uint64           `json:"directoryBlock,omitempty" form:"directoryBlock" query:"directoryBlock" validate:"required"`
	Receipt        protocol.Receipt `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
}

func (v *RequestKeyPageIndex) Equal(u *RequestKeyPageIndex) bool {
	if !((v.Url).Equal(u.Url)) {
		return false
	}
	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}

	return true
}

func (v *ResponseByTxId) Equal(u *ResponseByTxId) bool {
	if !(v.TxId == u.TxId) {
		return false
	}
	if !((v.Envelope).Equal(u.Envelope)) {
		return false
	}
	if !((v.Status).Equal(u.Status)) {
		return false
	}
	if !(bytes.Equal(v.TxSynthTxIds, u.TxSynthTxIds)) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.ChainState) != len(u.ChainState) {
		return false
	}
	for i := range v.ChainState {
		if !(bytes.Equal(v.ChainState[i], u.ChainState[i])) {
			return false
		}
	}
	if len(v.Receipts) != len(u.Receipts) {
		return false
	}
	for i := range v.Receipts {
		if !((v.Receipts[i]).Equal(u.Receipts[i])) {
			return false
		}
	}
	if !(v.SignatureThreshold == u.SignatureThreshold) {
		return false
	}
	if !(v.Invalidated == u.Invalidated) {
		return false
	}

	return true
}

func (v *ResponseChainEntry) Equal(u *ResponseChainEntry) bool {
	if !(v.Height == u.Height) {
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseChainRange) Equal(u *ResponseChainRange) bool {
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.End == u.End) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(bytes.Equal(v.Entries[i], u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseKeyPageIndex) Equal(u *ResponseKeyPageIndex) bool {
	if !((v.KeyBook).Equal(u.KeyBook)) {
		return false
	}
	if !((v.KeyPage).Equal(u.KeyPage)) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}

	return true
}

func (v *ResponsePending) Equal(u *ResponsePending) bool {
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !(v.Transactions[i] == u.Transactions[i]) {
			return false
		}
	}

	return true
}

func (v *ResponseTxHistory) Equal(u *ResponseTxHistory) bool {
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.End == u.End) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((&v.Transactions[i]).Equal(&u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *TxReceipt) Equal(u *TxReceipt) bool {
	if !((v.Account).Equal(u.Account)) {
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}
	if !(v.DirectoryBlock == u.DirectoryBlock) {
		return false
	}
	if !((&v.Receipt).Equal(&u.Receipt)) {
		return false
	}

	return true
}

var fieldNames_MultiResponse = []string{
	1: "Type",
	2: "Items",
	3: "Start",
	4: "Count",
	5: "Total",
}

func (v *MultiResponse) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Type) == 0) {
		writer.WriteString(1, v.Type)
	}
	if !(len(v.Items) == 0) {
		for _, v := range v.Items {
			writer.WriteString(2, v)
		}
	}
	writer.WriteUint(3, v.Start)
	writer.WriteUint(4, v.Count)
	writer.WriteUint(5, v.Total)

	_, _, err := writer.Reset(fieldNames_MultiResponse)
	return buffer.Bytes(), err
}

func (v *MultiResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if len(v.Type) == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Items is missing")
	} else if len(v.Items) == 0 {
		errs = append(errs, "field Items is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestKeyPageIndex = []string{
	1: "Url",
	2: "Key",
}

func (v *RequestKeyPageIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(len(v.Key) == 0) {
		writer.WriteBytes(2, v.Key)
	}

	_, _, err := writer.Reset(fieldNames_RequestKeyPageIndex)
	return buffer.Bytes(), err
}

func (v *RequestKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Key is missing")
	} else if len(v.Key) == 0 {
		errs = append(errs, "field Key is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseByTxId = []string{
	1: "TxId",
	2: "Envelope",
	3: "Status",
	4: "TxSynthTxIds",
	5: "Height",
	6: "ChainState",
	7: "Receipts",
	8: "SignatureThreshold",
	9: "Invalidated",
}

func (v *ResponseByTxId) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.TxId == ([32]byte{})) {
		writer.WriteHash(1, &v.TxId)
	}
	if !(v.Envelope == nil) {
		writer.WriteValue(2, v.Envelope)
	}
	if !(v.Status == nil) {
		writer.WriteValue(3, v.Status)
	}
	if !(len(v.TxSynthTxIds) == 0) {
		writer.WriteBytes(4, v.TxSynthTxIds)
	}
	writer.WriteInt(5, v.Height)
	if !(len(v.ChainState) == 0) {
		for _, v := range v.ChainState {
			writer.WriteBytes(6, v)
		}
	}
	if !(len(v.Receipts) == 0) {
		for _, v := range v.Receipts {
			writer.WriteValue(7, v)
		}
	}
	if !(v.SignatureThreshold == 0) {
		writer.WriteUint(8, v.SignatureThreshold)
	}
	if !(!v.Invalidated) {
		writer.WriteBool(9, v.Invalidated)
	}

	_, _, err := writer.Reset(fieldNames_ResponseByTxId)
	return buffer.Bytes(), err
}

func (v *ResponseByTxId) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TxId is missing")
	} else if v.TxId == ([32]byte{}) {
		errs = append(errs, "field TxId is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Envelope is missing")
	} else if v.Envelope == nil {
		errs = append(errs, "field Envelope is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TxSynthTxIds is missing")
	} else if len(v.TxSynthTxIds) == 0 {
		errs = append(errs, "field TxSynthTxIds is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field ChainState is missing")
	} else if len(v.ChainState) == 0 {
		errs = append(errs, "field ChainState is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Receipts is missing")
	} else if len(v.Receipts) == 0 {
		errs = append(errs, "field Receipts is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field SignatureThreshold is missing")
	} else if v.SignatureThreshold == 0 {
		errs = append(errs, "field SignatureThreshold is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field Invalidated is missing")
	} else if !v.Invalidated {
		errs = append(errs, "field Invalidated is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseChainEntry = []string{
	1: "Height",
	2: "Entry",
	3: "State",
}

func (v *ResponseChainEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteInt(1, v.Height)
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(2, v.Entry)
	}
	if !(len(v.State) == 0) {
		for _, v := range v.State {
			writer.WriteBytes(3, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseChainEntry)
	return buffer.Bytes(), err
}

func (v *ResponseChainEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if len(v.Entry) == 0 {
		errs = append(errs, "field Entry is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field State is missing")
	} else if len(v.State) == 0 {
		errs = append(errs, "field State is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseChainRange = []string{
	1: "Start",
	2: "End",
	3: "Total",
	4: "Entries",
}

func (v *ResponseChainRange) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteInt(1, v.Start)
	writer.WriteInt(2, v.End)
	writer.WriteInt(3, v.Total)
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteBytes(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseChainRange)
	return buffer.Bytes(), err
}

func (v *ResponseChainRange) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field End is missing")
	} else if v.End == 0 {
		errs = append(errs, "field End is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseKeyPageIndex = []string{
	1: "KeyBook",
	2: "KeyPage",
	3: "Index",
}

func (v *ResponseKeyPageIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.KeyBook == nil) {
		writer.WriteUrl(1, v.KeyBook)
	}
	if !(v.KeyPage == nil) {
		writer.WriteUrl(2, v.KeyPage)
	}
	writer.WriteUint(3, v.Index)

	_, _, err := writer.Reset(fieldNames_ResponseKeyPageIndex)
	return buffer.Bytes(), err
}

func (v *ResponseKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field KeyBook is missing")
	} else if v.KeyBook == nil {
		errs = append(errs, "field KeyBook is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field KeyPage is missing")
	} else if v.KeyPage == nil {
		errs = append(errs, "field KeyPage is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponsePending = []string{
	1: "Transactions",
}

func (v *ResponsePending) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteHash(1, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponsePending)
	return buffer.Bytes(), err
}

func (v *ResponsePending) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseTxHistory = []string{
	1: "Start",
	2: "End",
	3: "Total",
	4: "Transactions",
}

func (v *ResponseTxHistory) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteInt(1, v.Start)
	writer.WriteInt(2, v.End)
	writer.WriteInt(3, v.Total)
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(4, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseTxHistory)
	return buffer.Bytes(), err
}

func (v *ResponseTxHistory) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field End is missing")
	} else if v.End == 0 {
		errs = append(errs, "field End is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TxReceipt = []string{
	1: "Account",
	2: "Chain",
	3: "DirectoryBlock",
	4: "Receipt",
}

func (v *TxReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(2, v.Chain)
	}
	if !(v.DirectoryBlock == 0) {
		writer.WriteUint(3, v.DirectoryBlock)
	}
	if !((v.Receipt).Equal(new(protocol.Receipt))) {
		writer.WriteValue(4, &v.Receipt)
	}

	_, _, err := writer.Reset(fieldNames_TxReceipt)
	return buffer.Bytes(), err
}

func (v *TxReceipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field DirectoryBlock is missing")
	} else if v.DirectoryBlock == 0 {
		errs = append(errs, "field DirectoryBlock is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Receipt is missing")
	} else if (v.Receipt).Equal(new(protocol.Receipt)) {
		errs = append(errs, "field Receipt is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *MultiResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MultiResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Type = x
	}
	for {
		if x, ok := reader.ReadString(2); ok {
			v.Items = append(v.Items, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Count = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_MultiResponse)
	v.fieldsSet = seen
	return err
}

func (v *RequestKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Key = x
	}

	seen, err := reader.Reset(fieldNames_RequestKeyPageIndex)
	v.fieldsSet = seen
	return err
}

func (v *ResponseByTxId) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseByTxId) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.TxId = *x
	}
	if x := new(protocol.Envelope); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Envelope = x
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Status = x
	}
	if x, ok := reader.ReadBytes(4); ok {
		v.TxSynthTxIds = x
	}
	if x, ok := reader.ReadInt(5); ok {
		v.Height = x
	}
	for {
		if x, ok := reader.ReadBytes(6); ok {
			v.ChainState = append(v.ChainState, x)
		} else {
			break
		}
	}
	for {
		if x := new(TxReceipt); reader.ReadValue(7, x.UnmarshalBinary) {
			v.Receipts = append(v.Receipts, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(8); ok {
		v.SignatureThreshold = x
	}
	if x, ok := reader.ReadBool(9); ok {
		v.Invalidated = x
	}

	seen, err := reader.Reset(fieldNames_ResponseByTxId)
	v.fieldsSet = seen
	return err
}

func (v *ResponseChainEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseChainEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadInt(1); ok {
		v.Height = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Entry = x
	}
	for {
		if x, ok := reader.ReadBytes(3); ok {
			v.State = append(v.State, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseChainEntry)
	v.fieldsSet = seen
	return err
}

func (v *ResponseChainRange) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseChainRange) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadInt(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadInt(2); ok {
		v.End = x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.Total = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseChainRange)
	v.fieldsSet = seen
	return err
}

func (v *ResponseKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.KeyBook = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.KeyPage = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}

	seen, err := reader.Reset(fieldNames_ResponseKeyPageIndex)
	v.fieldsSet = seen
	return err
}

func (v *ResponsePending) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponsePending) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadHash(1); ok {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponsePending)
	v.fieldsSet = seen
	return err
}

func (v *ResponseTxHistory) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseTxHistory) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadInt(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadInt(2); ok {
		v.End = x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.Total = x
	}
	for {
		if x := new(ResponseByTxId); reader.ReadValue(4, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseTxHistory)
	v.fieldsSet = seen
	return err
}

func (v *TxReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TxReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Chain = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.DirectoryBlock = x
	}
	if x := new(protocol.Receipt); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Receipt = *x
	}

	seen, err := reader.Reset(fieldNames_TxReceipt)
	v.fieldsSet = seen
	return err
}

func (v *RequestKeyPageIndex) MarshalJSON() ([]byte, error) {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.Url
	u.Key = encoding.BytesToJSON(v.Key)
	return json.Marshal(&u)
}

func (v *ResponseByTxId) MarshalJSON() ([]byte, error) {
	u := struct {
		TxId               string                      `json:"txId,omitempty"`
		Envelope           *protocol.Envelope          `json:"envelope,omitempty"`
		Status             *protocol.TransactionStatus `json:"status,omitempty"`
		TxSynthTxIds       *string                     `json:"txSynthTxIds,omitempty"`
		Height             int64                       `json:"height"`
		ChainState         []*string                   `json:"chainState,omitempty"`
		Receipts           []*TxReceipt                `json:"receipts,omitempty"`
		SignatureThreshold uint64                      `json:"signatureThreshold,omitempty"`
		Invalidated        bool                        `json:"invalidated,omitempty"`
	}{}
	u.TxId = encoding.ChainToJSON(v.TxId)
	u.Envelope = v.Envelope
	u.Status = v.Status
	u.TxSynthTxIds = encoding.BytesToJSON(v.TxSynthTxIds)
	u.Height = v.Height
	u.ChainState = make([]*string, len(v.ChainState))
	for i, x := range v.ChainState {
		u.ChainState[i] = encoding.BytesToJSON(x)
	}
	u.Receipts = v.Receipts
	u.SignatureThreshold = v.SignatureThreshold
	u.Invalidated = v.Invalidated
	return json.Marshal(&u)
}

func (v *ResponseChainEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Height int64     `json:"height"`
		Entry  *string   `json:"entry,omitempty"`
		State  []*string `json:"state,omitempty"`
	}{}
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make([]*string, len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ResponseChainRange) MarshalJSON() ([]byte, error) {
	u := struct {
		Start   int64     `json:"start"`
		End     int64     `json:"end"`
		Total   int64     `json:"total"`
		Entries []*string `json:"entries,omitempty"`
	}{}
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make([]*string, len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ResponsePending) MarshalJSON() ([]byte, error) {
	u := struct {
		Transactions []string `json:"transactions,omitempty"`
	}{}
	u.Transactions = make([]string, len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *RequestKeyPageIndex) UnmarshalJSON(data []byte) error {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.Url
	u.Key = encoding.BytesToJSON(v.Key)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	return nil
}

func (v *ResponseByTxId) UnmarshalJSON(data []byte) error {
	u := struct {
		TxId               string                      `json:"txId,omitempty"`
		Envelope           *protocol.Envelope          `json:"envelope,omitempty"`
		Status             *protocol.TransactionStatus `json:"status,omitempty"`
		TxSynthTxIds       *string                     `json:"txSynthTxIds,omitempty"`
		Height             int64                       `json:"height"`
		ChainState         []*string                   `json:"chainState,omitempty"`
		Receipts           []*TxReceipt                `json:"receipts,omitempty"`
		SignatureThreshold uint64                      `json:"signatureThreshold,omitempty"`
		Invalidated        bool                        `json:"invalidated,omitempty"`
	}{}
	u.TxId = encoding.ChainToJSON(v.TxId)
	u.Envelope = v.Envelope
	u.Status = v.Status
	u.TxSynthTxIds = encoding.BytesToJSON(v.TxSynthTxIds)
	u.Height = v.Height
	u.ChainState = make([]*string, len(v.ChainState))
	for i, x := range v.ChainState {
		u.ChainState[i] = encoding.BytesToJSON(x)
	}
	u.Receipts = v.Receipts
	u.SignatureThreshold = v.SignatureThreshold
	u.Invalidated = v.Invalidated
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.TxId); err != nil {
		return fmt.Errorf("error decoding TxId: %w", err)
	} else {
		v.TxId = x
	}
	v.Envelope = u.Envelope
	v.Status = u.Status
	if x, err := encoding.BytesFromJSON(u.TxSynthTxIds); err != nil {
		return fmt.Errorf("error decoding TxSynthTxIds: %w", err)
	} else {
		v.TxSynthTxIds = x
	}
	v.Height = u.Height
	v.ChainState = make([][]byte, len(u.ChainState))
	for i, x := range u.ChainState {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding ChainState: %w", err)
		} else {
			v.ChainState[i] = x
		}
	}
	v.Receipts = u.Receipts
	v.SignatureThreshold = u.SignatureThreshold
	v.Invalidated = u.Invalidated
	return nil
}

func (v *ResponseChainEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Height int64     `json:"height"`
		Entry  *string   `json:"entry,omitempty"`
		State  []*string `json:"state,omitempty"`
	}{}
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make([]*string, len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Height = u.Height
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	return nil
}

func (v *ResponseChainRange) UnmarshalJSON(data []byte) error {
	u := struct {
		Start   int64     `json:"start"`
		End     int64     `json:"end"`
		Total   int64     `json:"total"`
		Entries []*string `json:"entries,omitempty"`
	}{}
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make([]*string, len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Start = u.Start
	v.End = u.End
	v.Total = u.Total
	v.Entries = make([][]byte, len(u.Entries))
	for i, x := range u.Entries {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Entries: %w", err)
		} else {
			v.Entries[i] = x
		}
	}
	return nil
}

func (v *ResponsePending) UnmarshalJSON(data []byte) error {
	u := struct {
		Transactions []string `json:"transactions,omitempty"`
	}{}
	u.Transactions = make([]string, len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transactions = make([][32]byte, len(u.Transactions))
	for i, x := range u.Transactions {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Transactions: %w", err)
		} else {
			v.Transactions[i] = x
		}
	}
	return nil
}
