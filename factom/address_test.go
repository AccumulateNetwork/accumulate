// MIT License
//
// Copyright 2018 Canonical Ledgers, LLC
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

package factom

import (
	"context"
	"encoding/json"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

var (
	// Valid Test Addresses generated by factom-walletd
	// OBVIOUSLY NEVER USE THESE FOR ANY FUNDS!
	FAAddressStr = "FA2PdKfzGP5XwoSbeW1k9QunCHwC8DY6d8xgEdfm57qfR31nTueb"
	FsAddressStr = "Fs1ipNRjEXcWj8RUn1GRLMJYVoPFBL1yw9rn6sCxWGcxciC4HdPd"
	ECAddressStr = "EC2Pawhv7uAiKFQeLgaqfRhzk5o9uPVY8Ehjh8DnLXENosvYTT26"
	EsAddressStr = "Es2tFRhAqHnydaygVAR6zbpWTQXUDaXy1JHWJugQXnYavS8ssQQE"
)

type addressUnmarshalJSONTest struct {
	Name   string
	Adr    interface{}
	ExpAdr interface{}
	Data   string
	Err    string
}

var addressUnmarshalJSONTests = []addressUnmarshalJSONTest{{
	Name: "valid FA",
	Data: fmt.Sprintf("%q", FAAddressStr),
	Adr:  new(FAAddress),
	ExpAdr: func() *FAAddress {
		adr, _ := NewFsAddress(FsAddressStr)
		pub := adr.FAAddress()
		return &pub
	}(),
}, {
	Name: "valid Fs",
	Data: fmt.Sprintf("%q", FsAddressStr),
	Adr:  new(FsAddress),
	ExpAdr: func() *FsAddress {
		adr, _ := NewFsAddress(FsAddressStr)
		return &adr
	}(),
}, {
	Name: "valid EC",
	Data: fmt.Sprintf("%q", ECAddressStr),
	Adr:  new(ECAddress),
	ExpAdr: func() *ECAddress {
		adr, _ := NewEsAddress(EsAddressStr)
		pub := adr.ECAddress()
		return &pub
	}(),
}, {
	Name: "valid Es",
	Data: fmt.Sprintf("%q", EsAddressStr),
	Adr:  new(EsAddress),
	ExpAdr: func() *EsAddress {
		adr, _ := NewEsAddress(EsAddressStr)
		return &adr
	}(),
}, {
	Name: "FA/invalid type",
	Data: `{}`,
	Err:  "json: cannot unmarshal object into Go value of type *factom.FAAddress",
	Adr:  new(FAAddress),
}, {
	Name: "FA/invalid type",
	Data: `5.5`,
	Err:  "json: cannot unmarshal number into Go value of type *factom.FAAddress",
	Adr:  new(FAAddress),
}, {
	Name: "FA/invalid type",
	Data: `["hello"]`,
	Err:  "json: cannot unmarshal array into Go value of type *factom.FAAddress",
	Adr:  new(FAAddress),
}, {
	Name: "EC/invalid type",
	Data: `{}`,
	Err:  "json: cannot unmarshal object into Go value of type *factom.ECAddress",
	Adr:  new(ECAddress),
}, {
	Name: "EC/invalid type",
	Data: `5.5`,
	Err:  "json: cannot unmarshal number into Go value of type *factom.ECAddress",
	Adr:  new(ECAddress),
}, {
	Name: "EC/invalid type",
	Data: `["hello"]`,
	Err:  "json: cannot unmarshal array into Go value of type *factom.ECAddress",
	Adr:  new(ECAddress),
}, {
	Name: "invalid length",
	Data: fmt.Sprintf("%q", FAAddressStr[0:len(FAAddressStr)-1]),
	Err:  "invalid length",
}, {
	Name: "invalid length",
	Data: fmt.Sprintf("%q", FAAddressStr+"Q"),
	Err:  "invalid length",
}, {
	Name: "invalid prefix",
	Data: fmt.Sprintf("%q", func() string {
		adr, _ := NewFAAddress(FAAddressStr)
		return adr.payload().StringWithPrefix([]byte{0x50, 0x50})
	}()),
	Err: "invalid prefix",
}, {
	Name: "invalid prefix",
	Data: fmt.Sprintf("%q", FsAddressStr),
	Err:  "invalid prefix",
}, {
	Name:   "invalid symbol/FA",
	Data:   fmt.Sprintf("%q", FAAddressStr[0:len(FAAddressStr)-1]+"0"),
	Err:    "invalid format: version and/or checksum bytes missing",
	Adr:    new(FAAddress),
	ExpAdr: new(FAAddress),
}, {
	Name:   "invalid checksum",
	Data:   fmt.Sprintf("%q", FAAddressStr[0:len(FAAddressStr)-1]+"e"),
	Err:    "checksum error",
	Adr:    new(FAAddress),
	ExpAdr: new(FAAddress),
}}

func testAddressUnmarshalJSON(t *testing.T, test addressUnmarshalJSONTest) {
	err := json.Unmarshal([]byte(test.Data), test.Adr)
	assert := assert.New(t)
	if len(test.Err) > 0 {
		assert.EqualError(err, test.Err)
		return
	}
	assert.NoError(err)
	assert.Equal(test.ExpAdr, test.Adr)
}

func TestAddress(t *testing.T) {
	for _, test := range addressUnmarshalJSONTests {
		if test.Adr != nil {
			t.Run("UnmarshalJSON/"+test.Name, func(t *testing.T) {
				testAddressUnmarshalJSON(t, test)
			})
			continue
		}
		test.ExpAdr, test.Adr = &FAAddress{}, &FAAddress{}
		t.Run("UnmarshalJSON/FA", func(t *testing.T) {
			testAddressUnmarshalJSON(t, test)
		})
		test.ExpAdr, test.Adr = &ECAddress{}, &ECAddress{}
		t.Run("UnmarshalJSON/EC", func(t *testing.T) {
			testAddressUnmarshalJSON(t, test)
		})
	}

	fa, _ := NewFAAddress(FAAddressStr)
	fs, _ := NewFsAddress(FsAddressStr)
	ec, _ := NewECAddress(ECAddressStr)
	es, _ := NewEsAddress(EsAddressStr)
	strToAdr := map[string]interface {
		PrefixString() string
		GetBalance(context.Context, *Client) (uint64, error)
	}{FAAddressStr: fa, FsAddressStr: fs,
		ECAddressStr: ec, EsAddressStr: es}
	for adrStr, adr := range strToAdr {
		t.Run("MarshalJSON/"+adr.PrefixString(), func(t *testing.T) {
			data, err := json.Marshal(adr)
			assert := assert.New(t)
			assert.NoError(err)
			assert.Equal(fmt.Sprintf("%q", adrStr), string(data))
		})
	}

	t.Run("FsAddress", func(t *testing.T) {
		adr, _ := NewFAAddress(FAAddressStr)
		priv, _ := NewFsAddress(FsAddressStr)
		assert := assert.New(t)
		assert.Equal(adr, priv.FAAddress())
	})
	t.Run("EsAddress", func(t *testing.T) {
		adr, _ := NewECAddress(ECAddressStr)
		priv, _ := NewEsAddress(EsAddressStr)
		assert := assert.New(t)
		assert.Equal(adr, priv.ECAddress())
	})

	t.Run("Generate/Fs", func(t *testing.T) {
		var err error
		fs, err = GenerateFsAddress()
		assert.NoError(t, err)
	})
	t.Run("Generate/Es", func(t *testing.T) {
		var err error
		es, err = GenerateEsAddress()
		assert.NoError(t, err)
	})

	c := NewClient()
	t.Run("Save/Fs", func(t *testing.T) {
		err := fs.Save(nil, c)
		assert.NoError(t, err)
	})
	t.Run("Save/Es", func(t *testing.T) {
		err := es.Save(nil, c)
		assert.NoError(t, err)
	})

	t.Run("GetPrivateAddresses", func(t *testing.T) {
		fss, ess, err := c.GetPrivateAddresses(nil)
		assert := assert.New(t)
		assert.NoError(err)
		assert.NotEmpty(fss)
		assert.NotEmpty(ess)
	})

	for _, adr := range strToAdr {
		t.Run("GetBalance/"+adr.PrefixString(), func(t *testing.T) {
			balance, err := adr.GetBalance(nil, c)
			assert := assert.New(t)
			assert.NoError(err)
			assert.Equal(uint64(0), balance)
		})
	}
	fundedEC, _ := NewECAddress("EC1zANmWuEMYoH6VizJg6uFaEdi8Excn1VbLN99KRuxh3GSvB7YQ")
	t.Run("GetBalance/"+fundedEC.String(), func(t *testing.T) {
		balance, err := fundedEC.GetBalance(nil, c)
		assert := assert.New(t)
		assert.NoError(err)
		assert.NotEqual(uint64(0), balance)
	})

	t.Run("Remove/Fs", func(t *testing.T) {
		err := fs.Remove(nil, c)
		assert.NoError(t, err)
	})
	t.Run("Remove/Es", func(t *testing.T) {
		err := es.Remove(nil, c)
		assert.NoError(t, err)
	})
}
