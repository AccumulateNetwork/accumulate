package validator

import (
	"context"
	"crypto/ed25519"
	"crypto/sha256"
	"fmt"
	"net"
	"time"

	"github.com/AccumulateNetwork/accumulated/types"
	"github.com/AccumulateNetwork/accumulated/types/api"
	pb "github.com/AccumulateNetwork/accumulated/types/proto"
	"github.com/AccumulateNetwork/accumulated/types/state"
	"github.com/spf13/viper"
	tmnet "github.com/tendermint/tendermint/libs/net"
	"google.golang.org/grpc"
)

// Node implements the general parameters to stimulate the validators, provide synthetic transactions, and issue state changes
type Node struct {
	AccRpcAddr   string
	RouterClient pb.ApiServiceClient

	mmDB           state.StateDB
	chainValidator *ValidatorContext
	leader         bool
	key            ed25519.PrivateKey
}

// Initialize will setup the node with the given parameters.  What we really need here are the bouncer, and private key
func (app *Node) Initialize(configFile string, workingDir string, key ed25519.PrivateKey, chainValidator *ValidatorContext) error {
	v := viper.New()
	v.SetConfigFile(configFile)
	v.AddConfigPath(workingDir)
	if err := v.ReadInConfig(); err != nil {

		return fmt.Errorf("viper failed to read config file: %w", err)
	}
	app.AccRpcAddr = v.GetString("accumulate.AccRPCAddress")

	//create a connection to the router.
	routeraddress := v.GetString("accumulate.RouterAddress")
	if len(routeraddress) == 0 {
		return fmt.Errorf("accumulate.RouterAddress token not specified in config file")
	}

	conn, err := grpc.Dial(routeraddress, grpc.WithBlock(), grpc.WithInsecure(), grpc.WithContextDialer(dialerFunc))
	if err != nil {
		return fmt.Errorf("error Openning GRPC client in router")
	}
	//defer conn.Close()
	app.RouterClient = pb.NewApiServiceClient(conn)
	networkId := viper.GetString("instrumentation/namespace")
	bvcId := sha256.Sum256([]byte(networkId))
	dbfilename := workingDir + "/" + "valacc.db"
	err = app.mmDB.Open(dbfilename, bvcId[:], false, true)

	app.chainValidator = chainValidator
	app.leader = false

	app.key = key
	return nil
}

// BeginBlock will set the height, time, and leader (flag if leader for the block)
func (app *Node) BeginBlock(height int64, Time *time.Time, leader bool) error {
	app.leader = leader
	app.chainValidator.BeginBlock(height, Time)
	return nil
}

// CanTransact will do light validation on the transaction
func (app *Node) CanTransact(transaction *pb.GenTransaction) error {
	currentState := state.NewStateEntry(nil, nil, &app.mmDB)

	//need to also provide a public key hash of the identity...
	if !transaction.ValidateSig(nil) {
		return fmt.Errorf("invalid signature for transaction %d", transaction.GetTransactionType())
	}

	app.chainValidator.Check(currentState, transaction)
	return nil
}

// Validate will do a deep validation of the transaction.  This is done by ALL the validators in the network
// transaction []byte will be replaced by transaction RawTransaction
func (app *Node) Validate(transaction *pb.GenTransaction) error {

	currentState := state.NewStateEntry(nil, nil, &app.mmDB)

	//placeholder for special validation rules for synthetic transactions.
	if transaction.GetTransactionType()&0xFF00 > 0 {
		//need to verify the sender is a legit bvc validator also need the dbvc receipt
		//so if the transaction is a synth tx, then we need to verify the sender is a BVC validator and
		//not an impostor. Need to figure out how to do this. Right now we just assume the synth request
		//sender is legit.
	}

	//run through the validation routine
	vdata, err := app.chainValidator.Validate(currentState, transaction)

	/// batch any synthetic tx's generated by the validator
	app.processValidatedSubmissionRequest(vdata)

	/// update the state data for the chain.
	if vdata.StateData != nil {
		for k, v := range vdata.StateData {
			header := state.Chain{}
			err := header.UnmarshalBinary(v)
			if err != nil {
				panic("invalid state object after submission processing, should never get here")
			}
			app.mmDB.AddStateEntry(k[:], v)
		}
	}

	return err
}

// EndBlock will return the merkle DAG root of the current state
func (app *Node) EndBlock() ([]byte, error) {

	mdRoot, numStateChanges, err := app.mmDB.WriteStates(app.chainValidator.GetCurrentHeight())

	if err != nil {
		//shouldn't get here.
		panic(fmt.Errorf("fatal error, block not set, %v", err))
	}

	//if we have no transactions this block then don't publish anything
	if app.leader && numStateChanges > 0 {
		//now we create a synthetic transaction and publish to the directory block validator
		dbvc := ResponseValidateTX{}
		dbvc.Submissions = make([]*pb.Submission, 1)
		dbvc.Submissions[0] = &pb.Submission{}
		dbvc.Submissions[0].Instruction = 0
		chainAdi := "dbvc"
		chainId := types.GetChainIdFromChainPath(&chainAdi)
		dbvc.Submissions[0].Identitychain = chainId[:] //1 is the chain id of the DBVC
		dbvc.Submissions[0].Chainid = chainId[:]

		dbvc.Submissions[0].Instruction = pb.AccInstruction_Data_Entry //this may be irrelevant...
		dbvc.Submissions[0].Param1 = 0
		dbvc.Submissions[0].Param2 = 0
		//broadcast the root
		app.processValidatedSubmissionRequest(&dbvc)
	}

	return mdRoot, nil
}

// Query will take a query object, process it, and return either the data or error
func (app *Node) Query(q *pb.Query) ([]byte, error) {

	//extract the state for the chain id
	chainState, err := app.mmDB.GetCurrentEntry(q.ChainId)
	if err != nil {
		return nil, fmt.Errorf("chain id query, %v", err)
	}

	chainHeader := state.Chain{}
	err = chainHeader.UnmarshalBinary(chainState.Entry)
	if err != nil {
		return nil, fmt.Errorf("unable to extract chain header\n")
	}

	fmt.Printf("Query URI: %s", q.Query)
	return chainState.Entry, nil
}

//processValidatedSubmissionRequest Figure out what to do with the processed validated transaction.  This may include firing off a synthetic TX or simply
//updating the state of the transaction
func (app *Node) processValidatedSubmissionRequest(vdata *ResponseValidateTX) error {

	//need to pass this to a threaded batcher / dispatcher to do both signing and sending of synth tx.  No need to
	//spend valuable time here doing that.
	for i := range vdata.Submissions {
		//generate a synthetic tx and send to the router.
		//need to track txid to make sure they get processed....
		if app.leader {
			//we may want to reconsider making this a go call since using grpc could delay things considerably.
			//we only need to make sure it is processed by the next EndBlock so place in pending queue.

			//The validator must have created a valid request with the timestamp included
			if vdata.Submissions[i].Timestamp == 0 {
				return fmt.Errorf("invalid synthetic transaction request.  Timestamp not set")
			}

			//derive the ledger to sign the data.
			ledger := types.MarshalBinaryLedgerChainId(vdata.Submissions[i].Chainid, vdata.Submissions[i].Data,
				vdata.Submissions[i].Timestamp)

			///if we are the leader then we are responsible for dispatching the synth tx.
			vdata.Submissions[i].Signature = ed25519.Sign(app.key, ledger)

			if vdata.Submissions[i].Signature == nil {
				return fmt.Errorf("error signing validated submission request")
			}

			//using protobuffers grpc is quite slow, so we need to use batch and dispatch
			//buffering these calls up into a batch and send them out at the end of frame instead.
			app.RouterClient.ProcessTx(context.Background(), vdata.Submissions[i])
		}
	}
	return nil
}

// dialerFunc is a helper function for protobuffers
func dialerFunc(ctx context.Context, addr string) (net.Conn, error) {
	return tmnet.Connect(addr)
}

func (app *Node) createBootstrapAccount() {
	tokenUrl := "wileecoyote/ACME"
	adi, chainPath, err := types.ParseIdentityChainPath(&tokenUrl)
	if err != nil {
		panic(err)
	}

	is := state.NewIdentityState(adi)
	keyHash := sha256.Sum256(app.key)
	_ = is.SetKeyData(state.KeyTypeSha256, keyHash[:])
	idStateData, err := is.MarshalBinary()
	if err != nil {
		panic(err)
	}

	identity := types.GetIdentityChainFromIdentity(&adi)
	chainid := types.GetChainIdFromChainPath(&chainPath)

	ti := api.NewToken(chainPath, "ACME", 8)

	tas := state.NewToken(chainPath)
	tas.Precision = ti.Precision
	tas.Symbol = ti.Symbol
	tas.Meta = ti.Meta

	tasstatedata, err := tas.MarshalBinary()
	if err != nil {
		panic(err)
	}
	err = app.mmDB.AddStateEntry(identity[:], idStateData)
	if err != nil {
		panic(err)
	}
	err = app.mmDB.AddStateEntry(chainid[:], tasstatedata)
	if err != nil {
		panic(err)
	}
}
