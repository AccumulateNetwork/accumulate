# Signature Validation Implementation

## Metadata
- **Document Type**: Technical Implementation
- **Version**: 1.0
- **Last Updated**: 2025-05-17
- **Related Components**: Transaction Processing, Security, Identity Management
- **Code References**: `internal/core/execute/v2/block/sig_validator.go`, `protocol/signature.go`
- **Tags**: signature_validation, implementation, code_reference, security

## 1. Introduction

This document provides a detailed overview of how signature validation is implemented in the Accumulate codebase. It serves as a bridge between the conceptual architecture of signatures and keybooks and their actual implementation, helping developers understand the code structure and flow.

## 2. Code Structure Overview

Signature validation in Accumulate is implemented across several packages:

### 2.1 Key Packages

- **`protocol/`**: Contains core data structures for signatures, keybooks, and key pages
- **`internal/core/execute/v2/block/`**: Contains the execution logic for signature validation
- **`internal/core/execute/v2/chain/`**: Contains chain-specific signature validation logic

### 2.2 Key Files

- **`protocol/signature.go`**: Defines signature interfaces and types
- **`protocol/keypage.go`**: Defines key page and keybook structures
- **`internal/core/execute/v2/block/sig_validator.go`**: Implements signature validation logic
- **`internal/core/execute/v2/block/exec_validate.go`**: Integrates signature validation into transaction processing

## 3. Signature Interfaces and Types

The foundation of signature validation is the `Signature` interface defined in `protocol/signature.go`:

```go
// Signature is the interface implemented by all signature types.
type Signature interface {
    Type() SignatureType
    GetSignerVersion() uint64
    GetTimestamp() uint64
    GetPublicKey() []byte
    GetSignature() []byte
    GetSigner() *url.URL
    GetTransactionHash() [32]byte
    Hash() [32]byte
}
```

This interface is extended by more specific interfaces:

```go
// KeySignature is implemented by signatures that use a key.
type KeySignature interface {
    Signature
    GetPublicKeyHash() []byte
}

// PartitionSignature is a signature generated by a partition.
type PartitionSignature interface {
    Signature
    GetSourceNetwork() string
    GetDestinationNetwork() string
    GetSourceIndex() uint64
    GetSequence() uint64
    GetSequenceNumber() uint64
}
```

These interfaces provide the foundation for all signature types in the system.

## 4. Signature Validation Process

### 4.1 Validation Entry Point

The main entry point for signature validation is in `internal/core/execute/v2/block/exec_validate.go`:

```go
func (x *Executor) Validate(envelope *messaging.Envelope, _ bool) ([]*protocol.TransactionStatus, error) {
    batch := x.db.Begin(false)
    defer batch.Discard()

    messages, err := envelope.Normalize()
    if err != nil {
        return nil, errors.UnknownError.Wrap(err)
    }

    // Make sure every transaction is signed
    err = x.checkForUnsignedTransactions(messages)
    if err != nil {
        return nil, errors.UnknownError.Wrap(err)
    }

    // Set up the bundle
    d := new(bundle)
    d.Block = new(Block)
    d.Executor = x
    d.logger = x.logger

    // Validate each message
    statuses := make([]*protocol.TransactionStatus, len(messages))
    for i, msg := range messages {
        // Validate the message
        ctx := &MessageContext{bundle: d, message: msg}
        s, err := d.callMessageValidator(batch, ctx)
        // ... error handling and status processing
    }

    return statuses, nil
}
```

### 4.2 Signature Validation Flow

The signature validation process follows these steps:

1. **Message Normalization**: Convert the envelope into a normalized set of messages
2. **Check for Unsigned Transactions**: Ensure all transactions have signatures
3. **Message Validation**: For each message, validate its signatures
4. **Signature Type Dispatch**: Route to the appropriate validator based on signature type
5. **Signature Verification**: Verify the cryptographic signature
6. **Authority Verification**: Check that the signer has authority
7. **Threshold Evaluation**: For key pages, evaluate against thresholds

### 4.3 Key Signature Validation

The core validation for key signatures is implemented in `internal/core/execute/v1/block/signature.go`:

```go
// validateKeySignature verifies that the signature matches the signer state.
func validateKeySignature(transaction *protocol.Transaction, signer protocol.Signer, signature protocol.KeySignature) (protocol.KeyEntry, error) {
    // Check the version
    if transaction.Body.Type().IsUser() && signature.GetSignerVersion() != signer.GetVersion() {
        return nil, errors.BadSignerVersion.WithFormat("invalid version: have %d, got %d", signer.GetVersion(), signature.GetSignerVersion())
    }

    // Find the key entry
    _, entry, ok := signer.EntryByKeyHash(signature.GetPublicKeyHash())
    if !ok {
        return nil, errors.Unauthorized.With("key does not belong to signer")
    }

    // Check the timestamp
    if transaction.Body.Type() != protocol.TransactionTypeAcmeFaucet &&
        signature.GetTimestamp() != 0 &&
        entry.GetLastUsedOn() >= signature.GetTimestamp() {
        return nil, errors.BadTimestamp.WithFormat("invalid timestamp: have %d, got %d", entry.GetLastUsedOn(), signature.GetTimestamp())
    }

    return entry, nil
}
```

## 5. Threshold Signature Validation

Threshold signature validation is a key feature of Accumulate's signature system. The implementation evaluates signatures against the thresholds defined in key pages.

### 5.1 Threshold Evaluation

The threshold evaluation process is implemented in the transaction status tracking:

```go
// Simplified threshold evaluation logic
func evaluateThresholds(status *protocol.TransactionStatus, keyPage *protocol.KeyPage) {
    // Count valid signatures
    validSignatureCount := countValidSignatures(status)
    rejectSignatureCount := countRejectSignatures(status)
    
    // Evaluate against thresholds
    if validSignatureCount >= keyPage.AcceptThreshold {
        status.Accepted = true
    } else if rejectSignatureCount >= keyPage.RejectThreshold {
        status.Rejected = true
    }
}
```

### 5.2 Signature Collection

Signatures are collected and tracked in the transaction status:

```go
// From internal/core/execute/v2/block/sig_validator.go
func (x *SignatureValidator) CollectSignature(batch *database.Batch, ctx *block.SignatureContext, signature protocol.Signature) (*protocol.TransactionStatus, error) {
    // Get the transaction status
    status, err := x.GetStatus(batch, ctx.Transaction())
    if err != nil {
        return nil, errors.UnknownError.Wrap(err)
    }

    // Add the signature to the status
    status.AddSignature(signature)
    
    // Update the status
    err = batch.Put(status)
    if err != nil {
        return nil, errors.UnknownError.Wrap(err)
    }
    
    return status, nil
}
```

## 6. Delegation Validation

Delegation validation is a complex part of the signature system, involving verification of delegation relationships.

### 6.1 Delegate Verification

When a key delegates to another entity, the system verifies the delegation relationship:

```go
// From internal/core/execute/v2/chain/update_key.go
func verifyIsNotPage(auth *protocol.AccountAuth, delegate *url.URL) error {
    // Get the account
    account, err := auth.GetAccount(delegate)
    if err != nil {
        return errors.UnknownError.Wrap(err)
    }

    // Verify it's not a key page
    if _, ok := account.(*protocol.KeyPage); ok {
        return errors.BadRequest.WithFormat("cannot use a key page as a delegate")
    }
    return nil
}
```

### 6.2 Signer Authority Check

The system checks if a signer has authority to sign for a transaction:

```go
// From internal/core/execute/v2/chain/sig_validator.go
func (x *SignatureValidator) SignerCanSign(batch *database.Batch, ctx *block.SignatureContext, signer protocol.Signer) (bool, error) {
    // Get the transaction type
    txType := ctx.Transaction().Body.Type()
    
    // Find the appropriate executor
    exec, ok := getExecutor(x.Executors, txType)
    if !ok {
        return false, errors.BadRequest.WithFormat("unsupported transaction type %v", txType)
    }
    
    // Check if the signer can sign
    fallback, err := exec.SignerCanSign(x, batch, ctx.Transaction(), signer)
    if err != nil {
        return false, errors.UnknownError.Wrap(err)
    }
    
    return fallback, nil
}
```

## 7. Special Signature Types

Accumulate supports several special signature types with custom validation logic.

### 7.1 Synthetic Transaction Signatures

Synthetic transactions (cross-chain transactions) require special validation:

```go
// From internal/core/execute/v1/block/validate.go
func validateSyntheticTransactionSignatures(transaction *protocol.Transaction, signatures []protocol.Signature) error {
    var gotSynthSig, gotReceiptSig, gotED25519Sig bool
    for _, sig := range signatures {
        switch sig.(type) {
        case *protocol.PartitionSignature:
            gotSynthSig = true

        case *protocol.ReceiptSignature:
            gotReceiptSig = true

        case *protocol.ED25519Signature, *protocol.LegacyED25519Signature:
            gotED25519Sig = true

        default:
            return errors.BadRequest.WithFormat("synthetic transaction do not support %T signatures", sig)
        }
    }

    if !gotSynthSig {
        return errors.Unauthenticated.WithFormat("missing synthetic transaction origin")
    }
    if !gotED25519Sig {
        return errors.Unauthenticated.WithFormat("missing ED25519 signature")
    }
    if transaction.Body.Type() == protocol.TransactionTypeDirectoryAnchor || transaction.Body.Type() == protocol.TransactionTypeBlockValidatorAnchor {
        return nil
    }

    if !gotReceiptSig {
        return errors.Unauthenticated.WithFormat("missing synthetic transaction receipt")
    }
    return nil
}
```

### 7.2 Remote Signatures

Remote signatures allow for cross-chain authorization:

```go
// Remote signature validation (simplified)
func validateRemoteSignature(signature *protocol.RemoteSignature, context *ValidationContext) error {
    // Verify the origin chain
    if err := verifyOriginChain(signature.OriginChain, context); err != nil {
        return err
    }
    
    // Verify the signature proof
    if err := verifySignatureProof(signature.Proof, context); err != nil {
        return err
    }
    
    return nil
}
```

## 8. Integration with Transaction Processing

Signature validation is tightly integrated with transaction processing in the Accumulate protocol.

### 8.1 Transaction Status Tracking

The system tracks transaction status, including signature collection and threshold evaluation:

```go
// From protocol/transaction.go
func (s *TransactionStatus) AddSignature(sig protocol.Signature) {
    // Add the signature to the appropriate collection
    switch sig.Type() {
    case protocol.SignatureTypeED25519, protocol.SignatureTypeLegacyED25519, protocol.SignatureTypeRCD1:
        s.addKeySignature(sig.(protocol.KeySignature))
    case protocol.SignatureTypeDelegate:
        s.addDelegateSignature(sig.(*protocol.DelegatedSignature))
    // ... other signature types
    }
    
    // Update signature counts
    s.SignatureCount++
}
```

### 8.2 Transaction Execution

After signature validation, transaction execution proceeds:

```go
// From internal/core/execute/v2/block/exec.go
func (x *Executor) Execute(batch *database.Batch, ctx *BlockContext) error {
    // Validate signatures
    if err := x.validateSignatures(batch, ctx); err != nil {
        return errors.UnknownError.Wrap(err)
    }
    
    // Execute the transaction
    if err := x.executeTransaction(batch, ctx); err != nil {
        return errors.UnknownError.Wrap(err)
    }
    
    return nil
}
```

## 9. Performance Optimizations

The signature validation system includes several optimizations for performance.

### 9.1 Signature Caching

Validated signatures are cached to avoid redundant validation:

```go
// Signature caching (simplified)
func cacheSignature(signature protocol.Signature, result ValidationResult) {
    signatureHash := signature.Hash()
    signatureCache[signatureHash] = result
}

func getCachedSignature(signature protocol.Signature) (ValidationResult, bool) {
    signatureHash := signature.Hash()
    result, found := signatureCache[signatureHash]
    return result, found
}
```

### 9.2 Batch Processing

Signatures are processed in batches for efficiency:

```go
// From internal/core/execute/v2/block/exec_validate.go
func (x *Executor) Validate(envelope *messaging.Envelope, _ bool) ([]*protocol.TransactionStatus, error) {
    // ... initialization
    
    // Validate each message in a single batch
    statuses := make([]*protocol.TransactionStatus, len(messages))
    for i, msg := range messages {
        // ... validation
    }
    
    return statuses, nil
}
```

## 10. Error Handling

Robust error handling is critical for signature validation.

### 10.1 Error Types

The system defines specific error types for signature validation:

```go
// From errors/errors.go
var (
    // Unauthenticated indicates the request lacks valid authentication.
    Unauthenticated = Code("unauthenticated")

    // Unauthorized indicates the authenticated principal lacks permission.
    Unauthorized = Code("unauthorized")

    // BadSignature indicates the signature is invalid.
    BadSignature = Code("bad-signature")

    // BadTimestamp indicates the timestamp is invalid.
    BadTimestamp = Code("bad-timestamp")

    // BadSignerVersion indicates the signer version is invalid.
    BadSignerVersion = Code("bad-signer-version")
)
```

### 10.2 Error Wrapping

Errors are wrapped to provide context:

```go
// From internal/core/execute/v2/block/sig_validator.go
func (x *SignatureValidator) ValidateKeySignature(batch *database.Batch, ctx *block.SignatureContext, keySignature protocol.KeySignature) (*protocol.TransactionStatus, error) {
    // Get the signer
    signer, err := x.GetSigner(batch, ctx, keySignature)
    if err != nil {
        return nil, errors.UnknownError.Wrap(err)
    }

    // Validate the signature
    entry, err := block.ValidateKeySignature(ctx.Transaction(), signer, keySignature)
    if err != nil {
        return nil, errors.UnknownError.Wrap(err)
    }
    
    // ... additional validation
}
```

## Related Documents

- [Keybooks and Signatures](../../02_architecture/02_signatures/01_keybooks_and_signatures.md)
- [Advanced Signature Validation](../../02_architecture/02_signatures/02_advanced_signature_validation.md)
- [Key Rotation Strategies](../../02_architecture/02_signatures/03_key_rotation_strategies.md)
- [Delegation Patterns](../../02_architecture/02_signatures/04_delegation_patterns.md)
- [Transaction Processing](../03_transaction_processing.md)
- [Transaction Validation Process](../../04_network/05_consensus/05_02_validation_process.md)
- [Transaction Processing Deep Dive](../../04_network/05_consensus/05_01_transaction_processing_deep_dive.md)
