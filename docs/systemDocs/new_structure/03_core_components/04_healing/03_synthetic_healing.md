# Synthetic Transaction Healing

## Introduction

Synthetic transaction healing is a critical process in Accumulate that ensures protocol-generated transactions are properly delivered across all partitions. This document provides a detailed explanation of the synthetic transaction healing process, its implementation, and how it works.

## What are Synthetic Transactions?

Synthetic transactions are transactions that are generated by the Accumulate protocol itself, rather than by users. They serve various internal purposes:

1. **Cross-Partition Operations**: Transactions that need to be executed across multiple partitions
2. **System Maintenance**: Transactions for maintaining the health of the network
3. **Protocol Updates**: Transactions related to protocol upgrades and changes

## Synthetic Healing Process Flow

The synthetic transaction healing process follows these steps:

1. **Initialization**: Set up the healer structure and identify valid partition pairs
2. **Transaction Discovery**: Find missing transactions between partitions using a binary search algorithm
3. **Transaction Fetching**: Retrieve transaction data from the source partition
4. **Transaction Healing**: Submit transactions to the destination partition
5. **Status Tracking**: Monitor and report on healing progress

## Core Implementation

The core implementation of synthetic transaction healing is in the `internal/core/healing/synthetic.go` file:

```go
// From internal/core/healing/synthetic.go
func (h *Healer) HealSynthetic(ctx context.Context, args HealSyntheticArgs, si SequencedInfo) error {
    if args.Querier == nil {
        args.Querier = args.Client
    }
    if args.Submitter == nil {
        args.Submitter = args.Client
    }

    // Query the synthetic transaction
    r, err := ResolveSequenced[messaging.Message](ctx, args.Client, args.NetInfo, si.Source, si.Destination, si.Number, false)
    if err != nil {
        return err
    }
    si.ID = r.ID

    // Query the status
    Q := api.Querier2{Querier: args.Querier}
    if s, err := Q.QueryMessage(ctx, r.ID, nil); err == nil &&
        // Has it already been delivered?
        s.Status.Delivered() &&
        // Does the sequence info match?
        s.Sequence != nil &&
        s.Sequence.Source.Equal(protocol.PartitionUrl(si.Source)) &&
        s.Sequence.Destination.Equal(protocol.PartitionUrl(si.Destination)) &&
        s.Sequence.Number == si.Number {
        // If it's been delivered, skip it
        slog.InfoContext(ctx, "Synthetic message has been delivered", "id", si.ID, "source", si.Source, "destination", si.Destination, "number", si.Number)
        return errors.Delivered
    }

    // Build the receipt
    var receipt *merkle.Receipt
    if args.NetInfo.Status.ExecutorVersion.V2VandenbergEnabled() {
        receipt, err = h.buildSynthReceiptV2(ctx, args, si)
    } else {
        receipt, err = h.buildSynthReceiptV1(ctx, args, si)
    }
    if err != nil {
        return err
    }

    // Submit the synthetic transaction
    // ...
}
```

## Transaction Discovery Algorithm

The synthetic healing process uses a binary search algorithm to efficiently identify missing transactions:

```go
// From tools/cmd/debug/heal_common.go
func (h *healer) findMissingSynth(src, dst string, begin, end uint64) ([]uint64, error) {
    if begin >= end {
        return nil, nil
    }

    // Check if the range is small enough to enumerate
    if end-begin <= 10 {
        var missing []uint64
        for i := begin; i < end; i++ {
            delivered, err := h.isDelivered(src, dst, i)
            if err != nil {
                return nil, err
            }
            if !delivered {
                missing = append(missing, i)
            }
        }
        return missing, nil
    }

    // Binary search for missing transactions
    mid := (begin + end) / 2
    left, err := h.findMissingSynth(src, dst, begin, mid)
    if err != nil {
        return nil, err
    }
    right, err := h.findMissingSynth(src, dst, mid, end)
    if err != nil {
        return nil, err
    }

    return append(left, right...), nil
}
```

This algorithm recursively divides the search space in half until it finds small ranges where it can directly check for missing transactions. This approach is much more efficient than checking each transaction individually, especially for large ranges.

## Transaction Fetching

Once missing transactions are identified, they need to be fetched from the source partition:

```go
// From tools/cmd/debug/heal_common.go
func (f *txFetcher) fetchTransaction(ctx context.Context, id *url.TxID) (*protocol.Transaction, error) {
    // Try to get the transaction from the cache first
    txn, found := f.Cache.Get(id.String())
    if found {
        return txn, nil
    }

    // If not in cache, fetch it from the network
    res, err := f.Client.QueryTransaction(ctx, id, api.QueryOptions{
        IncludeReceipt: false,
    })
    if err != nil {
        return nil, err
    }

    // Add to cache for future use
    f.Cache.Add(id.String(), res.Transaction)
    return res.Transaction, nil
}
```

The fetching process uses a cache to avoid repeated network requests for the same transaction, improving performance significantly.

## Transaction Healing

The actual healing of a synthetic transaction involves submitting it to the destination partition:

```go
// From tools/cmd/debug/heal_synth.go
func healSingleSynth(h *healer, source, destination string, number uint64, id *url.TxID, txns map[[32]byte]*protocol.Transaction) bool {
    // Increment the transaction submitted counter
    h.txSubmitted++
    
    // Update pair statistics
    pairKey := fmt.Sprintf("%s:%s", source, destination)
    if pairStat, ok := h.pairStats[pairKey]; ok {
        pairStat.TxSubmitted++
        pairStat.LastUpdated = time.Now()
    }
    
    // Attempt to heal the transaction
    err := healing.HealTransaction(h.ctx, healing.HealTransactionArgs{
        Client:  h.C2.ForAddress(nil),
        Source:  source,
        Dest:    destination,
        TxID:    id,
        Number:  number,
        TxnMap:  txns,
    })
    
    // Handle the result
    if err == nil {
        // Successfully healed
        h.txDelivered++
        h.totalHealed++
        
        // Update pair statistics
        if pairStat, ok := h.pairStats[pairKey]; ok {
            pairStat.TxDelivered++
            pairStat.CurrentDelivered = number
            pairStat.LastUpdated = time.Now()
        }
        
        return false
    }
    
    // Handle various error conditions
    // ...
}
```

This function submits the transaction to the destination partition and updates various statistics based on the result.

## Receipt Building

A critical part of synthetic transaction healing is building a cryptographic receipt that proves the transaction's validity:

```go
// From internal/core/healing/synthetic.go
func (h *Healer) buildSynthReceiptV2(_ context.Context, args HealSyntheticArgs, si SequencedInfo) (*merkle.Receipt, error) {
    batch := args.Light.OpenDB(false)
    defer batch.Discard()
    uSrc := protocol.PartitionUrl(si.Source)
    uSrcSys := uSrc.JoinPath(protocol.Ledger)
    uSrcSynth := uSrc.JoinPath(protocol.Synthetic)
    uDn := protocol.DnUrl()
    uDnSys := uDn.JoinPath(protocol.Ledger)
    uDnAnchor := uDn.JoinPath(protocol.AnchorPool)

    // Load the synthetic sequence chain entry
    b, err := batch.Account(uSrcSynth).SyntheticSequenceChain(si.Destination).Entry(int64(si.Number) - 1)
    if err != nil {
        return nil, errors.UnknownError.WithFormat(
            "load synthetic sequence chain entry %d: %w", si.Number, err)
    }
    seqEntry := new(protocol.IndexEntry)
    err = seqEntry.UnmarshalBinary(b)
    if err != nil {
        return nil, err
    }

    // Build the synthetic ledger part of the receipt
    receipt, err := batch.Account(uSrcSynth).MainChain().Receipt(seqEntry.Source, mainIndex.Source)
    if err != nil {
        return nil, errors.UnknownError.WithFormat(
            "build synthetic ledger receipt: %w", err)
    }

    // Build the BVN part of the receipt
    bvnReceipt, err := batch.Account(uSrcSys).RootChain().Receipt(mainIndex.Anchor, bvnRootIndex.Source)
    if err != nil {
        return nil, errors.UnknownError.WithFormat(
            "build BVN receipt: %w", err)
    }
    receipt, err = receipt.Combine(bvnReceipt)
    if err != nil {
        return nil, errors.UnknownError.WithFormat(
            "append BVN receipt: %w", err)
    }

    // Additional receipt building steps
    // ...

    return receipt, nil
}
```

The receipt building process combines multiple receipts from different chains to create a complete proof that can be verified by the destination partition.

## CLI Implementation

The synthetic transaction healing process is exposed through a command-line interface in `tools/cmd/debug/heal_synth.go`:

```go
// From tools/cmd/debug/heal_synth.go
func healSynth(cmd *cobra.Command, args []string) {
    // Parse command-line arguments
    // ...

    // Create a healer instance
    h := &healer{
        ctx:      ctx,
        C1:       client,
        C2:       client,
        net:      networkInfo,
        pairStats: make(map[string]*PartitionPairStats),
        fetcher:  newTxFetcher(client),
        startTime: time.Now(),
    }

    // Initialize partition pairs
    // ...

    // Set up periodic reporting
    reportTicker := time.NewTicker(reportInterval)
    defer reportTicker.Stop()
    
    // Print startup message
    // ...

    // Run the healing process
    h.heal(args)
    
    // Print a final report
    // ...
}
```

This CLI implementation provides a user-friendly interface for running the synthetic transaction healing process.

## Performance Considerations

The synthetic transaction healing process includes several optimizations for performance:

1. **Binary Search Algorithm**: Efficiently identifies missing transactions without checking each one individually
2. **Transaction Cache**: Avoids repeated network requests for the same transaction
3. **Batch Processing**: Processes multiple transactions in batches for efficiency
4. **Light Client Database**: Uses a light client database for efficient chain access

## Error Handling

The synthetic transaction healing process includes robust error handling:

```go
// From tools/cmd/debug/heal_synth.go
if err != nil {
    if errors.Is(err, errors.Delivered) {
        // Transaction already delivered
        h.txDelivered++
        h.totalHealed++
        
        // Update pair statistics
        // ...
        
        return true
    }
    
    if errors.Is(err, errors.NotFound) {
        // Transaction not found
        h.totalFailed++
        
        // Update pair statistics
        // ...
        
        return false
    }
    
    // Other errors
    h.totalFailed++
    
    // Update pair statistics
    // ...
    
    return false
}
```

This error handling ensures that the process can continue even if individual transactions fail to heal.

## Recent Changes

Recent changes to the synthetic transaction healing process include:

1. **Improved Reporting**: Enhanced reporting to provide more detailed information about the healing process
2. **ASCII Formatting**: Updated report formatting to use ASCII characters for better terminal compatibility
3. **Timestamp Formatting**: Improved timestamp formatting for readability
4. **Partition Pair Tracking**: Enhanced tracking of partition pairs to ensure all pairs are included in reports

## Conclusion

Synthetic transaction healing is a critical process in Accumulate that ensures protocol-generated transactions are properly delivered across all partitions. By understanding this process, developers and AI systems can better work with the healing code and contribute to its improvement.

In the next document, we will explore the anchor healing process, which ensures that cryptographic commitments between partitions are properly maintained.
