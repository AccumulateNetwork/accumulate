# Accumulate Healing Processes: Technical Documentation

## Overview

This document provides a comprehensive technical overview of the healing processes implemented in Accumulate. It covers both synthetic transaction healing and anchor healing mechanisms, focusing on the implementation details, algorithms, data structures, and reporting systems. This document is optimized for AI consumption, with clear structure and detailed explanations of code patterns.

## Table of Contents

1. [Introduction to Healing in Accumulate](#introduction)
2. [Common Healing Infrastructure](#common-infrastructure)
3. [Synthetic Transaction Healing](#synthetic-healing)
4. [Anchor Healing](#anchor-healing)
5. [Reporting System](#reporting-system)
6. [Metrics and Statistics](#metrics)
7. [Implementation Details](#implementation)
8. [Usage Examples](#usage)

## Introduction to Healing in Accumulate <a name="introduction"></a>

Accumulate is a distributed ledger technology that uses a multi-chain architecture with a Directory Network (DN) and multiple Blockchain Validation Networks (BVNs). The healing processes are essential maintenance operations that ensure data consistency across the network by repairing missing or undelivered transactions and anchors.

### Key Concepts

- **Synthetic Transactions**: Transactions that are generated by the protocol rather than by users, typically for internal operations.
- **Anchors**: Cryptographic commitments that link blocks across different partitions, ensuring data integrity and enabling cross-chain validation.
- **Healing**: The process of identifying and repairing missing or undelivered transactions or anchors between partitions.
- **Partition Pairs**: Valid combinations of source and destination partitions for transaction or anchor delivery (DN→BVN or BVN→DN).

## Common Healing Infrastructure <a name="common-infrastructure"></a>

Both healing processes share common infrastructure defined in `heal_common.go`. This section details the shared components.

### The Healer Structure

```go
type healer struct {
    ctx             context.Context
    C1, C2          client.Client
    net             *networkInfo
    txSubmitted     int
    txDelivered     int
    totalHealed     int
    totalFailed     int
    totalMissing    int
    initialDelivered int
    initialTotalDelivered int
    pairStats       map[string]*PartitionPairStats
    fetcher         *txFetcher
    // ... other fields
}
```

The `healer` structure is the core component that manages the healing process. It maintains:
- Network connections and state
- Transaction counters and statistics
- Partition pair statistics
- Transaction fetching mechanisms

### Partition Pair Statistics

```go
type PartitionPairStats struct {
    Source           string
    Destination      string
    InitialDelivered uint64
    CurrentDelivered uint64
    TotalProduced    uint64
    LastUpdated      time.Time
    IsUpToDate       bool
    TxSubmitted      int
    TxDelivered      int
    TxFailed         int
}
```

This structure tracks healing statistics for each valid partition pair, including:
- Initial and current delivered transaction heights
- Total produced transaction height
- Success/failure counters
- Status indicators
- Timestamp information

### Initialization Process

The healing process begins with initialization of valid partition pairs:

```go
// Initialize all valid anchor partition pairs to ensure complete reporting
for _, src := range h.net.Status.Network.Partitions {
    for _, dst := range h.net.Status.Network.Partitions {
        // Skip self pairs
        if src.ID == dst.ID {
            continue
        }
        
        // Skip BVN to BVN pairs (not valid for anchoring)
        if src.Type != protocol.PartitionTypeDirectory && dst.Type != protocol.PartitionTypeDirectory {
            continue
        }
        
        // Create a key for this partition pair
        pairKey := fmt.Sprintf("%s:%s", src.ID, dst.ID)
        
        // If this pair doesn't exist in stats yet, add it
        if _, exists := h.pairStats[pairKey]; !exists {
            h.pairStats[pairKey] = &PartitionPairStats{
                Source:      src.ID,
                Destination: dst.ID,
                LastUpdated: time.Now(),
                IsUpToDate:  false, // Assume not up to date until verified
            }
        }
    }
}
```

This ensures that all valid partition pairs (DN→BVN and BVN→DN) are included in the healing process and reporting, even if they haven't been processed yet.

### Reporting Infrastructure

Both healing processes use a common reporting infrastructure that includes:

1. **Detailed Reports**: Comprehensive statistics about the healing process
2. **Periodic Reports**: Regular updates during long-running healing operations
3. **Success Rate Calculations**: Metrics to evaluate healing effectiveness

## Synthetic Transaction Healing <a name="synthetic-healing"></a>

Synthetic transaction healing focuses on ensuring that protocol-generated transactions are properly delivered across the network.

### Process Flow

1. **Initialization**: Set up the healer structure and identify valid partition pairs
2. **Transaction Discovery**: Find missing transactions between partitions
3. **Transaction Fetching**: Retrieve transaction data from the source partition
4. **Transaction Healing**: Submit transactions to the destination partition
5. **Status Tracking**: Monitor and report on healing progress

### Transaction Discovery Algorithm

The synthetic healing process uses a binary search algorithm to efficiently identify missing transactions:

```go
func (h *healer) findMissingSynth(src, dst string, begin, end uint64) ([]uint64, error) {
    if begin >= end {
        return nil, nil
    }

    // Check if the range is small enough to enumerate
    if end-begin <= 10 {
        var missing []uint64
        for i := begin; i < end; i++ {
            delivered, err := h.isDelivered(src, dst, i)
            if err != nil {
                return nil, err
            }
            if !delivered {
                missing = append(missing, i)
            }
        }
        return missing, nil
    }

    // Binary search for missing transactions
    mid := (begin + end) / 2
    left, err := h.findMissingSynth(src, dst, begin, mid)
    if err != nil {
        return nil, err
    }
    right, err := h.findMissingSynth(src, dst, mid, end)
    if err != nil {
        return nil, err
    }

    return append(left, right...), nil
}
```

This algorithm recursively divides the search space in half until it finds small ranges where it can directly check for missing transactions.

### Transaction Healing Implementation

Once missing transactions are identified, the healing process attempts to deliver them:

```go
func healSingleSynth(h *healer, source, destination string, number uint64, id *url.TxID, txns map[[32]byte]*protocol.Transaction) bool {
    // Increment the transaction submitted counter
    h.txSubmitted++
    
    // Update pair statistics
    pairKey := fmt.Sprintf("%s:%s", source, destination)
    if pairStat, ok := h.pairStats[pairKey]; ok {
        pairStat.TxSubmitted++
        pairStat.LastUpdated = time.Now()
    }
    
    // Attempt to heal the transaction
    err := healing.HealTransaction(h.ctx, healing.HealTransactionArgs{
        Client:  h.C2.ForAddress(nil),
        Source:  source,
        Dest:    destination,
        TxID:    id,
        Number:  number,
        TxnMap:  txns,
    })
    
    // Handle the result
    if err == nil {
        // Successfully healed
        h.txDelivered++
        h.totalHealed++
        
        // Update pair statistics
        if pairStat, ok := h.pairStats[pairKey]; ok {
            pairStat.TxDelivered++
            pairStat.CurrentDelivered = number
            pairStat.LastUpdated = time.Now()
        }
        
        return false
    }
    
    // Handle various error conditions
    // ...
}
```

## Anchor Healing <a name="anchor-healing"></a>

Anchor healing ensures that cryptographic commitments between partitions are properly maintained, which is critical for cross-chain validation.

### Process Flow

1. **Initialization**: Set up the healer structure and identify valid partition pairs (DN→BVN and BVN→DN only)
2. **Anchor Discovery**: Find missing anchors between partitions
3. **Anchor Fetching**: Retrieve anchor data from the source partition
4. **Anchor Healing**: Submit anchors to the destination partition
5. **Status Tracking**: Monitor and report on healing progress

### Anchor Healing Implementation

The anchor healing process is similar to synthetic transaction healing but focuses specifically on anchor transactions:

```go
func (h *healer) healSingleAnchor(srcId, dstId string, seqNum uint64, txid *url.TxID, txns map[[32]byte]*protocol.Transaction) bool {
    // Increment the transaction submitted counter
    h.txSubmitted++
    
    // Update pair statistics
    pairKey := fmt.Sprintf("%s:%s", srcId, dstId)
    if pairStat, ok := h.pairStats[pairKey]; ok {
        pairStat.TxSubmitted++
        pairStat.LastUpdated = time.Now()
    }
    
    // Attempt to heal the anchor
    err := healing.HealAnchor(h.ctx, healing.HealAnchorArgs{
        Client:  h.C2.ForAddress(nil),
        Source:  srcId,
        Dest:    dstId,
        Number:  seqNum,
        TxnMap:  txns,
        ID:      txid,
    })
    
    // Handle the result
    if err == nil {
        // Successfully healed the anchor
        h.txDelivered++
        h.totalHealed++
        
        // Update pair statistics
        if pairStat, ok := h.pairStats[pairKey]; ok {
            pairStat.TxDelivered++
            pairStat.CurrentDelivered = seqNum
            pairStat.LastUpdated = time.Now()
        }
        
        return false
    }
    
    // Handle various error conditions
    // ...
}
```

### Valid Partition Pairs for Anchoring

A critical aspect of anchor healing is that it only operates on valid partition pairs:

```go
// Skip BVN to BVN pairs (not valid for anchoring)
if src.Type != protocol.PartitionTypeDirectory && dst.Type != protocol.PartitionTypeDirectory {
    continue
}
```

This ensures that only DN→BVN and BVN→DN anchor paths are processed, as BVN→BVN anchoring is not part of the Accumulate protocol.

## Reporting System <a name="reporting-system"></a>

The reporting system provides visibility into the healing process through detailed and periodic reports.

### Detailed Report Format

```
+-----------------------------------------------------------+
|                DETAILED HEALING REPORT                    |
+-----------------------------------------------------------+
* Total Runtime: 1h0m0s

* DELIVERY STATUS:
   Initial Delivered: 10000
   Current Delivered: 10500
   Transactions Healed: 500

* PARTITION PAIR STATUS:
   Total Valid Anchor Partition Pairs: 6
   Up to Date: 2
   Needs Healing: 4

   DETAILED PARTITION PAIR STATUS:
   Apollo -> Directory:
     Status: Up to date
     Delivered Height: 10000 -> 10000 (no change)
     Produced Height: 11000
     Delivery Gap: 1000
     Last Updated: 2025-05-11 22:12:00

   Directory -> Apollo:
     Status: Needs healing
     Delivered Height: 10000 -> 10500 (+500)
     Produced Height: 11000
     Delivery Gap: 500
     Last Updated: 2025-05-11 22:12:00

   ... other partition pairs ...

+-----------------------------------------------------------+
|                    END OF REPORT                          |
+-----------------------------------------------------------+
```

### Periodic Report Format

```
+------------------- PERIODIC HEALING REPORT -------------------+
Healing progress: 1000 missing, 500 healed, 50 failed (500 transactions healed)
Transaction statistics: 1200 submitted, 600 delivered

* Pausing between healing runs at 2025-05-11 22:12:00...
```

### Report Implementation

The reporting system uses ASCII characters for maximum terminal compatibility:

```go
func (h *healer) printDetailedReport() {
    // Print a header for the report with distinctive formatting
    fmt.Println()
    color.New(color.FgHiCyan).Add(color.Bold).Println("+-----------------------------------------------------------+")
    color.New(color.FgHiCyan).Add(color.Bold).Println("|                DETAILED HEALING REPORT                    |")
    color.New(color.FgHiCyan).Add(color.Bold).Println("+-----------------------------------------------------------+")
    
    // Calculate and print the total runtime
    runtime := time.Since(h.startTime)
    color.New(color.FgHiWhite).Add(color.Bold).Print("* Total Runtime: ")
    color.New(color.FgHiYellow).Println(runtime.Round(time.Second))
    
    // Print delivery statistics
    // ...
    
    // Print partition pair statistics
    // ...
}
```

## Metrics and Statistics <a name="metrics"></a>

The healing processes track various metrics to evaluate performance and effectiveness:

### Transaction Metrics

- **Submitted**: Number of transactions submitted for healing
- **Delivered**: Number of transactions successfully delivered
- **Failed**: Number of transactions that failed to heal
- **Success Rate**: Percentage of successful healing attempts

### Partition Pair Metrics

- **Initial Delivered**: Transaction height at the start of healing
- **Current Delivered**: Current transaction height after healing
- **Total Produced**: Total number of transactions produced
- **Delivery Gap**: Difference between produced and delivered transactions
- **Up to Date Status**: Whether the partition pair is fully synchronized

## Implementation Details <a name="implementation"></a>

### Key Files

- **heal_common.go**: Common infrastructure for both healing processes
- **heal_synth.go**: Synthetic transaction healing implementation
- **heal_anchor.go**: Anchor healing implementation

### Command-Line Interface

The healing processes are exposed through a command-line interface:

```
./tools/cmd/debug/debug heal synth mainnet --report-interval=1
./tools/cmd/debug/debug heal anchor mainnet --report-interval=1
```

### Configuration Options

- **Network**: Target network (mainnet, testnet, etc.)
- **Report Interval**: Frequency of periodic reports in minutes
- **Since**: Time frame for healing (for synthetic transactions)

## Usage Examples <a name="usage"></a>

### Synthetic Transaction Healing

```bash
# Basic synthetic healing
./tools/cmd/debug/debug heal synth mainnet

# With periodic reporting every 5 minutes
./tools/cmd/debug/debug heal synth mainnet --report-interval=5

# Healing transactions since a specific time
./tools/cmd/debug/debug heal synth mainnet --since=24h
```

### Anchor Healing

```bash
# Basic anchor healing
./tools/cmd/debug/debug heal anchor mainnet

# With periodic reporting every 5 minutes
./tools/cmd/debug/debug heal anchor mainnet --report-interval=5
```

## Conclusion

The healing processes in Accumulate are critical maintenance operations that ensure data consistency and integrity across the network. By efficiently identifying and repairing missing transactions and anchors, these processes help maintain the reliability and security of the distributed ledger.

This document provides a comprehensive overview of the implementation details, algorithms, and reporting systems used in both synthetic transaction healing and anchor healing. It serves as a reference for understanding and working with these processes.
