// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package light

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"io"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type AnchorMetadata struct {
	fieldsSet   []bool
	Index       uint64                    `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Hash        [32]byte                  `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	Anchor      *protocol.PartitionAnchor `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	Transaction *protocol.Transaction     `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	extraData   []byte
}

var machine_AnchorMetadata = &encoding.Machine[*AnchorMetadata]{
	ExtraData: func(v *AnchorMetadata) *[]byte { return &v.extraData },
	Seen:      func(v *AnchorMetadata) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*AnchorMetadata]{
		{Name: "Index", Number: 1, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.UintField[*AnchorMetadata](func(v *AnchorMetadata) *uint64 { return &v.Index })},
		{Name: "Hash", Number: 2, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.HashField[*AnchorMetadata](func(v *AnchorMetadata) *[32]byte { return &v.Hash })},
		{Name: "Anchor", Number: 3, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.StructPtrField[*AnchorMetadata, *protocol.PartitionAnchor, protocol.PartitionAnchor](func(v *AnchorMetadata) **protocol.PartitionAnchor { return &v.Anchor })},
		{Name: "Transaction", Number: 4, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.StructPtrField[*AnchorMetadata, *protocol.Transaction, protocol.Transaction](func(v *AnchorMetadata) **protocol.Transaction { return &v.Transaction })},
	},
}

func (v *AnchorMetadata) IsValid() error               { return machine_AnchorMetadata.IsValid(v) }
func (v *AnchorMetadata) Copy() *AnchorMetadata        { return encoding.Copy(machine_AnchorMetadata, v) }
func (v *AnchorMetadata) CopyAsInterface() interface{} { return v.Copy() }
func (v *AnchorMetadata) Equal(u *AnchorMetadata) bool { return machine_AnchorMetadata.Equal(v, u) }
func (v *AnchorMetadata) MarshalBinary() ([]byte, error) {
	return machine_AnchorMetadata.MarshalBinary(v)
}
func (v *AnchorMetadata) UnmarshalBinary(data []byte) error {
	return machine_AnchorMetadata.Unmarshal(data, v)
}
func (v *AnchorMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	return machine_AnchorMetadata.UnmarshalFrom(rd, v)
}
func (v *AnchorMetadata) MarshalJSON() ([]byte, error) { return machine_AnchorMetadata.JSONMarshal(v) }
func (v *AnchorMetadata) UnmarshalJSON(b []byte) error {
	return machine_AnchorMetadata.JSONUnmarshal(b, v)
}

type EventMetadata struct {
	fieldsSet      []bool
	LocalBlock     uint64    `json:"localBlock,omitempty" form:"localBlock" query:"localBlock" validate:"required"`
	LocalTime      time.Time `json:"localTime,omitempty" form:"localTime" query:"localTime" validate:"required"`
	DirectoryBlock uint64    `json:"directoryBlock,omitempty" form:"directoryBlock" query:"directoryBlock" validate:"required"`
	DirectoryTime  time.Time `json:"directoryTime,omitempty" form:"directoryTime" query:"directoryTime" validate:"required"`
	extraData      []byte
}

var machine_EventMetadata = &encoding.Machine[*EventMetadata]{
	ExtraData: func(v *EventMetadata) *[]byte { return &v.extraData },
	Seen:      func(v *EventMetadata) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*EventMetadata]{
		{Name: "LocalBlock", Number: 1, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.UintField[*EventMetadata](func(v *EventMetadata) *uint64 { return &v.LocalBlock })},
		{Name: "LocalTime", Number: 2, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.TimeField[*EventMetadata](func(v *EventMetadata) *time.Time { return &v.LocalTime })},
		{Name: "DirectoryBlock", Number: 3, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.UintField[*EventMetadata](func(v *EventMetadata) *uint64 { return &v.DirectoryBlock })},
		{Name: "DirectoryTime", Number: 4, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.TimeField[*EventMetadata](func(v *EventMetadata) *time.Time { return &v.DirectoryTime })},
	},
}

func (v *EventMetadata) IsValid() error               { return machine_EventMetadata.IsValid(v) }
func (v *EventMetadata) Copy() *EventMetadata         { return encoding.Copy(machine_EventMetadata, v) }
func (v *EventMetadata) CopyAsInterface() interface{} { return v.Copy() }
func (v *EventMetadata) Equal(u *EventMetadata) bool  { return machine_EventMetadata.Equal(v, u) }
func (v *EventMetadata) MarshalBinary() ([]byte, error) {
	return machine_EventMetadata.MarshalBinary(v)
}
func (v *EventMetadata) UnmarshalBinary(data []byte) error {
	return machine_EventMetadata.Unmarshal(data, v)
}
func (v *EventMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	return machine_EventMetadata.UnmarshalFrom(rd, v)
}
func (v *EventMetadata) MarshalJSON() ([]byte, error) { return machine_EventMetadata.JSONMarshal(v) }
func (v *EventMetadata) UnmarshalJSON(b []byte) error {
	return machine_EventMetadata.JSONUnmarshal(b, v)
}
