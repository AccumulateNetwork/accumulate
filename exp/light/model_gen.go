// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package light

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

//lint:file-ignore S1008,U1000 generated code

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	record "gitlab.com/accumulatenetwork/accumulate/pkg/database"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/values"
	"gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type IndexDB struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key

	account     map[indexDBAccountMapKey]*IndexDBAccount
	partition   map[indexDBPartitionMapKey]*IndexDBPartition
	transaction map[indexDBTransactionMapKey]*IndexDBTransaction
}

func (c *IndexDB) Key() *record.Key { return c.key }

type indexDBAccountKey struct {
	Url *url.URL
}

type indexDBAccountMapKey struct {
	Url [32]byte
}

func (k indexDBAccountKey) ForMap() indexDBAccountMapKey {
	return indexDBAccountMapKey{values.MapKeyUrl(k.Url)}
}

type indexDBPartitionKey struct {
	Url *url.URL
}

type indexDBPartitionMapKey struct {
	Url [32]byte
}

func (k indexDBPartitionKey) ForMap() indexDBPartitionMapKey {
	return indexDBPartitionMapKey{values.MapKeyUrl(k.Url)}
}

type indexDBTransactionKey struct {
	Hash [32]byte
}

type indexDBTransactionMapKey struct {
	Hash [32]byte
}

func (k indexDBTransactionKey) ForMap() indexDBTransactionMapKey {
	return indexDBTransactionMapKey{k.Hash}
}

func (c *IndexDB) Account(url *url.URL) *IndexDBAccount {
	return values.GetOrCreateMap(c, &c.account, indexDBAccountKey{url}, (*IndexDB).newAccount)
}

func (c *IndexDB) newAccount(k indexDBAccountKey) *IndexDBAccount {
	v := new(IndexDBAccount)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Account", k.Url)
	v.parent = c
	return v
}

func (c *IndexDB) Partition(url *url.URL) *IndexDBPartition {
	return values.GetOrCreateMap(c, &c.partition, indexDBPartitionKey{url}, (*IndexDB).newPartition)
}

func (c *IndexDB) newPartition(k indexDBPartitionKey) *IndexDBPartition {
	v := new(IndexDBPartition)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Partition", k.Url)
	v.parent = c
	return v
}

func (c *IndexDB) Transaction(hash [32]byte) *IndexDBTransaction {
	return values.GetOrCreateMap(c, &c.transaction, indexDBTransactionKey{hash}, (*IndexDB).newTransaction)
}

func (c *IndexDB) newTransaction(k indexDBTransactionKey) *IndexDBTransaction {
	v := new(IndexDBTransaction)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Transaction", k.Hash)
	v.parent = c
	return v
}

func (c *IndexDB) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for index db (1)")
	}

	switch key.Get(0) {
	case "Account":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for index db (2)")
		}
		url, okUrl := key.Get(1).(*url.URL)
		if !okUrl {
			return nil, nil, errors.InternalError.With("bad key for index db (3)")
		}
		v := c.Account(url)
		return v, key.SliceI(2), nil
	case "Partition":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for index db (4)")
		}
		url, okUrl := key.Get(1).(*url.URL)
		if !okUrl {
			return nil, nil, errors.InternalError.With("bad key for index db (5)")
		}
		v := c.Partition(url)
		return v, key.SliceI(2), nil
	case "Transaction":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for index db (6)")
		}
		hash, okHash := key.Get(1).([32]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for index db (7)")
		}
		v := c.Transaction(hash)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for index db (8)")
	}
}

func (c *IndexDB) IsDirty() bool {
	if c == nil {
		return false
	}

	for _, v := range c.account {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.partition {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *IndexDB) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkMap(&err, c.account, c.newAccount, nil, opts, fn)
	values.WalkMap(&err, c.partition, c.newPartition, nil, opts, fn)
	values.WalkMap(&err, c.transaction, c.newTransaction, nil, opts, fn)
	return err
}

func (c *IndexDB) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	for _, v := range c.account {
		values.Commit(&err, v)
	}
	for _, v := range c.partition {
		values.Commit(&err, v)
	}
	for _, v := range c.transaction {
		values.Commit(&err, v)
	}

	return err
}

type IndexDBAccount struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDB

	didIndexTransactionExecution values.Set[[32]byte]
	didLoadTransaction           values.Set[[32]byte]
	chain                        map[indexDBAccountChainMapKey]*IndexDBAccountChain
}

func (c *IndexDBAccount) Key() *record.Key { return c.key }

type indexDBAccountChainKey struct {
	Name string
}

type indexDBAccountChainMapKey struct {
	Name string
}

func (k indexDBAccountChainKey) ForMap() indexDBAccountChainMapKey {
	return indexDBAccountChainMapKey{k.Name}
}

func (c *IndexDBAccount) DidIndexTransactionExecution() values.Set[[32]byte] {
	return values.GetOrCreate(c, &c.didIndexTransactionExecution, (*IndexDBAccount).newDidIndexTransactionExecution)
}

func (c *IndexDBAccount) newDidIndexTransactionExecution() values.Set[[32]byte] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("DidIndexTransactionExecution"), values.Wrapped(values.HashWrapper), values.CompareHash)
}

func (c *IndexDBAccount) DidLoadTransaction() values.Set[[32]byte] {
	return values.GetOrCreate(c, &c.didLoadTransaction, (*IndexDBAccount).newDidLoadTransaction)
}

func (c *IndexDBAccount) newDidLoadTransaction() values.Set[[32]byte] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("DidLoadTransaction"), values.Wrapped(values.HashWrapper), values.CompareHash)
}

func (c *IndexDBAccount) Chain(name string) *IndexDBAccountChain {
	return values.GetOrCreateMap(c, &c.chain, indexDBAccountChainKey{name}, (*IndexDBAccount).newChain)
}

func (c *IndexDBAccount) newChain(k indexDBAccountChainKey) *IndexDBAccountChain {
	v := new(IndexDBAccountChain)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Chain", k.Name)
	v.parent = c
	return v
}

func (c *IndexDBAccount) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for account (1)")
	}

	switch key.Get(0) {
	case "DidIndexTransactionExecution":
		return c.DidIndexTransactionExecution(), key.SliceI(1), nil
	case "DidLoadTransaction":
		return c.DidLoadTransaction(), key.SliceI(1), nil
	case "Chain":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account (2)")
		}
		name, okName := key.Get(1).(string)
		if !okName {
			return nil, nil, errors.InternalError.With("bad key for account (3)")
		}
		v := c.Chain(name)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for account (4)")
	}
}

func (c *IndexDBAccount) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.didIndexTransactionExecution) {
		return true
	}
	if values.IsDirty(c.didLoadTransaction) {
		return true
	}
	for _, v := range c.chain {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *IndexDBAccount) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.didIndexTransactionExecution, c.newDidIndexTransactionExecution, opts, fn)
	values.WalkField(&err, c.didLoadTransaction, c.newDidLoadTransaction, opts, fn)
	values.WalkMap(&err, c.chain, c.newChain, nil, opts, fn)
	return err
}

func (c *IndexDBAccount) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.didIndexTransactionExecution)
	values.Commit(&err, c.didLoadTransaction)
	for _, v := range c.chain {
		values.Commit(&err, v)
	}

	return err
}

type IndexDBAccountChain struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDBAccount

	index values.List[*protocol.IndexEntry]
}

func (c *IndexDBAccountChain) Key() *record.Key { return c.key }

func (c *IndexDBAccountChain) getIndex() values.List[*protocol.IndexEntry] {
	return values.GetOrCreate(c, &c.index, (*IndexDBAccountChain).newIndex)
}

func (c *IndexDBAccountChain) newIndex() values.List[*protocol.IndexEntry] {
	return values.NewList(c.logger.L, c.store, c.key.Append("Index"), values.Struct[protocol.IndexEntry]())
}

func (c *IndexDBAccountChain) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for chain (1)")
	}

	switch key.Get(0) {
	case "Index":
		return c.getIndex(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for chain (2)")
	}
}

func (c *IndexDBAccountChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.index) {
		return true
	}

	return false
}

func (c *IndexDBAccountChain) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.index, c.newIndex, opts, fn)
	}
	return err
}

func (c *IndexDBAccountChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.index)

	return err
}

type IndexDBPartition struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDB

	anchors *IndexDBPartitionAnchors
}

func (c *IndexDBPartition) Key() *record.Key { return c.key }

func (c *IndexDBPartition) Anchors() *IndexDBPartitionAnchors {
	return values.GetOrCreate(c, &c.anchors, (*IndexDBPartition).newAnchors)
}

func (c *IndexDBPartition) newAnchors() *IndexDBPartitionAnchors {
	v := new(IndexDBPartitionAnchors)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Anchors")
	v.parent = c
	return v
}

func (c *IndexDBPartition) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for partition (1)")
	}

	switch key.Get(0) {
	case "Anchors":
		return c.Anchors(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for partition (2)")
	}
}

func (c *IndexDBPartition) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.anchors) {
		return true
	}

	return false
}

func (c *IndexDBPartition) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.anchors, c.newAnchors, opts, fn)
	return err
}

func (c *IndexDBPartition) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.anchors)

	return err
}

type IndexDBPartitionAnchors struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDBPartition

	produced values.List[*AnchorMetadata]
	received values.List[*AnchorMetadata]
}

func (c *IndexDBPartitionAnchors) Key() *record.Key { return c.key }

func (c *IndexDBPartitionAnchors) getProduced() values.List[*AnchorMetadata] {
	return values.GetOrCreate(c, &c.produced, (*IndexDBPartitionAnchors).newProduced)
}

func (c *IndexDBPartitionAnchors) newProduced() values.List[*AnchorMetadata] {
	return values.NewList(c.logger.L, c.store, c.key.Append("Produced"), values.Struct[AnchorMetadata]())
}

func (c *IndexDBPartitionAnchors) getReceived() values.List[*AnchorMetadata] {
	return values.GetOrCreate(c, &c.received, (*IndexDBPartitionAnchors).newReceived)
}

func (c *IndexDBPartitionAnchors) newReceived() values.List[*AnchorMetadata] {
	return values.NewList(c.logger.L, c.store, c.key.Append("Received"), values.Struct[AnchorMetadata]())
}

func (c *IndexDBPartitionAnchors) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for anchors (1)")
	}

	switch key.Get(0) {
	case "Produced":
		return c.getProduced(), key.SliceI(1), nil
	case "Received":
		return c.getReceived(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for anchors (2)")
	}
}

func (c *IndexDBPartitionAnchors) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.produced) {
		return true
	}
	if values.IsDirty(c.received) {
		return true
	}

	return false
}

func (c *IndexDBPartitionAnchors) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.produced, c.newProduced, opts, fn)
	values.WalkField(&err, c.received, c.newReceived, opts, fn)
	return err
}

func (c *IndexDBPartitionAnchors) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.produced)
	values.Commit(&err, c.received)

	return err
}

type IndexDBTransaction struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDB

	executed values.Value[*EventMetadata]
}

func (c *IndexDBTransaction) Key() *record.Key { return c.key }

func (c *IndexDBTransaction) Executed() values.Value[*EventMetadata] {
	return values.GetOrCreate(c, &c.executed, (*IndexDBTransaction).newExecuted)
}

func (c *IndexDBTransaction) newExecuted() values.Value[*EventMetadata] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Executed"), false, values.Struct[EventMetadata]())
}

func (c *IndexDBTransaction) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for transaction (1)")
	}

	switch key.Get(0) {
	case "Executed":
		return c.Executed(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for transaction (2)")
	}
}

func (c *IndexDBTransaction) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.executed) {
		return true
	}

	return false
}

func (c *IndexDBTransaction) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.executed, c.newExecuted, opts, fn)
	}
	return err
}

func (c *IndexDBTransaction) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.executed)

	return err
}
