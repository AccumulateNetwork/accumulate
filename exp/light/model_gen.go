// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package light

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

//lint:file-ignore S1008,U1000 generated code

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	record "gitlab.com/accumulatenetwork/accumulate/pkg/database"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/values"
	"gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
)

type IndexDB struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *DB

	account     map[indexDBAccountMapKey]*IndexDBAccount
	partition   map[indexDBPartitionMapKey]*IndexDBPartition
	transaction map[indexDBTransactionMapKey]*IndexDBTransaction
}

func (c *IndexDB) Key() *record.Key { return c.key }

type indexDBAccountKey struct {
	Url *url.URL
}

type indexDBAccountMapKey struct {
	Url [32]byte
}

func (k indexDBAccountKey) ForMap() indexDBAccountMapKey {
	return indexDBAccountMapKey{values.MapKeyUrl(k.Url)}
}

type indexDBPartitionKey struct {
	Url *url.URL
}

type indexDBPartitionMapKey struct {
	Url [32]byte
}

func (k indexDBPartitionKey) ForMap() indexDBPartitionMapKey {
	return indexDBPartitionMapKey{values.MapKeyUrl(k.Url)}
}

type indexDBTransactionKey struct {
	Hash [32]byte
}

type indexDBTransactionMapKey struct {
	Hash [32]byte
}

func (k indexDBTransactionKey) ForMap() indexDBTransactionMapKey {
	return indexDBTransactionMapKey{k.Hash}
}

func (c *IndexDB) Account(url *url.URL) *IndexDBAccount {
	return values.GetOrCreateMap(c, &c.account, indexDBAccountKey{url}, (*IndexDB).newAccount)
}

func (c *IndexDB) newAccount(k indexDBAccountKey) *IndexDBAccount {
	v := new(IndexDBAccount)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Account", k.Url)
	v.parent = c
	return v
}

func (c *IndexDB) Partition(url *url.URL) *IndexDBPartition {
	return values.GetOrCreateMap(c, &c.partition, indexDBPartitionKey{url}, (*IndexDB).newPartition)
}

func (c *IndexDB) newPartition(k indexDBPartitionKey) *IndexDBPartition {
	v := new(IndexDBPartition)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Partition", k.Url)
	v.parent = c
	return v
}

func (c *IndexDB) Transaction(hash [32]byte) *IndexDBTransaction {
	return values.GetOrCreateMap(c, &c.transaction, indexDBTransactionKey{hash}, (*IndexDB).newTransaction)
}

func (c *IndexDB) newTransaction(k indexDBTransactionKey) *IndexDBTransaction {
	v := new(IndexDBTransaction)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Transaction", k.Hash)
	v.parent = c
	return v
}

func (c *IndexDB) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for index db (1)")
	}

	switch key.Get(0) {
	case "Account":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for index db (2)")
		}
		url, okUrl := key.Get(1).(*url.URL)
		if !okUrl {
			return nil, nil, errors.InternalError.With("bad key for index db (3)")
		}
		v := c.Account(url)
		return v, key.SliceI(2), nil
	case "Partition":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for index db (4)")
		}
		url, okUrl := key.Get(1).(*url.URL)
		if !okUrl {
			return nil, nil, errors.InternalError.With("bad key for index db (5)")
		}
		v := c.Partition(url)
		return v, key.SliceI(2), nil
	case "Transaction":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for index db (6)")
		}
		hash, okHash := key.Get(1).([32]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for index db (7)")
		}
		v := c.Transaction(hash)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for index db (8)")
	}
}

func (c *IndexDB) IsDirty() bool {
	if c == nil {
		return false
	}

	for _, v := range c.account {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.partition {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *IndexDB) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkMap(&err, c.account, c.newAccount, nil, opts, fn)
	values.WalkMap(&err, c.partition, c.newPartition, nil, opts, fn)
	values.WalkMap(&err, c.transaction, c.newTransaction, nil, opts, fn)
	return err
}

func (c *IndexDB) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	for _, v := range c.account {
		values.Commit(&err, v)
	}
	for _, v := range c.partition {
		values.Commit(&err, v)
	}
	for _, v := range c.transaction {
		values.Commit(&err, v)
	}

	return err
}

type IndexDBAccount struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDB

	didIndexTransactionExecution values.Set[[32]byte]
	chain                        map[indexDBAccountChainMapKey]*IndexDBAccountChain
}

func (c *IndexDBAccount) Key() *record.Key { return c.key }

type indexDBAccountChainKey struct {
	Name string
}

type indexDBAccountChainMapKey struct {
	Name string
}

func (k indexDBAccountChainKey) ForMap() indexDBAccountChainMapKey {
	return indexDBAccountChainMapKey{k.Name}
}

func (c *IndexDBAccount) DidIndexTransactionExecution() values.Set[[32]byte] {
	return values.GetOrCreate(c, &c.didIndexTransactionExecution, (*IndexDBAccount).newDidIndexTransactionExecution)
}

func (c *IndexDBAccount) newDidIndexTransactionExecution() values.Set[[32]byte] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("DidIndexTransactionExecution"), values.Wrapped(values.HashWrapper), values.CompareHash)
}

func (c *IndexDBAccount) Chain(name string) *IndexDBAccountChain {
	return values.GetOrCreateMap(c, &c.chain, indexDBAccountChainKey{name}, (*IndexDBAccount).newChain)
}

func (c *IndexDBAccount) newChain(k indexDBAccountChainKey) *IndexDBAccountChain {
	v := new(IndexDBAccountChain)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Chain", k.Name)
	v.parent = c
	return v
}

func (c *IndexDBAccount) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for account (1)")
	}

	switch key.Get(0) {
	case "DidIndexTransactionExecution":
		return c.DidIndexTransactionExecution(), key.SliceI(1), nil
	case "Chain":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account (2)")
		}
		name, okName := key.Get(1).(string)
		if !okName {
			return nil, nil, errors.InternalError.With("bad key for account (3)")
		}
		v := c.Chain(name)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for account (4)")
	}
}

func (c *IndexDBAccount) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.didIndexTransactionExecution) {
		return true
	}
	for _, v := range c.chain {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *IndexDBAccount) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.didIndexTransactionExecution, c.newDidIndexTransactionExecution, opts, fn)
	values.WalkMap(&err, c.chain, c.newChain, nil, opts, fn)
	return err
}

func (c *IndexDBAccount) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.didIndexTransactionExecution)
	for _, v := range c.chain {
		values.Commit(&err, v)
	}

	return err
}

type IndexDBAccountChain struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDBAccount

	didLoad     values.Value[*rangeSet]
	sourceIndex *ChainIndexUint
	blockIndex  *ChainIndexUint
	blockTime   *ChainIndexTime
}

func (c *IndexDBAccountChain) Key() *record.Key { return c.key }

func (c *IndexDBAccountChain) getDidLoad() values.Value[*rangeSet] {
	return values.GetOrCreate(c, &c.didLoad, (*IndexDBAccountChain).newDidLoad)
}

func (c *IndexDBAccountChain) newDidLoad() values.Value[*rangeSet] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("DidLoad"), true, values.Struct[rangeSet]())
}

func (c *IndexDBAccountChain) SourceIndex() *ChainIndexUint {
	return values.GetOrCreate(c, &c.sourceIndex, (*IndexDBAccountChain).newSourceIndex)
}

func (c *IndexDBAccountChain) newSourceIndex() *ChainIndexUint {
	return newChainIndexUint(c, c.logger.L, c.store, c.key.Append("SourceIndex"), "index-db-account(%[3]v)-(%[5]v)-source-index")
}

func (c *IndexDBAccountChain) BlockIndex() *ChainIndexUint {
	return values.GetOrCreate(c, &c.blockIndex, (*IndexDBAccountChain).newBlockIndex)
}

func (c *IndexDBAccountChain) newBlockIndex() *ChainIndexUint {
	return newChainIndexUint(c, c.logger.L, c.store, c.key.Append("BlockIndex"), "index-db-account(%[3]v)-(%[5]v)-block-index")
}

func (c *IndexDBAccountChain) BlockTime() *ChainIndexTime {
	return values.GetOrCreate(c, &c.blockTime, (*IndexDBAccountChain).newBlockTime)
}

func (c *IndexDBAccountChain) newBlockTime() *ChainIndexTime {
	return newChainIndexTime(c, c.logger.L, c.store, c.key.Append("BlockTime"), "index-db-account(%[3]v)-(%[5]v)-block-time")
}

func (c *IndexDBAccountChain) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for chain (1)")
	}

	switch key.Get(0) {
	case "DidLoad":
		return c.getDidLoad(), key.SliceI(1), nil
	case "SourceIndex":
		return c.SourceIndex(), key.SliceI(1), nil
	case "BlockIndex":
		return c.BlockIndex(), key.SliceI(1), nil
	case "BlockTime":
		return c.BlockTime(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for chain (2)")
	}
}

func (c *IndexDBAccountChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.didLoad) {
		return true
	}
	if values.IsDirty(c.sourceIndex) {
		return true
	}
	if values.IsDirty(c.blockIndex) {
		return true
	}
	if values.IsDirty(c.blockTime) {
		return true
	}

	return false
}

func (c *IndexDBAccountChain) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.didLoad, c.newDidLoad, opts, fn)
	values.WalkField(&err, c.sourceIndex, c.newSourceIndex, opts, fn)
	values.WalkField(&err, c.blockIndex, c.newBlockIndex, opts, fn)
	values.WalkField(&err, c.blockTime, c.newBlockTime, opts, fn)
	return err
}

func (c *IndexDBAccountChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.didLoad)
	values.Commit(&err, c.sourceIndex)
	values.Commit(&err, c.blockIndex)
	values.Commit(&err, c.blockTime)

	return err
}

type IndexDBPartition struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDB

	anchors *IndexDBPartitionAnchors
}

func (c *IndexDBPartition) Key() *record.Key { return c.key }

func (c *IndexDBPartition) Anchors() *IndexDBPartitionAnchors {
	return values.GetOrCreate(c, &c.anchors, (*IndexDBPartition).newAnchors)
}

func (c *IndexDBPartition) newAnchors() *IndexDBPartitionAnchors {
	v := new(IndexDBPartitionAnchors)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Anchors")
	v.parent = c
	return v
}

func (c *IndexDBPartition) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for partition (1)")
	}

	switch key.Get(0) {
	case "Anchors":
		return c.Anchors(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for partition (2)")
	}
}

func (c *IndexDBPartition) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.anchors) {
		return true
	}

	return false
}

func (c *IndexDBPartition) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.anchors, c.newAnchors, opts, fn)
	return err
}

func (c *IndexDBPartition) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.anchors)

	return err
}

type IndexDBPartitionAnchors struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDBPartition

	produced values.List[*AnchorMetadata]
	received map[indexDBPartitionAnchorsReceivedMapKey]*ChainIndexUint
}

func (c *IndexDBPartitionAnchors) Key() *record.Key { return c.key }

type indexDBPartitionAnchorsReceivedKey struct {
	Url *url.URL
}

type indexDBPartitionAnchorsReceivedMapKey struct {
	Url [32]byte
}

func (k indexDBPartitionAnchorsReceivedKey) ForMap() indexDBPartitionAnchorsReceivedMapKey {
	return indexDBPartitionAnchorsReceivedMapKey{values.MapKeyUrl(k.Url)}
}

func (c *IndexDBPartitionAnchors) getProduced() values.List[*AnchorMetadata] {
	return values.GetOrCreate(c, &c.produced, (*IndexDBPartitionAnchors).newProduced)
}

func (c *IndexDBPartitionAnchors) newProduced() values.List[*AnchorMetadata] {
	return values.NewList(c.logger.L, c.store, c.key.Append("Produced"), values.Struct[AnchorMetadata]())
}

func (c *IndexDBPartitionAnchors) Received(url *url.URL) *ChainIndexUint {
	return values.GetOrCreateMap(c, &c.received, indexDBPartitionAnchorsReceivedKey{url}, (*IndexDBPartitionAnchors).newReceived)
}

func (c *IndexDBPartitionAnchors) newReceived(k indexDBPartitionAnchorsReceivedKey) *ChainIndexUint {
	return newChainIndexUint(c, c.logger.L, c.store, c.key.Append("Received", k.Url), "index-db-partition(%[3]v)-anchors-received(%[6]v)")
}

func (c *IndexDBPartitionAnchors) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for anchors (1)")
	}

	switch key.Get(0) {
	case "Produced":
		return c.getProduced(), key.SliceI(1), nil
	case "Received":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for anchors (2)")
		}
		url, okUrl := key.Get(1).(*url.URL)
		if !okUrl {
			return nil, nil, errors.InternalError.With("bad key for anchors (3)")
		}
		v := c.Received(url)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for anchors (4)")
	}
}

func (c *IndexDBPartitionAnchors) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.produced) {
		return true
	}
	for _, v := range c.received {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *IndexDBPartitionAnchors) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.produced, c.newProduced, opts, fn)
	values.WalkMap(&err, c.received, c.newReceived, nil, opts, fn)
	return err
}

func (c *IndexDBPartitionAnchors) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.produced)
	for _, v := range c.received {
		values.Commit(&err, v)
	}

	return err
}

type IndexDBTransaction struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *IndexDB

	executed values.Value[*EventMetadata]
}

func (c *IndexDBTransaction) Key() *record.Key { return c.key }

func (c *IndexDBTransaction) Executed() values.Value[*EventMetadata] {
	return values.GetOrCreate(c, &c.executed, (*IndexDBTransaction).newExecuted)
}

func (c *IndexDBTransaction) newExecuted() values.Value[*EventMetadata] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Executed"), false, values.Struct[EventMetadata]())
}

func (c *IndexDBTransaction) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for transaction (1)")
	}

	switch key.Get(0) {
	case "Executed":
		return c.Executed(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for transaction (2)")
	}
}

func (c *IndexDBTransaction) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.executed) {
		return true
	}

	return false
}

func (c *IndexDBTransaction) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.executed, c.newExecuted, opts, fn)
	}
	return err
}

func (c *IndexDBTransaction) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.executed)

	return err
}
