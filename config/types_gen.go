package config

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type Describe struct {
	fieldsSet   []bool
	NetworkType NetworkType               `json:"networkType,omitempty" form:"networkType" query:"networkType" validate:"required" toml:"type" mapstructure:"type"`
	PartitionId string                    `json:"partitionId,omitempty" form:"partitionId" query:"partitionId" validate:"required" toml:"partition-id" mapstructure:"partition-id"`
	Advertise   *protocol.InternetAddress `json:"advertise,omitempty" form:"advertise" query:"advertise" validate:"required" toml:"advertise" mapstructure:"advertise"`
	Network     Network                   `json:"network,omitempty" form:"network" query:"network" validate:"required" toml:"network" mapstructure:"network"`
	extraData   []byte
}

type Network struct {
	fieldsSet  []bool
	Id         string                       `json:"id,omitempty" form:"id" query:"id" validate:"required" toml:"id" mapstructure:"id"`
	Seeds      []*protocol.AddressBookEntry `json:"seeds,omitempty" form:"seeds" query:"seeds" validate:"required"`
	Ignore     []*protocol.AddressBookEntry `json:"ignore,omitempty" form:"ignore" query:"ignore" validate:"required"`
	Partitions []Partition                  `json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required" toml:"partitions" mapstructure:"partitions"`
	extraData  []byte
}

type Node struct {
	fieldsSet []bool
	Address   *protocol.InternetAddress `json:"address,omitempty" form:"address" query:"address" validate:"required" toml:"address" mapstructure:"address"`
	PublicKey []byte                    `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required" toml:"public-key" mapstructure:"public-key"`
	extraData []byte
}

type Partition struct {
	fieldsSet []bool
	Id        string      `json:"id,omitempty" form:"id" query:"id" validate:"required" toml:"id" mapstructure:"id"`
	Type      NetworkType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	BasePort  int64       `json:"basePort,omitempty" form:"basePort" query:"basePort" validate:"required" toml:"port" mapstructure:"port"`
	Nodes     []Node      `json:"nodes,omitempty" form:"nodes" query:"nodes" validate:"required" toml:"nodes" mapstructure:"nodes"`
	extraData []byte
}

func (v *Describe) Copy() *Describe {
	u := new(Describe)

	u.NetworkType = v.NetworkType
	u.PartitionId = v.PartitionId
	if v.Advertise != nil {
		u.Advertise = (v.Advertise).Copy()
	}
	u.Network = *(&v.Network).Copy()

	return u
}

func (v *Describe) CopyAsInterface() interface{} { return v.Copy() }

func (v *Network) Copy() *Network {
	u := new(Network)

	u.Id = v.Id
	u.Seeds = make([]*protocol.AddressBookEntry, len(v.Seeds))
	for i, v := range v.Seeds {
		if v != nil {
			u.Seeds[i] = (v).Copy()
		}
	}
	u.Ignore = make([]*protocol.AddressBookEntry, len(v.Ignore))
	for i, v := range v.Ignore {
		if v != nil {
			u.Ignore[i] = (v).Copy()
		}
	}
	u.Partitions = make([]Partition, len(v.Partitions))
	for i, v := range v.Partitions {
		u.Partitions[i] = *(&v).Copy()
	}

	return u
}

func (v *Network) CopyAsInterface() interface{} { return v.Copy() }

func (v *Node) Copy() *Node {
	u := new(Node)

	if v.Address != nil {
		u.Address = (v.Address).Copy()
	}
	u.PublicKey = encoding.BytesCopy(v.PublicKey)

	return u
}

func (v *Node) CopyAsInterface() interface{} { return v.Copy() }

func (v *Partition) Copy() *Partition {
	u := new(Partition)

	u.Id = v.Id
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = make([]Node, len(v.Nodes))
	for i, v := range v.Nodes {
		u.Nodes[i] = *(&v).Copy()
	}

	return u
}

func (v *Partition) CopyAsInterface() interface{} { return v.Copy() }

func (v *Describe) Equal(u *Describe) bool {
	if !(v.NetworkType == u.NetworkType) {
		return false
	}
	if !(v.PartitionId == u.PartitionId) {
		return false
	}
	switch {
	case v.Advertise == u.Advertise:
		// equal
	case v.Advertise == nil || u.Advertise == nil:
		return false
	case !((v.Advertise).Equal(u.Advertise)):
		return false
	}
	if !((&v.Network).Equal(&u.Network)) {
		return false
	}

	return true
}

func (v *Network) Equal(u *Network) bool {
	if !(v.Id == u.Id) {
		return false
	}
	if len(v.Seeds) != len(u.Seeds) {
		return false
	}
	for i := range v.Seeds {
		if !((v.Seeds[i]).Equal(u.Seeds[i])) {
			return false
		}
	}
	if len(v.Ignore) != len(u.Ignore) {
		return false
	}
	for i := range v.Ignore {
		if !((v.Ignore[i]).Equal(u.Ignore[i])) {
			return false
		}
	}
	if len(v.Partitions) != len(u.Partitions) {
		return false
	}
	for i := range v.Partitions {
		if !((&v.Partitions[i]).Equal(&u.Partitions[i])) {
			return false
		}
	}

	return true
}

func (v *Node) Equal(u *Node) bool {
	switch {
	case v.Address == u.Address:
		// equal
	case v.Address == nil || u.Address == nil:
		return false
	case !((v.Address).Equal(u.Address)):
		return false
	}
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}

	return true
}

func (v *Partition) Equal(u *Partition) bool {
	if !(v.Id == u.Id) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.BasePort == u.BasePort) {
		return false
	}
	if len(v.Nodes) != len(u.Nodes) {
		return false
	}
	for i := range v.Nodes {
		if !((&v.Nodes[i]).Equal(&u.Nodes[i])) {
			return false
		}
	}

	return true
}

var fieldNames_Describe = []string{
	1: "NetworkType",
	2: "PartitionId",
	3: "Advertise",
	4: "Network",
}

func (v *Describe) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.NetworkType == 0) {
		writer.WriteEnum(1, v.NetworkType)
	}
	if !(len(v.PartitionId) == 0) {
		writer.WriteString(2, v.PartitionId)
	}
	if !(v.Advertise == nil) {
		writer.WriteValue(3, v.Advertise.MarshalBinary)
	}
	if !((v.Network).Equal(new(Network))) {
		writer.WriteValue(4, v.Network.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_Describe)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Describe) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field NetworkType is missing")
	} else if v.NetworkType == 0 {
		errs = append(errs, "field NetworkType is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field PartitionId is missing")
	} else if len(v.PartitionId) == 0 {
		errs = append(errs, "field PartitionId is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Advertise is missing")
	} else if v.Advertise == nil {
		errs = append(errs, "field Advertise is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Network is missing")
	} else if (v.Network).Equal(new(Network)) {
		errs = append(errs, "field Network is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Network = []string{
	1: "Id",
	2: "Seeds",
	3: "Ignore",
	4: "Partitions",
}

func (v *Network) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Id) == 0) {
		writer.WriteString(1, v.Id)
	}
	if !(len(v.Seeds) == 0) {
		for _, v := range v.Seeds {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	if !(len(v.Ignore) == 0) {
		for _, v := range v.Ignore {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}
	if !(len(v.Partitions) == 0) {
		for _, v := range v.Partitions {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_Network)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Network) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Id is missing")
	} else if len(v.Id) == 0 {
		errs = append(errs, "field Id is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Seeds is missing")
	} else if len(v.Seeds) == 0 {
		errs = append(errs, "field Seeds is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Ignore is missing")
	} else if len(v.Ignore) == 0 {
		errs = append(errs, "field Ignore is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Partitions is missing")
	} else if len(v.Partitions) == 0 {
		errs = append(errs, "field Partitions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Node = []string{
	1: "Address",
	2: "PublicKey",
}

func (v *Node) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Address == nil) {
		writer.WriteValue(1, v.Address.MarshalBinary)
	}
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}

	_, _, err := writer.Reset(fieldNames_Node)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Node) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Address is missing")
	} else if v.Address == nil {
		errs = append(errs, "field Address is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Partition = []string{
	1: "Id",
	2: "Type",
	3: "BasePort",
	4: "Nodes",
}

func (v *Partition) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Id) == 0) {
		writer.WriteString(1, v.Id)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.BasePort == 0) {
		writer.WriteInt(3, v.BasePort)
	}
	if !(len(v.Nodes) == 0) {
		for _, v := range v.Nodes {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_Partition)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Partition) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Id is missing")
	} else if len(v.Id) == 0 {
		errs = append(errs, "field Id is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field BasePort is missing")
	} else if v.BasePort == 0 {
		errs = append(errs, "field BasePort is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Nodes is missing")
	} else if len(v.Nodes) == 0 {
		errs = append(errs, "field Nodes is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *Describe) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Describe) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(NetworkType); reader.ReadEnum(1, x) {
		v.NetworkType = *x
	}
	if x, ok := reader.ReadString(2); ok {
		v.PartitionId = x
	}
	if x := new(protocol.InternetAddress); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Advertise = x
	}
	if x := new(Network); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Network = *x
	}

	seen, err := reader.Reset(fieldNames_Describe)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Network) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Network) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Id = x
	}
	for {
		if x := new(protocol.AddressBookEntry); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Seeds = append(v.Seeds, x)
		} else {
			break
		}
	}
	for {
		if x := new(protocol.AddressBookEntry); reader.ReadValue(3, x.UnmarshalBinary) {
			v.Ignore = append(v.Ignore, x)
		} else {
			break
		}
	}
	for {
		if x := new(Partition); reader.ReadValue(4, x.UnmarshalBinary) {
			v.Partitions = append(v.Partitions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_Network)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Node) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Node) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.InternetAddress); reader.ReadValue(1, x.UnmarshalBinary) {
		v.Address = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}

	seen, err := reader.Reset(fieldNames_Node)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Partition) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Partition) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Id = x
	}
	if x := new(NetworkType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.BasePort = x
	}
	for {
		if x := new(Node); reader.ReadValue(4, x.UnmarshalBinary) {
			v.Nodes = append(v.Nodes, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_Partition)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Describe) MarshalJSON() ([]byte, error) {
	u := struct {
		NetworkType  NetworkType               `json:"networkType,omitempty"`
		PartitionId  string                    `json:"partitionId,omitempty"`
		SubnetId     string                    `json:"subnetId,omitempty"`
		Advertise    *protocol.InternetAddress `json:"advertise,omitempty"`
		LocalAddress string                    `json:"localAddress,omitempty"`
		Network      Network                   `json:"network,omitempty"`
	}{}
	u.NetworkType = v.NetworkType
	u.PartitionId = v.PartitionId
	u.SubnetId = v.PartitionId
	u.Advertise = v.Advertise
	u.LocalAddress = v.LocalAddress()
	u.Network = v.Network
	return json.Marshal(&u)
}

func (v *Network) MarshalJSON() ([]byte, error) {
	u := struct {
		Id         string                                        `json:"id,omitempty"`
		Seeds      encoding.JsonList[*protocol.AddressBookEntry] `json:"seeds,omitempty"`
		Ignore     encoding.JsonList[*protocol.AddressBookEntry] `json:"ignore,omitempty"`
		Partitions encoding.JsonList[Partition]                  `json:"partitions,omitempty"`
		Subnets    encoding.JsonList[Partition]                  `json:"subnets,omitempty"`
	}{}
	u.Id = v.Id
	u.Seeds = v.Seeds
	u.Ignore = v.Ignore
	u.Partitions = v.Partitions
	u.Subnets = v.Partitions
	return json.Marshal(&u)
}

func (v *Node) MarshalJSON() ([]byte, error) {
	u := struct {
		Address   *protocol.InternetAddress `json:"address,omitempty"`
		PublicKey *string                   `json:"publicKey,omitempty"`
	}{}
	u.Address = v.Address
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	return json.Marshal(&u)
}

func (v *Partition) MarshalJSON() ([]byte, error) {
	u := struct {
		Id       string                  `json:"id,omitempty"`
		Type     NetworkType             `json:"type,omitempty"`
		BasePort int64                   `json:"basePort,omitempty"`
		Nodes    encoding.JsonList[Node] `json:"nodes,omitempty"`
	}{}
	u.Id = v.Id
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = v.Nodes
	return json.Marshal(&u)
}

func (v *Describe) UnmarshalJSON(data []byte) error {
	u := struct {
		NetworkType  NetworkType               `json:"networkType,omitempty"`
		PartitionId  string                    `json:"partitionId,omitempty"`
		SubnetId     string                    `json:"subnetId,omitempty"`
		Advertise    *protocol.InternetAddress `json:"advertise,omitempty"`
		LocalAddress string                    `json:"localAddress,omitempty"`
		Network      Network                   `json:"network,omitempty"`
	}{}
	u.NetworkType = v.NetworkType
	u.PartitionId = v.PartitionId
	u.SubnetId = v.PartitionId
	u.Advertise = v.Advertise
	u.LocalAddress = v.LocalAddress()
	u.Network = v.Network
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.NetworkType = u.NetworkType
	if !(u.PartitionId == "") {
		v.PartitionId = u.PartitionId
	} else {
		v.PartitionId = u.SubnetId
	}
	v.Advertise = u.Advertise
	v.Network = u.Network
	return nil
}

func (v *Network) UnmarshalJSON(data []byte) error {
	u := struct {
		Id         string                                        `json:"id,omitempty"`
		Seeds      encoding.JsonList[*protocol.AddressBookEntry] `json:"seeds,omitempty"`
		Ignore     encoding.JsonList[*protocol.AddressBookEntry] `json:"ignore,omitempty"`
		Partitions encoding.JsonList[Partition]                  `json:"partitions,omitempty"`
		Subnets    encoding.JsonList[Partition]                  `json:"subnets,omitempty"`
	}{}
	u.Id = v.Id
	u.Seeds = v.Seeds
	u.Ignore = v.Ignore
	u.Partitions = v.Partitions
	u.Subnets = v.Partitions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Id = u.Id
	v.Seeds = u.Seeds
	v.Ignore = u.Ignore
	if !(len(u.Partitions) == 0) {
		v.Partitions = u.Partitions
	} else {
		v.Partitions = u.Subnets
	}
	return nil
}

func (v *Node) UnmarshalJSON(data []byte) error {
	u := struct {
		Address   *protocol.InternetAddress `json:"address,omitempty"`
		PublicKey *string                   `json:"publicKey,omitempty"`
	}{}
	u.Address = v.Address
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Address = u.Address
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	return nil
}

func (v *Partition) UnmarshalJSON(data []byte) error {
	u := struct {
		Id       string                  `json:"id,omitempty"`
		Type     NetworkType             `json:"type,omitempty"`
		BasePort int64                   `json:"basePort,omitempty"`
		Nodes    encoding.JsonList[Node] `json:"nodes,omitempty"`
	}{}
	u.Id = v.Id
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = v.Nodes
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Id = u.Id
	v.Type = u.Type
	v.BasePort = u.BasePort
	v.Nodes = u.Nodes
	return nil
}
