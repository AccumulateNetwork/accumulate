package config

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"encoding/json"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

type Describe struct {
	Network
	NetworkType  NetworkType `json:"networkType,omitempty" form:"networkType" query:"networkType" validate:"required" toml:"type" mapstructure:"type"`
	SubnetId     string      `json:"subnetId,omitempty" form:"subnetId" query:"subnetId" validate:"required" toml:"subnet-id" mapstructure:"subnet-id"`
	LocalAddress string      `json:"localAddress,omitempty" form:"localAddress" query:"localAddress" validate:"required" toml:"local-address" mapstructure:"local-address"`
	extraData    []byte
}

type Network struct {
	Name      string   `json:"name,omitempty" form:"name" query:"name" validate:"required" toml:"name" mapstructure:"name"`
	Subnets   []Subnet `json:"subnets,omitempty" form:"subnets" query:"subnets" validate:"required" toml:"subnets" mapstructure:"subnets"`
	extraData []byte
}

type Node struct {
	Address   string   `json:"address,omitempty" form:"address" query:"address" validate:"required" toml:"address" mapstructure:"address"`
	Type      NodeType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	extraData []byte
}

type Subnet struct {
	ID        string      `json:"iD,omitempty" form:"iD" query:"iD" validate:"required" toml:"id" mapstructure:"id"`
	Type      NetworkType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	BasePort  int64       `json:"basePort,omitempty" form:"basePort" query:"basePort" validate:"required" toml:"port" mapstructure:"port"`
	Nodes     []Node      `json:"nodes,omitempty" form:"nodes" query:"nodes" validate:"required" toml:"nodes" mapstructure:"nodes"`
	extraData []byte
}

func (v *Describe) Copy() *Describe {
	u := new(Describe)

	u.Network = *v.Network.Copy()
	u.NetworkType = v.NetworkType
	u.SubnetId = v.SubnetId
	u.LocalAddress = v.LocalAddress

	return u
}

func (v *Describe) CopyAsInterface() interface{} { return v.Copy() }

func (v *Network) Copy() *Network {
	u := new(Network)

	u.Name = v.Name
	u.Subnets = make([]Subnet, len(v.Subnets))
	for i, v := range v.Subnets {
		u.Subnets[i] = *(&v).Copy()
	}

	return u
}

func (v *Network) CopyAsInterface() interface{} { return v.Copy() }

func (v *Node) Copy() *Node {
	u := new(Node)

	u.Address = v.Address
	u.Type = v.Type

	return u
}

func (v *Node) CopyAsInterface() interface{} { return v.Copy() }

func (v *Subnet) Copy() *Subnet {
	u := new(Subnet)

	u.ID = v.ID
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = make([]Node, len(v.Nodes))
	for i, v := range v.Nodes {
		u.Nodes[i] = *(&v).Copy()
	}

	return u
}

func (v *Subnet) CopyAsInterface() interface{} { return v.Copy() }

func (v *Describe) Equal(u *Describe) bool {
	if !v.Network.Equal(&u.Network) {
		return false
	}
	if !(v.NetworkType == u.NetworkType) {
		return false
	}
	if !(v.SubnetId == u.SubnetId) {
		return false
	}
	if !(v.LocalAddress == u.LocalAddress) {
		return false
	}

	return true
}

func (v *Network) Equal(u *Network) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if len(v.Subnets) != len(u.Subnets) {
		return false
	}
	for i := range v.Subnets {
		if !((&v.Subnets[i]).Equal(&u.Subnets[i])) {
			return false
		}
	}

	return true
}

func (v *Node) Equal(u *Node) bool {
	if !(v.Address == u.Address) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *Subnet) Equal(u *Subnet) bool {
	if !(v.ID == u.ID) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.BasePort == u.BasePort) {
		return false
	}
	if len(v.Nodes) != len(u.Nodes) {
		return false
	}
	for i := range v.Nodes {
		if !((&v.Nodes[i]).Equal(&u.Nodes[i])) {
			return false
		}
	}

	return true
}

func (v *Describe) MarshalJSON() ([]byte, error) {
	u := struct {
		Name         string                    `json:"name,omitempty"`
		Subnets      encoding.JsonList[Subnet] `json:"subnets,omitempty"`
		NetworkType  NetworkType               `json:"networkType,omitempty"`
		SubnetId     string                    `json:"subnetId,omitempty"`
		LocalAddress string                    `json:"localAddress,omitempty"`
	}{}
	u.Name = v.Network.Name
	u.Subnets = v.Network.Subnets
	u.NetworkType = v.NetworkType
	u.SubnetId = v.SubnetId
	u.LocalAddress = v.LocalAddress
	return json.Marshal(&u)
}

func (v *Network) MarshalJSON() ([]byte, error) {
	u := struct {
		Name    string                    `json:"name,omitempty"`
		Subnets encoding.JsonList[Subnet] `json:"subnets,omitempty"`
	}{}
	u.Name = v.Name
	u.Subnets = v.Subnets
	return json.Marshal(&u)
}

func (v *Subnet) MarshalJSON() ([]byte, error) {
	u := struct {
		ID       string                  `json:"iD,omitempty"`
		Type     NetworkType             `json:"type,omitempty"`
		BasePort int64                   `json:"basePort,omitempty"`
		Nodes    encoding.JsonList[Node] `json:"nodes,omitempty"`
	}{}
	u.ID = v.ID
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = v.Nodes
	return json.Marshal(&u)
}

func (v *Describe) UnmarshalJSON(data []byte) error {
	u := struct {
		Name         string                    `json:"name,omitempty"`
		Subnets      encoding.JsonList[Subnet] `json:"subnets,omitempty"`
		NetworkType  NetworkType               `json:"networkType,omitempty"`
		SubnetId     string                    `json:"subnetId,omitempty"`
		LocalAddress string                    `json:"localAddress,omitempty"`
	}{}
	u.Name = v.Network.Name
	u.Subnets = v.Network.Subnets
	u.NetworkType = v.NetworkType
	u.SubnetId = v.SubnetId
	u.LocalAddress = v.LocalAddress
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Network.Name = u.Name
	v.Network.Subnets = u.Subnets
	v.NetworkType = u.NetworkType
	v.SubnetId = u.SubnetId
	v.LocalAddress = u.LocalAddress
	return nil
}

func (v *Network) UnmarshalJSON(data []byte) error {
	u := struct {
		Name    string                    `json:"name,omitempty"`
		Subnets encoding.JsonList[Subnet] `json:"subnets,omitempty"`
	}{}
	u.Name = v.Name
	u.Subnets = v.Subnets
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Name = u.Name
	v.Subnets = u.Subnets
	return nil
}

func (v *Subnet) UnmarshalJSON(data []byte) error {
	u := struct {
		ID       string                  `json:"iD,omitempty"`
		Type     NetworkType             `json:"type,omitempty"`
		BasePort int64                   `json:"basePort,omitempty"`
		Nodes    encoding.JsonList[Node] `json:"nodes,omitempty"`
	}{}
	u.ID = v.ID
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = v.Nodes
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ID = u.ID
	v.Type = u.Type
	v.BasePort = u.BasePort
	v.Nodes = u.Nodes
	return nil
}
