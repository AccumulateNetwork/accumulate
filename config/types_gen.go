package config

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"encoding/json"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

type Network struct {
	NetworkName   string      `json:"networkName,omitempty" form:"networkName" query:"networkName" validate:"required" toml:"network-name" mapstructure:"network-name"`
	Type          NetworkType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	LocalSubnetID string      `json:"localSubnetID,omitempty" form:"localSubnetID" query:"localSubnetID" validate:"required" toml:"local-subnet" mapstructure:"local-subnet"`
	LocalAddress  string      `json:"localAddress,omitempty" form:"localAddress" query:"localAddress" validate:"required" toml:"local-address" mapstructure:"local-address"`
	Subnets       []*Subnet   `json:"subnets,omitempty" form:"subnets" query:"subnets" validate:"required" toml:"subnets" mapstructure:"subnets"`
	extraData     []byte
}

type Node struct {
	Address   string   `json:"address,omitempty" form:"address" query:"address" validate:"required" toml:"address" mapstructure:"address"`
	Type      NodeType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	extraData []byte
}

type Subnet struct {
	ID        string      `json:"iD,omitempty" form:"iD" query:"iD" validate:"required" toml:"id" mapstructure:"id"`
	Type      NetworkType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	Nodes     []*Node     `json:"nodes,omitempty" form:"nodes" query:"nodes" validate:"required" toml:"nodes" mapstructure:"nodes"`
	extraData []byte
}

func (v *Network) Copy() *Network {
	u := new(Network)

	u.NetworkName = v.NetworkName
	u.Type = v.Type
	u.LocalSubnetID = v.LocalSubnetID
	u.LocalAddress = v.LocalAddress
	u.Subnets = make([]*Subnet, len(v.Subnets))
	for i, v := range v.Subnets {
		if v != nil {
			u.Subnets[i] = (v).Copy()
		}
	}

	return u
}

func (v *Network) CopyAsInterface() interface{} { return v.Copy() }

func (v *Node) Copy() *Node {
	u := new(Node)

	u.Address = v.Address
	u.Type = v.Type

	return u
}

func (v *Node) CopyAsInterface() interface{} { return v.Copy() }

func (v *Subnet) Copy() *Subnet {
	u := new(Subnet)

	u.ID = v.ID
	u.Type = v.Type
	u.Nodes = make([]*Node, len(v.Nodes))
	for i, v := range v.Nodes {
		if v != nil {
			u.Nodes[i] = (v).Copy()
		}
	}

	return u
}

func (v *Subnet) CopyAsInterface() interface{} { return v.Copy() }

func (v *Network) Equal(u *Network) bool {
	if !(v.NetworkName == u.NetworkName) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.LocalSubnetID == u.LocalSubnetID) {
		return false
	}
	if !(v.LocalAddress == u.LocalAddress) {
		return false
	}
	if len(v.Subnets) != len(u.Subnets) {
		return false
	}
	for i := range v.Subnets {
		if !((v.Subnets[i]).Equal(u.Subnets[i])) {
			return false
		}
	}

	return true
}

func (v *Node) Equal(u *Node) bool {
	if !(v.Address == u.Address) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *Subnet) Equal(u *Subnet) bool {
	if !(v.ID == u.ID) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if len(v.Nodes) != len(u.Nodes) {
		return false
	}
	for i := range v.Nodes {
		if !((v.Nodes[i]).Equal(u.Nodes[i])) {
			return false
		}
	}

	return true
}

func (v *Network) MarshalJSON() ([]byte, error) {
	u := struct {
		NetworkName   string                     `json:"networkName,omitempty"`
		Type          NetworkType                `json:"type,omitempty"`
		LocalSubnetID string                     `json:"localSubnetID,omitempty"`
		LocalAddress  string                     `json:"localAddress,omitempty"`
		Subnets       encoding.JsonList[*Subnet] `json:"subnets,omitempty"`
	}{}
	u.NetworkName = v.NetworkName
	u.Type = v.Type
	u.LocalSubnetID = v.LocalSubnetID
	u.LocalAddress = v.LocalAddress
	u.Subnets = v.Subnets
	return json.Marshal(&u)
}

func (v *Subnet) MarshalJSON() ([]byte, error) {
	u := struct {
		ID    string                   `json:"iD,omitempty"`
		Type  NetworkType              `json:"type,omitempty"`
		Nodes encoding.JsonList[*Node] `json:"nodes,omitempty"`
	}{}
	u.ID = v.ID
	u.Type = v.Type
	u.Nodes = v.Nodes
	return json.Marshal(&u)
}

func (v *Network) UnmarshalJSON(data []byte) error {
	u := struct {
		NetworkName   string                     `json:"networkName,omitempty"`
		Type          NetworkType                `json:"type,omitempty"`
		LocalSubnetID string                     `json:"localSubnetID,omitempty"`
		LocalAddress  string                     `json:"localAddress,omitempty"`
		Subnets       encoding.JsonList[*Subnet] `json:"subnets,omitempty"`
	}{}
	u.NetworkName = v.NetworkName
	u.Type = v.Type
	u.LocalSubnetID = v.LocalSubnetID
	u.LocalAddress = v.LocalAddress
	u.Subnets = v.Subnets
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.NetworkName = u.NetworkName
	v.Type = u.Type
	v.LocalSubnetID = u.LocalSubnetID
	v.LocalAddress = u.LocalAddress
	v.Subnets = u.Subnets
	return nil
}

func (v *Subnet) UnmarshalJSON(data []byte) error {
	u := struct {
		ID    string                   `json:"iD,omitempty"`
		Type  NetworkType              `json:"type,omitempty"`
		Nodes encoding.JsonList[*Node] `json:"nodes,omitempty"`
	}{}
	u.ID = v.ID
	u.Type = v.Type
	u.Nodes = v.Nodes
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ID = u.ID
	v.Type = u.Type
	v.Nodes = u.Nodes
	return nil
}
