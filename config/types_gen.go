package config

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"encoding/json"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

type Network struct {
	NetworkName      string      `json:"networkName,omitempty" form:"networkName" query:"networkName" validate:"required" toml:"network-name" mapstructure:"network-name"`
	Type             NetworkType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	LocalPartitionID string      `json:"localPartitionID,omitempty" form:"localPartitionID" query:"localPartitionID" validate:"required" toml:"local-partition" mapstructure:"local-partition"`
	LocalAddress     string      `json:"localAddress,omitempty" form:"localAddress" query:"localAddress" validate:"required" toml:"local-address" mapstructure:"local-address"`
	Partitions       []Partition `json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required" toml:"partitions" mapstructure:"partitions"`
	extraData        []byte
}

type Node struct {
	Address   string   `json:"address,omitempty" form:"address" query:"address" validate:"required" toml:"address" mapstructure:"address"`
	Type      NodeType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	extraData []byte
}

type Partition struct {
	ID        string      `json:"iD,omitempty" form:"iD" query:"iD" validate:"required" toml:"id" mapstructure:"id"`
	Type      NetworkType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	Nodes     []Node      `json:"nodes,omitempty" form:"nodes" query:"nodes" validate:"required" toml:"nodes" mapstructure:"nodes"`
	extraData []byte
}

func (v *Network) Copy() *Network {
	u := new(Network)

	u.NetworkName = v.NetworkName
	u.Type = v.Type
	u.LocalPartitionID = v.LocalPartitionID
	u.LocalAddress = v.LocalAddress
	u.Partitions = make([]Partition, len(v.Partitions))
	for i, v := range v.Partitions {
		u.Partitions[i] = *(&v).Copy()
	}

	return u
}

func (v *Network) CopyAsInterface() interface{} { return v.Copy() }

func (v *Node) Copy() *Node {
	u := new(Node)

	u.Address = v.Address
	u.Type = v.Type

	return u
}

func (v *Node) CopyAsInterface() interface{} { return v.Copy() }

func (v *Partition) Copy() *Partition {
	u := new(Partition)

	u.ID = v.ID
	u.Type = v.Type
	u.Nodes = make([]Node, len(v.Nodes))
	for i, v := range v.Nodes {
		u.Nodes[i] = *(&v).Copy()
	}

	return u
}

func (v *Partition) CopyAsInterface() interface{} { return v.Copy() }

func (v *Network) Equal(u *Network) bool {
	if !(v.NetworkName == u.NetworkName) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.LocalPartitionID == u.LocalPartitionID) {
		return false
	}
	if !(v.LocalAddress == u.LocalAddress) {
		return false
	}
	if len(v.Partitions) != len(u.Partitions) {
		return false
	}
	for i := range v.Partitions {
		if !((&v.Partitions[i]).Equal(&u.Partitions[i])) {
			return false
		}
	}

	return true
}

func (v *Node) Equal(u *Node) bool {
	if !(v.Address == u.Address) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *Partition) Equal(u *Partition) bool {
	if !(v.ID == u.ID) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if len(v.Nodes) != len(u.Nodes) {
		return false
	}
	for i := range v.Nodes {
		if !((&v.Nodes[i]).Equal(&u.Nodes[i])) {
			return false
		}
	}

	return true
}

func (v *Network) MarshalJSON() ([]byte, error) {
	u := struct {
		NetworkName      string                       `json:"networkName,omitempty"`
		Type             NetworkType                  `json:"type,omitempty"`
		LocalPartitionID string                       `json:"localPartitionID,omitempty"`
		LocalSubnetID    string                       `json:"localSubnetID,omitempty"`
		LocalAddress     string                       `json:"localAddress,omitempty"`
		Partitions       encoding.JsonList[Partition] `json:"partitions,omitempty"`
		Subnets          encoding.JsonList[Partition] `json:"subnets,omitempty"`
	}{}
	u.NetworkName = v.NetworkName
	u.Type = v.Type
	u.LocalPartitionID = v.LocalPartitionID
	u.LocalSubnetID = v.LocalPartitionID
	u.LocalAddress = v.LocalAddress
	u.Partitions = v.Partitions
	u.Subnets = v.Partitions
	return json.Marshal(&u)
}

func (v *Partition) MarshalJSON() ([]byte, error) {
	u := struct {
		ID    string                  `json:"iD,omitempty"`
		Type  NetworkType             `json:"type,omitempty"`
		Nodes encoding.JsonList[Node] `json:"nodes,omitempty"`
	}{}
	u.ID = v.ID
	u.Type = v.Type
	u.Nodes = v.Nodes
	return json.Marshal(&u)
}

func (v *Network) UnmarshalJSON(data []byte) error {
	u := struct {
		NetworkName      string                       `json:"networkName,omitempty"`
		Type             NetworkType                  `json:"type,omitempty"`
		LocalPartitionID string                       `json:"localPartitionID,omitempty"`
		LocalSubnetID    string                       `json:"localSubnetID,omitempty"`
		LocalAddress     string                       `json:"localAddress,omitempty"`
		Partitions       encoding.JsonList[Partition] `json:"partitions,omitempty"`
		Subnets          encoding.JsonList[Partition] `json:"subnets,omitempty"`
	}{}
	u.NetworkName = v.NetworkName
	u.Type = v.Type
	u.LocalPartitionID = v.LocalPartitionID
	u.LocalSubnetID = v.LocalPartitionID
	u.LocalAddress = v.LocalAddress
	u.Partitions = v.Partitions
	u.Subnets = v.Partitions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.NetworkName = u.NetworkName
	v.Type = u.Type
	if !(u.LocalPartitionID == "") {
		v.LocalPartitionID = u.LocalPartitionID
	} else {
		v.LocalPartitionID = u.LocalSubnetID
	}
	v.LocalAddress = u.LocalAddress
	if !(u.Partitions.Equal(&[]Partition{})) {
		v.Partitions = u.Partitions
	} else {
		v.Partitions = u.Subnets
	}
	return nil
}

func (v *Partition) UnmarshalJSON(data []byte) error {
	u := struct {
		ID    string                  `json:"iD,omitempty"`
		Type  NetworkType             `json:"type,omitempty"`
		Nodes encoding.JsonList[Node] `json:"nodes,omitempty"`
	}{}
	u.ID = v.ID
	u.Type = v.Type
	u.Nodes = v.Nodes
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ID = u.ID
	v.Type = u.Type
	v.Nodes = u.Nodes
	return nil
}
