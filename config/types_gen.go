package config

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

type Describe struct {
	fieldsSet   []bool
	NetworkType NetworkType `json:"networkType,omitempty" form:"networkType" query:"networkType" validate:"required" toml:"type" mapstructure:"type"`
	NetworkId   string      `json:"networkId,omitempty" form:"networkId" query:"networkId" validate:"required" toml:"network-id" mapstructure:"network-id"`
	PartitionId string      `json:"partitionId,omitempty" form:"partitionId" query:"partitionId" validate:"required" toml:"partition-id" mapstructure:"partition-id"`
	extraData   []byte
}

func (v *Describe) Copy() *Describe {
	u := new(Describe)

	u.NetworkType = v.NetworkType
	u.NetworkId = v.NetworkId
	u.PartitionId = v.PartitionId

	return u
}

func (v *Describe) CopyAsInterface() interface{} { return v.Copy() }

func (v *Describe) Equal(u *Describe) bool {
	if !(v.NetworkType == u.NetworkType) {
		return false
	}
	if !(v.NetworkId == u.NetworkId) {
		return false
	}
	if !(v.PartitionId == u.PartitionId) {
		return false
	}

	return true
}

var fieldNames_Describe = []string{
	1: "NetworkType",
	2: "NetworkId",
	3: "PartitionId",
}

func (v *Describe) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.NetworkType == 0) {
		writer.WriteEnum(1, v.NetworkType)
	}
	if !(len(v.NetworkId) == 0) {
		writer.WriteString(2, v.NetworkId)
	}
	if !(len(v.PartitionId) == 0) {
		writer.WriteString(3, v.PartitionId)
	}

	_, _, err := writer.Reset(fieldNames_Describe)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Describe) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field NetworkType is missing")
	} else if v.NetworkType == 0 {
		errs = append(errs, "field NetworkType is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field NetworkId is missing")
	} else if len(v.NetworkId) == 0 {
		errs = append(errs, "field NetworkId is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field PartitionId is missing")
	} else if len(v.PartitionId) == 0 {
		errs = append(errs, "field PartitionId is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *Describe) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Describe) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(NetworkType); reader.ReadEnum(1, x) {
		v.NetworkType = *x
	}
	if x, ok := reader.ReadString(2); ok {
		v.NetworkId = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.PartitionId = x
	}

	seen, err := reader.Reset(fieldNames_Describe)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Describe) MarshalJSON() ([]byte, error) {
	u := struct {
		NetworkType NetworkType `json:"networkType,omitempty"`
		NetworkId   string      `json:"networkId,omitempty"`
		PartitionId string      `json:"partitionId,omitempty"`
		SubnetId    string      `json:"subnetId,omitempty"`
	}{}
	u.NetworkType = v.NetworkType
	u.NetworkId = v.NetworkId
	u.PartitionId = v.PartitionId
	u.SubnetId = v.PartitionId
	return json.Marshal(&u)
}

func (v *Describe) UnmarshalJSON(data []byte) error {
	u := struct {
		NetworkType NetworkType `json:"networkType,omitempty"`
		NetworkId   string      `json:"networkId,omitempty"`
		PartitionId string      `json:"partitionId,omitempty"`
		SubnetId    string      `json:"subnetId,omitempty"`
	}{}
	u.NetworkType = v.NetworkType
	u.NetworkId = v.NetworkId
	u.PartitionId = v.PartitionId
	u.SubnetId = v.PartitionId
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.NetworkType = u.NetworkType
	v.NetworkId = u.NetworkId
	if !(u.PartitionId == "") {
		v.PartitionId = u.PartitionId
	} else {
		v.PartitionId = u.SubnetId
	}
	return nil
}
