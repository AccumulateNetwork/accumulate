package config

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"encoding/json"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

type Describe struct {
	NetworkType  NetworkType `json:"networkType,omitempty" form:"networkType" query:"networkType" validate:"required" toml:"type" mapstructure:"type"`
	PartitionId  string      `json:"partitionId,omitempty" form:"partitionId" query:"partitionId" validate:"required" toml:"partition-id" mapstructure:"partition-id"`
	LocalAddress string      `json:"localAddress,omitempty" form:"localAddress" query:"localAddress" validate:"required" toml:"local-address" mapstructure:"local-address"`
	Network      Network     `json:"network,omitempty" form:"network" query:"network" validate:"required" toml:"network" mapstructure:"network"`
	extraData    []byte
}

type Network struct {
	Id         string      `json:"id,omitempty" form:"id" query:"id" validate:"required" toml:"id" mapstructure:"id"`
	Partitions []Partition `json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required" toml:"partitions" mapstructure:"partitions"`
	extraData  []byte
}

type Node struct {
	Address   string   `json:"address,omitempty" form:"address" query:"address" validate:"required" toml:"address" mapstructure:"address"`
	Type      NodeType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	extraData []byte
}

type Partition struct {
	Id        string      `json:"id,omitempty" form:"id" query:"id" validate:"required" toml:"id" mapstructure:"id"`
	Type      NetworkType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	BasePort  int64       `json:"basePort,omitempty" form:"basePort" query:"basePort" validate:"required" toml:"port" mapstructure:"port"`
	Nodes     []Node      `json:"nodes,omitempty" form:"nodes" query:"nodes" validate:"required" toml:"nodes" mapstructure:"nodes"`
	extraData []byte
}

func (v *Describe) Copy() *Describe {
	u := new(Describe)

	u.NetworkType = v.NetworkType
	u.PartitionId = v.PartitionId
	u.LocalAddress = v.LocalAddress
	u.Network = *(&v.Network).Copy()

	return u
}

func (v *Describe) CopyAsInterface() interface{} { return v.Copy() }

func (v *Network) Copy() *Network {
	u := new(Network)

	u.Id = v.Id
	u.Partitions = make([]Partition, len(v.Partitions))
	for i, v := range v.Partitions {
		u.Partitions[i] = *(&v).Copy()
	}

	return u
}

func (v *Network) CopyAsInterface() interface{} { return v.Copy() }

func (v *Node) Copy() *Node {
	u := new(Node)

	u.Address = v.Address
	u.Type = v.Type

	return u
}

func (v *Node) CopyAsInterface() interface{} { return v.Copy() }

func (v *Partition) Copy() *Partition {
	u := new(Partition)

	u.Id = v.Id
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = make([]Node, len(v.Nodes))
	for i, v := range v.Nodes {
		u.Nodes[i] = *(&v).Copy()
	}

	return u
}

func (v *Partition) CopyAsInterface() interface{} { return v.Copy() }

func (v *Describe) Equal(u *Describe) bool {
	if !(v.NetworkType == u.NetworkType) {
		return false
	}
	if !(v.PartitionId == u.PartitionId) {
		return false
	}
	if !(v.LocalAddress == u.LocalAddress) {
		return false
	}
	if !((&v.Network).Equal(&u.Network)) {
		return false
	}

	return true
}

func (v *Network) Equal(u *Network) bool {
	if !(v.Id == u.Id) {
		return false
	}
	if len(v.Partitions) != len(u.Partitions) {
		return false
	}
	for i := range v.Partitions {
		if !((&v.Partitions[i]).Equal(&u.Partitions[i])) {
			return false
		}
	}

	return true
}

func (v *Node) Equal(u *Node) bool {
	if !(v.Address == u.Address) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *Partition) Equal(u *Partition) bool {
	if !(v.Id == u.Id) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.BasePort == u.BasePort) {
		return false
	}
	if len(v.Nodes) != len(u.Nodes) {
		return false
	}
	for i := range v.Nodes {
		if !((&v.Nodes[i]).Equal(&u.Nodes[i])) {
			return false
		}
	}

	return true
}

func (v *Describe) MarshalJSON() ([]byte, error) {
	u := struct {
		NetworkType  NetworkType `json:"networkType,omitempty"`
		PartitionId  string      `json:"partitionId,omitempty"`
		SubnetId     string      `json:"subnetId,omitempty"`
		LocalAddress string      `json:"localAddress,omitempty"`
		Network      Network     `json:"network,omitempty"`
	}{}
	u.NetworkType = v.NetworkType
	u.PartitionId = v.PartitionId
	u.SubnetId = v.PartitionId
	u.LocalAddress = v.LocalAddress
	u.Network = v.Network
	return json.Marshal(&u)
}

func (v *Network) MarshalJSON() ([]byte, error) {
	u := struct {
		Id         string                       `json:"id,omitempty"`
		Partitions encoding.JsonList[Partition] `json:"partitions,omitempty"`
		Subnets    encoding.JsonList[Partition] `json:"subnets,omitempty"`
	}{}
	u.Id = v.Id
	u.Partitions = v.Partitions
	u.Subnets = v.Partitions
	return json.Marshal(&u)
}

func (v *Partition) MarshalJSON() ([]byte, error) {
	u := struct {
		Id       string                  `json:"id,omitempty"`
		Type     NetworkType             `json:"type,omitempty"`
		BasePort int64                   `json:"basePort,omitempty"`
		Nodes    encoding.JsonList[Node] `json:"nodes,omitempty"`
	}{}
	u.Id = v.Id
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = v.Nodes
	return json.Marshal(&u)
}

func (v *Describe) UnmarshalJSON(data []byte) error {
	u := struct {
		NetworkType  NetworkType `json:"networkType,omitempty"`
		PartitionId  string      `json:"partitionId,omitempty"`
		SubnetId     string      `json:"subnetId,omitempty"`
		LocalAddress string      `json:"localAddress,omitempty"`
		Network      Network     `json:"network,omitempty"`
	}{}
	u.NetworkType = v.NetworkType
	u.PartitionId = v.PartitionId
	u.SubnetId = v.PartitionId
	u.LocalAddress = v.LocalAddress
	u.Network = v.Network
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.NetworkType = u.NetworkType
	if !(u.PartitionId == "") {
		v.PartitionId = u.PartitionId
	} else {
		v.PartitionId = u.SubnetId
	}
	v.LocalAddress = u.LocalAddress
	v.Network = u.Network
	return nil
}

func (v *Network) UnmarshalJSON(data []byte) error {
	u := struct {
		Id         string                       `json:"id,omitempty"`
		Partitions encoding.JsonList[Partition] `json:"partitions,omitempty"`
		Subnets    encoding.JsonList[Partition] `json:"subnets,omitempty"`
	}{}
	u.Id = v.Id
	u.Partitions = v.Partitions
	u.Subnets = v.Partitions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Id = u.Id
	if !(len(u.Partitions) == 0) {
		v.Partitions = u.Partitions
	} else {
		v.Partitions = u.Subnets
	}
	return nil
}

func (v *Partition) UnmarshalJSON(data []byte) error {
	u := struct {
		Id       string                  `json:"id,omitempty"`
		Type     NetworkType             `json:"type,omitempty"`
		BasePort int64                   `json:"basePort,omitempty"`
		Nodes    encoding.JsonList[Node] `json:"nodes,omitempty"`
	}{}
	u.Id = v.Id
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = v.Nodes
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Id = u.Id
	v.Type = u.Type
	v.BasePort = u.BasePort
	v.Nodes = u.Nodes
	return nil
}
