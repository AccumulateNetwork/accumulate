package api

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type AuthorizationRequired struct {
	fieldsSet []bool
	Key       []byte  `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Version   Version `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	extraData []byte
}

type DecodeTransactionRequest struct {
	TransactionBinary []byte `json:"transactionBinary,omitempty" form:"transactionBinary" query:"transactionBinary" validate:"required"`
}

type DecodeTransactionResponse struct {
	TransactionJson string `json:"transactionJson,omitempty" form:"transactionJson" query:"transactionJson" validate:"required"`
}

type EncodeTransactionRequest struct {
	TransactionJson string `json:"transactionJson,omitempty" form:"transactionJson" query:"transactionJson" validate:"required"`
}

type EncodeTransactionRespones struct {
	TransactionBinary []byte `json:"transactionBinary,omitempty" form:"transactionBinary" query:"transactionBinary" validate:"required"`
	TransactionHash   []byte `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash" validate:"required"`
}

type KeyList struct {
	fieldsSet []bool
	Name      string                 `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	PublicKey []byte                 `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	KeyType   protocol.SignatureType `json:"keyType,omitempty" form:"keyType" query:"keyType" validate:"required"`
	extraData []byte
}

type KeyListResponse struct {
	fieldsSet []bool
	KeyList   []KeyList `json:"keyList,omitempty" form:"keyList" query:"keyList" validate:"required"`
	extraData []byte
}

type SignRequest struct {
	ReferenceId int64  `json:"referenceId,omitempty" form:"referenceId" query:"referenceId" validate:"required"`
	KeyName     string `json:"keyName,omitempty" form:"keyName" query:"keyName"`
}

type SignResponse struct {
	Signature []byte `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	PublicKey []byte `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
}

type VersionResponse struct {
	fieldsSet []bool
	Version   string `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Commit    string `json:"commit,omitempty" form:"commit" query:"commit" validate:"required"`
	extraData []byte
}

func (v *AuthorizationRequired) Copy() *AuthorizationRequired {
	u := new(AuthorizationRequired)

	u.Key = encoding.BytesCopy(v.Key)
	u.Version = *(&v.Version).Copy()

	return u
}

func (v *AuthorizationRequired) CopyAsInterface() interface{} { return v.Copy() }

func (v *DecodeTransactionRequest) Copy() *DecodeTransactionRequest {
	u := new(DecodeTransactionRequest)

	u.TransactionBinary = encoding.BytesCopy(v.TransactionBinary)

	return u
}

func (v *DecodeTransactionRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *DecodeTransactionResponse) Copy() *DecodeTransactionResponse {
	u := new(DecodeTransactionResponse)

	u.TransactionJson = v.TransactionJson

	return u
}

func (v *DecodeTransactionResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *EncodeTransactionRequest) Copy() *EncodeTransactionRequest {
	u := new(EncodeTransactionRequest)

	u.TransactionJson = v.TransactionJson

	return u
}

func (v *EncodeTransactionRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *EncodeTransactionRespones) Copy() *EncodeTransactionRespones {
	u := new(EncodeTransactionRespones)

	u.TransactionBinary = encoding.BytesCopy(v.TransactionBinary)
	u.TransactionHash = encoding.BytesCopy(v.TransactionHash)

	return u
}

func (v *EncodeTransactionRespones) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeyList) Copy() *KeyList {
	u := new(KeyList)

	u.Name = v.Name
	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.KeyType = v.KeyType

	return u
}

func (v *KeyList) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeyListResponse) Copy() *KeyListResponse {
	u := new(KeyListResponse)

	u.KeyList = make([]KeyList, len(v.KeyList))
	for i, v := range v.KeyList {
		u.KeyList[i] = *(&v).Copy()
	}

	return u
}

func (v *KeyListResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignRequest) Copy() *SignRequest {
	u := new(SignRequest)

	u.ReferenceId = v.ReferenceId
	u.KeyName = v.KeyName

	return u
}

func (v *SignRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignResponse) Copy() *SignResponse {
	u := new(SignResponse)

	u.Signature = encoding.BytesCopy(v.Signature)
	u.PublicKey = encoding.BytesCopy(v.PublicKey)

	return u
}

func (v *SignResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *VersionResponse) Copy() *VersionResponse {
	u := new(VersionResponse)

	u.Version = v.Version
	u.Commit = v.Commit

	return u
}

func (v *VersionResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *AuthorizationRequired) Equal(u *AuthorizationRequired) bool {
	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}
	if !((&v.Version).Equal(&u.Version)) {
		return false
	}

	return true
}

func (v *DecodeTransactionRequest) Equal(u *DecodeTransactionRequest) bool {
	if !(bytes.Equal(v.TransactionBinary, u.TransactionBinary)) {
		return false
	}

	return true
}

func (v *DecodeTransactionResponse) Equal(u *DecodeTransactionResponse) bool {
	if !(v.TransactionJson == u.TransactionJson) {
		return false
	}

	return true
}

func (v *EncodeTransactionRequest) Equal(u *EncodeTransactionRequest) bool {
	if !(v.TransactionJson == u.TransactionJson) {
		return false
	}

	return true
}

func (v *EncodeTransactionRespones) Equal(u *EncodeTransactionRespones) bool {
	if !(bytes.Equal(v.TransactionBinary, u.TransactionBinary)) {
		return false
	}
	if !(bytes.Equal(v.TransactionHash, u.TransactionHash)) {
		return false
	}

	return true
}

func (v *KeyList) Equal(u *KeyList) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(v.KeyType == u.KeyType) {
		return false
	}

	return true
}

func (v *KeyListResponse) Equal(u *KeyListResponse) bool {
	if len(v.KeyList) != len(u.KeyList) {
		return false
	}
	for i := range v.KeyList {
		if !((&v.KeyList[i]).Equal(&u.KeyList[i])) {
			return false
		}
	}

	return true
}

func (v *SignRequest) Equal(u *SignRequest) bool {
	if !(v.ReferenceId == u.ReferenceId) {
		return false
	}
	if !(v.KeyName == u.KeyName) {
		return false
	}

	return true
}

func (v *SignResponse) Equal(u *SignResponse) bool {
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}

	return true
}

func (v *VersionResponse) Equal(u *VersionResponse) bool {
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.Commit == u.Commit) {
		return false
	}

	return true
}

var fieldNames_AuthorizationRequired = []string{
	1: "Key",
	2: "Version",
}

func (v *AuthorizationRequired) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Key) == 0) {
		writer.WriteBytes(1, v.Key)
	}
	if !((v.Version).Equal(new(Version))) {
		writer.WriteValue(2, v.Version.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_AuthorizationRequired)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AuthorizationRequired) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Key is missing")
	} else if len(v.Key) == 0 {
		errs = append(errs, "field Key is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Version is missing")
	} else if (v.Version).Equal(new(Version)) {
		errs = append(errs, "field Version is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeyList = []string{
	1: "Name",
	2: "PublicKey",
	3: "KeyType",
}

func (v *KeyList) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(v.KeyType == 0) {
		writer.WriteEnum(3, v.KeyType)
	}

	_, _, err := writer.Reset(fieldNames_KeyList)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *KeyList) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field KeyType is missing")
	} else if v.KeyType == 0 {
		errs = append(errs, "field KeyType is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_KeyListResponse = []string{
	1: "KeyList",
}

func (v *KeyListResponse) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.KeyList) == 0) {
		for _, v := range v.KeyList {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_KeyListResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *KeyListResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field KeyList is missing")
	} else if len(v.KeyList) == 0 {
		errs = append(errs, "field KeyList is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_VersionResponse = []string{
	1: "Version",
	2: "Commit",
}

func (v *VersionResponse) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Version) == 0) {
		writer.WriteString(1, v.Version)
	}
	if !(len(v.Commit) == 0) {
		writer.WriteString(2, v.Commit)
	}

	_, _, err := writer.Reset(fieldNames_VersionResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *VersionResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Version is missing")
	} else if len(v.Version) == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Commit is missing")
	} else if len(v.Commit) == 0 {
		errs = append(errs, "field Commit is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *AuthorizationRequired) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AuthorizationRequired) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.Key = x
	}
	if x := new(Version); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Version = *x
	}

	seen, err := reader.Reset(fieldNames_AuthorizationRequired)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *KeyList) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeyList) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x := new(protocol.SignatureType); reader.ReadEnum(3, x) {
		v.KeyType = *x
	}

	seen, err := reader.Reset(fieldNames_KeyList)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *KeyListResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeyListResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(KeyList); reader.ReadValue(1, x.UnmarshalBinary) {
			v.KeyList = append(v.KeyList, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_KeyListResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *VersionResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *VersionResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Version = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Commit = x
	}

	seen, err := reader.Reset(fieldNames_VersionResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AuthorizationRequired) MarshalJSON() ([]byte, error) {
	u := struct {
		Key     *string `json:"key,omitempty"`
		Version Version `json:"version,omitempty"`
	}{}
	u.Key = encoding.BytesToJSON(v.Key)
	u.Version = v.Version
	return json.Marshal(&u)
}

func (v *DecodeTransactionRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		TransactionBinary *string `json:"transactionBinary,omitempty"`
	}{}
	u.TransactionBinary = encoding.BytesToJSON(v.TransactionBinary)
	return json.Marshal(&u)
}

func (v *EncodeTransactionRespones) MarshalJSON() ([]byte, error) {
	u := struct {
		TransactionBinary *string `json:"transactionBinary,omitempty"`
		TransactionHash   *string `json:"transactionHash,omitempty"`
	}{}
	u.TransactionBinary = encoding.BytesToJSON(v.TransactionBinary)
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	return json.Marshal(&u)
}

func (v *KeyList) MarshalJSON() ([]byte, error) {
	u := struct {
		Name      string                 `json:"name,omitempty"`
		PublicKey *string                `json:"publicKey,omitempty"`
		KeyType   protocol.SignatureType `json:"keyType,omitempty"`
	}{}
	u.Name = v.Name
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.KeyType = v.KeyType
	return json.Marshal(&u)
}

func (v *KeyListResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		KeyList encoding.JsonList[KeyList] `json:"keyList,omitempty"`
	}{}
	u.KeyList = v.KeyList
	return json.Marshal(&u)
}

func (v *SignResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Signature *string `json:"signature,omitempty"`
		PublicKey *string `json:"publicKey,omitempty"`
	}{}
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	return json.Marshal(&u)
}

func (v *AuthorizationRequired) UnmarshalJSON(data []byte) error {
	u := struct {
		Key     *string `json:"key,omitempty"`
		Version Version `json:"version,omitempty"`
	}{}
	u.Key = encoding.BytesToJSON(v.Key)
	u.Version = v.Version
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	v.Version = u.Version
	return nil
}

func (v *DecodeTransactionRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		TransactionBinary *string `json:"transactionBinary,omitempty"`
	}{}
	u.TransactionBinary = encoding.BytesToJSON(v.TransactionBinary)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.TransactionBinary); err != nil {
		return fmt.Errorf("error decoding TransactionBinary: %w", err)
	} else {
		v.TransactionBinary = x
	}
	return nil
}

func (v *EncodeTransactionRespones) UnmarshalJSON(data []byte) error {
	u := struct {
		TransactionBinary *string `json:"transactionBinary,omitempty"`
		TransactionHash   *string `json:"transactionHash,omitempty"`
	}{}
	u.TransactionBinary = encoding.BytesToJSON(v.TransactionBinary)
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.TransactionBinary); err != nil {
		return fmt.Errorf("error decoding TransactionBinary: %w", err)
	} else {
		v.TransactionBinary = x
	}
	if x, err := encoding.BytesFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	return nil
}

func (v *KeyList) UnmarshalJSON(data []byte) error {
	u := struct {
		Name      string                 `json:"name,omitempty"`
		PublicKey *string                `json:"publicKey,omitempty"`
		KeyType   protocol.SignatureType `json:"keyType,omitempty"`
	}{}
	u.Name = v.Name
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.KeyType = v.KeyType
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Name = u.Name
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	v.KeyType = u.KeyType
	return nil
}

func (v *KeyListResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		KeyList encoding.JsonList[KeyList] `json:"keyList,omitempty"`
	}{}
	u.KeyList = v.KeyList
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.KeyList = u.KeyList
	return nil
}

func (v *SignResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Signature *string `json:"signature,omitempty"`
		PublicKey *string `json:"publicKey,omitempty"`
	}{}
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	return nil
}
