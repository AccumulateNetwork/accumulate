package walletd

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"errors"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/core/encoding"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type KeyInfo struct {
	fieldsSet  []bool
	Type       protocol.SignatureType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Derivation string                 `json:"derivation,omitempty" form:"derivation" query:"derivation"`
	extraData  []byte
}

func (v *KeyInfo) Copy() *KeyInfo {
	u := new(KeyInfo)

	u.Type = v.Type
	u.Derivation = v.Derivation

	return u
}

func (v *KeyInfo) CopyAsInterface() interface{} { return v.Copy() }

func (v *KeyInfo) Equal(u *KeyInfo) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Derivation == u.Derivation) {
		return false
	}

	return true
}

var fieldNames_KeyInfo = []string{
	1: "Type",
	2: "Derivation",
}

func (v *KeyInfo) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	if !(len(v.Derivation) == 0) {
		writer.WriteString(2, v.Derivation)
	}

	_, _, err := writer.Reset(fieldNames_KeyInfo)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *KeyInfo) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *KeyInfo) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *KeyInfo) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.SignatureType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Derivation = x
	}

	seen, err := reader.Reset(fieldNames_KeyInfo)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}
