// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package main

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"io"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
)

type AnchorData struct {
	fieldsSet []bool
	Block     uint64    `json:"block,omitempty" form:"block" query:"block" validate:"required"`
	Time      time.Time `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	extraData []byte
}

var machine_AnchorData = &encoding.Machine[*AnchorData]{
	ExtraData: func(v *AnchorData) *[]byte { return &v.extraData },
	Seen:      func(v *AnchorData) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*AnchorData]{
		{Name: "Block", Number: 1, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.UintField[*AnchorData](func(v *AnchorData) *uint64 { return &v.Block })},
		{Name: "Time", Number: 2, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.TimeField[*AnchorData](func(v *AnchorData) *time.Time { return &v.Time })},
	},
}

func (v *AnchorData) IsValid() error                    { return machine_AnchorData.IsValid(v) }
func (v *AnchorData) Copy() *AnchorData                 { return encoding.Copy(machine_AnchorData, v) }
func (v *AnchorData) CopyAsInterface() interface{}      { return v.Copy() }
func (v *AnchorData) Equal(u *AnchorData) bool          { return machine_AnchorData.Equal(v, u) }
func (v *AnchorData) MarshalBinary() ([]byte, error)    { return machine_AnchorData.MarshalBinary(v) }
func (v *AnchorData) UnmarshalBinary(data []byte) error { return machine_AnchorData.Unmarshal(data, v) }
func (v *AnchorData) UnmarshalBinaryFrom(rd io.Reader) error {
	return machine_AnchorData.UnmarshalFrom(rd, v)
}
func (v *AnchorData) MarshalJSON() ([]byte, error) { return machine_AnchorData.JSONMarshal(v) }
func (v *AnchorData) UnmarshalJSON(b []byte) error { return machine_AnchorData.JSONUnmarshal(b, v) }

type ChainData struct {
	fieldsSet []bool
	Account   *url.URL  `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Chain     string    `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	Block     uint64    `json:"block,omitempty" form:"block" query:"block" validate:"required"`
	Time      time.Time `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	extraData []byte
}

var machine_ChainData = &encoding.Machine[*ChainData]{
	ExtraData: func(v *ChainData) *[]byte { return &v.extraData },
	Seen:      func(v *ChainData) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*ChainData]{
		{Name: "Account", Number: 1, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.UrlPtrField[*ChainData](func(v *ChainData) **url.URL { return &v.Account })},
		{Name: "Chain", Number: 2, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.StringField[*ChainData](func(v *ChainData) *string { return &v.Chain })},
		{Name: "Block", Number: 3, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.UintField[*ChainData](func(v *ChainData) *uint64 { return &v.Block })},
		{Name: "Time", Number: 4, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.TimeField[*ChainData](func(v *ChainData) *time.Time { return &v.Time })},
	},
}

func (v *ChainData) IsValid() error                    { return machine_ChainData.IsValid(v) }
func (v *ChainData) Copy() *ChainData                  { return encoding.Copy(machine_ChainData, v) }
func (v *ChainData) CopyAsInterface() interface{}      { return v.Copy() }
func (v *ChainData) Equal(u *ChainData) bool           { return machine_ChainData.Equal(v, u) }
func (v *ChainData) MarshalBinary() ([]byte, error)    { return machine_ChainData.MarshalBinary(v) }
func (v *ChainData) UnmarshalBinary(data []byte) error { return machine_ChainData.Unmarshal(data, v) }
func (v *ChainData) UnmarshalBinaryFrom(rd io.Reader) error {
	return machine_ChainData.UnmarshalFrom(rd, v)
}
func (v *ChainData) MarshalJSON() ([]byte, error) { return machine_ChainData.JSONMarshal(v) }
func (v *ChainData) UnmarshalJSON(b []byte) error { return machine_ChainData.JSONUnmarshal(b, v) }

type MessageData struct {
	fieldsSet   []bool
	LastUpdated time.Time    `json:"lastUpdated,omitempty" form:"lastUpdated" query:"lastUpdated" validate:"required"`
	Chains      []*ChainData `json:"chains" form:"chains" query:"chains" validate:"required"`
	extraData   []byte
}

var machine_MessageData = &encoding.Machine[*MessageData]{
	ExtraData: func(v *MessageData) *[]byte { return &v.extraData },
	Seen:      func(v *MessageData) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*MessageData]{
		{Name: "LastUpdated", Number: 1, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.TimeField[*MessageData](func(v *MessageData) *time.Time { return &v.LastUpdated })},
		{Name: "Chains", Number: 2, Binary: true, Required: true, Accessor: encoding.SliceField[*MessageData, *ChainData, encoding.StructPtrField[encoding.SliceIndex[*ChainData], *ChainData, ChainData]](func(v *MessageData) *[]*ChainData { return &v.Chains })},
	},
}

func (v *MessageData) IsValid() error                 { return machine_MessageData.IsValid(v) }
func (v *MessageData) Copy() *MessageData             { return encoding.Copy(machine_MessageData, v) }
func (v *MessageData) CopyAsInterface() interface{}   { return v.Copy() }
func (v *MessageData) Equal(u *MessageData) bool      { return machine_MessageData.Equal(v, u) }
func (v *MessageData) MarshalBinary() ([]byte, error) { return machine_MessageData.MarshalBinary(v) }
func (v *MessageData) UnmarshalBinary(data []byte) error {
	return machine_MessageData.Unmarshal(data, v)
}
func (v *MessageData) UnmarshalBinaryFrom(rd io.Reader) error {
	return machine_MessageData.UnmarshalFrom(rd, v)
}
func (v *MessageData) MarshalJSON() ([]byte, error) { return machine_MessageData.JSONMarshal(v) }
func (v *MessageData) UnmarshalJSON(b []byte) error { return machine_MessageData.JSONUnmarshal(b, v) }
