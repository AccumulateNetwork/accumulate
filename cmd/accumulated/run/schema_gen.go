// Code generated by gitlab.com/accumulatenetwork/core/schema. DO NOT EDIT.

package run

import (
	"fmt"
	"io/fs"
	"log/slog"

	peer "github.com/libp2p/go-libp2p/core/peer"
	multiaddr "github.com/multiformats/go-multiaddr"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/address"
	encoding "gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/network"
	record "gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
	url "gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/core/schema"
)

var (
	sBadgerStorage              schema.Methods[*BadgerStorage, *BadgerStorage, *schema.CompositeType]
	sBoltStorage                schema.Methods[*BoltStorage, *BoltStorage, *schema.CompositeType]
	sCometNodeKeyFile           schema.Methods[*CometNodeKeyFile, *CometNodeKeyFile, *schema.CompositeType]
	sCometPrivValFile           schema.Methods[*CometPrivValFile, *CometPrivValFile, *schema.CompositeType]
	sConfig                     schema.Methods[*Config, *Config, *schema.CompositeType]
	sConfiguration              schema.UnionMethods[Configuration, ConfigurationType]
	sConfigurationType          schema.EnumMethods[ConfigurationType]
	sConsensusApp               schema.UnionMethods[ConsensusApp, ConsensusAppType]
	sConsensusAppType           schema.EnumMethods[ConsensusAppType]
	sConsensusService           schema.Methods[*ConsensusService, *ConsensusService, *schema.CompositeType]
	sCoreConsensusApp           schema.Methods[*CoreConsensusApp, *CoreConsensusApp, *schema.CompositeType]
	sCoreValidatorConfiguration schema.Methods[*CoreValidatorConfiguration, *CoreValidatorConfiguration, *schema.CompositeType]
	sCoreValidatorMode          schema.EnumMethods[CoreValidatorMode]
	sDevnetConfiguration        schema.Methods[*DevnetConfiguration, *DevnetConfiguration, *schema.CompositeType]
	sEventsService              schema.Methods[*EventsService, *EventsService, *schema.CompositeType]
	sExpBlockDBStorage          schema.Methods[*ExpBlockDBStorage, *ExpBlockDBStorage, *schema.CompositeType]
	sFaucetService              schema.Methods[*FaucetService, *FaucetService, *schema.CompositeType]
	sGatewayConfiguration       schema.Methods[*GatewayConfiguration, *GatewayConfiguration, *schema.CompositeType]
	sHttpListener               schema.Methods[*HttpListener, *HttpListener, *schema.CompositeType]
	sHttpPeerMapEntry           schema.Methods[*HttpPeerMapEntry, *HttpPeerMapEntry, *schema.CompositeType]
	sHttpService                schema.Methods[*HttpService, *HttpService, *schema.CompositeType]
	sInstrumentation            schema.Methods[*Instrumentation, *Instrumentation, *schema.CompositeType]
	sLevelDBStorage             schema.Methods[*LevelDBStorage, *LevelDBStorage, *schema.CompositeType]
	sLogging                    schema.Methods[*Logging, *Logging, *schema.CompositeType]
	sLoggingRule                schema.Methods[*LoggingRule, *LoggingRule, *schema.CompositeType]
	sLokiLogging                schema.Methods[*LokiLogging, *LokiLogging, *schema.CompositeType]
	sMemoryStorage              schema.Methods[*MemoryStorage, *MemoryStorage, *schema.CompositeType]
	sMetricsService             schema.Methods[*MetricsService, *MetricsService, *schema.CompositeType]
	sMonitor                    schema.Methods[*Monitor, *Monitor, *schema.CompositeType]
	sMultiaddr                  schema.Methods[*Multiaddr, *Multiaddr, *schema.ExternalType]
	sNetworkService             schema.Methods[*NetworkService, *NetworkService, *schema.CompositeType]
	sOtlpConfig                 schema.Methods[*OtlpConfig, *OtlpConfig, *schema.CompositeType]
	sP2P                        schema.Methods[*P2P, *P2P, *schema.CompositeType]
	sPeerID                     schema.Methods[*PeerID, *PeerID, *schema.ExternalType]
	sPrivateKey                 schema.UnionMethods[PrivateKey, PrivateKeyType]
	sPrivateKeySeed             schema.Methods[*PrivateKeySeed, *PrivateKeySeed, *schema.CompositeType]
	sPrivateKeyType             schema.EnumMethods[PrivateKeyType]
	sQuerier                    schema.Methods[*Querier, *Querier, *schema.CompositeType]
	sRawPrivateKey              schema.Methods[*RawPrivateKey, *RawPrivateKey, *schema.CompositeType]
	sRouterService              schema.Methods[*RouterService, *RouterService, *schema.CompositeType]
	sService                    schema.UnionMethods[Service, ServiceType]
	sServiceType                schema.EnumMethods[ServiceType]
	sSnapshotService            schema.Methods[*SnapshotService, *SnapshotService, *schema.CompositeType]
	sStorage                    schema.UnionMethods[Storage, StorageType]
	sStorageService             schema.Methods[*StorageService, *StorageService, *schema.CompositeType]
	sStorageType                schema.EnumMethods[StorageType]
	sSubnodeService             schema.Methods[*SubnodeService, *SubnodeService, *schema.CompositeType]
	sTelemetry                  schema.Methods[*Telemetry, *Telemetry, *schema.CompositeType]
	sTelemetryRule              schema.Methods[*TelemetryRule, *TelemetryRule, *schema.CompositeType]
	sTransientPrivateKey        schema.Methods[*TransientPrivateKey, *TransientPrivateKey, *schema.CompositeType]
)

func init() {
	var deferredTypes schema.ResolverSet

	sBadgerStorage = schema.WithMethods[*BadgerStorage, *BadgerStorage](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "BadgerStorage",
		},
		Fields: []*schema.Field{
			{
				Name: "Path",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "Version",
				Type: &schema.SimpleType{Type: schema.SimpleTypeInt},
			},
		},
	}).SetGoType()

	sBoltStorage = schema.WithMethods[*BoltStorage, *BoltStorage](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "BoltStorage",
		},
		Fields: []*schema.Field{
			{
				Name: "Path",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sCometNodeKeyFile = schema.WithMethods[*CometNodeKeyFile, *CometNodeKeyFile](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "CometNodeKeyFile",
		},
		Fields: []*schema.Field{
			{
				Name: "Path",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
		Transients: []*schema.Field{
			{
				Name: "key",
				Type: schema.TypeReferenceFor[address.Address](),
			},
		},
	}).SetGoType()

	sCometPrivValFile = schema.WithMethods[*CometPrivValFile, *CometPrivValFile](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "CometPrivValFile",
		},
		Fields: []*schema.Field{
			{
				Name: "Path",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
		Transients: []*schema.Field{
			{
				Name: "key",
				Type: schema.TypeReferenceFor[address.Address](),
			},
		},
	}).SetGoType()

	sConfig = schema.WithMethods[*Config, *Config](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Config",
		},
		Fields: []*schema.Field{
			{
				Name: "DotEnv",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name: "Network",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "Configurations",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Configuration"),
			},
			{
				Name: "Services",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Service"),
			},
			{
				Name: "P2P",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "P2P"),
			},
			{
				Name: "Logging",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Logging"),
			},
			{
				Name: "Instrumentation",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Instrumentation"),
			},
			{
				Name: "Telemetry",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Telemetry"),
			},
		},
		Transients: []*schema.Field{
			{
				Name: "file",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "fs",
				Type: schema.TypeReferenceFor[fs.FS](),
			},
		},
	}).SetGoType()

	sConfiguration = schema.WithUnionMethods[Configuration, ConfigurationType](
		&schema.UnionType{
			TypeBase: schema.TypeBase{
				Name: "Configuration",
			},
			Discriminator: (&schema.UnionDiscriminator{
				Field: "Type",
			}).
				ResolveTypeTo(&deferredTypes, "ConfigurationType").
				ResolveEnumTo(&deferredTypes, "ConfigurationType"),
			Members: []*schema.UnionMember{
				{
					Discriminator: "coreValidator",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "CoreValidatorConfiguration"),
				},
				{
					Discriminator: "gateway",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "GatewayConfiguration"),
				},
				{
					Discriminator: "devnet",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "DevnetConfiguration"),
				},
			},
		}).SetGoType()

	sConfigurationType = schema.WithEnumMethods[ConfigurationType](
		&schema.EnumType{
			TypeBase: schema.TypeBase{
				Name: "ConfigurationType",
			},
			Underlying: &schema.SimpleType{Type: schema.SimpleTypeInt},
			Values: map[string]*schema.EnumValue{
				"CoreValidator": {
					Name:  "CoreValidator",
					Value: 1,
				},
				"Devnet": {
					Name:  "Devnet",
					Value: 3,
				},
				"Gateway": {
					Name:  "Gateway",
					Value: 2,
				},
			},
		}).SetGoType()

	sConsensusApp = schema.WithUnionMethods[ConsensusApp, ConsensusAppType](
		&schema.UnionType{
			TypeBase: schema.TypeBase{
				Name: "ConsensusApp",
			},
			Discriminator: (&schema.UnionDiscriminator{
				Field: "Type",
			}).
				ResolveTypeTo(&deferredTypes, "ConsensusAppType").
				ResolveEnumTo(&deferredTypes, "ConsensusAppType"),
			Members: []*schema.UnionMember{
				{
					Discriminator: "core",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "CoreConsensusApp"),
				},
			},
		}).SetGoType()

	sConsensusAppType = schema.WithEnumMethods[ConsensusAppType](
		&schema.EnumType{
			TypeBase: schema.TypeBase{
				Name: "ConsensusAppType",
			},
			Underlying: &schema.SimpleType{Type: schema.SimpleTypeInt},
			Values: map[string]*schema.EnumValue{
				"Core": {
					Name:  "Core",
					Value: 1,
				},
			},
		}).SetGoType()

	sConsensusService = schema.WithMethods[*ConsensusService, *ConsensusService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "ConsensusService",
		},
		Fields: []*schema.Field{
			{
				Name: "NodeDir",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			(&schema.Field{
				Name: "ValidatorKey",
			}).ResolveTo(&deferredTypes, "PrivateKey"),
			{
				Name: "Genesis",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			(&schema.Field{
				Name: "Listen",
			}).ResolveTo(&deferredTypes, "Multiaddr"),
			{
				Name: "BootstrapPeers",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Multiaddr"),
			},
			{
				Name:     "MetricsNamespace",
				Optional: true,
				Type:     &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			(&schema.Field{
				Name: "App",
			}).ResolveTo(&deferredTypes, "ConsensusApp"),
		},
	}).SetGoType()

	sCoreConsensusApp = schema.WithMethods[*CoreConsensusApp, *CoreConsensusApp](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "CoreConsensusApp",
		},
		Fields: []*schema.Field{
			{
				Name: "Partition",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[protocol.PartitionInfo](),
				},
			},
			{
				Name:     "EnableHealing",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name:     "EnableDirectDispatch",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name:     "MaxEnvelopesPerBlock",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeUint},
				},
			},
		},
	}).SetGoType()

	sCoreValidatorConfiguration = schema.WithMethods[*CoreValidatorConfiguration, *CoreValidatorConfiguration](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "CoreValidatorConfiguration",
		},
		Fields: []*schema.Field{
			(&schema.Field{
				Name: "Mode",
			}).ResolveTo(&deferredTypes, "CoreValidatorMode"),
			(&schema.Field{
				Name: "Listen",
			}).ResolveTo(&deferredTypes, "Multiaddr"),
			{
				Name: "BVN",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			(&schema.Field{
				Name: "ValidatorKey",
			}).ResolveTo(&deferredTypes, "PrivateKey"),
			{
				Name: "DnGenesis",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "BvnGenesis",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "DnBootstrapPeers",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Multiaddr"),
			},
			{
				Name: "BvnBootstrapPeers",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Multiaddr"),
			},
			{
				Name:     "EnableHealing",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name:     "EnableDirectDispatch",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name:     "EnableSnapshots",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name:     "MaxEnvelopesPerBlock",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeUint},
				},
			},
			{
				Name:     "StorageType",
				Optional: true,
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "StorageType"),
			},
		},
	}).SetGoType()

	sCoreValidatorMode = schema.WithEnumMethods[CoreValidatorMode](
		&schema.EnumType{
			TypeBase: schema.TypeBase{
				Name: "CoreValidatorMode",
			},
			Underlying: &schema.SimpleType{Type: schema.SimpleTypeInt},
			Values: map[string]*schema.EnumValue{
				"BVN": {
					Name:  "BVN",
					Value: 2,
				},
				"DN": {
					Name:  "DN",
					Value: 1,
				},
				"Dual": {
					Name:  "Dual",
					Value: 0,
				},
			},
		}).SetGoType()

	sDevnetConfiguration = schema.WithMethods[*DevnetConfiguration, *DevnetConfiguration](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "DevnetConfiguration",
		},
		Fields: []*schema.Field{
			(&schema.Field{
				Name: "Listen",
			}).ResolveTo(&deferredTypes, "Multiaddr"),
			{
				Name: "Bvns",
				Type: &schema.SimpleType{Type: schema.SimpleTypeUint},
			},
			{
				Name: "Validators",
				Type: &schema.SimpleType{Type: schema.SimpleTypeUint},
			},
			{
				Name:     "Followers",
				Optional: true,
				Type:     &schema.SimpleType{Type: schema.SimpleTypeUint},
			},
			{
				Name: "Globals",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[network.GlobalValues](),
				},
			},
			{
				Name:     "StorageType",
				Optional: true,
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "StorageType"),
			},
		},
	}).SetGoType()

	sEventsService = schema.WithMethods[*EventsService, *EventsService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "EventsService",
		},
		Fields: []*schema.Field{
			{
				Name: "Partition",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sExpBlockDBStorage = schema.WithMethods[*ExpBlockDBStorage, *ExpBlockDBStorage](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "ExpBlockDBStorage",
		},
		Fields: []*schema.Field{
			{
				Name: "Path",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sFaucetService = schema.WithMethods[*FaucetService, *FaucetService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "FaucetService",
		},
		Fields: []*schema.Field{
			{
				Name: "Account",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[url.URL](),
				},
			},
			(&schema.Field{
				Name: "SigningKey",
			}).ResolveTo(&deferredTypes, "PrivateKey"),
			{
				Name: "Router",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[RouterServiceRef](),
				},
			},
		},
	}).SetGoType()

	sGatewayConfiguration = schema.WithMethods[*GatewayConfiguration, *GatewayConfiguration](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "GatewayConfiguration",
		},
		Fields: []*schema.Field{
			(&schema.Field{
				Name: "Listen",
			}).ResolveTo(&deferredTypes, "Multiaddr"),
		},
	}).SetGoType()

	sHttpListener = schema.WithMethods[*HttpListener, *HttpListener](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "HttpListener",
		},
		Fields: []*schema.Field{
			{
				Name:        "Listen",
				Description: "are the addresses and schemes to listen on",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Multiaddr"),
			},
			{
				Name:        "ConnectionLimit",
				Description: "limits the number of concurrent connections",
				Optional:    true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeInt},
				},
			},
			{
				Name:        "ReadHeaderTimeout",
				Description: "protects against slow-loris attacks",
				Optional:    true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[encoding.Duration](),
				},
			},
			{
				Name:        "TlsCertPath",
				Description: "is the path of the TLS certificate",
				Optional:    true,
				Type:        &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name:        "TlsKeyPath",
				Description: "is the path of the TLS key",
				Optional:    true,
				Type:        &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sHttpPeerMapEntry = schema.WithMethods[*HttpPeerMapEntry, *HttpPeerMapEntry](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "HttpPeerMapEntry",
		},
		Fields: []*schema.Field{
			(&schema.Field{
				Name: "ID",
			}).ResolveTo(&deferredTypes, "PeerID"),
			{
				Name: "Partitions",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeString},
				},
			},
			{
				Name: "Addresses",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Multiaddr"),
			},
		},
	}).SetGoType()

	sHttpService = schema.WithMethods[*HttpService, *HttpService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "HttpService",
		},
		Fields: []*schema.Field{
			(&schema.Field{}).ResolveTo(&deferredTypes, "HttpListener"),
			{
				Name:        "CorsOrigins",
				Description: "is a list of allowed CORS origins",
				Optional:    true,
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeString},
				},
			},
			{
				Name:        "LetsEncrypt",
				Description: "automatically retrieves a certificate from Let's Encrypt for the specified domains",
				Optional:    true,
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeString},
				},
			},
			{
				Name:     "DebugJsonRpc",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name: "Router",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[RouterServiceRef](),
				},
			},
			{
				Name:        "PeerMap",
				Description: "hard-codes the peer map",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "HttpPeerMapEntry"),
				},
			},
		},
	}).SetGoType()

	sInstrumentation = schema.WithMethods[*Instrumentation, *Instrumentation](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Instrumentation",
		},
		Fields: []*schema.Field{
			(&schema.Field{}).ResolveTo(&deferredTypes, "HttpListener"),
			(&schema.Field{
				Name: "PprofListen",
			}).ResolveTo(&deferredTypes, "Multiaddr"),
			{
				Name: "Monitoring",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Monitor"),
			},
		},
	}).SetGoType()

	sLevelDBStorage = schema.WithMethods[*LevelDBStorage, *LevelDBStorage](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "LevelDBStorage",
		},
		Fields: []*schema.Field{
			{
				Name: "Path",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sLogging = schema.WithMethods[*Logging, *Logging](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Logging",
		},
		Fields: []*schema.Field{
			{
				Name: "Format",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "Color",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name: "Rules",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "LoggingRule"),
				},
			},
			{
				Name: "Loki",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "LokiLogging"),
			},
		},
	}).SetGoType()

	sLoggingRule = schema.WithMethods[*LoggingRule, *LoggingRule](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "LoggingRule",
		},
		Fields: []*schema.Field{
			{
				Name: "Level",
				Type: schema.TypeReferenceFor[slog.Level](),
			},
			{
				Name: "Modules",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeString},
				},
			},
		},
	}).SetGoType()

	sLokiLogging = schema.WithMethods[*LokiLogging, *LokiLogging](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "LokiLogging",
		},
		Fields: []*schema.Field{
			{
				Name: "Enable",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBool},
			},
			{
				Name: "Url",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "Username",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "Password",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sMemoryStorage = schema.WithMethods[*MemoryStorage, *MemoryStorage](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "MemoryStorage",
		},
	}).SetGoType()

	sMetricsService = schema.WithMethods[*MetricsService, *MetricsService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "MetricsService",
		},
		Fields: []*schema.Field{
			{
				Name: "Partition",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sMonitor = schema.WithMethods[*Monitor, *Monitor](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Monitor",
		},
		Fields: []*schema.Field{
			{
				Name:        "Directory",
				Description: "is the directory traces and profiles are written to",
				Type:        &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name:        "ProfileMemory",
				Description: "enables profiling when memory usage increases dramatically",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name:        "MemoryPollingRate",
				Description: "is rate at which to poll memory usage",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[encoding.Duration](),
				},
			},
			{
				Name:        "AllocRateTrigger",
				Description: "is the rate of allocation in bytes/second that triggers a profile",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeFloat},
				},
			},
		},
	}).SetGoType()

	sMultiaddr = schema.WithMethods[*Multiaddr, *Multiaddr](
		&schema.ExternalType{
			TypeBase: schema.TypeBase{
				Name: "Multiaddr",
				Encode: schema.MapValue{
					"withWidget": schema.StringValue("wMultiaddr"),
				},
				Generate: schema.MapValue{
					"widgets": schema.BooleanValue(true),
				},
			},
			Underlying: schema.TypeReferenceFor[multiaddr.Multiaddr](),
			Encoder:    schema.WidgetExternalEncoder(wMultiaddr),
		}).SetGoType()

	sNetworkService = schema.WithMethods[*NetworkService, *NetworkService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "NetworkService",
		},
		Fields: []*schema.Field{
			{
				Name: "Partition",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sOtlpConfig = schema.WithMethods[*OtlpConfig, *OtlpConfig](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "OtlpConfig",
		},
		Fields: []*schema.Field{
			{
				Name: "Enabled",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name: "Endpoint",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "Username",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name: "Password",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sP2P = schema.WithMethods[*P2P, *P2P](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "P2P",
		},
		Fields: []*schema.Field{
			{
				Name: "Listen",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Multiaddr"),
			},
			{
				Name: "BootstrapPeers",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Multiaddr"),
			},
			(&schema.Field{
				Name: "Key",
			}).ResolveTo(&deferredTypes, "PrivateKey"),
			{
				Name: "PeerDB",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeString},
				},
			},
			{
				Name: "EnablePeerTracking",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBool},
			},
			{
				Name: "DiscoveryMode",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[DhtMode](),
				},
			},
			(&schema.Field{
				Name: "External",
			}).ResolveTo(&deferredTypes, "Multiaddr"),
		},
	}).SetGoType()

	sPeerID = schema.WithMethods[*PeerID, *PeerID](
		&schema.ExternalType{
			TypeBase: schema.TypeBase{
				Name: "PeerID",
				Encode: schema.MapValue{
					"withWidget": schema.StringValue("wPeerID"),
				},
				Generate: schema.MapValue{
					"widgets": schema.BooleanValue(true),
				},
			},
			Underlying: schema.TypeReferenceFor[peer.ID](),
			Encoder:    schema.WidgetExternalEncoder(wPeerID),
		}).SetGoType()

	sPrivateKey = schema.WithUnionMethods[PrivateKey, PrivateKeyType](
		&schema.UnionType{
			TypeBase: schema.TypeBase{
				Name: "PrivateKey",
			},
			Discriminator: (&schema.UnionDiscriminator{
				Field: "Type",
			}).
				ResolveTypeTo(&deferredTypes, "PrivateKeyType").
				ResolveEnumTo(&deferredTypes, "PrivateKeyType"),
			Members: []*schema.UnionMember{
				{
					Discriminator: "raw",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "RawPrivateKey"),
				},
				{
					Discriminator: "transient",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "TransientPrivateKey"),
				},
				{
					Discriminator: "seed",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "PrivateKeySeed"),
				},
				{
					Discriminator: "cometPrivValFile",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "CometPrivValFile"),
				},
				{
					Discriminator: "cometNodeKeyFile",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "CometNodeKeyFile"),
				},
			},
		}).SetGoType()

	sPrivateKeySeed = schema.WithMethods[*PrivateKeySeed, *PrivateKeySeed](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "PrivateKeySeed",
		},
		Fields: []*schema.Field{
			{
				Name: "Seed",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[record.Key](),
				},
			},
		},
		Transients: []*schema.Field{
			{
				Name: "key",
				Type: schema.TypeReferenceFor[address.Address](),
			},
		},
	}).SetGoType()

	sPrivateKeyType = schema.WithEnumMethods[PrivateKeyType](
		&schema.EnumType{
			TypeBase: schema.TypeBase{
				Name: "PrivateKeyType",
			},
			Underlying: &schema.SimpleType{Type: schema.SimpleTypeInt},
			Values: map[string]*schema.EnumValue{
				"CometNodeKeyFile": {
					Name:  "CometNodeKeyFile",
					Value: 5,
				},
				"CometPrivValFile": {
					Name:  "CometPrivValFile",
					Value: 4,
				},
				"Raw": {
					Name:  "Raw",
					Value: 1,
				},
				"Seed": {
					Name:  "Seed",
					Value: 3,
				},
				"Transient": {
					Name:  "Transient",
					Value: 2,
				},
			},
		}).SetGoType()

	sQuerier = schema.WithMethods[*Querier, *Querier](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Querier",
		},
		Fields: []*schema.Field{
			{
				Name: "Partition",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name:     "Storage",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[StorageOrRef](),
				},
			},
		},
	}).SetGoType()

	sRawPrivateKey = schema.WithMethods[*RawPrivateKey, *RawPrivateKey](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "RawPrivateKey",
		},
		Fields: []*schema.Field{
			{
				Name: "Address",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
		},
	}).SetGoType()

	sRouterService = schema.WithMethods[*RouterService, *RouterService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "RouterService",
		},
		Fields: []*schema.Field{
			{
				Name:     "Name",
				Optional: true,
				Type:     &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name:        "Events",
				Description: "may specify an event bus to use for routing table updates",
				Optional:    true,
				Type:        &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name:        "PeerMap",
				Description: "uses a hard-coded peer map for initializing routing",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "HttpPeerMapEntry"),
				},
			},
		},
	}).SetGoType()

	sService = schema.WithUnionMethods[Service, ServiceType](
		&schema.UnionType{
			TypeBase: schema.TypeBase{
				Name: "Service",
			},
			Discriminator: (&schema.UnionDiscriminator{
				Field: "Type",
			}).
				ResolveTypeTo(&deferredTypes, "ServiceType").
				ResolveEnumTo(&deferredTypes, "ServiceType"),
			Members: []*schema.UnionMember{
				{
					Discriminator: "storage",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "StorageService"),
				},
				{
					Discriminator: "consensus",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "ConsensusService"),
				},
				{
					Discriminator: "querier",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "Querier"),
				},
				{
					Discriminator: "network",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "NetworkService"),
				},
				{
					Discriminator: "metrics",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "MetricsService"),
				},
				{
					Discriminator: "events",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "EventsService"),
				},
				{
					Discriminator: "http",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "HttpService"),
				},
				{
					Discriminator: "router",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "RouterService"),
				},
				{
					Discriminator: "snapshot",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "SnapshotService"),
				},
				{
					Discriminator: "faucet",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "FaucetService"),
				},
				{
					Discriminator: "subnode",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "SubnodeService"),
				},
			},
		}).SetGoType()

	sServiceType = schema.WithEnumMethods[ServiceType](
		&schema.EnumType{
			TypeBase: schema.TypeBase{
				Name: "ServiceType",
			},
			Underlying: &schema.SimpleType{Type: schema.SimpleTypeInt},
			Values: map[string]*schema.EnumValue{
				"Consensus": {
					Name:  "Consensus",
					Value: 2,
				},
				"Events": {
					Name:  "Events",
					Value: 6,
				},
				"Faucet": {
					Name:  "Faucet",
					Value: 10,
				},
				"Http": {
					Name:  "Http",
					Value: 7,
				},
				"Metrics": {
					Name:  "Metrics",
					Value: 5,
				},
				"Network": {
					Name:  "Network",
					Value: 4,
				},
				"Querier": {
					Name:  "Querier",
					Value: 3,
				},
				"Router": {
					Name:  "Router",
					Value: 8,
				},
				"Snapshot": {
					Name:  "Snapshot",
					Value: 9,
				},
				"Storage": {
					Name:  "Storage",
					Value: 1,
				},
				"Subnode": {
					Name:  "Subnode",
					Value: 11,
				},
			},
		}).SetGoType()

	sSnapshotService = schema.WithMethods[*SnapshotService, *SnapshotService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "SnapshotService",
		},
		Fields: []*schema.Field{
			{
				Name: "Partition",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name:     "Storage",
				Optional: true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[StorageOrRef](),
				},
			},
			{
				Name:        "Directory",
				Description: "is the directory to store snapshots in",
				Type:        &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			{
				Name:        "Schedule",
				Description: "is the schedule for capturing snapshots",
				Optional:    true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     schema.TypeReferenceFor[network.CronSchedule](),
				},
			},
			{
				Name:        "RetainCount",
				Description: "is the number of snapshots to retain",
				Optional:    true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeUint},
				},
			},
			{
				Name:        "EnableIndexing",
				Description: "enables indexing of snapshots",
				Optional:    true,
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
		},
	}).SetGoType()

	sStorage = schema.WithUnionMethods[Storage, StorageType](
		&schema.UnionType{
			TypeBase: schema.TypeBase{
				Name: "Storage",
			},
			Discriminator: (&schema.UnionDiscriminator{
				Field: "Type",
			}).
				ResolveTypeTo(&deferredTypes, "StorageType").
				ResolveEnumTo(&deferredTypes, "StorageType"),
			Members: []*schema.UnionMember{
				{
					Discriminator: "memory",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "MemoryStorage"),
				},
				{
					Discriminator: "badger",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "BadgerStorage"),
				},
				{
					Discriminator: "bolt",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "BoltStorage"),
				},
				{
					Discriminator: "levelDB",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "LevelDBStorage"),
				},
				{
					Discriminator: "expBlockDB",
					Type: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "ExpBlockDBStorage"),
				},
			},
		}).SetGoType()

	sStorageService = schema.WithMethods[*StorageService, *StorageService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "StorageService",
		},
		Fields: []*schema.Field{
			{
				Name:     "Name",
				Optional: true,
				Type:     &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			(&schema.Field{
				Name: "Storage",
			}).ResolveTo(&deferredTypes, "Storage"),
		},
	}).SetGoType()

	sStorageType = schema.WithEnumMethods[StorageType](
		&schema.EnumType{
			TypeBase: schema.TypeBase{
				Name: "StorageType",
			},
			Underlying: &schema.SimpleType{Type: schema.SimpleTypeInt},
			Values: map[string]*schema.EnumValue{
				"Badger": {
					Name:  "Badger",
					Value: 2,
				},
				"Bolt": {
					Name:  "Bolt",
					Value: 3,
				},
				"ExpBlockDB": {
					Name:  "ExpBlockDB",
					Value: 1001,
				},
				"LevelDB": {
					Name:  "LevelDB",
					Value: 4,
				},
				"Memory": {
					Name:  "Memory",
					Value: 1,
				},
			},
		}).SetGoType()

	sSubnodeService = schema.WithMethods[*SubnodeService, *SubnodeService](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "SubnodeService",
		},
		Fields: []*schema.Field{
			{
				Name: "Name",
				Type: &schema.SimpleType{Type: schema.SimpleTypeString},
			},
			(&schema.Field{
				Name: "NodeKey",
			}).ResolveTo(&deferredTypes, "PrivateKey"),
			{
				Name: "Services",
				Type: (&schema.ArrayType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "Service"),
			},
		},
	}).SetGoType()

	sTelemetry = schema.WithMethods[*Telemetry, *Telemetry](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "Telemetry",
		},
		Fields: []*schema.Field{
			{
				Name: "Enabled",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name: "Stdout",
				Type: &schema.PointerType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeBool},
				},
			},
			{
				Name: "Export",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "HttpListener"),
			},
			{
				Name: "Otlp",
				Type: (&schema.PointerType{
					TypeBase: schema.TypeBase{},
				}).
					ResolveElemTo(&deferredTypes, "OtlpConfig"),
			},
			{
				Name: "Rules",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem: (&schema.PointerType{
						TypeBase: schema.TypeBase{},
					}).
						ResolveElemTo(&deferredTypes, "TelemetryRule"),
				},
			},
		},
	}).SetGoType()

	sTelemetryRule = schema.WithMethods[*TelemetryRule, *TelemetryRule](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "TelemetryRule",
		},
		Fields: []*schema.Field{
			{
				Name: "Match",
				Type: &schema.ArrayType{
					TypeBase: schema.TypeBase{},
					Elem:     &schema.SimpleType{Type: schema.SimpleTypeString},
				},
			},
			{
				Name: "Drop",
				Type: &schema.SimpleType{Type: schema.SimpleTypeBool},
			},
			{
				Name: "Rate",
				Type: schema.TypeReferenceFor[encoding.Duration](),
			},
		},
	}).SetGoType()

	sTransientPrivateKey = schema.WithMethods[*TransientPrivateKey, *TransientPrivateKey](&schema.CompositeType{
		TypeBase: schema.TypeBase{
			Name: "TransientPrivateKey",
		},
		Transients: []*schema.Field{
			{
				Name: "key",
				Type: schema.TypeReferenceFor[address.Address](),
			},
		},
	}).SetGoType()

	s, err := schema.New(
		sBadgerStorage.Type,
		sBoltStorage.Type,
		sCometNodeKeyFile.Type,
		sCometPrivValFile.Type,
		sConfig.Type,
		sConfiguration.Type,
		sConfigurationType.Type,
		sConsensusApp.Type,
		sConsensusAppType.Type,
		sConsensusService.Type,
		sCoreConsensusApp.Type,
		sCoreValidatorConfiguration.Type,
		sCoreValidatorMode.Type,
		sDevnetConfiguration.Type,
		sEventsService.Type,
		sExpBlockDBStorage.Type,
		sFaucetService.Type,
		sGatewayConfiguration.Type,
		sHttpListener.Type,
		sHttpPeerMapEntry.Type,
		sHttpService.Type,
		sInstrumentation.Type,
		sLevelDBStorage.Type,
		sLogging.Type,
		sLoggingRule.Type,
		sLokiLogging.Type,
		sMemoryStorage.Type,
		sMetricsService.Type,
		sMonitor.Type,
		sMultiaddr.Type,
		sNetworkService.Type,
		sOtlpConfig.Type,
		sP2P.Type,
		sPeerID.Type,
		sPrivateKey.Type,
		sPrivateKeySeed.Type,
		sPrivateKeyType.Type,
		sQuerier.Type,
		sRawPrivateKey.Type,
		sRouterService.Type,
		sService.Type,
		sServiceType.Type,
		sSnapshotService.Type,
		sStorage.Type,
		sStorageService.Type,
		sStorageType.Type,
		sSubnodeService.Type,
		sTelemetry.Type,
		sTelemetryRule.Type,
		sTransientPrivateKey.Type,
	)
	if err != nil {
		panic(fmt.Errorf("invalid embedded schema: %w", err))
	}

	s.Generate = schema.MapValue{
		"import": schema.MapValue{
			"encoding":  schema.StringValue("gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"),
			"multiaddr": schema.StringValue("github.com/multiformats/go-multiaddr"),
			"peer":      schema.StringValue("github.com/libp2p/go-libp2p/core/peer"),
			"record":    schema.StringValue("gitlab.com/accumulatenetwork/accumulate/pkg/types/record"),
			"url":       schema.StringValue("gitlab.com/accumulatenetwork/accumulate/pkg/url"),
		},
		"methods": schema.MapValue{
			"json": schema.BooleanValue(true),
		},
		"varPrefix": schema.MapValue{
			"schema": schema.StringValue("s"),
		},
	}

	deferredTypes.Resolve(s)
	err = s.Validate()
	if err != nil {
		panic(fmt.Errorf("invalid embedded schema: %w", err))
	}
}
