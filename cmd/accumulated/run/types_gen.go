// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package run

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/address"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"golang.org/x/exp/slog"
)

type BadgerStorage struct {
	Path string `json:"path,omitempty" form:"path" query:"path" validate:"required"`
}

type CometNodeKeyFile struct {
	key  address.Address
	Path string `json:"path,omitempty" form:"path" query:"path" validate:"required"`
}

type CometPrivValFile struct {
	key  address.Address
	Path string `json:"path,omitempty" form:"path" query:"path" validate:"required"`
}

type Config struct {
	file     string
	Logging  *Logging  `json:"logging,omitempty" form:"logging" query:"logging" validate:"required"`
	P2P      *P2P      `json:"p2P,omitempty" form:"p2P" query:"p2P" validate:"required"`
	Apps     []Service `json:"apps,omitempty" form:"apps" query:"apps" validate:"required"`
	Services []Service `json:"services,omitempty" form:"services" query:"services" validate:"required"`
}

type ConsensusService struct {
	NodeDir string       `json:"nodeDir,omitempty" form:"nodeDir" query:"nodeDir" validate:"required"`
	App     ConsensusApp `json:"app,omitempty" form:"app" query:"app" validate:"required"`
}

type CoreConsensusApp struct {
	Partition     *protocol.PartitionInfo `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	EnableHealing bool                    `json:"enableHealing,omitempty" form:"enableHealing" query:"enableHealing"`
}

type EventsService struct {
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
}

type Logging struct {
	Format string         `json:"format,omitempty" form:"format" query:"format" validate:"required"`
	Rules  []*LoggingRule `json:"rules,omitempty" form:"rules" query:"rules" validate:"required"`
}

type LoggingRule struct {
	Level  slog.Level `json:"level" form:"level" query:"level" validate:"required"`
	Module string     `json:"module,omitempty" form:"module" query:"module" validate:"required"`
}

type MemoryStorage struct {
}

type MetricsService struct {
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
}

type NetworkService struct {
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
}

type P2P struct {
	Network            string          `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Listen             []p2p.Multiaddr `json:"listen,omitempty" form:"listen" query:"listen" validate:"required" toml:"listen" mapstructure:"listen"`
	BootstrapPeers     []p2p.Multiaddr `json:"bootstrapPeers,omitempty" form:"bootstrapPeers" query:"bootstrapPeers" validate:"required" toml:"bootstrap-peers" mapstructure:"bootstrap-peers"`
	Key                PrivateKey      `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	PeerDB             string          `json:"peerDB,omitempty" form:"peerDB" query:"peerDB" validate:"required"`
	EnablePeerTracking bool            `json:"enablePeerTracking,omitempty" form:"enablePeerTracking" query:"enablePeerTracking" validate:"required"`
}

type PrivateKeySeed struct {
	key  address.Address
	Seed *record.Key `json:"seed,omitempty" form:"seed" query:"seed" validate:"required"`
}

type Querier struct {
	Partition string `json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
}

type StorageService struct {
	Name    string  `json:"name,omitempty" form:"name" query:"name"`
	Storage Storage `json:"storage,omitempty" form:"storage" query:"storage" validate:"required"`
}

type TransientPrivateKey struct {
	key address.Address
}

func (*BadgerStorage) Type() StorageType { return StorageTypeBadger }

func (*CometNodeKeyFile) Type() PrivateKeyType { return PrivateKeyTypeCometNodeKeyFile }

func (*CometPrivValFile) Type() PrivateKeyType { return PrivateKeyTypeCometPrivValFile }

func (*ConsensusService) Type() ServiceType { return ServiceTypeConsensus }

func (*CoreConsensusApp) Type() ConsensusAppType { return ConsensusAppTypeCore }

func (*EventsService) Type() ServiceType { return ServiceTypeEvents }

func (*MemoryStorage) Type() StorageType { return StorageTypeMemory }

func (*MetricsService) Type() ServiceType { return ServiceTypeMetrics }

func (*NetworkService) Type() ServiceType { return ServiceTypeNetwork }

func (*PrivateKeySeed) Type() PrivateKeyType { return PrivateKeyTypeSeed }

func (*Querier) Type() ServiceType { return ServiceTypeQuerier }

func (*StorageService) Type() ServiceType { return ServiceTypeStorage }

func (*TransientPrivateKey) Type() PrivateKeyType { return PrivateKeyTypeTransient }

func (v *BadgerStorage) Copy() *BadgerStorage {
	u := new(BadgerStorage)

	u.Path = v.Path

	return u
}

func (v *BadgerStorage) CopyAsInterface() interface{} { return v.Copy() }

func (v *CometNodeKeyFile) Copy() *CometNodeKeyFile {
	u := new(CometNodeKeyFile)

	u.Path = v.Path

	return u
}

func (v *CometNodeKeyFile) CopyAsInterface() interface{} { return v.Copy() }

func (v *CometPrivValFile) Copy() *CometPrivValFile {
	u := new(CometPrivValFile)

	u.Path = v.Path

	return u
}

func (v *CometPrivValFile) CopyAsInterface() interface{} { return v.Copy() }

func (v *Config) Copy() *Config {
	u := new(Config)

	if v.Logging != nil {
		u.Logging = (v.Logging).Copy()
	}
	if v.P2P != nil {
		u.P2P = (v.P2P).Copy()
	}
	u.Apps = make([]Service, len(v.Apps))
	for i, v := range v.Apps {
		v := v
		if v != nil {
			u.Apps[i] = CopyService(v)
		}
	}
	u.Services = make([]Service, len(v.Services))
	for i, v := range v.Services {
		v := v
		if v != nil {
			u.Services[i] = CopyService(v)
		}
	}

	return u
}

func (v *Config) CopyAsInterface() interface{} { return v.Copy() }

func (v *ConsensusService) Copy() *ConsensusService {
	u := new(ConsensusService)

	u.NodeDir = v.NodeDir
	if v.App != nil {
		u.App = CopyConsensusApp(v.App)
	}

	return u
}

func (v *ConsensusService) CopyAsInterface() interface{} { return v.Copy() }

func (v *CoreConsensusApp) Copy() *CoreConsensusApp {
	u := new(CoreConsensusApp)

	if v.Partition != nil {
		u.Partition = (v.Partition).Copy()
	}
	u.EnableHealing = v.EnableHealing

	return u
}

func (v *CoreConsensusApp) CopyAsInterface() interface{} { return v.Copy() }

func (v *EventsService) Copy() *EventsService {
	u := new(EventsService)

	u.Partition = v.Partition

	return u
}

func (v *EventsService) CopyAsInterface() interface{} { return v.Copy() }

func (v *Logging) Copy() *Logging {
	u := new(Logging)

	u.Format = v.Format
	u.Rules = make([]*LoggingRule, len(v.Rules))
	for i, v := range v.Rules {
		v := v
		if v != nil {
			u.Rules[i] = (v).Copy()
		}
	}

	return u
}

func (v *Logging) CopyAsInterface() interface{} { return v.Copy() }

func (v *LoggingRule) Copy() *LoggingRule {
	u := new(LoggingRule)

	u.Level = v.Level
	u.Module = v.Module

	return u
}

func (v *LoggingRule) CopyAsInterface() interface{} { return v.Copy() }

func (v *MemoryStorage) Copy() *MemoryStorage {
	u := new(MemoryStorage)

	return u
}

func (v *MemoryStorage) CopyAsInterface() interface{} { return v.Copy() }

func (v *MetricsService) Copy() *MetricsService {
	u := new(MetricsService)

	u.Partition = v.Partition

	return u
}

func (v *MetricsService) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkService) Copy() *NetworkService {
	u := new(NetworkService)

	u.Partition = v.Partition

	return u
}

func (v *NetworkService) CopyAsInterface() interface{} { return v.Copy() }

func (v *P2P) Copy() *P2P {
	u := new(P2P)

	u.Network = v.Network
	u.Listen = make([]p2p.Multiaddr, len(v.Listen))
	for i, v := range v.Listen {
		v := v
		if v != nil {
			u.Listen[i] = p2p.CopyMultiaddr(v)
		}
	}
	u.BootstrapPeers = make([]p2p.Multiaddr, len(v.BootstrapPeers))
	for i, v := range v.BootstrapPeers {
		v := v
		if v != nil {
			u.BootstrapPeers[i] = p2p.CopyMultiaddr(v)
		}
	}
	if v.Key != nil {
		u.Key = CopyPrivateKey(v.Key)
	}
	u.PeerDB = v.PeerDB
	u.EnablePeerTracking = v.EnablePeerTracking

	return u
}

func (v *P2P) CopyAsInterface() interface{} { return v.Copy() }

func (v *PrivateKeySeed) Copy() *PrivateKeySeed {
	u := new(PrivateKeySeed)

	if v.Seed != nil {
		u.Seed = (v.Seed).Copy()
	}

	return u
}

func (v *PrivateKeySeed) CopyAsInterface() interface{} { return v.Copy() }

func (v *Querier) Copy() *Querier {
	u := new(Querier)

	u.Partition = v.Partition

	return u
}

func (v *Querier) CopyAsInterface() interface{} { return v.Copy() }

func (v *StorageService) Copy() *StorageService {
	u := new(StorageService)

	u.Name = v.Name
	if v.Storage != nil {
		u.Storage = CopyStorage(v.Storage)
	}

	return u
}

func (v *StorageService) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransientPrivateKey) Copy() *TransientPrivateKey {
	u := new(TransientPrivateKey)

	return u
}

func (v *TransientPrivateKey) CopyAsInterface() interface{} { return v.Copy() }

func (v *BadgerStorage) Equal(u *BadgerStorage) bool {
	if !(v.Path == u.Path) {
		return false
	}

	return true
}

func (v *CometNodeKeyFile) Equal(u *CometNodeKeyFile) bool {
	if !(v.Path == u.Path) {
		return false
	}

	return true
}

func (v *CometPrivValFile) Equal(u *CometPrivValFile) bool {
	if !(v.Path == u.Path) {
		return false
	}

	return true
}

func (v *Config) Equal(u *Config) bool {
	switch {
	case v.Logging == u.Logging:
		// equal
	case v.Logging == nil || u.Logging == nil:
		return false
	case !((v.Logging).Equal(u.Logging)):
		return false
	}
	switch {
	case v.P2P == u.P2P:
		// equal
	case v.P2P == nil || u.P2P == nil:
		return false
	case !((v.P2P).Equal(u.P2P)):
		return false
	}
	if len(v.Apps) != len(u.Apps) {
		return false
	}
	for i := range v.Apps {
		if !(EqualService(v.Apps[i], u.Apps[i])) {
			return false
		}
	}
	if len(v.Services) != len(u.Services) {
		return false
	}
	for i := range v.Services {
		if !(EqualService(v.Services[i], u.Services[i])) {
			return false
		}
	}

	return true
}

func (v *ConsensusService) Equal(u *ConsensusService) bool {
	if !(v.NodeDir == u.NodeDir) {
		return false
	}
	if !(EqualConsensusApp(v.App, u.App)) {
		return false
	}

	return true
}

func (v *CoreConsensusApp) Equal(u *CoreConsensusApp) bool {
	switch {
	case v.Partition == u.Partition:
		// equal
	case v.Partition == nil || u.Partition == nil:
		return false
	case !((v.Partition).Equal(u.Partition)):
		return false
	}
	if !(v.EnableHealing == u.EnableHealing) {
		return false
	}

	return true
}

func (v *EventsService) Equal(u *EventsService) bool {
	if !(v.Partition == u.Partition) {
		return false
	}

	return true
}

func (v *Logging) Equal(u *Logging) bool {
	if !(v.Format == u.Format) {
		return false
	}
	if len(v.Rules) != len(u.Rules) {
		return false
	}
	for i := range v.Rules {
		if !((v.Rules[i]).Equal(u.Rules[i])) {
			return false
		}
	}

	return true
}

func (v *LoggingRule) Equal(u *LoggingRule) bool {
	if !(v.Level == u.Level) {
		return false
	}
	if !(v.Module == u.Module) {
		return false
	}

	return true
}

func (v *MemoryStorage) Equal(u *MemoryStorage) bool {

	return true
}

func (v *MetricsService) Equal(u *MetricsService) bool {
	if !(v.Partition == u.Partition) {
		return false
	}

	return true
}

func (v *NetworkService) Equal(u *NetworkService) bool {
	if !(v.Partition == u.Partition) {
		return false
	}

	return true
}

func (v *P2P) Equal(u *P2P) bool {
	if !(v.Network == u.Network) {
		return false
	}
	if len(v.Listen) != len(u.Listen) {
		return false
	}
	for i := range v.Listen {
		if !(p2p.EqualMultiaddr(v.Listen[i], u.Listen[i])) {
			return false
		}
	}
	if len(v.BootstrapPeers) != len(u.BootstrapPeers) {
		return false
	}
	for i := range v.BootstrapPeers {
		if !(p2p.EqualMultiaddr(v.BootstrapPeers[i], u.BootstrapPeers[i])) {
			return false
		}
	}
	if !(EqualPrivateKey(v.Key, u.Key)) {
		return false
	}
	if !(v.PeerDB == u.PeerDB) {
		return false
	}
	if !(v.EnablePeerTracking == u.EnablePeerTracking) {
		return false
	}

	return true
}

func (v *PrivateKeySeed) Equal(u *PrivateKeySeed) bool {
	switch {
	case v.Seed == u.Seed:
		// equal
	case v.Seed == nil || u.Seed == nil:
		return false
	case !((v.Seed).Equal(u.Seed)):
		return false
	}

	return true
}

func (v *Querier) Equal(u *Querier) bool {
	if !(v.Partition == u.Partition) {
		return false
	}

	return true
}

func (v *StorageService) Equal(u *StorageService) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(EqualStorage(v.Storage, u.Storage)) {
		return false
	}

	return true
}

func (v *TransientPrivateKey) Equal(u *TransientPrivateKey) bool {

	return true
}

func (v *BadgerStorage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type StorageType `json:"type"`
		Path string      `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Path) == 0) {
		u.Path = v.Path
	}
	return json.Marshal(&u)
}

func (v *CometNodeKeyFile) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Path) == 0) {
		u.Path = v.Path
	}
	return json.Marshal(&u)
}

func (v *CometPrivValFile) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Path) == 0) {
		u.Path = v.Path
	}
	return json.Marshal(&u)
}

func (v *Config) MarshalJSON() ([]byte, error) {
	u := struct {
		Logging  *Logging                                 `json:"logging,omitempty"`
		P2P      *P2P                                     `json:"p2P,omitempty"`
		Apps     *encoding.JsonUnmarshalListWith[Service] `json:"apps,omitempty"`
		Services *encoding.JsonUnmarshalListWith[Service] `json:"services,omitempty"`
	}{}
	if !(v.Logging == nil) {
		u.Logging = v.Logging
	}
	if !(v.P2P == nil) {
		u.P2P = v.P2P
	}
	if !(len(v.Apps) == 0) {
		u.Apps = &encoding.JsonUnmarshalListWith[Service]{Value: v.Apps, Func: UnmarshalServiceJSON}
	}
	if !(len(v.Services) == 0) {
		u.Services = &encoding.JsonUnmarshalListWith[Service]{Value: v.Services, Func: UnmarshalServiceJSON}
	}
	return json.Marshal(&u)
}

func (v *ConsensusService) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    ServiceType                               `json:"type"`
		NodeDir string                                    `json:"nodeDir,omitempty"`
		App     *encoding.JsonUnmarshalWith[ConsensusApp] `json:"app,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.NodeDir) == 0) {
		u.NodeDir = v.NodeDir
	}
	if !(EqualConsensusApp(v.App, nil)) {
		u.App = &encoding.JsonUnmarshalWith[ConsensusApp]{Value: v.App, Func: UnmarshalConsensusAppJSON}
	}
	return json.Marshal(&u)
}

func (v *CoreConsensusApp) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          ConsensusAppType        `json:"type"`
		Partition     *protocol.PartitionInfo `json:"partition,omitempty"`
		EnableHealing bool                    `json:"enableHealing,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Partition == nil) {
		u.Partition = v.Partition
	}
	if !(!v.EnableHealing) {
		u.EnableHealing = v.EnableHealing
	}
	return json.Marshal(&u)
}

func (v *EventsService) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      ServiceType `json:"type"`
		Partition string      `json:"partition,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Partition) == 0) {
		u.Partition = v.Partition
	}
	return json.Marshal(&u)
}

func (v *Logging) MarshalJSON() ([]byte, error) {
	u := struct {
		Format string                          `json:"format,omitempty"`
		Rules  encoding.JsonList[*LoggingRule] `json:"rules,omitempty"`
	}{}
	if !(len(v.Format) == 0) {
		u.Format = v.Format
	}
	if !(len(v.Rules) == 0) {
		u.Rules = v.Rules
	}
	return json.Marshal(&u)
}

func (v *MemoryStorage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type StorageType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *MetricsService) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      ServiceType `json:"type"`
		Partition string      `json:"partition,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Partition) == 0) {
		u.Partition = v.Partition
	}
	return json.Marshal(&u)
}

func (v *NetworkService) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      ServiceType `json:"type"`
		Partition string      `json:"partition,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Partition) == 0) {
		u.Partition = v.Partition
	}
	return json.Marshal(&u)
}

func (v *P2P) MarshalJSON() ([]byte, error) {
	u := struct {
		Network            string                                         `json:"network,omitempty"`
		Listen             *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"listen,omitempty"`
		BootstrapPeers     *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"bootstrapPeers,omitempty"`
		Key                *encoding.JsonUnmarshalWith[PrivateKey]        `json:"key,omitempty"`
		PeerDB             string                                         `json:"peerDB,omitempty"`
		EnablePeerTracking bool                                           `json:"enablePeerTracking,omitempty"`
	}{}
	if !(len(v.Network) == 0) {
		u.Network = v.Network
	}
	if !(len(v.Listen) == 0) {
		u.Listen = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Listen, Func: p2p.UnmarshalMultiaddrJSON}
	}
	if !(len(v.BootstrapPeers) == 0) {
		u.BootstrapPeers = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.BootstrapPeers, Func: p2p.UnmarshalMultiaddrJSON}
	}
	if !(EqualPrivateKey(v.Key, nil)) {
		u.Key = &encoding.JsonUnmarshalWith[PrivateKey]{Value: v.Key, Func: UnmarshalPrivateKeyJSON}
	}
	if !(len(v.PeerDB) == 0) {
		u.PeerDB = v.PeerDB
	}
	if !(!v.EnablePeerTracking) {
		u.EnablePeerTracking = v.EnablePeerTracking
	}
	return json.Marshal(&u)
}

func (v *PrivateKeySeed) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Seed *record.Key    `json:"seed,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Seed == nil) {
		u.Seed = v.Seed
	}
	return json.Marshal(&u)
}

func (v *Querier) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      ServiceType `json:"type"`
		Partition string      `json:"partition,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Partition) == 0) {
		u.Partition = v.Partition
	}
	return json.Marshal(&u)
}

func (v *StorageService) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    ServiceType                          `json:"type"`
		Name    string                               `json:"name,omitempty"`
		Storage *encoding.JsonUnmarshalWith[Storage] `json:"storage,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Name) == 0) {
		u.Name = v.Name
	}
	if !(EqualStorage(v.Storage, nil)) {
		u.Storage = &encoding.JsonUnmarshalWith[Storage]{Value: v.Storage, Func: UnmarshalStorageJSON}
	}
	return json.Marshal(&u)
}

func (v *TransientPrivateKey) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *BadgerStorage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type StorageType `json:"type"`
		Path string      `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	u.Path = v.Path
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Path = u.Path
	return nil
}

func (v *CometNodeKeyFile) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	u.Path = v.Path
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Path = u.Path
	return nil
}

func (v *CometPrivValFile) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	u.Path = v.Path
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Path = u.Path
	return nil
}

func (v *Config) UnmarshalJSON(data []byte) error {
	u := struct {
		Logging  *Logging                                 `json:"logging,omitempty"`
		P2P      *P2P                                     `json:"p2P,omitempty"`
		Apps     *encoding.JsonUnmarshalListWith[Service] `json:"apps,omitempty"`
		Services *encoding.JsonUnmarshalListWith[Service] `json:"services,omitempty"`
	}{}
	u.Logging = v.Logging
	u.P2P = v.P2P
	u.Apps = &encoding.JsonUnmarshalListWith[Service]{Value: v.Apps, Func: UnmarshalServiceJSON}
	u.Services = &encoding.JsonUnmarshalListWith[Service]{Value: v.Services, Func: UnmarshalServiceJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Logging = u.Logging
	v.P2P = u.P2P
	if u.Apps != nil {
		v.Apps = make([]Service, len(u.Apps.Value))
		for i, x := range u.Apps.Value {
			v.Apps[i] = x
		}
	}
	if u.Services != nil {
		v.Services = make([]Service, len(u.Services.Value))
		for i, x := range u.Services.Value {
			v.Services[i] = x
		}
	}
	return nil
}

func (v *ConsensusService) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    ServiceType                               `json:"type"`
		NodeDir string                                    `json:"nodeDir,omitempty"`
		App     *encoding.JsonUnmarshalWith[ConsensusApp] `json:"app,omitempty"`
	}{}
	u.Type = v.Type()
	u.NodeDir = v.NodeDir
	u.App = &encoding.JsonUnmarshalWith[ConsensusApp]{Value: v.App, Func: UnmarshalConsensusAppJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.NodeDir = u.NodeDir
	if u.App != nil {
		v.App = u.App.Value
	}

	return nil
}

func (v *CoreConsensusApp) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          ConsensusAppType        `json:"type"`
		Partition     *protocol.PartitionInfo `json:"partition,omitempty"`
		EnableHealing bool                    `json:"enableHealing,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.Partition
	u.EnableHealing = v.EnableHealing
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Partition = u.Partition
	v.EnableHealing = u.EnableHealing
	return nil
}

func (v *EventsService) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      ServiceType `json:"type"`
		Partition string      `json:"partition,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.Partition
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Partition = u.Partition
	return nil
}

func (v *Logging) UnmarshalJSON(data []byte) error {
	u := struct {
		Format string                          `json:"format,omitempty"`
		Rules  encoding.JsonList[*LoggingRule] `json:"rules,omitempty"`
	}{}
	u.Format = v.Format
	u.Rules = v.Rules
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Format = u.Format
	v.Rules = u.Rules
	return nil
}

func (v *MemoryStorage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type StorageType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *MetricsService) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      ServiceType `json:"type"`
		Partition string      `json:"partition,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.Partition
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Partition = u.Partition
	return nil
}

func (v *NetworkService) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      ServiceType `json:"type"`
		Partition string      `json:"partition,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.Partition
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Partition = u.Partition
	return nil
}

func (v *P2P) UnmarshalJSON(data []byte) error {
	u := struct {
		Network            string                                         `json:"network,omitempty"`
		Listen             *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"listen,omitempty"`
		BootstrapPeers     *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"bootstrapPeers,omitempty"`
		Key                *encoding.JsonUnmarshalWith[PrivateKey]        `json:"key,omitempty"`
		PeerDB             string                                         `json:"peerDB,omitempty"`
		EnablePeerTracking bool                                           `json:"enablePeerTracking,omitempty"`
	}{}
	u.Network = v.Network
	u.Listen = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Listen, Func: p2p.UnmarshalMultiaddrJSON}
	u.BootstrapPeers = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.BootstrapPeers, Func: p2p.UnmarshalMultiaddrJSON}
	u.Key = &encoding.JsonUnmarshalWith[PrivateKey]{Value: v.Key, Func: UnmarshalPrivateKeyJSON}
	u.PeerDB = v.PeerDB
	u.EnablePeerTracking = v.EnablePeerTracking
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Network = u.Network
	if u.Listen != nil {
		v.Listen = make([]p2p.Multiaddr, len(u.Listen.Value))
		for i, x := range u.Listen.Value {
			v.Listen[i] = x
		}
	}
	if u.BootstrapPeers != nil {
		v.BootstrapPeers = make([]p2p.Multiaddr, len(u.BootstrapPeers.Value))
		for i, x := range u.BootstrapPeers.Value {
			v.BootstrapPeers[i] = x
		}
	}
	if u.Key != nil {
		v.Key = u.Key.Value
	}

	v.PeerDB = u.PeerDB
	v.EnablePeerTracking = u.EnablePeerTracking
	return nil
}

func (v *PrivateKeySeed) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Seed *record.Key    `json:"seed,omitempty"`
	}{}
	u.Type = v.Type()
	u.Seed = v.Seed
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Seed = u.Seed
	return nil
}

func (v *Querier) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      ServiceType `json:"type"`
		Partition string      `json:"partition,omitempty"`
	}{}
	u.Type = v.Type()
	u.Partition = v.Partition
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Partition = u.Partition
	return nil
}

func (v *StorageService) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    ServiceType                          `json:"type"`
		Name    string                               `json:"name,omitempty"`
		Storage *encoding.JsonUnmarshalWith[Storage] `json:"storage,omitempty"`
	}{}
	u.Type = v.Type()
	u.Name = v.Name
	u.Storage = &encoding.JsonUnmarshalWith[Storage]{Value: v.Storage, Func: UnmarshalStorageJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Name = u.Name
	if u.Storage != nil {
		v.Storage = u.Storage.Value
	}

	return nil
}

func (v *TransientPrivateKey) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}
