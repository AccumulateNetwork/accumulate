// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package run

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/address"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
	"golang.org/x/exp/slog"
)

type BadgerStorage struct {
	Path string `json:"path,omitempty" form:"path" query:"path" validate:"required"`
}

type Config struct {
	file     string
	Logging  *Logging  `json:"logging,omitempty" form:"logging" query:"logging" validate:"required"`
	P2P      *P2P      `json:"p2P,omitempty" form:"p2P" query:"p2P" validate:"required"`
	Services []Service `json:"services,omitempty" form:"services" query:"services" validate:"required"`
}

type Logging struct {
	Format string         `json:"format,omitempty" form:"format" query:"format" validate:"required"`
	Rules  []*LoggingRule `json:"rules,omitempty" form:"rules" query:"rules" validate:"required"`
}

type LoggingRule struct {
	Level  slog.Level `json:"level" form:"level" query:"level" validate:"required"`
	Module string     `json:"module,omitempty" form:"module" query:"module" validate:"required"`
}

type MemoryStorage struct {
}

type P2P struct {
	Network            string          `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Listen             []p2p.Multiaddr `json:"listen,omitempty" form:"listen" query:"listen" validate:"required" toml:"listen" mapstructure:"listen"`
	BootstrapPeers     []p2p.Multiaddr `json:"bootstrapPeers,omitempty" form:"bootstrapPeers" query:"bootstrapPeers" validate:"required" toml:"bootstrap-peers" mapstructure:"bootstrap-peers"`
	Key                PrivateKey      `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	PeerDB             string          `json:"peerDB,omitempty" form:"peerDB" query:"peerDB" validate:"required"`
	EnablePeerTracking bool            `json:"enablePeerTracking,omitempty" form:"enablePeerTracking" query:"enablePeerTracking" validate:"required"`
}

type PrivateKeySeed struct {
	key  address.Address
	Seed *record.Key `json:"seed,omitempty" form:"seed" query:"seed" validate:"required"`
}

type StorageService struct {
	Name    string  `json:"name,omitempty" form:"name" query:"name"`
	Storage Storage `json:"storage,omitempty" form:"storage" query:"storage" validate:"required"`
}

type TransientPrivateKey struct {
	key address.Address
}

func (*BadgerStorage) Type() StorageType { return StorageTypeBadger }

func (*MemoryStorage) Type() StorageType { return StorageTypeMemory }

func (*PrivateKeySeed) Type() PrivateKeyType { return PrivateKeyTypeSeed }

func (*StorageService) Type() ServiceType { return ServiceTypeStorage }

func (*TransientPrivateKey) Type() PrivateKeyType { return PrivateKeyTypeTransient }

func (v *BadgerStorage) Copy() *BadgerStorage {
	u := new(BadgerStorage)

	u.Path = v.Path

	return u
}

func (v *BadgerStorage) CopyAsInterface() interface{} { return v.Copy() }

func (v *Config) Copy() *Config {
	u := new(Config)

	if v.Logging != nil {
		u.Logging = (v.Logging).Copy()
	}
	if v.P2P != nil {
		u.P2P = (v.P2P).Copy()
	}
	u.Services = make([]Service, len(v.Services))
	for i, v := range v.Services {
		v := v
		u.Services[i] = v
	}

	return u
}

func (v *Config) CopyAsInterface() interface{} { return v.Copy() }

func (v *Logging) Copy() *Logging {
	u := new(Logging)

	u.Format = v.Format
	u.Rules = make([]*LoggingRule, len(v.Rules))
	for i, v := range v.Rules {
		v := v
		if v != nil {
			u.Rules[i] = (v).Copy()
		}
	}

	return u
}

func (v *Logging) CopyAsInterface() interface{} { return v.Copy() }

func (v *LoggingRule) Copy() *LoggingRule {
	u := new(LoggingRule)

	u.Level = v.Level
	u.Module = v.Module

	return u
}

func (v *LoggingRule) CopyAsInterface() interface{} { return v.Copy() }

func (v *MemoryStorage) Copy() *MemoryStorage {
	u := new(MemoryStorage)

	return u
}

func (v *MemoryStorage) CopyAsInterface() interface{} { return v.Copy() }

func (v *P2P) Copy() *P2P {
	u := new(P2P)

	u.Network = v.Network
	u.Listen = make([]p2p.Multiaddr, len(v.Listen))
	for i, v := range v.Listen {
		v := v
		if v != nil {
			u.Listen[i] = p2p.CopyMultiaddr(v)
		}
	}
	u.BootstrapPeers = make([]p2p.Multiaddr, len(v.BootstrapPeers))
	for i, v := range v.BootstrapPeers {
		v := v
		if v != nil {
			u.BootstrapPeers[i] = p2p.CopyMultiaddr(v)
		}
	}
	if v.Key != nil {
		u.Key = CopyPrivateKey(v.Key)
	}
	u.PeerDB = v.PeerDB
	u.EnablePeerTracking = v.EnablePeerTracking

	return u
}

func (v *P2P) CopyAsInterface() interface{} { return v.Copy() }

func (v *PrivateKeySeed) Copy() *PrivateKeySeed {
	u := new(PrivateKeySeed)

	if v.Seed != nil {
		u.Seed = (v.Seed).Copy()
	}

	return u
}

func (v *PrivateKeySeed) CopyAsInterface() interface{} { return v.Copy() }

func (v *StorageService) Copy() *StorageService {
	u := new(StorageService)

	u.Name = v.Name
	if v.Storage != nil {
		u.Storage = CopyStorage(v.Storage)
	}

	return u
}

func (v *StorageService) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransientPrivateKey) Copy() *TransientPrivateKey {
	u := new(TransientPrivateKey)

	return u
}

func (v *TransientPrivateKey) CopyAsInterface() interface{} { return v.Copy() }

func (v *BadgerStorage) Equal(u *BadgerStorage) bool {
	if !(v.Path == u.Path) {
		return false
	}

	return true
}

func (v *Config) Equal(u *Config) bool {
	switch {
	case v.Logging == u.Logging:
		// equal
	case v.Logging == nil || u.Logging == nil:
		return false
	case !((v.Logging).Equal(u.Logging)):
		return false
	}
	switch {
	case v.P2P == u.P2P:
		// equal
	case v.P2P == nil || u.P2P == nil:
		return false
	case !((v.P2P).Equal(u.P2P)):
		return false
	}
	if len(v.Services) != len(u.Services) {
		return false
	}
	for i := range v.Services {
		if !(v.Services[i] == u.Services[i]) {
			return false
		}
	}

	return true
}

func (v *Logging) Equal(u *Logging) bool {
	if !(v.Format == u.Format) {
		return false
	}
	if len(v.Rules) != len(u.Rules) {
		return false
	}
	for i := range v.Rules {
		if !((v.Rules[i]).Equal(u.Rules[i])) {
			return false
		}
	}

	return true
}

func (v *LoggingRule) Equal(u *LoggingRule) bool {
	if !(v.Level == u.Level) {
		return false
	}
	if !(v.Module == u.Module) {
		return false
	}

	return true
}

func (v *MemoryStorage) Equal(u *MemoryStorage) bool {

	return true
}

func (v *P2P) Equal(u *P2P) bool {
	if !(v.Network == u.Network) {
		return false
	}
	if len(v.Listen) != len(u.Listen) {
		return false
	}
	for i := range v.Listen {
		if !(p2p.EqualMultiaddr(v.Listen[i], u.Listen[i])) {
			return false
		}
	}
	if len(v.BootstrapPeers) != len(u.BootstrapPeers) {
		return false
	}
	for i := range v.BootstrapPeers {
		if !(p2p.EqualMultiaddr(v.BootstrapPeers[i], u.BootstrapPeers[i])) {
			return false
		}
	}
	if !(EqualPrivateKey(v.Key, u.Key)) {
		return false
	}
	if !(v.PeerDB == u.PeerDB) {
		return false
	}
	if !(v.EnablePeerTracking == u.EnablePeerTracking) {
		return false
	}

	return true
}

func (v *PrivateKeySeed) Equal(u *PrivateKeySeed) bool {
	switch {
	case v.Seed == u.Seed:
		// equal
	case v.Seed == nil || u.Seed == nil:
		return false
	case !((v.Seed).Equal(u.Seed)):
		return false
	}

	return true
}

func (v *StorageService) Equal(u *StorageService) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(EqualStorage(v.Storage, u.Storage)) {
		return false
	}

	return true
}

func (v *TransientPrivateKey) Equal(u *TransientPrivateKey) bool {

	return true
}

func (v *BadgerStorage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type StorageType `json:"type"`
		Path string      `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Path) == 0) {
		u.Path = v.Path
	}
	return json.Marshal(&u)
}

func (v *Config) MarshalJSON() ([]byte, error) {
	u := struct {
		Logging  *Logging                   `json:"logging,omitempty"`
		P2P      *P2P                       `json:"p2P,omitempty"`
		Services encoding.JsonList[Service] `json:"services,omitempty"`
	}{}
	if !(v.Logging == nil) {
		u.Logging = v.Logging
	}
	if !(v.P2P == nil) {
		u.P2P = v.P2P
	}
	if !(len(v.Services) == 0) {
		u.Services = v.Services
	}
	return json.Marshal(&u)
}

func (v *Logging) MarshalJSON() ([]byte, error) {
	u := struct {
		Format string                          `json:"format,omitempty"`
		Rules  encoding.JsonList[*LoggingRule] `json:"rules,omitempty"`
	}{}
	if !(len(v.Format) == 0) {
		u.Format = v.Format
	}
	if !(len(v.Rules) == 0) {
		u.Rules = v.Rules
	}
	return json.Marshal(&u)
}

func (v *MemoryStorage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type StorageType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *P2P) MarshalJSON() ([]byte, error) {
	u := struct {
		Network            string                                         `json:"network,omitempty"`
		Listen             *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"listen,omitempty"`
		BootstrapPeers     *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"bootstrapPeers,omitempty"`
		Key                *encoding.JsonUnmarshalWith[PrivateKey]        `json:"key,omitempty"`
		PeerDB             string                                         `json:"peerDB,omitempty"`
		EnablePeerTracking bool                                           `json:"enablePeerTracking,omitempty"`
	}{}
	if !(len(v.Network) == 0) {
		u.Network = v.Network
	}
	if !(len(v.Listen) == 0) {
		u.Listen = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Listen, Func: p2p.UnmarshalMultiaddrJSON}
	}
	if !(len(v.BootstrapPeers) == 0) {
		u.BootstrapPeers = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.BootstrapPeers, Func: p2p.UnmarshalMultiaddrJSON}
	}
	if !(EqualPrivateKey(v.Key, nil)) {
		u.Key = &encoding.JsonUnmarshalWith[PrivateKey]{Value: v.Key, Func: UnmarshalPrivateKeyJSON}
	}
	if !(len(v.PeerDB) == 0) {
		u.PeerDB = v.PeerDB
	}
	if !(!v.EnablePeerTracking) {
		u.EnablePeerTracking = v.EnablePeerTracking
	}
	return json.Marshal(&u)
}

func (v *PrivateKeySeed) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Seed *record.Key    `json:"seed,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Seed == nil) {
		u.Seed = v.Seed
	}
	return json.Marshal(&u)
}

func (v *StorageService) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    ServiceType                          `json:"type"`
		Name    string                               `json:"name,omitempty"`
		Storage *encoding.JsonUnmarshalWith[Storage] `json:"storage,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Name) == 0) {
		u.Name = v.Name
	}
	if !(EqualStorage(v.Storage, nil)) {
		u.Storage = &encoding.JsonUnmarshalWith[Storage]{Value: v.Storage, Func: UnmarshalStorageJSON}
	}
	return json.Marshal(&u)
}

func (v *TransientPrivateKey) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *BadgerStorage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type StorageType `json:"type"`
		Path string      `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	u.Path = v.Path
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Path = u.Path
	return nil
}

func (v *Config) UnmarshalJSON(data []byte) error {
	u := struct {
		Logging  *Logging                   `json:"logging,omitempty"`
		P2P      *P2P                       `json:"p2P,omitempty"`
		Services encoding.JsonList[Service] `json:"services,omitempty"`
	}{}
	u.Logging = v.Logging
	u.P2P = v.P2P
	u.Services = v.Services
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Logging = u.Logging
	v.P2P = u.P2P
	v.Services = u.Services
	return nil
}

func (v *Logging) UnmarshalJSON(data []byte) error {
	u := struct {
		Format string                          `json:"format,omitempty"`
		Rules  encoding.JsonList[*LoggingRule] `json:"rules,omitempty"`
	}{}
	u.Format = v.Format
	u.Rules = v.Rules
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Format = u.Format
	v.Rules = u.Rules
	return nil
}

func (v *MemoryStorage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type StorageType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *P2P) UnmarshalJSON(data []byte) error {
	u := struct {
		Network            string                                         `json:"network,omitempty"`
		Listen             *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"listen,omitempty"`
		BootstrapPeers     *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"bootstrapPeers,omitempty"`
		Key                *encoding.JsonUnmarshalWith[PrivateKey]        `json:"key,omitempty"`
		PeerDB             string                                         `json:"peerDB,omitempty"`
		EnablePeerTracking bool                                           `json:"enablePeerTracking,omitempty"`
	}{}
	u.Network = v.Network
	u.Listen = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Listen, Func: p2p.UnmarshalMultiaddrJSON}
	u.BootstrapPeers = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.BootstrapPeers, Func: p2p.UnmarshalMultiaddrJSON}
	u.Key = &encoding.JsonUnmarshalWith[PrivateKey]{Value: v.Key, Func: UnmarshalPrivateKeyJSON}
	u.PeerDB = v.PeerDB
	u.EnablePeerTracking = v.EnablePeerTracking
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Network = u.Network
	if u.Listen != nil {
		v.Listen = make([]p2p.Multiaddr, len(u.Listen.Value))
		for i, x := range u.Listen.Value {
			v.Listen[i] = x
		}
	}
	if u.BootstrapPeers != nil {
		v.BootstrapPeers = make([]p2p.Multiaddr, len(u.BootstrapPeers.Value))
		for i, x := range u.BootstrapPeers.Value {
			v.BootstrapPeers[i] = x
		}
	}
	if u.Key != nil {
		v.Key = u.Key.Value
	}

	v.PeerDB = u.PeerDB
	v.EnablePeerTracking = u.EnablePeerTracking
	return nil
}

func (v *PrivateKeySeed) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Seed *record.Key    `json:"seed,omitempty"`
	}{}
	u.Type = v.Type()
	u.Seed = v.Seed
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Seed = u.Seed
	return nil
}

func (v *StorageService) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    ServiceType                          `json:"type"`
		Name    string                               `json:"name,omitempty"`
		Storage *encoding.JsonUnmarshalWith[Storage] `json:"storage,omitempty"`
	}{}
	u.Type = v.Type()
	u.Name = v.Name
	u.Storage = &encoding.JsonUnmarshalWith[Storage]{Value: v.Storage, Func: UnmarshalStorageJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Name = u.Name
	if u.Storage != nil {
		v.Storage = u.Storage.Value
	}

	return nil
}

func (v *TransientPrivateKey) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}
