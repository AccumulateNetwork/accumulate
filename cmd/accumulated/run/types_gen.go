// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package run

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/address"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/record"
	"golang.org/x/exp/slog"
)

type CometNodeKeyFile struct {
	key  address.Address
	Path string `json:"path,omitempty" form:"path" query:"path" validate:"required"`
}

type CometPrivValFile struct {
	key  address.Address
	Path string `json:"path,omitempty" form:"path" query:"path" validate:"required"`
}

type Config struct {
	file    string
	Network string   `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Logging *Logging `json:"logging,omitempty" form:"logging" query:"logging" validate:"required"`
	P2P     *P2P     `json:"p2P,omitempty" form:"p2P" query:"p2P" validate:"required"`
}

type Logging struct {
	Format string         `json:"format,omitempty" form:"format" query:"format" validate:"required"`
	Rules  []*LoggingRule `json:"rules,omitempty" form:"rules" query:"rules" validate:"required"`
}

type LoggingRule struct {
	Level  slog.Level `json:"level" form:"level" query:"level" validate:"required"`
	Module string     `json:"module,omitempty" form:"module" query:"module" validate:"required"`
}

type P2P struct {
	Listen             []p2p.Multiaddr `json:"listen,omitempty" form:"listen" query:"listen" validate:"required"`
	BootstrapPeers     []p2p.Multiaddr `json:"bootstrapPeers,omitempty" form:"bootstrapPeers" query:"bootstrapPeers" validate:"required"`
	Key                PrivateKey      `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	PeerDB             string          `json:"peerDB,omitempty" form:"peerDB" query:"peerDB" validate:"required"`
	EnablePeerTracking bool            `json:"enablePeerTracking,omitempty" form:"enablePeerTracking" query:"enablePeerTracking" validate:"required"`
	DiscoveryMode      DhtMode         `json:"discoveryMode,omitempty" form:"discoveryMode" query:"discoveryMode" validate:"required"`
	External           p2p.Multiaddr   `json:"external,omitempty" form:"external" query:"external" validate:"required"`
}

type PrivateKeySeed struct {
	key  address.Address
	Seed *record.Key `json:"seed,omitempty" form:"seed" query:"seed" validate:"required"`
}

type RawPrivateKey struct {
	Address string `json:"address,omitempty" form:"address" query:"address" validate:"required"`
}

type TransientPrivateKey struct {
	key address.Address
}

func (*CometNodeKeyFile) Type() PrivateKeyType { return PrivateKeyTypeCometNodeKeyFile }

func (*CometPrivValFile) Type() PrivateKeyType { return PrivateKeyTypeCometPrivValFile }

func (*PrivateKeySeed) Type() PrivateKeyType { return PrivateKeyTypeSeed }

func (*RawPrivateKey) Type() PrivateKeyType { return PrivateKeyTypeRaw }

func (*TransientPrivateKey) Type() PrivateKeyType { return PrivateKeyTypeTransient }

func (v *CometNodeKeyFile) Copy() *CometNodeKeyFile {
	u := new(CometNodeKeyFile)

	u.Path = v.Path

	return u
}

func (v *CometNodeKeyFile) CopyAsInterface() interface{} { return v.Copy() }

func (v *CometPrivValFile) Copy() *CometPrivValFile {
	u := new(CometPrivValFile)

	u.Path = v.Path

	return u
}

func (v *CometPrivValFile) CopyAsInterface() interface{} { return v.Copy() }

func (v *Config) Copy() *Config {
	u := new(Config)

	u.Network = v.Network
	if v.Logging != nil {
		u.Logging = (v.Logging).Copy()
	}
	if v.P2P != nil {
		u.P2P = (v.P2P).Copy()
	}

	return u
}

func (v *Config) CopyAsInterface() interface{} { return v.Copy() }

func (v *Logging) Copy() *Logging {
	u := new(Logging)

	u.Format = v.Format
	u.Rules = make([]*LoggingRule, len(v.Rules))
	for i, v := range v.Rules {
		v := v
		if v != nil {
			u.Rules[i] = (v).Copy()
		}
	}

	return u
}

func (v *Logging) CopyAsInterface() interface{} { return v.Copy() }

func (v *LoggingRule) Copy() *LoggingRule {
	u := new(LoggingRule)

	u.Level = v.Level
	u.Module = v.Module

	return u
}

func (v *LoggingRule) CopyAsInterface() interface{} { return v.Copy() }

func (v *P2P) Copy() *P2P {
	u := new(P2P)

	u.Listen = make([]p2p.Multiaddr, len(v.Listen))
	for i, v := range v.Listen {
		v := v
		if v != nil {
			u.Listen[i] = p2p.CopyMultiaddr(v)
		}
	}
	u.BootstrapPeers = make([]p2p.Multiaddr, len(v.BootstrapPeers))
	for i, v := range v.BootstrapPeers {
		v := v
		if v != nil {
			u.BootstrapPeers[i] = p2p.CopyMultiaddr(v)
		}
	}
	if v.Key != nil {
		u.Key = CopyPrivateKey(v.Key)
	}
	u.PeerDB = v.PeerDB
	u.EnablePeerTracking = v.EnablePeerTracking
	u.DiscoveryMode = v.DiscoveryMode
	if v.External != nil {
		u.External = p2p.CopyMultiaddr(v.External)
	}

	return u
}

func (v *P2P) CopyAsInterface() interface{} { return v.Copy() }

func (v *PrivateKeySeed) Copy() *PrivateKeySeed {
	u := new(PrivateKeySeed)

	if v.Seed != nil {
		u.Seed = (v.Seed).Copy()
	}

	return u
}

func (v *PrivateKeySeed) CopyAsInterface() interface{} { return v.Copy() }

func (v *RawPrivateKey) Copy() *RawPrivateKey {
	u := new(RawPrivateKey)

	u.Address = v.Address

	return u
}

func (v *RawPrivateKey) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransientPrivateKey) Copy() *TransientPrivateKey {
	u := new(TransientPrivateKey)

	return u
}

func (v *TransientPrivateKey) CopyAsInterface() interface{} { return v.Copy() }

func (v *CometNodeKeyFile) Equal(u *CometNodeKeyFile) bool {
	if !(v.Path == u.Path) {
		return false
	}

	return true
}

func (v *CometPrivValFile) Equal(u *CometPrivValFile) bool {
	if !(v.Path == u.Path) {
		return false
	}

	return true
}

func (v *Config) Equal(u *Config) bool {
	if !(v.Network == u.Network) {
		return false
	}
	switch {
	case v.Logging == u.Logging:
		// equal
	case v.Logging == nil || u.Logging == nil:
		return false
	case !((v.Logging).Equal(u.Logging)):
		return false
	}
	switch {
	case v.P2P == u.P2P:
		// equal
	case v.P2P == nil || u.P2P == nil:
		return false
	case !((v.P2P).Equal(u.P2P)):
		return false
	}

	return true
}

func (v *Logging) Equal(u *Logging) bool {
	if !(v.Format == u.Format) {
		return false
	}
	if len(v.Rules) != len(u.Rules) {
		return false
	}
	for i := range v.Rules {
		if !((v.Rules[i]).Equal(u.Rules[i])) {
			return false
		}
	}

	return true
}

func (v *LoggingRule) Equal(u *LoggingRule) bool {
	if !(v.Level == u.Level) {
		return false
	}
	if !(v.Module == u.Module) {
		return false
	}

	return true
}

func (v *P2P) Equal(u *P2P) bool {
	if len(v.Listen) != len(u.Listen) {
		return false
	}
	for i := range v.Listen {
		if !(p2p.EqualMultiaddr(v.Listen[i], u.Listen[i])) {
			return false
		}
	}
	if len(v.BootstrapPeers) != len(u.BootstrapPeers) {
		return false
	}
	for i := range v.BootstrapPeers {
		if !(p2p.EqualMultiaddr(v.BootstrapPeers[i], u.BootstrapPeers[i])) {
			return false
		}
	}
	if !(EqualPrivateKey(v.Key, u.Key)) {
		return false
	}
	if !(v.PeerDB == u.PeerDB) {
		return false
	}
	if !(v.EnablePeerTracking == u.EnablePeerTracking) {
		return false
	}
	if !(v.DiscoveryMode == u.DiscoveryMode) {
		return false
	}
	if !(p2p.EqualMultiaddr(v.External, u.External)) {
		return false
	}

	return true
}

func (v *PrivateKeySeed) Equal(u *PrivateKeySeed) bool {
	switch {
	case v.Seed == u.Seed:
		// equal
	case v.Seed == nil || u.Seed == nil:
		return false
	case !((v.Seed).Equal(u.Seed)):
		return false
	}

	return true
}

func (v *RawPrivateKey) Equal(u *RawPrivateKey) bool {
	if !(v.Address == u.Address) {
		return false
	}

	return true
}

func (v *TransientPrivateKey) Equal(u *TransientPrivateKey) bool {

	return true
}

func (v *CometNodeKeyFile) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Path) == 0) {
		u.Path = v.Path
	}
	return json.Marshal(&u)
}

func (v *CometPrivValFile) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Path) == 0) {
		u.Path = v.Path
	}
	return json.Marshal(&u)
}

func (v *Logging) MarshalJSON() ([]byte, error) {
	u := struct {
		Format string                          `json:"format,omitempty"`
		Rules  encoding.JsonList[*LoggingRule] `json:"rules,omitempty"`
	}{}
	if !(len(v.Format) == 0) {
		u.Format = v.Format
	}
	if !(len(v.Rules) == 0) {
		u.Rules = v.Rules
	}
	return json.Marshal(&u)
}

func (v *P2P) MarshalJSON() ([]byte, error) {
	u := struct {
		Listen             *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"listen,omitempty"`
		BootstrapPeers     *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"bootstrapPeers,omitempty"`
		Key                *encoding.JsonUnmarshalWith[PrivateKey]        `json:"key,omitempty"`
		PeerDB             string                                         `json:"peerDB,omitempty"`
		EnablePeerTracking bool                                           `json:"enablePeerTracking,omitempty"`
		DiscoveryMode      DhtMode                                        `json:"discoveryMode,omitempty"`
		External           *encoding.JsonUnmarshalWith[p2p.Multiaddr]     `json:"external,omitempty"`
	}{}
	if !(len(v.Listen) == 0) {
		u.Listen = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Listen, Func: p2p.UnmarshalMultiaddrJSON}
	}
	if !(len(v.BootstrapPeers) == 0) {
		u.BootstrapPeers = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.BootstrapPeers, Func: p2p.UnmarshalMultiaddrJSON}
	}
	if !(EqualPrivateKey(v.Key, nil)) {
		u.Key = &encoding.JsonUnmarshalWith[PrivateKey]{Value: v.Key, Func: UnmarshalPrivateKeyJSON}
	}
	if !(len(v.PeerDB) == 0) {
		u.PeerDB = v.PeerDB
	}
	if !(!v.EnablePeerTracking) {
		u.EnablePeerTracking = v.EnablePeerTracking
	}
	if !(v.DiscoveryMode == (0)) {
		u.DiscoveryMode = v.DiscoveryMode
	}
	if !(p2p.EqualMultiaddr(v.External, nil)) {
		u.External = &encoding.JsonUnmarshalWith[p2p.Multiaddr]{Value: v.External, Func: p2p.UnmarshalMultiaddrJSON}
	}
	return json.Marshal(&u)
}

func (v *PrivateKeySeed) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Seed *record.Key    `json:"seed,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Seed == nil) {
		u.Seed = v.Seed
	}
	return json.Marshal(&u)
}

func (v *RawPrivateKey) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    PrivateKeyType `json:"type"`
		Address string         `json:"address,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Address) == 0) {
		u.Address = v.Address
	}
	return json.Marshal(&u)
}

func (v *TransientPrivateKey) MarshalJSON() ([]byte, error) {
	u := struct {
		Type PrivateKeyType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *CometNodeKeyFile) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	u.Path = v.Path
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Path = u.Path
	return nil
}

func (v *CometPrivValFile) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	u.Path = v.Path
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Path = u.Path
	return nil
}

func (v *Logging) UnmarshalJSON(data []byte) error {
	u := struct {
		Format string                          `json:"format,omitempty"`
		Rules  encoding.JsonList[*LoggingRule] `json:"rules,omitempty"`
	}{}
	u.Format = v.Format
	u.Rules = v.Rules
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Format = u.Format
	v.Rules = u.Rules
	return nil
}

func (v *P2P) UnmarshalJSON(data []byte) error {
	u := struct {
		Listen             *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"listen,omitempty"`
		BootstrapPeers     *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"bootstrapPeers,omitempty"`
		Key                *encoding.JsonUnmarshalWith[PrivateKey]        `json:"key,omitempty"`
		PeerDB             string                                         `json:"peerDB,omitempty"`
		EnablePeerTracking bool                                           `json:"enablePeerTracking,omitempty"`
		DiscoveryMode      DhtMode                                        `json:"discoveryMode,omitempty"`
		External           *encoding.JsonUnmarshalWith[p2p.Multiaddr]     `json:"external,omitempty"`
	}{}
	u.Listen = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Listen, Func: p2p.UnmarshalMultiaddrJSON}
	u.BootstrapPeers = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.BootstrapPeers, Func: p2p.UnmarshalMultiaddrJSON}
	u.Key = &encoding.JsonUnmarshalWith[PrivateKey]{Value: v.Key, Func: UnmarshalPrivateKeyJSON}
	u.PeerDB = v.PeerDB
	u.EnablePeerTracking = v.EnablePeerTracking
	u.DiscoveryMode = v.DiscoveryMode
	u.External = &encoding.JsonUnmarshalWith[p2p.Multiaddr]{Value: v.External, Func: p2p.UnmarshalMultiaddrJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Listen != nil {
		v.Listen = make([]p2p.Multiaddr, len(u.Listen.Value))
		for i, x := range u.Listen.Value {
			v.Listen[i] = x
		}
	}
	if u.BootstrapPeers != nil {
		v.BootstrapPeers = make([]p2p.Multiaddr, len(u.BootstrapPeers.Value))
		for i, x := range u.BootstrapPeers.Value {
			v.BootstrapPeers[i] = x
		}
	}
	if u.Key != nil {
		v.Key = u.Key.Value
	}

	v.PeerDB = u.PeerDB
	v.EnablePeerTracking = u.EnablePeerTracking
	v.DiscoveryMode = u.DiscoveryMode
	if u.External != nil {
		v.External = u.External.Value
	}

	return nil
}

func (v *PrivateKeySeed) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
		Seed *record.Key    `json:"seed,omitempty"`
	}{}
	u.Type = v.Type()
	u.Seed = v.Seed
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Seed = u.Seed
	return nil
}

func (v *RawPrivateKey) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    PrivateKeyType `json:"type"`
		Address string         `json:"address,omitempty"`
	}{}
	u.Type = v.Type()
	u.Address = v.Address
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Address = u.Address
	return nil
}

func (v *TransientPrivateKey) UnmarshalJSON(data []byte) error {
	u := struct {
		Type PrivateKeyType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}
