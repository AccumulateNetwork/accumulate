// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package services

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
)

type Faucet struct {
	fieldsSet []bool
	Key       KeyStorage `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Account   *url.URL   `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	extraData []byte
}

type FileKeyStorage struct {
	fieldsSet []bool
	Path      string `json:"path,omitempty" form:"path" query:"path" validate:"required"`
	extraData []byte
}

type InlineKeyStorage struct {
	fieldsSet []bool
	Address   string `json:"address,omitempty" form:"address" query:"address" validate:"required"`
	extraData []byte
}

type P2P struct {
	fieldsSet []bool
	Key       KeyStorage      `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Listen    []p2p.Multiaddr `json:"listen,omitempty" form:"listen" query:"listen" validate:"required"`
	Bootstrap []p2p.Multiaddr `json:"bootstrap,omitempty" form:"bootstrap" query:"bootstrap" validate:"required"`
	extraData []byte
}

func (*Faucet) Type() ServiceType { return ServiceTypeFaucet }

func (*FileKeyStorage) Type() KeyStorageType { return KeyStorageTypeFile }

func (*InlineKeyStorage) Type() KeyStorageType { return KeyStorageTypeInline }

func (v *Faucet) Copy() *Faucet {
	u := new(Faucet)

	if v.Key != nil {
		u.Key = CopyKeyStorage(v.Key)
	}
	if v.Account != nil {
		u.Account = v.Account
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *Faucet) CopyAsInterface() interface{} { return v.Copy() }

func (v *FileKeyStorage) Copy() *FileKeyStorage {
	u := new(FileKeyStorage)

	u.Path = v.Path
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *FileKeyStorage) CopyAsInterface() interface{} { return v.Copy() }

func (v *InlineKeyStorage) Copy() *InlineKeyStorage {
	u := new(InlineKeyStorage)

	u.Address = v.Address
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *InlineKeyStorage) CopyAsInterface() interface{} { return v.Copy() }

func (v *P2P) Copy() *P2P {
	u := new(P2P)

	if v.Key != nil {
		u.Key = CopyKeyStorage(v.Key)
	}
	u.Listen = make([]p2p.Multiaddr, len(v.Listen))
	for i, v := range v.Listen {
		if v != nil {
			u.Listen[i] = p2p.CopyMultiaddr(v)
		}
	}
	u.Bootstrap = make([]p2p.Multiaddr, len(v.Bootstrap))
	for i, v := range v.Bootstrap {
		if v != nil {
			u.Bootstrap[i] = p2p.CopyMultiaddr(v)
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *P2P) CopyAsInterface() interface{} { return v.Copy() }

func (v *Faucet) Equal(u *Faucet) bool {
	if !(EqualKeyStorage(v.Key, u.Key)) {
		return false
	}
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}

	return true
}

func (v *FileKeyStorage) Equal(u *FileKeyStorage) bool {
	if !(v.Path == u.Path) {
		return false
	}

	return true
}

func (v *InlineKeyStorage) Equal(u *InlineKeyStorage) bool {
	if !(v.Address == u.Address) {
		return false
	}

	return true
}

func (v *P2P) Equal(u *P2P) bool {
	if !(EqualKeyStorage(v.Key, u.Key)) {
		return false
	}
	if len(v.Listen) != len(u.Listen) {
		return false
	}
	for i := range v.Listen {
		if !(p2p.EqualMultiaddr(v.Listen[i], u.Listen[i])) {
			return false
		}
	}
	if len(v.Bootstrap) != len(u.Bootstrap) {
		return false
	}
	for i := range v.Bootstrap {
		if !(p2p.EqualMultiaddr(v.Bootstrap[i], u.Bootstrap[i])) {
			return false
		}
	}

	return true
}

var fieldNames_Faucet = []string{
	1: "Type",
	2: "Key",
	3: "Account",
}

func (v *Faucet) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(EqualKeyStorage(v.Key, nil)) {
		writer.WriteValue(2, v.Key.MarshalBinary)
	}
	if !(v.Account == nil) {
		writer.WriteUrl(3, v.Account)
	}

	_, _, err := writer.Reset(fieldNames_Faucet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Faucet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Key is missing")
	} else if EqualKeyStorage(v.Key, nil) {
		errs = append(errs, "field Key is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_FileKeyStorage = []string{
	1: "Type",
	2: "Path",
}

func (v *FileKeyStorage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Path) == 0) {
		writer.WriteString(2, v.Path)
	}

	_, _, err := writer.Reset(fieldNames_FileKeyStorage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *FileKeyStorage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Path is missing")
	} else if len(v.Path) == 0 {
		errs = append(errs, "field Path is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_InlineKeyStorage = []string{
	1: "Type",
	2: "Address",
}

func (v *InlineKeyStorage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Address) == 0) {
		writer.WriteString(2, v.Address)
	}

	_, _, err := writer.Reset(fieldNames_InlineKeyStorage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *InlineKeyStorage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Address is missing")
	} else if len(v.Address) == 0 {
		errs = append(errs, "field Address is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_P2P = []string{
	1: "Key",
	2: "Listen",
	3: "Bootstrap",
}

func (v *P2P) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(EqualKeyStorage(v.Key, nil)) {
		writer.WriteValue(1, v.Key.MarshalBinary)
	}
	if !(len(v.Listen) == 0) {
		for _, v := range v.Listen {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	if !(len(v.Bootstrap) == 0) {
		for _, v := range v.Bootstrap {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_P2P)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *P2P) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Key is missing")
	} else if EqualKeyStorage(v.Key, nil) {
		errs = append(errs, "field Key is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Listen is missing")
	} else if len(v.Listen) == 0 {
		errs = append(errs, "field Listen is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Bootstrap is missing")
	} else if len(v.Bootstrap) == 0 {
		errs = append(errs, "field Bootstrap is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *Faucet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Faucet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType ServiceType
	if x := new(ServiceType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *Faucet) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := UnmarshalKeyStorageFrom(r)
		if err == nil {
			v.Key = x
		}
		return err
	})
	if x, ok := reader.ReadUrl(3); ok {
		v.Account = x
	}

	seen, err := reader.Reset(fieldNames_Faucet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *FileKeyStorage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *FileKeyStorage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyStorageType
	if x := new(KeyStorageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *FileKeyStorage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadString(2); ok {
		v.Path = x
	}

	seen, err := reader.Reset(fieldNames_FileKeyStorage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *InlineKeyStorage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *InlineKeyStorage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType KeyStorageType
	if x := new(KeyStorageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *InlineKeyStorage) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadString(2); ok {
		v.Address = x
	}

	seen, err := reader.Reset(fieldNames_InlineKeyStorage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *P2P) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *P2P) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(r io.Reader) error {
		x, err := UnmarshalKeyStorageFrom(r)
		if err == nil {
			v.Key = x
		}
		return err
	})
	for {
		ok := reader.ReadValue(2, func(r io.Reader) error {
			x, err := p2p.UnmarshalMultiaddrFrom(r)
			if err == nil {
				v.Listen = append(v.Listen, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	for {
		ok := reader.ReadValue(3, func(r io.Reader) error {
			x, err := p2p.UnmarshalMultiaddrFrom(r)
			if err == nil {
				v.Bootstrap = append(v.Bootstrap, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_P2P)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Faucet) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    ServiceType                             `json:"type"`
		Key     *encoding.JsonUnmarshalWith[KeyStorage] `json:"key,omitempty"`
		Account *url.URL                                `json:"account,omitempty"`
	}{}
	u.Type = v.Type()
	if !(EqualKeyStorage(v.Key, nil)) {
		u.Key = &encoding.JsonUnmarshalWith[KeyStorage]{Value: v.Key, Func: UnmarshalKeyStorageJSON}
	}
	if !(v.Account == nil) {
		u.Account = v.Account
	}
	return json.Marshal(&u)
}

func (v *FileKeyStorage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type KeyStorageType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Path) == 0) {
		u.Path = v.Path
	}
	return json.Marshal(&u)
}

func (v *InlineKeyStorage) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    KeyStorageType `json:"type"`
		Address string         `json:"address,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Address) == 0) {
		u.Address = v.Address
	}
	return json.Marshal(&u)
}

func (v *P2P) MarshalJSON() ([]byte, error) {
	u := struct {
		Key       *encoding.JsonUnmarshalWith[KeyStorage]        `json:"key,omitempty"`
		Listen    *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"listen,omitempty"`
		Bootstrap *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"bootstrap,omitempty"`
	}{}
	if !(EqualKeyStorage(v.Key, nil)) {
		u.Key = &encoding.JsonUnmarshalWith[KeyStorage]{Value: v.Key, Func: UnmarshalKeyStorageJSON}
	}
	if !(len(v.Listen) == 0) {
		u.Listen = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Listen, Func: p2p.UnmarshalMultiaddrJSON}
	}
	if !(len(v.Bootstrap) == 0) {
		u.Bootstrap = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Bootstrap, Func: p2p.UnmarshalMultiaddrJSON}
	}
	return json.Marshal(&u)
}

func (v *Faucet) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    ServiceType                             `json:"type"`
		Key     *encoding.JsonUnmarshalWith[KeyStorage] `json:"key,omitempty"`
		Account *url.URL                                `json:"account,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = &encoding.JsonUnmarshalWith[KeyStorage]{Value: v.Key, Func: UnmarshalKeyStorageJSON}
	u.Account = v.Account
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if u.Key != nil {
		v.Key = u.Key.Value
	}

	v.Account = u.Account
	return nil
}

func (v *FileKeyStorage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type KeyStorageType `json:"type"`
		Path string         `json:"path,omitempty"`
	}{}
	u.Type = v.Type()
	u.Path = v.Path
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Path = u.Path
	return nil
}

func (v *InlineKeyStorage) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    KeyStorageType `json:"type"`
		Address string         `json:"address,omitempty"`
	}{}
	u.Type = v.Type()
	u.Address = v.Address
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Address = u.Address
	return nil
}

func (v *P2P) UnmarshalJSON(data []byte) error {
	u := struct {
		Key       *encoding.JsonUnmarshalWith[KeyStorage]        `json:"key,omitempty"`
		Listen    *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"listen,omitempty"`
		Bootstrap *encoding.JsonUnmarshalListWith[p2p.Multiaddr] `json:"bootstrap,omitempty"`
	}{}
	u.Key = &encoding.JsonUnmarshalWith[KeyStorage]{Value: v.Key, Func: UnmarshalKeyStorageJSON}
	u.Listen = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Listen, Func: p2p.UnmarshalMultiaddrJSON}
	u.Bootstrap = &encoding.JsonUnmarshalListWith[p2p.Multiaddr]{Value: v.Bootstrap, Func: p2p.UnmarshalMultiaddrJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Key != nil {
		v.Key = u.Key.Value
	}

	if u.Listen != nil {
		v.Listen = make([]p2p.Multiaddr, len(u.Listen.Value))
		for i, x := range u.Listen.Value {
			v.Listen[i] = x
		}
	}
	if u.Bootstrap != nil {
		v.Bootstrap = make([]p2p.Multiaddr, len(u.Bootstrap.Value))
		for i, x := range u.Bootstrap.Value {
			v.Bootstrap[i] = x
		}
	}
	return nil
}
