// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package services

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

// NewService creates a new Service for the specified ServiceType.
func NewService(typ ServiceType) (Service, error) {
	switch typ {
	case ServiceTypeFaucet:
		return new(Faucet), nil
	}
	return nil, fmt.Errorf("unknown service %v", typ)
}

// EqualService is used to compare the values of the union
func EqualService(a, b Service) bool {
	if a == b {
		return true
	}
	switch a := a.(type) {
	case *Faucet:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*Faucet)
		return ok && a.Equal(b)
	}
	return false
}

// CopyService copies a Service.
func CopyService(v Service) Service {
	switch v := v.(type) {
	case *Faucet:
		return v.Copy()
	default:
		return v.CopyAsInterface().(Service)
	}
}

// UnmarshalService unmarshals a Service.
func UnmarshalService(data []byte) (Service, error) {
	return UnmarshalServiceFrom(bytes.NewReader(data))
}

// UnmarshalServiceFrom unmarshals a Service.
func UnmarshalServiceFrom(rd io.Reader) (Service, error) {
	reader := encoding.NewReader(rd)

	// Read the type code
	var typ ServiceType
	if !reader.ReadEnum(1, &typ) {
		if reader.IsEmpty() {
			return nil, nil
		}
		return nil, fmt.Errorf("field Type: missing")
	}

	// Create a new service
	v, err := NewService(ServiceType(typ))
	if err != nil {
		return nil, err
	}

	// Unmarshal the rest of the service
	err = v.UnmarshalFieldsFrom(reader)
	if err != nil {
		return nil, err
	}

	return v, nil
}

// UnmarshalServiceJson unmarshals a Service.
func UnmarshalServiceJSON(data []byte) (Service, error) {
	var typ *struct{ Type ServiceType }
	err := json.Unmarshal(data, &typ)
	if err != nil {
		return nil, err
	}

	if typ == nil {
		return nil, nil
	}

	acnt, err := NewService(typ.Type)
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(data, acnt)
	if err != nil {
		return nil, err
	}

	return acnt, nil
}

// NewKeyStorage creates a new KeyStorage for the specified KeyStorageType.
func NewKeyStorage(typ KeyStorageType) (KeyStorage, error) {
	switch typ {
	case KeyStorageTypeFile:
		return new(FileKeyStorage), nil
	case KeyStorageTypeInline:
		return new(InlineKeyStorage), nil
	}
	return nil, fmt.Errorf("unknown key storage %v", typ)
}

// EqualKeyStorage is used to compare the values of the union
func EqualKeyStorage(a, b KeyStorage) bool {
	if a == b {
		return true
	}
	switch a := a.(type) {
	case *FileKeyStorage:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*FileKeyStorage)
		return ok && a.Equal(b)
	case *InlineKeyStorage:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*InlineKeyStorage)
		return ok && a.Equal(b)
	}
	return false
}

// CopyKeyStorage copies a KeyStorage.
func CopyKeyStorage(v KeyStorage) KeyStorage {
	switch v := v.(type) {
	case *FileKeyStorage:
		return v.Copy()
	case *InlineKeyStorage:
		return v.Copy()
	default:
		return v.CopyAsInterface().(KeyStorage)
	}
}

// UnmarshalKeyStorage unmarshals a KeyStorage.
func UnmarshalKeyStorage(data []byte) (KeyStorage, error) {
	return UnmarshalKeyStorageFrom(bytes.NewReader(data))
}

// UnmarshalKeyStorageFrom unmarshals a KeyStorage.
func UnmarshalKeyStorageFrom(rd io.Reader) (KeyStorage, error) {
	reader := encoding.NewReader(rd)

	// Read the type code
	var typ KeyStorageType
	if !reader.ReadEnum(1, &typ) {
		if reader.IsEmpty() {
			return nil, nil
		}
		return nil, fmt.Errorf("field Type: missing")
	}

	// Create a new key storage
	v, err := NewKeyStorage(KeyStorageType(typ))
	if err != nil {
		return nil, err
	}

	// Unmarshal the rest of the key storage
	err = v.UnmarshalFieldsFrom(reader)
	if err != nil {
		return nil, err
	}

	return v, nil
}

// UnmarshalKeyStorageJson unmarshals a KeyStorage.
func UnmarshalKeyStorageJSON(data []byte) (KeyStorage, error) {
	var typ *struct{ Type KeyStorageType }
	err := json.Unmarshal(data, &typ)
	if err != nil {
		return nil, err
	}

	if typ == nil {
		return nil, nil
	}

	acnt, err := NewKeyStorage(typ.Type)
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(data, acnt)
	if err != nil {
		return nil, err
	}

	return acnt, nil
}
