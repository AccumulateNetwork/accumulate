// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package genesis

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"io"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type ConsensusBlock struct {
	fieldsSet  []bool
	Height     int64  `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	HeaderHash []byte `json:"headerHash,omitempty" form:"headerHash" query:"headerHash" validate:"required"`
	AppHash    []byte `json:"appHash,omitempty" form:"appHash" query:"appHash" validate:"required"`
	extraData  []byte
}

var machine_ConsensusBlock = &encoding.Machine[*ConsensusBlock]{
	ExtraData: func(v *ConsensusBlock) *[]byte { return &v.extraData },
	Seen:      func(v *ConsensusBlock) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*ConsensusBlock]{
		{Name: "Height", Number: 1, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.IntField[*ConsensusBlock](func(v *ConsensusBlock) *int64 { return &v.Height })},
		{Name: "HeaderHash", Number: 2, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.BytesField[*ConsensusBlock](func(v *ConsensusBlock) *[]byte { return &v.HeaderHash })},
		{Name: "AppHash", Number: 3, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.BytesField[*ConsensusBlock](func(v *ConsensusBlock) *[]byte { return &v.AppHash })},
	},
}

func (v *ConsensusBlock) IsValid() error               { return machine_ConsensusBlock.IsValid(v) }
func (v *ConsensusBlock) Copy() *ConsensusBlock        { return encoding.Copy(machine_ConsensusBlock, v) }
func (v *ConsensusBlock) CopyAsInterface() interface{} { return v.Copy() }
func (v *ConsensusBlock) Equal(u *ConsensusBlock) bool { return machine_ConsensusBlock.Equal(v, u) }
func (v *ConsensusBlock) MarshalBinary() ([]byte, error) {
	return machine_ConsensusBlock.MarshalBinary(v)
}
func (v *ConsensusBlock) UnmarshalBinary(data []byte) error {
	return machine_ConsensusBlock.Unmarshal(data, v)
}
func (v *ConsensusBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	return machine_ConsensusBlock.UnmarshalFrom(rd, v)
}
func (v *ConsensusBlock) MarshalJSON() ([]byte, error) { return machine_ConsensusBlock.JSONMarshal(v) }
func (v *ConsensusBlock) UnmarshalJSON(b []byte) error {
	return machine_ConsensusBlock.JSONUnmarshal(b, v)
}

type ConsensusDoc struct {
	fieldsSet  []bool
	ChainID    string              `json:"chainID,omitempty" form:"chainID" query:"chainID" validate:"required"`
	Params     *ConsensusParams    `json:"params,omitempty" form:"params" query:"params" validate:"required"`
	Validators []*GenesisValidator `json:"validators,omitempty" form:"validators" query:"validators" validate:"required"`
	Block      *ConsensusBlock     `json:"block,omitempty" form:"block" query:"block" validate:"required"`
	extraData  []byte
}

var machine_ConsensusDoc = &encoding.Machine[*ConsensusDoc]{
	ExtraData: func(v *ConsensusDoc) *[]byte { return &v.extraData },
	Seen:      func(v *ConsensusDoc) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*ConsensusDoc]{
		{Name: "ChainID", Number: 1, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.StringField[*ConsensusDoc](func(v *ConsensusDoc) *string { return &v.ChainID })},
		{Name: "Params", Number: 2, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.StructPtrField[*ConsensusDoc, *ConsensusParams, ConsensusParams](func(v *ConsensusDoc) **ConsensusParams { return &v.Params })},
		{Name: "Validators", Number: 3, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.SliceField[*ConsensusDoc, *GenesisValidator, encoding.StructPtrField[encoding.SliceIndex[*GenesisValidator], *GenesisValidator, GenesisValidator]](func(v *ConsensusDoc) *[]*GenesisValidator { return &v.Validators })},
		{Name: "Block", Number: 4, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.StructPtrField[*ConsensusDoc, *ConsensusBlock, ConsensusBlock](func(v *ConsensusDoc) **ConsensusBlock { return &v.Block })},
	},
}

func (v *ConsensusDoc) IsValid() error                 { return machine_ConsensusDoc.IsValid(v) }
func (v *ConsensusDoc) Copy() *ConsensusDoc            { return encoding.Copy(machine_ConsensusDoc, v) }
func (v *ConsensusDoc) CopyAsInterface() interface{}   { return v.Copy() }
func (v *ConsensusDoc) Equal(u *ConsensusDoc) bool     { return machine_ConsensusDoc.Equal(v, u) }
func (v *ConsensusDoc) MarshalBinary() ([]byte, error) { return machine_ConsensusDoc.MarshalBinary(v) }
func (v *ConsensusDoc) UnmarshalBinary(data []byte) error {
	return machine_ConsensusDoc.Unmarshal(data, v)
}
func (v *ConsensusDoc) UnmarshalBinaryFrom(rd io.Reader) error {
	return machine_ConsensusDoc.UnmarshalFrom(rd, v)
}
func (v *ConsensusDoc) MarshalJSON() ([]byte, error) { return machine_ConsensusDoc.JSONMarshal(v) }
func (v *ConsensusDoc) UnmarshalJSON(b []byte) error { return machine_ConsensusDoc.JSONUnmarshal(b, v) }

type GenesisValidator struct {
	fieldsSet []bool
	Address   []byte                 `json:"address,omitempty" form:"address" query:"address" validate:"required"`
	Type      protocol.SignatureType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	PubKey    []byte                 `json:"pubKey,omitempty" form:"pubKey" query:"pubKey" validate:"required"`
	Power     int64                  `json:"power,omitempty" form:"power" query:"power" validate:"required"`
	Name      string                 `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	extraData []byte
}

var machine_GenesisValidator = &encoding.Machine[*GenesisValidator]{
	ExtraData: func(v *GenesisValidator) *[]byte { return &v.extraData },
	Seen:      func(v *GenesisValidator) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*GenesisValidator]{
		{Name: "Address", Number: 1, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.BytesField[*GenesisValidator](func(v *GenesisValidator) *[]byte { return &v.Address })},
		{Name: "Type", Number: 2, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.EnumField[*GenesisValidator, *protocol.SignatureType, protocol.SignatureType](func(v *GenesisValidator) *protocol.SignatureType { return &v.Type })},
		{Name: "PubKey", Number: 3, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.BytesField[*GenesisValidator](func(v *GenesisValidator) *[]byte { return &v.PubKey })},
		{Name: "Power", Number: 4, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.IntField[*GenesisValidator](func(v *GenesisValidator) *int64 { return &v.Power })},
		{Name: "Name", Number: 5, Binary: true, OmitEmpty: true, Required: true, Accessor: encoding.StringField[*GenesisValidator](func(v *GenesisValidator) *string { return &v.Name })},
	},
}

func (v *GenesisValidator) IsValid() error { return machine_GenesisValidator.IsValid(v) }
func (v *GenesisValidator) Copy() *GenesisValidator {
	return encoding.Copy(machine_GenesisValidator, v)
}
func (v *GenesisValidator) CopyAsInterface() interface{} { return v.Copy() }
func (v *GenesisValidator) Equal(u *GenesisValidator) bool {
	return machine_GenesisValidator.Equal(v, u)
}
func (v *GenesisValidator) MarshalBinary() ([]byte, error) {
	return machine_GenesisValidator.MarshalBinary(v)
}
func (v *GenesisValidator) UnmarshalBinary(data []byte) error {
	return machine_GenesisValidator.Unmarshal(data, v)
}
func (v *GenesisValidator) UnmarshalBinaryFrom(rd io.Reader) error {
	return machine_GenesisValidator.UnmarshalFrom(rd, v)
}
func (v *GenesisValidator) MarshalJSON() ([]byte, error) {
	return machine_GenesisValidator.JSONMarshal(v)
}
func (v *GenesisValidator) UnmarshalJSON(b []byte) error {
	return machine_GenesisValidator.JSONUnmarshal(b, v)
}
