package indexing

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
)

type BlockStateIndex struct {
	fieldsSet         []bool
	ProducedSynthTxns []*BlockStateSynthTxnEntry `json:"producedSynthTxns,omitempty" form:"producedSynthTxns" query:"producedSynthTxns" validate:"required"`
}

type BlockStateSynthTxnEntry struct {
	fieldsSet   []bool
	Transaction []byte `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	ChainEntry  uint64 `json:"chainEntry,omitempty" form:"chainEntry" query:"chainEntry" validate:"required"`
}

type PendingTransactionsIndex struct {
	fieldsSet    []bool
	Transactions [][32]byte `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
}

type TransactionChainEntry struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	// Chain is the name of the chain.
	Chain string `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	// ChainIndex is the index of the entry in the chain's index chain.
	ChainIndex uint64 `json:"chainIndex,omitempty" form:"chainIndex" query:"chainIndex" validate:"required"`
	// AnchorIndex is the index of the entry in the anchor chain's index chain.
	AnchorIndex uint64 `json:"anchorIndex,omitempty" form:"anchorIndex" query:"anchorIndex" validate:"required"`
}

type TransactionChainIndex struct {
	fieldsSet []bool
	Entries   []*TransactionChainEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
}

func (v *BlockStateIndex) Equal(u *BlockStateIndex) bool {
	if len(v.ProducedSynthTxns) != len(u.ProducedSynthTxns) {
		return false
	}
	for i := range v.ProducedSynthTxns {
		if !((v.ProducedSynthTxns[i]).Equal(u.ProducedSynthTxns[i])) {
			return false
		}
	}

	return true
}

func (v *BlockStateSynthTxnEntry) Equal(u *BlockStateSynthTxnEntry) bool {
	if !(bytes.Equal(v.Transaction, u.Transaction)) {
		return false
	}
	if !(v.ChainEntry == u.ChainEntry) {
		return false
	}

	return true
}

func (v *PendingTransactionsIndex) Equal(u *PendingTransactionsIndex) bool {
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !(v.Transactions[i] == u.Transactions[i]) {
			return false
		}
	}

	return true
}

func (v *TransactionChainEntry) Equal(u *TransactionChainEntry) bool {
	if !((v.Account).Equal(u.Account)) {
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}
	if !(v.ChainIndex == u.ChainIndex) {
		return false
	}
	if !(v.AnchorIndex == u.AnchorIndex) {
		return false
	}

	return true
}

func (v *TransactionChainIndex) Equal(u *TransactionChainIndex) bool {
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((v.Entries[i]).Equal(u.Entries[i])) {
			return false
		}
	}

	return true
}

var fieldNames_BlockStateIndex = []string{
	1: "ProducedSynthTxns",
}

func (v *BlockStateIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.ProducedSynthTxns) == 0) {
		for _, v := range v.ProducedSynthTxns {
			writer.WriteValue(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_BlockStateIndex)
	return buffer.Bytes(), err
}

func (v *BlockStateIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field ProducedSynthTxns is missing")
	} else if len(v.ProducedSynthTxns) == 0 {
		errs = append(errs, "field ProducedSynthTxns is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockStateSynthTxnEntry = []string{
	1: "Transaction",
	2: "ChainEntry",
}

func (v *BlockStateSynthTxnEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Transaction) == 0) {
		writer.WriteBytes(1, v.Transaction)
	}
	if !(v.ChainEntry == 0) {
		writer.WriteUint(2, v.ChainEntry)
	}

	_, _, err := writer.Reset(fieldNames_BlockStateSynthTxnEntry)
	return buffer.Bytes(), err
}

func (v *BlockStateSynthTxnEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transaction is missing")
	} else if len(v.Transaction) == 0 {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ChainEntry is missing")
	} else if v.ChainEntry == 0 {
		errs = append(errs, "field ChainEntry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PendingTransactionsIndex = []string{
	1: "Transactions",
}

func (v *PendingTransactionsIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteHash(1, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_PendingTransactionsIndex)
	return buffer.Bytes(), err
}

func (v *PendingTransactionsIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionChainEntry = []string{
	1: "Account",
	2: "Chain",
	3: "ChainIndex",
	4: "AnchorIndex",
}

func (v *TransactionChainEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(2, v.Chain)
	}
	if !(v.ChainIndex == 0) {
		writer.WriteUint(3, v.ChainIndex)
	}
	if !(v.AnchorIndex == 0) {
		writer.WriteUint(4, v.AnchorIndex)
	}

	_, _, err := writer.Reset(fieldNames_TransactionChainEntry)
	return buffer.Bytes(), err
}

func (v *TransactionChainEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ChainIndex is missing")
	} else if v.ChainIndex == 0 {
		errs = append(errs, "field ChainIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field AnchorIndex is missing")
	} else if v.AnchorIndex == 0 {
		errs = append(errs, "field AnchorIndex is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionChainIndex = []string{
	1: "Entries",
}

func (v *TransactionChainIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_TransactionChainIndex)
	return buffer.Bytes(), err
}

func (v *TransactionChainIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *BlockStateIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockStateIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(BlockStateSynthTxnEntry); reader.ReadValue(1, x.UnmarshalBinary) {
			v.ProducedSynthTxns = append(v.ProducedSynthTxns, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_BlockStateIndex)
	v.fieldsSet = seen
	return err
}

func (v *BlockStateSynthTxnEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockStateSynthTxnEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBytes(1); ok {
		v.Transaction = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.ChainEntry = x
	}

	seen, err := reader.Reset(fieldNames_BlockStateSynthTxnEntry)
	v.fieldsSet = seen
	return err
}

func (v *PendingTransactionsIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PendingTransactionsIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadHash(1); ok {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_PendingTransactionsIndex)
	v.fieldsSet = seen
	return err
}

func (v *TransactionChainEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionChainEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Chain = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.ChainIndex = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.AnchorIndex = x
	}

	seen, err := reader.Reset(fieldNames_TransactionChainEntry)
	v.fieldsSet = seen
	return err
}

func (v *TransactionChainIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionChainIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(TransactionChainEntry); reader.ReadValue(1, x.UnmarshalBinary) {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_TransactionChainIndex)
	v.fieldsSet = seen
	return err
}

func (v *BlockStateSynthTxnEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Transaction *string `json:"transaction,omitempty"`
		ChainEntry  uint64  `json:"chainEntry,omitempty"`
	}{}
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	u.ChainEntry = v.ChainEntry
	return json.Marshal(&u)
}

func (v *PendingTransactionsIndex) MarshalJSON() ([]byte, error) {
	u := struct {
		Transactions []string `json:"transactions,omitempty"`
	}{}
	u.Transactions = make([]string, len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *BlockStateSynthTxnEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Transaction *string `json:"transaction,omitempty"`
		ChainEntry  uint64  `json:"chainEntry,omitempty"`
	}{}
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	u.ChainEntry = v.ChainEntry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.Transaction); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	v.ChainEntry = u.ChainEntry
	return nil
}

func (v *PendingTransactionsIndex) UnmarshalJSON(data []byte) error {
	u := struct {
		Transactions []string `json:"transactions,omitempty"`
	}{}
	u.Transactions = make([]string, len(v.Transactions))
	for i, x := range v.Transactions {
		u.Transactions[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transactions = make([][32]byte, len(u.Transactions))
	for i, x := range u.Transactions {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Transactions: %w", err)
		} else {
			v.Transactions[i] = x
		}
	}
	return nil
}
