package block

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/chain"
	"gitlab.com/accumulatenetwork/accumulate/internal/database"
	"gitlab.com/accumulatenetwork/accumulate/internal/errors"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type Block struct {
	BlockMeta
	State BlockState
	Batch *database.Batch
}

func (x *Executor) ExecuteEnvelope(block *Block, delivery *chain.Delivery) (*protocol.TransactionStatus, error) {
	status, err := delivery.LoadTransaction(block.Batch)
	switch {
	case err == nil:
		// Ok

	case !errors.Is(err, errors.StatusDelivered):
		// Unknown error
		return nil, errors.Wrap(errors.StatusUnknown, err)

	default:
		// Transaction has already been delivered
		status := status.Copy()
		status.Code = protocol.ErrorCodeAlreadyDelivered.GetEnumValue()
		return status, nil
	}

	// Process signatures
	{
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		for _, signature := range delivery.Signatures {
			s, err := x.ProcessSignature(batch, delivery, signature)
			if err != nil {
				return nil, err
			}
			block.State.MergeSignature(s)

			fwd, err := x.prepareToForward(delivery, s, signature)
			if err != nil {
				return nil, err
			}
			if fwd != nil {
				delivery.Remote = append(delivery.Remote, fwd)
			}
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}
	}

	// Process remote signatures
	if len(delivery.Remote) > 0 {
		err := x.ProcessRemoteSignatures(block, delivery)
		if err != nil {
			return nil, err
		}
	}

	if len(delivery.Remote) == len(delivery.Signatures) {
		// All signatures are remote
		status = &protocol.TransactionStatus{Remote: true}

	} else {
		// Process the transaction
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		var state *chain.ProcessTransactionState
		status, state, err = x.ProcessTransaction(batch, delivery.Transaction)
		if err != nil {
			return nil, err
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}

		delivery.State.Merge(state)

		if !delivery.Transaction.Body.Type().IsInternal() && delivery.Transaction.Body.Type() != protocol.TransactionTypeSyntheticAnchor {
			kv := []interface{}{
				"module", "block-executor",
				"block", block.Index,
				"type", delivery.Transaction.Body.Type(),
				"pending", status.Pending,
				"delivered", status.Delivered,
				"remote", status.Remote,
				"txn-hash", logging.AsHex(delivery.Transaction.GetHash()).Slice(0, 4),
				"principal", delivery.Transaction.Header.Principal,
			}
			if status.Code != 0 {
				kv = append(kv,
					"code", status.Code,
					"error", status.Message,
				)
				x.Logger.Info("Transaction failed", kv...)
			} else {
				x.Logger.Debug("Transaction succeeded", kv...)
			}
		}
	}

	block.State.MergeTransaction(&delivery.State)

	// Process synthetic transactions generated by the validator
	{
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		err = x.ProduceSynthetic(batch, delivery.Transaction, delivery.State.ProducedTxns)
		if err != nil {
			return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}
	}

	// Process additional transactions
	for _, delivery := range delivery.State.AdditionalTransactions {
		// Discard the status of additional transactions
		_, err = x.ExecuteEnvelope(block, delivery)
		if err != nil {
			return nil, err
		}
	}

	return status, nil
}
