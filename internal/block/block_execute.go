package block

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/chain"
	"gitlab.com/accumulatenetwork/accumulate/internal/database"
	"gitlab.com/accumulatenetwork/accumulate/internal/errors"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type Block struct {
	BlockMeta
	State BlockState
	Batch *database.Batch
}

func (x *Executor) ExecuteEnvelope(block *Block, delivery *chain.Delivery) (*protocol.TransactionStatus, error) {
	status, err := delivery.LoadTransaction(block.Batch)
	switch {
	case err == nil:
		// Ok

	case !errors.Is(err, errors.StatusDelivered):
		// Unknown error
		return nil, errors.Wrap(errors.StatusUnknown, err)

	default:
		// Transaction has already been delivered
		status := status.Copy()
		status.Code = protocol.ErrorCodeAlreadyDelivered.GetEnumValue()
		return status, nil
	}

	// Process signatures
	shouldProcessTransaction := !delivery.Transaction.Body.Type().IsUser()
	{
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		for _, signature := range delivery.Signatures {
			if signature.RoutingLocation().LocalTo(delivery.Transaction.Header.Principal) {
				shouldProcessTransaction = true
			}

			s, err := x.ProcessSignature(batch, delivery, signature)
			if err, ok := err.(*errors.Error); ok {
				status := new(protocol.TransactionStatus)
				status.Code = protocol.ErrorCodeInvalidSignature.GetEnumValue()
				status.Message = err.Message
				status.Error = err
				status.Result = new(protocol.EmptyResult)
				return status, nil
			}
			if err != nil {
				return nil, err
			}
			block.State.MergeSignature(s)
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}
	}

	if shouldProcessTransaction {
		// Process the transaction
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		var state *chain.ProcessTransactionState
		status, state, err = x.ProcessTransaction(batch, delivery.Transaction)
		if err != nil {
			return nil, err
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}

		delivery.State.Merge(state)

		if !delivery.Transaction.Type().IsInternal() && delivery.Transaction.Type() != protocol.TransactionTypeSyntheticAnchor {
			kv := []interface{}{
				"module", "block-executor",
				"block", block.Index,
				"type", delivery.Transaction.Type(),
				"pending", status.Pending,
				"delivered", status.Delivered,
				"remote", status.Remote,
				"txn-hash", logging.AsHex(delivery.Transaction.GetHash()).Slice(0, 4),
				"principal", delivery.Transaction.Header.Principal,
			}
			if status.Code != 0 {
				kv = append(kv,
					"code", status.Code,
					"error", status.Message,
				)
				x.Logger.Info("Transaction failed", kv...)
			} else {
				x.Logger.Debug("Transaction succeeded", kv...)
			}
		}

	} else {
		status = &protocol.TransactionStatus{Remote: true}
	}

	err = x.ProcessRemoteSignatures(block, delivery)
	if err != nil {
		return nil, err
	}

	block.State.MergeTransaction(&delivery.State)

	// Process synthetic transactions generated by the validator
	{
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		err = x.ProduceSynthetic(batch, delivery.Transaction, delivery.State.ProducedTxns)
		if err != nil {
			return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}
	}

	// Process additional transactions
	for _, delivery := range delivery.State.AdditionalTransactions {
		// Discard the status of additional transactions
		_, err = x.ExecuteEnvelope(block, delivery)
		if err != nil {
			return nil, err
		}
	}

	return status, nil
}
