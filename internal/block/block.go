package block

import (
	"time"

	"github.com/tendermint/tendermint/abci/types"
	"gitlab.com/accumulatenetwork/accumulate/internal/chain"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

// BeginBlockRequest is the input parameter to Chain.BeginBlock.
type BeginBlockRequest struct {
	IsLeader   bool
	Height     int64
	Time       time.Time
	CommitInfo *types.LastCommitInfo
	Evidence   []types.Evidence
}

// BeginBlockResponse is the return value of Chain.BeginBlock.
type BeginBlockResponse struct{}

// EndBlockRequest is the input parameter to Chain.EndBlock
type EndBlockRequest struct{}

type EndBlockResponse struct {
	ValidatorsUpdates []chain.ValidatorUpdate
}

func (x *Executor) ExecuteEnvelope(block *Block, envelope *protocol.Envelope) (*protocol.TransactionStatus, error) {
	// Load the transaction using the block batch
	transaction, err := x.LoadTransaction(block.Batch, envelope)
	if err != nil {
		return nil, err
	}

	// Process signatures
	var remote []protocol.Signature
	{
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		for _, signature := range envelope.Signatures {
			s, err := x.ProcessSignature(batch, transaction, signature)
			if err != nil {
				return nil, err
			}

			block.State.MergeSignature(s)
			if s.Remote {
				remote = append(remote, signature)
			}
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}
	}

	// Process remote signatures
	txnState := new(chain.ProcessTransactionState)
	if len(remote) > 0 {
		fwdTxn, err := x.ProcessRemoteSignatures(block, transaction, remote)
		if err != nil {
			return nil, err
		}
		txnState.DidProduceTxn(transaction.Header.Principal, fwdTxn)
	}

	var status *protocol.TransactionStatus
	if len(remote) == len(envelope.Signatures) {
		// All signatures are remote
		status = &protocol.TransactionStatus{Remote: true}

	} else {
		// Process the transaction
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		var state *chain.ProcessTransactionState
		status, state, err = x.ProcessTransaction(batch, transaction)
		if err != nil {
			return nil, err
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}

		txnState.Merge(state)

		if !envelope.Type().IsInternal() && envelope.Type() != protocol.TransactionTypeSyntheticAnchor {
			x.Logger.Info("Transaction delivered",
				"module", "simulator",
				"block", block.Index,
				"type", envelope.Type(),
				"pending", status.Pending,
				"delivered", status.Delivered,
				"remote", status.Remote,
				"txn-hash", logging.AsHex(envelope.GetTxHash()).Slice(0, 4),
				"env-hash", logging.AsHex(envelope.EnvHash()).Slice(0, 4),
				"code", status.Code,
				"message", status.Message,
				"principal", envelope.Transaction.Header.Principal)
		}
	}

	block.State.MergeTransaction(txnState)

	// Process synthetic transactions generated by the validator
	{
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		err = x.ProduceSynthetic(batch, transaction, txnState.ProducedTxns)
		if err != nil {
			return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}
	}

	// Process additional transactions
	for _, envelope := range txnState.AdditionalTransactions {
		// Discard the status of additional transactions
		_, err := x.ExecuteEnvelope(block, envelope)
		if err != nil {
			return nil, err
		}
	}

	return status, nil
}
