package block

import (
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/internal/chain"
	"gitlab.com/accumulatenetwork/accumulate/internal/database"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type Block struct {
	BlockMeta
	State  BlockState
	Anchor *protocol.SyntheticAnchor
	Batch  *database.Batch
}

type Delivery struct {
	parent      *Delivery
	Signatures  []protocol.Signature
	Transaction *protocol.Transaction
	Remote      []protocol.KeySignature
	State       chain.ProcessTransactionState
}

// IsForwarded returns true if the transaction was delivered within a
// SyntheticForwardedTransaction.
func (d *Delivery) IsForwarded() bool {
	if d.parent == nil {
		return false
	}
	return d.parent.Transaction.Body.Type() == protocol.TransactionTypeSyntheticForwardTransaction
}

func (d *Delivery) prepare(block *Block, envelope *protocol.Envelope) (*Delivery, error) {
	// Load the transaction using the block batch
	transaction, err := loadTransaction(block.Batch, envelope)
	if err != nil {
		return nil, err
	}

	e := new(Delivery)
	e.parent = d
	e.Signatures = envelope.Signatures
	e.Transaction = transaction
	return e, nil
}

func PrepareDelivery(block *Block, envelope *protocol.Envelope) (*Delivery, error) {
	return (*Delivery)(nil).prepare(block, envelope)
}

func (x *Executor) ExecuteEnvelope(block *Block, delivery *Delivery) (*protocol.TransactionStatus, error) {
	// Process signatures
	var err error
	{
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		for _, signature := range delivery.Signatures {
			s, err := x.ProcessSignature(batch, delivery, signature)
			if err != nil {
				return nil, err
			}
			block.State.MergeSignature(s)

			if !s.Remote {
				continue
			}

			keySig, ok := signature.(protocol.KeySignature)
			if !ok {
				// This should never happen
				return nil, fmt.Errorf("unexpected remote signature that is not a key signature: %T", signature)
			}

			if s.Remote {
				delivery.Remote = append(delivery.Remote, keySig)
			}
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}
	}

	// Process remote signatures
	if len(delivery.Remote) > 0 {
		fwdTxn, err := x.ProcessRemoteSignatures(block, delivery.Transaction, delivery.Remote)
		if err != nil {
			return nil, err
		}
		delivery.State.DidProduceTxn(delivery.Transaction.Header.Principal, fwdTxn)
	}

	var status *protocol.TransactionStatus
	if len(delivery.Remote) == len(delivery.Signatures) {
		// All signatures are remote
		status = &protocol.TransactionStatus{Remote: true}

	} else {
		// Process the transaction
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		var state *chain.ProcessTransactionState
		status, state, err = x.ProcessTransaction(batch, delivery.Transaction)
		if err != nil {
			return nil, err
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}

		delivery.State.Merge(state)

		if !delivery.Transaction.Type().IsInternal() && delivery.Transaction.Type() != protocol.TransactionTypeSyntheticAnchor {
			kv := []interface{}{
				"block", block.Index,
				"type", delivery.Transaction.Type(),
				"pending", status.Pending,
				"delivered", status.Delivered,
				"remote", status.Remote,
				"txn-hash", logging.AsHex(delivery.Transaction.GetHash()).Slice(0, 4),
				"principal", delivery.Transaction.Header.Principal,
			}
			if status.Code != 0 {
				kv = append(kv,
					"code", status.Code,
					"error", status.Message,
				)
				x.Logger.Info("Transaction failed", kv...)
			} else {
				x.Logger.Debug("Transaction succeeded", kv...)
			}
		}
	}

	block.State.MergeTransaction(&delivery.State)

	// Process synthetic transactions generated by the validator
	{
		batch := block.Batch.Begin(true)
		defer batch.Discard()

		err = x.ProduceSynthetic(batch, delivery.Transaction, delivery.State.ProducedTxns)
		if err != nil {
			return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
		}

		err = batch.Commit()
		if err != nil {
			return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
		}
	}

	// Process additional transactions
	for _, envelope := range delivery.State.AdditionalTransactions {
		delivery, err := delivery.prepare(block, envelope)
		if err != nil {
			return nil, err
		}

		// Discard the status of additional transactions
		_, err = x.ExecuteEnvelope(block, delivery)
		if err != nil {
			return nil, err
		}
	}

	return status, nil
}
