package chain

import (
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

// CheckTx implements ./abci.Chain
func (m *Executor) CheckTx(envelope *protocol.Envelope) (protocol.TransactionResult, *protocol.Error) {
	batch := m.DB.Begin(false)
	defer batch.Discard()

	result, err := m.ValidateEnvelope(batch, envelope)
	if err != nil {
		return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
	}
	if result == nil {
		result = new(protocol.EmptyResult)
	}

	return result, nil
}

// DeliverTx implements ./abci.Chain
func (m *Executor) DeliverTx(envelope *protocol.Envelope) (result protocol.TransactionResult, retErr *protocol.Error) {
	// if txt.IsInternal() && tx.Transaction.Nonce != uint64(m.blockIndex) {
	// 	err := fmt.Errorf("nonce does not match block index, want %d, got %d", m.blockIndex, tx.Transaction.Nonce)
	// 	return nil, m.recordTransactionError(tx, nil, nil, &chainId, tx.GetTxHash(), &protocol.Error{Code: protocol.CodeInvalidTxnError, Message: err})
	// }

	if envelope.Type() == protocol.TransactionTypeSyntheticCreateChain {
		print("")
	}

	// Process signatures
	//   Start a batch
	batch := m.blockBatch.Begin()
	defer batch.Discard()

	//   Load the signature
	transaction, err := LoadTransaction(batch, envelope)
	if err != nil {
		return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
	}

	//   Process each signature
	for _, signature := range envelope.Signatures {
		err = m.ProcessSignature(batch, transaction, signature)
		if err != nil {
			return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
		}
	}

	//   Commit changes
	err = batch.Commit()
	if err != nil {
		return nil, protocol.Errorf(protocol.ErrorCodeUnknownError, "commit batch: %w", err)
	}

	// Process the transaction
	//   Start a batch, always commit
	batch = m.blockBatch.Begin()
	defer func() {
		err = batch.Commit()
		if err != nil {
			// If we can't commit, something is seriously broken
			panic(fmt.Errorf("commit batch: %w", err))
		}
	}()

	//   Load the signature (from the new batch)
	transaction, err = LoadTransaction(batch, envelope)
	if err != nil {
		return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
	}

	//   Process the transaction
	result, produced, err := m.ProcessTransaction(batch, transaction)
	if err != nil {
		return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
	}

	//   Process synthetic transactions generated by the validator
	err = m.ProduceSynthetic(batch, transaction, produced)
	if err != nil {
		return nil, protocol.NewError(protocol.ErrorCodeUnknownError, err)
	}

	if result == nil {
		return new(protocol.EmptyResult), nil
	}
	return result, nil
}

func (m *Executor) processInternalDataTransaction(internalAccountPath string, wd *protocol.WriteData) error {
	dataAccountUrl := m.Network.NodeUrl(internalAccountPath)

	if wd == nil {
		return fmt.Errorf("no internal data transaction provided")
	}

	var signer protocol.SignerAccount
	signerUrl := m.Network.ValidatorPage(0)
	err := m.blockBatch.Account(signerUrl).GetStateAs(&signer)
	if err != nil {
		return err
	}

	txn := new(protocol.Transaction)
	txn.Header.Principal = m.Network.NodeUrl()
	txn.Body = wd
	txn.Header.Initiator = signerUrl.AccountID32()

	sw := protocol.SegWitDataEntry{}
	sw.Cause = *(*[32]byte)(txn.GetHash())
	sw.EntryHash = *(*[32]byte)(wd.Entry.Hash())
	sw.EntryUrl = txn.Header.Principal
	txn.Body = &sw

	st := NewStateManager(m.blockBatch.Begin, m.Network.NodeUrl(), signerUrl, signer, nil, txn)
	defer st.Discard()
	st.logger.L = m.logger

	var da *protocol.DataAccount
	va := m.blockBatch.Account(dataAccountUrl)
	err = va.GetStateAs(&da)
	if err != nil {
		return err
	}

	st.UpdateData(da, wd.Entry.Hash(), &wd.Entry)

	err = m.blockBatch.Transaction(txn.GetHash()).Put(
		&protocol.Envelope{Transaction: txn},
		&protocol.TransactionStatus{Delivered: true},
		[]protocol.Signature{&protocol.InternalSignature{Network: signerUrl}})
	if err != nil {
		return err
	}

	err = st.Commit()
	return err
}
