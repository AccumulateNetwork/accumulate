// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package model

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

//lint:file-ignore S1008,U1000 generated code

import (
	"encoding/hex"

	"gitlab.com/accumulatenetwork/accumulate/internal/database/record"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
)

type BPT struct {
	logger logging.OptionalLogger
	store  record.Store
	key    record.Key
	label  string

	state record.Value[*RootState]
	block map[bptblockKey]record.Value[[]byte]
}

type bptblockKey struct {
	Key [32]byte
}

func keyForBPTBlock(key [32]byte) bptblockKey {
	return bptblockKey{key}
}

func (c *BPT) State() record.Value[*RootState] {
	return getOrCreateField(&c.state, func() record.Value[*RootState] {
		return record.NewValue(c.logger.L, c.store, c.key.Append("Root"), c.label+" "+"state", false, record.Struct[RootState]())
	})
}

func (c *BPT) Block(key [32]byte) record.Value[[]byte] {
	return getOrCreateMap(&c.block, keyForBPTBlock(key), func() record.Value[[]byte] {
		return record.NewValue(c.logger.L, c.store, c.key.Append(key), c.label+" "+"block"+" "+hex.EncodeToString(key[:]), false, record.Wrapped(record.RawWrapper))
	})
}

func (c *BPT) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.state) {
		return true
	}
	for _, v := range c.block {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *BPT) WalkChanges(fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	var err error
	walkChanges(&err, c.state, fn)
	for _, v := range c.block {
		walkChanges(&err, v, fn)
	}
	return err
}

func (c *BPT) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.state)
	for _, v := range c.block {
		commitField(&err, v)
	}

	return err
}

func getOrCreateField[T any](ptr *T, create func() T) T {
	var z T
	if any(*ptr) != any(z) {
		return *ptr
	}

	*ptr = create()
	return *ptr
}

func getOrCreateMap[T any, K comparable](ptr *map[K]T, key K, create func() T) T {
	if *ptr == nil {
		*ptr = map[K]T{}
	}

	if v, ok := (*ptr)[key]; ok {
		return v
	}

	v := create()
	(*ptr)[key] = v
	return v
}

func commitField[T record.Record](lastErr *error, field T) {
	var z T
	if *lastErr != nil || any(field) == any(z) {
		return
	}

	*lastErr = field.Commit()
}

func fieldIsDirty[T record.Record](field T) bool {
	var z T
	return any(field) != any(z) && field.IsDirty()
}

func walkChanges[T record.Record](lastErr *error, field T, fn record.WalkFunc) {
	var z T
	if *lastErr != nil || any(field) == any(z) {
		return
	}

	*lastErr = field.WalkChanges(fn)
}
