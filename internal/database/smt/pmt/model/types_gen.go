// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package model

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

type RootState struct {
	RootHash  [32]byte `json:"rootHash,omitempty" form:"rootHash" query:"rootHash" validate:"required"`
	MaxHeight uint64   `json:"maxHeight,omitempty" form:"maxHeight" query:"maxHeight" validate:"required"`
	Power     uint64   `json:"power,omitempty" form:"power" query:"power" validate:"required"`
	Mask      uint64   `json:"mask,omitempty" form:"mask" query:"mask" validate:"required"`
}

func (v *RootState) Copy() *RootState {
	u := new(RootState)

	u.RootHash = v.RootHash
	u.MaxHeight = v.MaxHeight
	u.Power = v.Power
	u.Mask = v.Mask

	return u
}

func (v *RootState) CopyAsInterface() interface{} { return v.Copy() }

func (v *RootState) Equal(u *RootState) bool {
	if !(v.RootHash == u.RootHash) {
		return false
	}
	if !(v.MaxHeight == u.MaxHeight) {
		return false
	}
	if !(v.Power == u.Power) {
		return false
	}
	if !(v.Mask == u.Mask) {
		return false
	}

	return true
}

func (v *RootState) MarshalJSON() ([]byte, error) {
	u := struct {
		RootHash  string `json:"rootHash,omitempty"`
		MaxHeight uint64 `json:"maxHeight,omitempty"`
		Power     uint64 `json:"power,omitempty"`
		Mask      uint64 `json:"mask,omitempty"`
	}{}
	if !(v.RootHash == ([32]byte{})) {
		u.RootHash = encoding.ChainToJSON(v.RootHash)
	}
	if !(v.MaxHeight == 0) {
		u.MaxHeight = v.MaxHeight
	}
	if !(v.Power == 0) {
		u.Power = v.Power
	}
	if !(v.Mask == 0) {
		u.Mask = v.Mask
	}
	return json.Marshal(&u)
}

func (v *RootState) UnmarshalJSON(data []byte) error {
	u := struct {
		RootHash  string `json:"rootHash,omitempty"`
		MaxHeight uint64 `json:"maxHeight,omitempty"`
		Power     uint64 `json:"power,omitempty"`
		Mask      uint64 `json:"mask,omitempty"`
	}{}
	u.RootHash = encoding.ChainToJSON(v.RootHash)
	u.MaxHeight = v.MaxHeight
	u.Power = v.Power
	u.Mask = v.Mask
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.RootHash); err != nil {
		return fmt.Errorf("error decoding RootHash: %w", err)
	} else {
		v.RootHash = x
	}
	v.MaxHeight = u.MaxHeight
	v.Power = u.Power
	v.Mask = u.Mask
	return nil
}
