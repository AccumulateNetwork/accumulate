// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package bpt

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

type branch struct {
	bpt    *BPT
	parent *branch
	status branchStatus
	Height uint64   `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Key    [32]byte `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Hash   [32]byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	Left   node
	Right  node
}

type emptyNode struct {
	parent *branch
}

type leaf struct {
	Key    [32]byte `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Hash   [32]byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	parent *branch
}

type parameters struct {
	RootHash  [32]byte `json:"rootHash,omitempty" form:"rootHash" query:"rootHash" validate:"required"`
	MaxHeight uint64   `json:"maxHeight,omitempty" form:"maxHeight" query:"maxHeight" validate:"required"`
	Power     uint64   `json:"power,omitempty" form:"power" query:"power" validate:"required"`
	Mask      uint64   `json:"mask,omitempty" form:"mask" query:"mask" validate:"required"`
}

func (*branch) Type() nodeType { return nodeTypeBranch }

func (*emptyNode) Type() nodeType { return nodeTypeEmpty }

func (*leaf) Type() nodeType { return nodeTypeLeaf }

func (v *branch) Copy() *branch {
	u := new(branch)

	u.Height = v.Height
	u.Key = v.Key
	u.Hash = v.Hash

	return u
}

func (v *branch) CopyAsInterface() interface{} { return v.Copy() }

func (v *emptyNode) Copy() *emptyNode {
	u := new(emptyNode)

	return u
}

func (v *emptyNode) CopyAsInterface() interface{} { return v.Copy() }

func (v *leaf) Copy() *leaf {
	u := new(leaf)

	u.Key = v.Key
	u.Hash = v.Hash

	return u
}

func (v *leaf) CopyAsInterface() interface{} { return v.Copy() }

func (v *parameters) Copy() *parameters {
	u := new(parameters)

	u.RootHash = v.RootHash
	u.MaxHeight = v.MaxHeight
	u.Power = v.Power
	u.Mask = v.Mask

	return u
}

func (v *parameters) CopyAsInterface() interface{} { return v.Copy() }

func (v *branch) Equal(u *branch) bool {
	if !(v.Height == u.Height) {
		return false
	}
	if !(v.Key == u.Key) {
		return false
	}
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *emptyNode) Equal(u *emptyNode) bool {

	return true
}

func (v *leaf) Equal(u *leaf) bool {
	if !(v.Key == u.Key) {
		return false
	}
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *parameters) Equal(u *parameters) bool {
	if !(v.RootHash == u.RootHash) {
		return false
	}
	if !(v.MaxHeight == u.MaxHeight) {
		return false
	}
	if !(v.Power == u.Power) {
		return false
	}
	if !(v.Mask == u.Mask) {
		return false
	}

	return true
}

func (v *branch) MarshalJSON() ([]byte, error) {
	u := struct {
		Type   nodeType `json:"type"`
		Height uint64   `json:"height,omitempty"`
		Key    string   `json:"key,omitempty"`
		Hash   string   `json:"hash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Height == 0) {
		u.Height = v.Height
	}
	if !(v.Key == ([32]byte{})) {
		u.Key = encoding.ChainToJSON(v.Key)
	}
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(v.Hash)
	}
	return json.Marshal(&u)
}

func (v *emptyNode) MarshalJSON() ([]byte, error) {
	u := struct {
		Type nodeType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *leaf) MarshalJSON() ([]byte, error) {
	u := struct {
		Type nodeType `json:"type"`
		Key  string   `json:"key,omitempty"`
		Hash string   `json:"hash,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.Key == ([32]byte{})) {
		u.Key = encoding.ChainToJSON(v.Key)
	}
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(v.Hash)
	}
	return json.Marshal(&u)
}

func (v *parameters) MarshalJSON() ([]byte, error) {
	u := struct {
		RootHash  string `json:"rootHash,omitempty"`
		MaxHeight uint64 `json:"maxHeight,omitempty"`
		Power     uint64 `json:"power,omitempty"`
		Mask      uint64 `json:"mask,omitempty"`
	}{}
	if !(v.RootHash == ([32]byte{})) {
		u.RootHash = encoding.ChainToJSON(v.RootHash)
	}
	if !(v.MaxHeight == 0) {
		u.MaxHeight = v.MaxHeight
	}
	if !(v.Power == 0) {
		u.Power = v.Power
	}
	if !(v.Mask == 0) {
		u.Mask = v.Mask
	}
	return json.Marshal(&u)
}

func (v *branch) UnmarshalJSON(data []byte) error {
	u := struct {
		Type   nodeType `json:"type"`
		Height uint64   `json:"height,omitempty"`
		Key    string   `json:"key,omitempty"`
		Hash   string   `json:"hash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Height = v.Height
	u.Key = encoding.ChainToJSON(v.Key)
	u.Hash = encoding.ChainToJSON(v.Hash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Height = u.Height
	if x, err := encoding.ChainFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	return nil
}

func (v *emptyNode) UnmarshalJSON(data []byte) error {
	u := struct {
		Type nodeType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *leaf) UnmarshalJSON(data []byte) error {
	u := struct {
		Type nodeType `json:"type"`
		Key  string   `json:"key,omitempty"`
		Hash string   `json:"hash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = encoding.ChainToJSON(v.Key)
	u.Hash = encoding.ChainToJSON(v.Hash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	return nil
}

func (v *parameters) UnmarshalJSON(data []byte) error {
	u := struct {
		RootHash  string `json:"rootHash,omitempty"`
		MaxHeight uint64 `json:"maxHeight,omitempty"`
		Power     uint64 `json:"power,omitempty"`
		Mask      uint64 `json:"mask,omitempty"`
	}{}
	u.RootHash = encoding.ChainToJSON(v.RootHash)
	u.MaxHeight = v.MaxHeight
	u.Power = v.Power
	u.Mask = v.Mask
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.RootHash); err != nil {
		return fmt.Errorf("error decoding RootHash: %w", err)
	} else {
		v.RootHash = x
	}
	v.MaxHeight = u.MaxHeight
	v.Power = u.Power
	v.Mask = u.Mask
	return nil
}
