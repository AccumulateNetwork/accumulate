// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package bpt2

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

type NilEntry struct {
	parent *Node
}

type NotLoaded struct {
}

type RootState struct {
	RootHash  [32]byte `json:"rootHash,omitempty" form:"rootHash" query:"rootHash" validate:"required"`
	MaxHeight uint64   `json:"maxHeight,omitempty" form:"maxHeight" query:"maxHeight" validate:"required"`
	Power     uint64   `json:"power,omitempty" form:"power" query:"power" validate:"required"`
	Mask      uint64   `json:"mask,omitempty" form:"mask" query:"mask" validate:"required"`
}

type Value struct {
	Key    [32]byte `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Hash   [32]byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	parent *Node
}

func (*NilEntry) Type() EntryType { return EntryTypeNil }

func (*NotLoaded) Type() EntryType { return EntryTypeNotLoaded }

func (*Value) Type() EntryType { return EntryTypeValue }

func (v *NilEntry) Copy() *NilEntry {
	u := new(NilEntry)

	return u
}

func (v *NilEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *NotLoaded) Copy() *NotLoaded {
	u := new(NotLoaded)

	return u
}

func (v *NotLoaded) CopyAsInterface() interface{} { return v.Copy() }

func (v *RootState) Copy() *RootState {
	u := new(RootState)

	u.RootHash = v.RootHash
	u.MaxHeight = v.MaxHeight
	u.Power = v.Power
	u.Mask = v.Mask

	return u
}

func (v *RootState) CopyAsInterface() interface{} { return v.Copy() }

func (v *Value) Copy() *Value {
	u := new(Value)

	u.Key = v.Key
	u.Hash = v.Hash

	return u
}

func (v *Value) CopyAsInterface() interface{} { return v.Copy() }

func (v *NilEntry) Equal(u *NilEntry) bool {

	return true
}

func (v *NotLoaded) Equal(u *NotLoaded) bool {

	return true
}

func (v *RootState) Equal(u *RootState) bool {
	if !(v.RootHash == u.RootHash) {
		return false
	}
	if !(v.MaxHeight == u.MaxHeight) {
		return false
	}
	if !(v.Power == u.Power) {
		return false
	}
	if !(v.Mask == u.Mask) {
		return false
	}

	return true
}

func (v *Value) Equal(u *Value) bool {
	if !(v.Key == u.Key) {
		return false
	}
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *NilEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type EntryType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *NotLoaded) MarshalJSON() ([]byte, error) {
	u := struct {
		Type EntryType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *RootState) MarshalJSON() ([]byte, error) {
	u := struct {
		RootHash  string `json:"rootHash,omitempty"`
		MaxHeight uint64 `json:"maxHeight,omitempty"`
		Power     uint64 `json:"power,omitempty"`
		Mask      uint64 `json:"mask,omitempty"`
	}{}
	u.RootHash = encoding.ChainToJSON(v.RootHash)
	u.MaxHeight = v.MaxHeight
	u.Power = v.Power
	u.Mask = v.Mask
	return json.Marshal(&u)
}

func (v *Value) MarshalJSON() ([]byte, error) {
	u := struct {
		Type EntryType `json:"type"`
		Key  string    `json:"key,omitempty"`
		Hash string    `json:"hash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = encoding.ChainToJSON(v.Key)
	u.Hash = encoding.ChainToJSON(v.Hash)
	return json.Marshal(&u)
}

func (v *NilEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type EntryType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *NotLoaded) UnmarshalJSON(data []byte) error {
	u := struct {
		Type EntryType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}

func (v *RootState) UnmarshalJSON(data []byte) error {
	u := struct {
		RootHash  string `json:"rootHash,omitempty"`
		MaxHeight uint64 `json:"maxHeight,omitempty"`
		Power     uint64 `json:"power,omitempty"`
		Mask      uint64 `json:"mask,omitempty"`
	}{}
	u.RootHash = encoding.ChainToJSON(v.RootHash)
	u.MaxHeight = v.MaxHeight
	u.Power = v.Power
	u.Mask = v.Mask
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.RootHash); err != nil {
		return fmt.Errorf("error decoding RootHash: %w", err)
	} else {
		v.RootHash = x
	}
	v.MaxHeight = u.MaxHeight
	v.Power = u.Power
	v.Mask = u.Mask
	return nil
}

func (v *Value) UnmarshalJSON(data []byte) error {
	u := struct {
		Type EntryType `json:"type"`
		Key  string    `json:"key,omitempty"`
		Hash string    `json:"hash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Key = encoding.ChainToJSON(v.Key)
	u.Hash = encoding.ChainToJSON(v.Hash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	return nil
}
