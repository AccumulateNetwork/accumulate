package database

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type SignatureEntry struct {
	fieldsSet     []bool
	Type          protocol.SignatureType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	KeyEntryIndex uint64                 `json:"keyEntryIndex,omitempty" form:"keyEntryIndex" query:"keyEntryIndex" validate:"required"`
	SignatureHash [32]byte               `json:"signatureHash,omitempty" form:"signatureHash" query:"signatureHash" validate:"required"`
	extraData     []byte
}

type TransactionChainEntry struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	// Chain is the name of the chain.
	Chain string `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	// ChainIndex is the index of the entry in the chain's index chain.
	ChainIndex uint64 `json:"chainIndex,omitempty" form:"chainIndex" query:"chainIndex" validate:"required"`
	// AnchorIndex is the index of the entry in the anchor chain's index chain.
	AnchorIndex uint64 `json:"anchorIndex,omitempty" form:"anchorIndex" query:"anchorIndex" validate:"required"`
	extraData   []byte
}

type chainState struct {
	fieldsSet []bool
	Name      string             `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Count     uint64             `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	Pending   [][]byte           `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	Entries   [][]byte           `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type fullAccountState struct {
	fieldsSet []bool
	// State is the main state of the account.
	State protocol.Account `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	// Chains is the state of the account's chains.
	Chains             []*chainState     `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
	Pending            []*url.TxID       `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	SyntheticForAnchor []*hashAndTxidSet `json:"syntheticForAnchor,omitempty" form:"syntheticForAnchor" query:"syntheticForAnchor" validate:"required"`
	// Transactions is the state of transactions related to the account.
	Transactions []*fullTransactionState `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	extraData    []byte
}

type fullTransactionState struct {
	fieldsSet  []bool
	Hash       [32]byte                    `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	Value      *protocol.Transaction       `json:"value,omitempty" form:"value" query:"value" validate:"required"`
	Status     *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	Produced   []*url.TxID                 `json:"produced,omitempty" form:"produced" query:"produced" validate:"required"`
	Signatures []*signerAndSigSet          `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	extraData  []byte
}

type hashAndTxidSet struct {
	fieldsSet []bool
	Anchor    [32]byte    `json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	Txids     []*url.TxID `json:"txids,omitempty" form:"txids" query:"txids" validate:"required"`
	extraData []byte
}

type signerAndSigSet struct {
	fieldsSet  []bool
	Signer     *url.URL          `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	Version    uint64            `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Signatures []*SignatureEntry `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	extraData  []byte
}

func (v *SignatureEntry) Copy() *SignatureEntry {
	u := new(SignatureEntry)

	u.Type = v.Type
	u.KeyEntryIndex = v.KeyEntryIndex
	u.SignatureHash = v.SignatureHash

	return u
}

func (v *SignatureEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionChainEntry) Copy() *TransactionChainEntry {
	u := new(TransactionChainEntry)

	if v.Account != nil {
		u.Account = (v.Account).Copy()
	}
	u.Chain = v.Chain
	u.ChainIndex = v.ChainIndex
	u.AnchorIndex = v.AnchorIndex

	return u
}

func (v *TransactionChainEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *chainState) Copy() *chainState {
	u := new(chainState)

	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.Pending = make([][]byte, len(v.Pending))
	for i, v := range v.Pending {
		u.Pending[i] = encoding.BytesCopy(v)
	}
	u.Entries = make([][]byte, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *chainState) CopyAsInterface() interface{} { return v.Copy() }

func (v *fullAccountState) Copy() *fullAccountState {
	u := new(fullAccountState)

	if v.State != nil {
		u.State = (v.State).CopyAsInterface().(protocol.Account)
	}
	u.Chains = make([]*chainState, len(v.Chains))
	for i, v := range v.Chains {
		if v != nil {
			u.Chains[i] = (v).Copy()
		}
	}
	u.Pending = make([]*url.TxID, len(v.Pending))
	for i, v := range v.Pending {
		if v != nil {
			u.Pending[i] = (v).Copy()
		}
	}
	u.SyntheticForAnchor = make([]*hashAndTxidSet, len(v.SyntheticForAnchor))
	for i, v := range v.SyntheticForAnchor {
		if v != nil {
			u.SyntheticForAnchor[i] = (v).Copy()
		}
	}
	u.Transactions = make([]*fullTransactionState, len(v.Transactions))
	for i, v := range v.Transactions {
		if v != nil {
			u.Transactions[i] = (v).Copy()
		}
	}

	return u
}

func (v *fullAccountState) CopyAsInterface() interface{} { return v.Copy() }

func (v *fullTransactionState) Copy() *fullTransactionState {
	u := new(fullTransactionState)

	u.Hash = v.Hash
	if v.Value != nil {
		u.Value = (v.Value).Copy()
	}
	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}
	u.Produced = make([]*url.TxID, len(v.Produced))
	for i, v := range v.Produced {
		if v != nil {
			u.Produced[i] = (v).Copy()
		}
	}
	u.Signatures = make([]*signerAndSigSet, len(v.Signatures))
	for i, v := range v.Signatures {
		if v != nil {
			u.Signatures[i] = (v).Copy()
		}
	}

	return u
}

func (v *fullTransactionState) CopyAsInterface() interface{} { return v.Copy() }

func (v *hashAndTxidSet) Copy() *hashAndTxidSet {
	u := new(hashAndTxidSet)

	u.Anchor = v.Anchor
	u.Txids = make([]*url.TxID, len(v.Txids))
	for i, v := range v.Txids {
		if v != nil {
			u.Txids[i] = (v).Copy()
		}
	}

	return u
}

func (v *hashAndTxidSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *signerAndSigSet) Copy() *signerAndSigSet {
	u := new(signerAndSigSet)

	if v.Signer != nil {
		u.Signer = (v.Signer).Copy()
	}
	u.Version = v.Version
	u.Signatures = make([]*SignatureEntry, len(v.Signatures))
	for i, v := range v.Signatures {
		if v != nil {
			u.Signatures[i] = (v).Copy()
		}
	}

	return u
}

func (v *signerAndSigSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureEntry) Equal(u *SignatureEntry) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.KeyEntryIndex == u.KeyEntryIndex) {
		return false
	}
	if !(v.SignatureHash == u.SignatureHash) {
		return false
	}

	return true
}

func (v *TransactionChainEntry) Equal(u *TransactionChainEntry) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}
	if !(v.ChainIndex == u.ChainIndex) {
		return false
	}
	if !(v.AnchorIndex == u.AnchorIndex) {
		return false
	}

	return true
}

func (v *chainState) Equal(u *chainState) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if len(v.Pending) != len(u.Pending) {
		return false
	}
	for i := range v.Pending {
		if !(bytes.Equal(v.Pending[i], u.Pending[i])) {
			return false
		}
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(bytes.Equal(v.Entries[i], u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *fullAccountState) Equal(u *fullAccountState) bool {
	if !(protocol.EqualAccount(v.State, u.State)) {
		return false
	}
	if len(v.Chains) != len(u.Chains) {
		return false
	}
	for i := range v.Chains {
		if !((v.Chains[i]).Equal(u.Chains[i])) {
			return false
		}
	}
	if len(v.Pending) != len(u.Pending) {
		return false
	}
	for i := range v.Pending {
		if !((v.Pending[i]).Equal(u.Pending[i])) {
			return false
		}
	}
	if len(v.SyntheticForAnchor) != len(u.SyntheticForAnchor) {
		return false
	}
	for i := range v.SyntheticForAnchor {
		if !((v.SyntheticForAnchor[i]).Equal(u.SyntheticForAnchor[i])) {
			return false
		}
	}
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((v.Transactions[i]).Equal(u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *fullTransactionState) Equal(u *fullTransactionState) bool {
	if !(v.Hash == u.Hash) {
		return false
	}
	switch {
	case v.Value == u.Value:
		// equal
	case v.Value == nil || u.Value == nil:
		return false
	case !((v.Value).Equal(u.Value)):
		return false
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}
	if len(v.Produced) != len(u.Produced) {
		return false
	}
	for i := range v.Produced {
		if !((v.Produced[i]).Equal(u.Produced[i])) {
			return false
		}
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !((v.Signatures[i]).Equal(u.Signatures[i])) {
			return false
		}
	}

	return true
}

func (v *hashAndTxidSet) Equal(u *hashAndTxidSet) bool {
	if !(v.Anchor == u.Anchor) {
		return false
	}
	if len(v.Txids) != len(u.Txids) {
		return false
	}
	for i := range v.Txids {
		if !((v.Txids[i]).Equal(u.Txids[i])) {
			return false
		}
	}

	return true
}

func (v *signerAndSigSet) Equal(u *signerAndSigSet) bool {
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !((v.Signatures[i]).Equal(u.Signatures[i])) {
			return false
		}
	}

	return true
}

var fieldNames_SignatureEntry = []string{
	1: "Type",
	2: "KeyEntryIndex",
	3: "SignatureHash",
}

func (v *SignatureEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	if !(v.KeyEntryIndex == 0) {
		writer.WriteUint(2, v.KeyEntryIndex)
	}
	if !(v.SignatureHash == ([32]byte{})) {
		writer.WriteHash(3, &v.SignatureHash)
	}

	_, _, err := writer.Reset(fieldNames_SignatureEntry)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *SignatureEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field KeyEntryIndex is missing")
	} else if v.KeyEntryIndex == 0 {
		errs = append(errs, "field KeyEntryIndex is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field SignatureHash is missing")
	} else if v.SignatureHash == ([32]byte{}) {
		errs = append(errs, "field SignatureHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionChainEntry = []string{
	1: "Account",
	2: "Chain",
	3: "ChainIndex",
	4: "AnchorIndex",
}

func (v *TransactionChainEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(2, v.Chain)
	}
	if !(v.ChainIndex == 0) {
		writer.WriteUint(3, v.ChainIndex)
	}
	if !(v.AnchorIndex == 0) {
		writer.WriteUint(4, v.AnchorIndex)
	}

	_, _, err := writer.Reset(fieldNames_TransactionChainEntry)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *TransactionChainEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ChainIndex is missing")
	} else if v.ChainIndex == 0 {
		errs = append(errs, "field ChainIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field AnchorIndex is missing")
	} else if v.AnchorIndex == 0 {
		errs = append(errs, "field AnchorIndex is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_chainState = []string{
	1: "Name",
	2: "Type",
	3: "Count",
	4: "Pending",
	5: "Entries",
}

func (v *chainState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.Count == 0) {
		writer.WriteUint(3, v.Count)
	}
	if !(len(v.Pending) == 0) {
		for _, v := range v.Pending {
			writer.WriteBytes(4, v)
		}
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteBytes(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_chainState)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *chainState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Pending is missing")
	} else if len(v.Pending) == 0 {
		errs = append(errs, "field Pending is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_fullAccountState = []string{
	1: "State",
	2: "Chains",
	3: "Pending",
	4: "SyntheticForAnchor",
	5: "Transactions",
}

func (v *fullAccountState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.State == nil) {
		writer.WriteValue(1, v.State.MarshalBinary)
	}
	if !(len(v.Chains) == 0) {
		for _, v := range v.Chains {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	if !(len(v.Pending) == 0) {
		for _, v := range v.Pending {
			writer.WriteTxid(3, v)
		}
	}
	if !(len(v.SyntheticForAnchor) == 0) {
		for _, v := range v.SyntheticForAnchor {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(5, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_fullAccountState)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *fullAccountState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field State is missing")
	} else if v.State == nil {
		errs = append(errs, "field State is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chains is missing")
	} else if len(v.Chains) == 0 {
		errs = append(errs, "field Chains is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Pending is missing")
	} else if len(v.Pending) == 0 {
		errs = append(errs, "field Pending is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SyntheticForAnchor is missing")
	} else if len(v.SyntheticForAnchor) == 0 {
		errs = append(errs, "field SyntheticForAnchor is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_fullTransactionState = []string{
	1: "Hash",
	2: "Value",
	3: "Status",
	4: "Produced",
	5: "Signatures",
}

func (v *fullTransactionState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(1, &v.Hash)
	}
	if !(v.Value == nil) {
		writer.WriteValue(2, v.Value.MarshalBinary)
	}
	if !(v.Status == nil) {
		writer.WriteValue(3, v.Status.MarshalBinary)
	}
	if !(len(v.Produced) == 0) {
		for _, v := range v.Produced {
			writer.WriteTxid(4, v)
		}
	}
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(5, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_fullTransactionState)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *fullTransactionState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Hash is missing")
	} else if v.Hash == ([32]byte{}) {
		errs = append(errs, "field Hash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Value is missing")
	} else if v.Value == nil {
		errs = append(errs, "field Value is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Produced is missing")
	} else if len(v.Produced) == 0 {
		errs = append(errs, "field Produced is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_hashAndTxidSet = []string{
	1: "Anchor",
	2: "Txids",
}

func (v *hashAndTxidSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Anchor == ([32]byte{})) {
		writer.WriteHash(1, &v.Anchor)
	}
	if !(len(v.Txids) == 0) {
		for _, v := range v.Txids {
			writer.WriteTxid(2, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_hashAndTxidSet)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *hashAndTxidSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Anchor is missing")
	} else if v.Anchor == ([32]byte{}) {
		errs = append(errs, "field Anchor is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Txids is missing")
	} else if len(v.Txids) == 0 {
		errs = append(errs, "field Txids is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_signerAndSigSet = []string{
	1: "Signer",
	2: "Version",
	3: "Signatures",
}

func (v *signerAndSigSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Signer == nil) {
		writer.WriteUrl(1, v.Signer)
	}
	if !(v.Version == 0) {
		writer.WriteUint(2, v.Version)
	}
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_signerAndSigSet)
	if err != nil {
		return nil, err
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), err
}

func (v *signerAndSigSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *SignatureEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.SignatureType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.KeyEntryIndex = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.SignatureHash = *x
	}

	seen, err := reader.Reset(fieldNames_SignatureEntry)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *TransactionChainEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionChainEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Chain = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.ChainIndex = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.AnchorIndex = x
	}

	seen, err := reader.Reset(fieldNames_TransactionChainEntry)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *chainState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *chainState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x := new(protocol.ChainType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Count = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.Pending = append(v.Pending, x)
		} else {
			break
		}
	}
	for {
		if x, ok := reader.ReadBytes(5); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_chainState)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *fullAccountState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *fullAccountState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.State = x
		}
		return err
	})
	for {
		if x := new(chainState); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Chains = append(v.Chains, x)
		} else {
			break
		}
	}
	for {
		if x, ok := reader.ReadTxid(3); ok {
			v.Pending = append(v.Pending, x)
		} else {
			break
		}
	}
	for {
		if x := new(hashAndTxidSet); reader.ReadValue(4, x.UnmarshalBinary) {
			v.SyntheticForAnchor = append(v.SyntheticForAnchor, x)
		} else {
			break
		}
	}
	for {
		if x := new(fullTransactionState); reader.ReadValue(5, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_fullAccountState)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *fullTransactionState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *fullTransactionState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.Hash = *x
	}
	if x := new(protocol.Transaction); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Value = x
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Status = x
	}
	for {
		if x, ok := reader.ReadTxid(4); ok {
			v.Produced = append(v.Produced, x)
		} else {
			break
		}
	}
	for {
		if x := new(signerAndSigSet); reader.ReadValue(5, x.UnmarshalBinary) {
			v.Signatures = append(v.Signatures, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_fullTransactionState)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *hashAndTxidSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *hashAndTxidSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.Anchor = *x
	}
	for {
		if x, ok := reader.ReadTxid(2); ok {
			v.Txids = append(v.Txids, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_hashAndTxidSet)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *signerAndSigSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *signerAndSigSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Version = x
	}
	for {
		if x := new(SignatureEntry); reader.ReadValue(3, x.UnmarshalBinary) {
			v.Signatures = append(v.Signatures, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_signerAndSigSet)
	if err != nil {
		return err
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	return err
}

func (v *SignatureEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          protocol.SignatureType `json:"type,omitempty"`
		KeyEntryIndex uint64                 `json:"keyEntryIndex,omitempty"`
		SignatureHash string                 `json:"signatureHash,omitempty"`
	}{}
	u.Type = v.Type
	u.KeyEntryIndex = v.KeyEntryIndex
	u.SignatureHash = encoding.ChainToJSON(v.SignatureHash)
	return json.Marshal(&u)
}

func (v *chainState) MarshalJSON() ([]byte, error) {
	u := struct {
		Name    string                     `json:"name,omitempty"`
		Type    protocol.ChainType         `json:"type,omitempty"`
		Count   uint64                     `json:"count,omitempty"`
		Pending encoding.JsonList[*string] `json:"pending,omitempty"`
		Entries encoding.JsonList[*string] `json:"entries,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.Pending = make(encoding.JsonList[*string], len(v.Pending))
	for i, x := range v.Pending {
		u.Pending[i] = encoding.BytesToJSON(x)
	}
	u.Entries = make(encoding.JsonList[*string], len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *fullAccountState) MarshalJSON() ([]byte, error) {
	u := struct {
		State              encoding.JsonUnmarshalWith[protocol.Account] `json:"state,omitempty"`
		Chains             encoding.JsonList[*chainState]               `json:"chains,omitempty"`
		Pending            encoding.JsonList[*url.TxID]                 `json:"pending,omitempty"`
		SyntheticForAnchor encoding.JsonList[*hashAndTxidSet]           `json:"syntheticForAnchor,omitempty"`
		Transactions       encoding.JsonList[*fullTransactionState]     `json:"transactions,omitempty"`
	}{}
	u.State = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.State, Func: protocol.UnmarshalAccountJSON}
	u.Chains = v.Chains
	u.Pending = v.Pending
	u.SyntheticForAnchor = v.SyntheticForAnchor
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *fullTransactionState) MarshalJSON() ([]byte, error) {
	u := struct {
		Hash       string                              `json:"hash,omitempty"`
		Value      *protocol.Transaction               `json:"value,omitempty"`
		Status     *protocol.TransactionStatus         `json:"status,omitempty"`
		Produced   encoding.JsonList[*url.TxID]        `json:"produced,omitempty"`
		Signatures encoding.JsonList[*signerAndSigSet] `json:"signatures,omitempty"`
	}{}
	u.Hash = encoding.ChainToJSON(v.Hash)
	u.Value = v.Value
	u.Status = v.Status
	u.Produced = v.Produced
	u.Signatures = v.Signatures
	return json.Marshal(&u)
}

func (v *hashAndTxidSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Anchor string                       `json:"anchor,omitempty"`
		Txids  encoding.JsonList[*url.TxID] `json:"txids,omitempty"`
	}{}
	u.Anchor = encoding.ChainToJSON(v.Anchor)
	u.Txids = v.Txids
	return json.Marshal(&u)
}

func (v *signerAndSigSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Signer     *url.URL                           `json:"signer,omitempty"`
		Version    uint64                             `json:"version,omitempty"`
		Signatures encoding.JsonList[*SignatureEntry] `json:"signatures,omitempty"`
	}{}
	u.Signer = v.Signer
	u.Version = v.Version
	u.Signatures = v.Signatures
	return json.Marshal(&u)
}

func (v *SignatureEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          protocol.SignatureType `json:"type,omitempty"`
		KeyEntryIndex uint64                 `json:"keyEntryIndex,omitempty"`
		SignatureHash string                 `json:"signatureHash,omitempty"`
	}{}
	u.Type = v.Type
	u.KeyEntryIndex = v.KeyEntryIndex
	u.SignatureHash = encoding.ChainToJSON(v.SignatureHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.KeyEntryIndex = u.KeyEntryIndex
	if x, err := encoding.ChainFromJSON(u.SignatureHash); err != nil {
		return fmt.Errorf("error decoding SignatureHash: %w", err)
	} else {
		v.SignatureHash = x
	}
	return nil
}

func (v *chainState) UnmarshalJSON(data []byte) error {
	u := struct {
		Name    string                     `json:"name,omitempty"`
		Type    protocol.ChainType         `json:"type,omitempty"`
		Count   uint64                     `json:"count,omitempty"`
		Pending encoding.JsonList[*string] `json:"pending,omitempty"`
		Entries encoding.JsonList[*string] `json:"entries,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.Pending = make(encoding.JsonList[*string], len(v.Pending))
	for i, x := range v.Pending {
		u.Pending[i] = encoding.BytesToJSON(x)
	}
	u.Entries = make(encoding.JsonList[*string], len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Name = u.Name
	v.Type = u.Type
	v.Count = u.Count
	v.Pending = make([][]byte, len(u.Pending))
	for i, x := range u.Pending {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Pending: %w", err)
		} else {
			v.Pending[i] = x
		}
	}
	v.Entries = make([][]byte, len(u.Entries))
	for i, x := range u.Entries {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Entries: %w", err)
		} else {
			v.Entries[i] = x
		}
	}
	return nil
}

func (v *fullAccountState) UnmarshalJSON(data []byte) error {
	u := struct {
		State              encoding.JsonUnmarshalWith[protocol.Account] `json:"state,omitempty"`
		Chains             encoding.JsonList[*chainState]               `json:"chains,omitempty"`
		Pending            encoding.JsonList[*url.TxID]                 `json:"pending,omitempty"`
		SyntheticForAnchor encoding.JsonList[*hashAndTxidSet]           `json:"syntheticForAnchor,omitempty"`
		Transactions       encoding.JsonList[*fullTransactionState]     `json:"transactions,omitempty"`
	}{}
	u.State = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.State, Func: protocol.UnmarshalAccountJSON}
	u.Chains = v.Chains
	u.Pending = v.Pending
	u.SyntheticForAnchor = v.SyntheticForAnchor
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.State = u.State.Value

	v.Chains = u.Chains
	v.Pending = u.Pending
	v.SyntheticForAnchor = u.SyntheticForAnchor
	v.Transactions = u.Transactions
	return nil
}

func (v *fullTransactionState) UnmarshalJSON(data []byte) error {
	u := struct {
		Hash       string                              `json:"hash,omitempty"`
		Value      *protocol.Transaction               `json:"value,omitempty"`
		Status     *protocol.TransactionStatus         `json:"status,omitempty"`
		Produced   encoding.JsonList[*url.TxID]        `json:"produced,omitempty"`
		Signatures encoding.JsonList[*signerAndSigSet] `json:"signatures,omitempty"`
	}{}
	u.Hash = encoding.ChainToJSON(v.Hash)
	u.Value = v.Value
	u.Status = v.Status
	u.Produced = v.Produced
	u.Signatures = v.Signatures
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
	v.Value = u.Value
	v.Status = u.Status
	v.Produced = u.Produced
	v.Signatures = u.Signatures
	return nil
}

func (v *hashAndTxidSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Anchor string                       `json:"anchor,omitempty"`
		Txids  encoding.JsonList[*url.TxID] `json:"txids,omitempty"`
	}{}
	u.Anchor = encoding.ChainToJSON(v.Anchor)
	u.Txids = v.Txids
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Anchor = x
	}
	v.Txids = u.Txids
	return nil
}

func (v *signerAndSigSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Signer     *url.URL                           `json:"signer,omitempty"`
		Version    uint64                             `json:"version,omitempty"`
		Signatures encoding.JsonList[*SignatureEntry] `json:"signatures,omitempty"`
	}{}
	u.Signer = v.Signer
	u.Version = v.Version
	u.Signatures = v.Signatures
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Signer = u.Signer
	v.Version = u.Version
	v.Signatures = u.Signatures
	return nil
}
