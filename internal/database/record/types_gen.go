// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package record

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

type ChainHead struct {
	Count    int64    `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	Pending  [][]byte `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	HashList [][]byte `json:"hashList,omitempty" form:"hashList" query:"hashList" validate:"required"`
}

func (v *ChainHead) Copy() *ChainHead {
	u := new(ChainHead)

	u.Count = v.Count
	u.Pending = make([][]byte, len(v.Pending))
	for i, v := range v.Pending {
		u.Pending[i] = encoding.BytesCopy(v)
	}
	u.HashList = make([][]byte, len(v.HashList))
	for i, v := range v.HashList {
		u.HashList[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *ChainHead) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainHead) Equal(u *ChainHead) bool {
	if !(v.Count == u.Count) {
		return false
	}
	if len(v.Pending) != len(u.Pending) {
		return false
	}
	for i := range v.Pending {
		if !(bytes.Equal(v.Pending[i], u.Pending[i])) {
			return false
		}
	}
	if len(v.HashList) != len(u.HashList) {
		return false
	}
	for i := range v.HashList {
		if !(bytes.Equal(v.HashList[i], u.HashList[i])) {
			return false
		}
	}

	return true
}

func (v *ChainHead) MarshalJSON() ([]byte, error) {
	u := struct {
		Count    int64                      `json:"count,omitempty"`
		Pending  encoding.JsonList[*string] `json:"pending,omitempty"`
		HashList encoding.JsonList[*string] `json:"hashList,omitempty"`
	}{}
	u.Count = v.Count
	u.Pending = make(encoding.JsonList[*string], len(v.Pending))
	for i, x := range v.Pending {
		u.Pending[i] = encoding.BytesToJSON(x)
	}
	u.HashList = make(encoding.JsonList[*string], len(v.HashList))
	for i, x := range v.HashList {
		u.HashList[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ChainHead) UnmarshalJSON(data []byte) error {
	u := struct {
		Count    int64                      `json:"count,omitempty"`
		Pending  encoding.JsonList[*string] `json:"pending,omitempty"`
		HashList encoding.JsonList[*string] `json:"hashList,omitempty"`
	}{}
	u.Count = v.Count
	u.Pending = make(encoding.JsonList[*string], len(v.Pending))
	for i, x := range v.Pending {
		u.Pending[i] = encoding.BytesToJSON(x)
	}
	u.HashList = make(encoding.JsonList[*string], len(v.HashList))
	for i, x := range v.HashList {
		u.HashList[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Count = u.Count
	v.Pending = make([][]byte, len(u.Pending))
	for i, x := range u.Pending {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Pending: %w", err)
		} else {
			v.Pending[i] = x
		}
	}
	v.HashList = make([][]byte, len(u.HashList))
	for i, x := range u.HashList {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding HashList: %w", err)
		} else {
			v.HashList[i] = x
		}
	}
	return nil
}
