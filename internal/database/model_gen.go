// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package database

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

//lint:file-ignore S1008,U1000 generated code

import (
	"encoding/hex"
	"strconv"

	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	record "gitlab.com/accumulatenetwork/accumulate/pkg/database"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/bpt"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/values"
	"gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/messaging"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type Batch struct {
	logger      logging.OptionalLogger
	store       record.Store
	done        bool
	writable    bool
	id          string
	nextChildId int64
	parent      *Batch
	observer    Observer

	bpt         *bpt.BPT
	account     map[accountKey]*Account
	message     map[messageKey]*Message
	transaction map[transactionKey]*Transaction
	systemData  map[systemDataKey]*SystemData
}

func (c *Batch) Key() *record.Key { return nil }

type accountKey struct {
	Url [32]byte
}

func keyForAccount(url *url.URL) accountKey {
	return accountKey{values.MapKeyUrl(url)}
}

type messageKey struct {
	Hash [32]byte
}

func keyForMessage(hash [32]byte) messageKey {
	return messageKey{hash}
}

type transactionKey struct {
	Hash [32]byte
}

func keyForTransaction(hash [32]byte) transactionKey {
	return transactionKey{hash}
}

type systemDataKey struct {
	Partition string
}

func keyForSystemData(partition string) systemDataKey {
	return systemDataKey{partition}
}

func (c *Batch) BPT() *bpt.BPT {
	return values.GetOrCreate(&c.bpt, func() *bpt.BPT {
		return newBPT(c, c.logger.L, c.store, (*record.Key)(nil).Append("BPT"), "bpt", "bpt")
	})
}

func (c *Batch) getAccount(url *url.URL) *Account {
	return values.GetOrCreateMap(&c.account, keyForAccount(url), func() *Account {
		v := new(Account)
		v.logger = c.logger
		v.store = c.store
		v.key = (*record.Key)(nil).Append("Account", url)
		v.parent = c
		v.label = "account" + " " + url.RawString()
		return v
	})
}

func (c *Batch) Message(hash [32]byte) *Message {
	return values.GetOrCreateMap(&c.message, keyForMessage(hash), func() *Message {
		v := new(Message)
		v.logger = c.logger
		v.store = c.store
		v.key = (*record.Key)(nil).Append("Message", hash)
		v.parent = c
		v.label = "message" + " " + hex.EncodeToString(hash[:])
		return v
	})
}

func (c *Batch) getTransaction(hash [32]byte) *Transaction {
	return values.GetOrCreateMap(&c.transaction, keyForTransaction(hash), func() *Transaction {
		v := new(Transaction)
		v.logger = c.logger
		v.store = c.store
		v.key = (*record.Key)(nil).Append("Transaction", hash)
		v.parent = c
		v.label = "transaction" + " " + hex.EncodeToString(hash[:])
		return v
	})
}

func (c *Batch) SystemData(partition string) *SystemData {
	return values.GetOrCreateMap(&c.systemData, keyForSystemData(partition), func() *SystemData {
		v := new(SystemData)
		v.logger = c.logger
		v.store = c.store
		v.key = (*record.Key)(nil).Append("SystemData", partition)
		v.parent = c
		v.label = "system data" + " " + partition
		return v
	})
}

func (c *Batch) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for batch")
	}

	switch key.Get(0) {
	case "BPT":
		return c.BPT(), key.SliceI(1), nil
	case "Account":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for batch")
		}
		url, okUrl := key.Get(1).(*url.URL)
		if !okUrl {
			return nil, nil, errors.InternalError.With("bad key for batch")
		}
		v := c.getAccount(url)
		return v, key.SliceI(2), nil
	case "Message":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for batch")
		}
		hash, okHash := key.Get(1).([32]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for batch")
		}
		v := c.Message(hash)
		return v, key.SliceI(2), nil
	case "Transaction":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for batch")
		}
		hash, okHash := key.Get(1).([32]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for batch")
		}
		v := c.getTransaction(hash)
		return v, key.SliceI(2), nil
	case "SystemData":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for batch")
		}
		partition, okPartition := key.Get(1).(string)
		if !okPartition {
			return nil, nil, errors.InternalError.With("bad key for batch")
		}
		v := c.SystemData(partition)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for batch")
	}
}

func (c *Batch) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.bpt) {
		return true
	}
	for _, v := range c.account {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.message {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.systemData {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *Batch) dirtyChains() []*MerkleManager {
	if c == nil {
		return nil
	}

	var chains []*MerkleManager

	for _, v := range c.account {
		chains = append(chains, v.dirtyChains()...)
	}

	return chains
}

func (c *Batch) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.Walk(&err, c.bpt, opts, fn)
	for _, v := range c.account {
		values.Walk(&err, v, opts, fn)
	}
	for _, v := range c.message {
		values.Walk(&err, v, opts, fn)
	}
	for _, v := range c.transaction {
		values.Walk(&err, v, opts, fn)
	}
	for _, v := range c.systemData {
		values.Walk(&err, v, opts, fn)
	}
	return err
}

func (c *Batch) baseCommit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.bpt)
	for _, v := range c.account {
		values.Commit(&err, v)
	}
	for _, v := range c.message {
		values.Commit(&err, v)
	}
	for _, v := range c.transaction {
		values.Commit(&err, v)
	}
	for _, v := range c.systemData {
		values.Commit(&err, v)
	}

	return err
}

type Account struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	label  string
	parent *Batch

	url                    values.Value[*url.URL]
	main                   values.Value[protocol.Account]
	pending                values.Set[*url.TxID]
	syntheticForAnchor     map[accountSyntheticForAnchorKey]values.Set[*url.TxID]
	directory              values.Set[*url.URL]
	transaction            map[accountTransactionKey]*AccountTransaction
	mainChain              *Chain2
	scratchChain           *Chain2
	signatureChain         *Chain2
	rootChain              *Chain2
	anchorSequenceChain    *Chain2
	majorBlockChain        *Chain2
	syntheticSequenceChain map[accountSyntheticSequenceChainKey]*Chain2
	anchorChain            map[accountAnchorChainKey]*AccountAnchorChain
	chains                 values.Set[*protocol.ChainMetadata]
	syntheticAnchors       values.Set[[32]byte]
	data                   *AccountData
}

func (c *Account) Key() *record.Key { return c.key }

type accountSyntheticForAnchorKey struct {
	Anchor [32]byte
}

func keyForAccountSyntheticForAnchor(anchor [32]byte) accountSyntheticForAnchorKey {
	return accountSyntheticForAnchorKey{anchor}
}

type accountTransactionKey struct {
	Hash [32]byte
}

func keyForAccountTransaction(hash [32]byte) accountTransactionKey {
	return accountTransactionKey{hash}
}

type accountSyntheticSequenceChainKey struct {
	Partition string
}

func keyForAccountSyntheticSequenceChain(partition string) accountSyntheticSequenceChainKey {
	return accountSyntheticSequenceChainKey{partition}
}

type accountAnchorChainKey struct {
	Partition string
}

func keyForAccountAnchorChain(partition string) accountAnchorChainKey {
	return accountAnchorChainKey{partition}
}

func (c *Account) getUrl() values.Value[*url.URL] {
	return values.GetOrCreate(&c.url, func() values.Value[*url.URL] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Url"), c.label+" "+"url", false, values.Wrapped(values.UrlWrapper))
	})
}

func (c *Account) Main() values.Value[protocol.Account] {
	return values.GetOrCreate(&c.main, func() values.Value[protocol.Account] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Main"), c.label+" "+"main", false, values.Union(protocol.UnmarshalAccount))
	})
}

func (c *Account) Pending() values.Set[*url.TxID] {
	return values.GetOrCreate(&c.pending, func() values.Set[*url.TxID] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Pending"), c.label+" "+"pending", values.Wrapped(values.TxidWrapper), values.CompareTxid)
	})
}

func (c *Account) SyntheticForAnchor(anchor [32]byte) values.Set[*url.TxID] {
	return values.GetOrCreateMap(&c.syntheticForAnchor, keyForAccountSyntheticForAnchor(anchor), func() values.Set[*url.TxID] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("SyntheticForAnchor", anchor), c.label+" "+"synthetic for anchor"+" "+hex.EncodeToString(anchor[:]), values.Wrapped(values.TxidWrapper), values.CompareTxid)
	})
}

func (c *Account) Directory() values.Set[*url.URL] {
	return values.GetOrCreate(&c.directory, func() values.Set[*url.URL] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Directory"), c.label+" "+"directory", values.Wrapped(values.UrlWrapper), values.CompareUrl)
	})
}

func (c *Account) Transaction(hash [32]byte) *AccountTransaction {
	return values.GetOrCreateMap(&c.transaction, keyForAccountTransaction(hash), func() *AccountTransaction {
		v := new(AccountTransaction)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("Transaction", hash)
		v.parent = c
		v.label = c.label + " " + "transaction" + " " + hex.EncodeToString(hash[:])
		return v
	})
}

func (c *Account) MainChain() *Chain2 {
	return values.GetOrCreate(&c.mainChain, func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("MainChain"), "main", c.label+" "+"main chain")
	})
}

func (c *Account) ScratchChain() *Chain2 {
	return values.GetOrCreate(&c.scratchChain, func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("ScratchChain"), "scratch", c.label+" "+"scratch chain")
	})
}

func (c *Account) SignatureChain() *Chain2 {
	return values.GetOrCreate(&c.signatureChain, func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("SignatureChain"), "signature", c.label+" "+"signature chain")
	})
}

func (c *Account) RootChain() *Chain2 {
	return values.GetOrCreate(&c.rootChain, func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("RootChain"), "root", c.label+" "+"root chain")
	})
}

func (c *Account) AnchorSequenceChain() *Chain2 {
	return values.GetOrCreate(&c.anchorSequenceChain, func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("AnchorSequenceChain"), "anchor-sequence", c.label+" "+"anchor sequence chain")
	})
}

func (c *Account) MajorBlockChain() *Chain2 {
	return values.GetOrCreate(&c.majorBlockChain, func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("MajorBlockChain"), "major-block", c.label+" "+"major block chain")
	})
}

func (c *Account) getSyntheticSequenceChain(partition string) *Chain2 {
	return values.GetOrCreateMap(&c.syntheticSequenceChain, keyForAccountSyntheticSequenceChain(partition), func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("SyntheticSequenceChain", partition), "synthetic-sequence(%[4]v)", c.label+" "+"synthetic sequence chain"+" "+partition)
	})
}

func (c *Account) getAnchorChain(partition string) *AccountAnchorChain {
	return values.GetOrCreateMap(&c.anchorChain, keyForAccountAnchorChain(partition), func() *AccountAnchorChain {
		v := new(AccountAnchorChain)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("AnchorChain", partition)
		v.parent = c
		v.label = c.label + " " + "anchor chain" + " " + partition
		return v
	})
}

func (c *Account) Chains() values.Set[*protocol.ChainMetadata] {
	return values.GetOrCreate(&c.chains, func() values.Set[*protocol.ChainMetadata] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Chains"), c.label+" "+"chains", values.Struct[protocol.ChainMetadata](), func(u, v *protocol.ChainMetadata) int { return u.Compare(v) })
	})
}

func (c *Account) SyntheticAnchors() values.Set[[32]byte] {
	return values.GetOrCreate(&c.syntheticAnchors, func() values.Set[[32]byte] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("SyntheticAnchors"), c.label+" "+"synthetic anchors", values.Wrapped(values.HashWrapper), values.CompareHash)
	})
}

func (c *Account) Data() *AccountData {
	return values.GetOrCreate(&c.data, func() *AccountData {
		v := new(AccountData)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("Data")
		v.parent = c
		v.label = c.label + " " + "data"
		return v
	})
}

func (c *Account) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for account")
	}

	switch key.Get(0) {
	case "Url":
		return c.getUrl(), key.SliceI(1), nil
	case "Main":
		return c.Main(), key.SliceI(1), nil
	case "Pending":
		return c.Pending(), key.SliceI(1), nil
	case "SyntheticForAnchor":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account")
		}
		anchor, okAnchor := key.Get(1).([32]byte)
		if !okAnchor {
			return nil, nil, errors.InternalError.With("bad key for account")
		}
		v := c.SyntheticForAnchor(anchor)
		return v, key.SliceI(2), nil
	case "Directory":
		return c.Directory(), key.SliceI(1), nil
	case "Transaction":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account")
		}
		hash, okHash := key.Get(1).([32]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for account")
		}
		v := c.Transaction(hash)
		return v, key.SliceI(2), nil
	case "MainChain":
		return c.MainChain(), key.SliceI(1), nil
	case "ScratchChain":
		return c.ScratchChain(), key.SliceI(1), nil
	case "SignatureChain":
		return c.SignatureChain(), key.SliceI(1), nil
	case "RootChain":
		return c.RootChain(), key.SliceI(1), nil
	case "AnchorSequenceChain":
		return c.AnchorSequenceChain(), key.SliceI(1), nil
	case "MajorBlockChain":
		return c.MajorBlockChain(), key.SliceI(1), nil
	case "SyntheticSequenceChain":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account")
		}
		partition, okPartition := key.Get(1).(string)
		if !okPartition {
			return nil, nil, errors.InternalError.With("bad key for account")
		}
		v := c.getSyntheticSequenceChain(partition)
		return v, key.SliceI(2), nil
	case "AnchorChain":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account")
		}
		partition, okPartition := key.Get(1).(string)
		if !okPartition {
			return nil, nil, errors.InternalError.With("bad key for account")
		}
		v := c.getAnchorChain(partition)
		return v, key.SliceI(2), nil
	case "Chains":
		return c.Chains(), key.SliceI(1), nil
	case "SyntheticAnchors":
		return c.SyntheticAnchors(), key.SliceI(1), nil
	case "Data":
		return c.Data(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for account")
	}
}

func (c *Account) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.url) {
		return true
	}
	if values.IsDirty(c.main) {
		return true
	}
	if values.IsDirty(c.pending) {
		return true
	}
	for _, v := range c.syntheticForAnchor {
		if v.IsDirty() {
			return true
		}
	}
	if values.IsDirty(c.directory) {
		return true
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}
	if values.IsDirty(c.mainChain) {
		return true
	}
	if values.IsDirty(c.scratchChain) {
		return true
	}
	if values.IsDirty(c.signatureChain) {
		return true
	}
	if values.IsDirty(c.rootChain) {
		return true
	}
	if values.IsDirty(c.anchorSequenceChain) {
		return true
	}
	if values.IsDirty(c.majorBlockChain) {
		return true
	}
	for _, v := range c.syntheticSequenceChain {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.anchorChain {
		if v.IsDirty() {
			return true
		}
	}
	if values.IsDirty(c.chains) {
		return true
	}
	if values.IsDirty(c.syntheticAnchors) {
		return true
	}
	if values.IsDirty(c.data) {
		return true
	}

	return false
}

func (c *Account) dirtyChains() []*MerkleManager {
	if c == nil {
		return nil
	}

	var chains []*MerkleManager

	chains = append(chains, c.mainChain.dirtyChains()...)
	chains = append(chains, c.scratchChain.dirtyChains()...)
	chains = append(chains, c.signatureChain.dirtyChains()...)
	chains = append(chains, c.rootChain.dirtyChains()...)
	chains = append(chains, c.anchorSequenceChain.dirtyChains()...)
	chains = append(chains, c.majorBlockChain.dirtyChains()...)
	for _, v := range c.syntheticSequenceChain {
		chains = append(chains, v.dirtyChains()...)
	}
	for _, v := range c.anchorChain {
		chains = append(chains, v.dirtyChains()...)
	}

	return chains
}

func (c *Account) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.Walk(&err, c.url, opts, fn)
	values.Walk(&err, c.main, opts, fn)
	values.Walk(&err, c.pending, opts, fn)
	for _, v := range c.syntheticForAnchor {
		values.Walk(&err, v, opts, fn)
	}
	values.Walk(&err, c.directory, opts, fn)
	for _, v := range c.transaction {
		values.Walk(&err, v, opts, fn)
	}
	values.Walk(&err, c.mainChain, opts, fn)
	values.Walk(&err, c.scratchChain, opts, fn)
	values.Walk(&err, c.signatureChain, opts, fn)
	values.Walk(&err, c.rootChain, opts, fn)
	values.Walk(&err, c.anchorSequenceChain, opts, fn)
	values.Walk(&err, c.majorBlockChain, opts, fn)
	for _, v := range c.syntheticSequenceChain {
		values.Walk(&err, v, opts, fn)
	}
	for _, v := range c.anchorChain {
		values.Walk(&err, v, opts, fn)
	}
	values.Walk(&err, c.data, opts, fn)
	return err
}

func (c *Account) baseCommit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.url)
	values.Commit(&err, c.main)
	values.Commit(&err, c.pending)
	for _, v := range c.syntheticForAnchor {
		values.Commit(&err, v)
	}
	values.Commit(&err, c.directory)
	for _, v := range c.transaction {
		values.Commit(&err, v)
	}
	values.Commit(&err, c.mainChain)
	values.Commit(&err, c.scratchChain)
	values.Commit(&err, c.signatureChain)
	values.Commit(&err, c.rootChain)
	values.Commit(&err, c.anchorSequenceChain)
	values.Commit(&err, c.majorBlockChain)
	for _, v := range c.syntheticSequenceChain {
		values.Commit(&err, v)
	}
	for _, v := range c.anchorChain {
		values.Commit(&err, v)
	}
	values.Commit(&err, c.chains)
	values.Commit(&err, c.syntheticAnchors)
	values.Commit(&err, c.data)

	return err
}

type AccountTransaction struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	label  string
	parent *Account

	payments            values.Set[[32]byte]
	votes               values.Set[*VoteEntry]
	signatures          values.Set[*SignatureSetEntry]
	validatorSignatures values.Set[protocol.KeySignature]
	history             values.Set[uint64]
}

func (c *AccountTransaction) Key() *record.Key { return c.key }

func (c *AccountTransaction) Payments() values.Set[[32]byte] {
	return values.GetOrCreate(&c.payments, func() values.Set[[32]byte] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Payments"), c.label+" "+"payments", values.Wrapped(values.HashWrapper), values.CompareHash)
	})
}

func (c *AccountTransaction) Votes() values.Set[*VoteEntry] {
	return values.GetOrCreate(&c.votes, func() values.Set[*VoteEntry] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Votes"), c.label+" "+"votes", values.Struct[VoteEntry](), compareVoteEntries)
	})
}

func (c *AccountTransaction) Signatures() values.Set[*SignatureSetEntry] {
	return values.GetOrCreate(&c.signatures, func() values.Set[*SignatureSetEntry] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Signatures"), c.label+" "+"signatures", values.Struct[SignatureSetEntry](), compareSignatureSetEntries)
	})
}

func (c *AccountTransaction) ValidatorSignatures() values.Set[protocol.KeySignature] {
	return values.GetOrCreate(&c.validatorSignatures, func() values.Set[protocol.KeySignature] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("ValidatorSignatures"), c.label+" "+"validator signatures", values.Union(protocol.UnmarshalKeySignature), compareSignatureByKey)
	})
}

func (c *AccountTransaction) History() values.Set[uint64] {
	return values.GetOrCreate(&c.history, func() values.Set[uint64] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("History"), c.label+" "+"history", values.Wrapped(values.UintWrapper), values.CompareUint)
	})
}

func (c *AccountTransaction) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for transaction")
	}

	switch key.Get(0) {
	case "Payments":
		return c.Payments(), key.SliceI(1), nil
	case "Votes":
		return c.Votes(), key.SliceI(1), nil
	case "Signatures":
		return c.Signatures(), key.SliceI(1), nil
	case "ValidatorSignatures":
		return c.ValidatorSignatures(), key.SliceI(1), nil
	case "History":
		return c.History(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for transaction")
	}
}

func (c *AccountTransaction) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.payments) {
		return true
	}
	if values.IsDirty(c.votes) {
		return true
	}
	if values.IsDirty(c.signatures) {
		return true
	}
	if values.IsDirty(c.validatorSignatures) {
		return true
	}
	if values.IsDirty(c.history) {
		return true
	}

	return false
}

func (c *AccountTransaction) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.Walk(&err, c.payments, opts, fn)
	values.Walk(&err, c.votes, opts, fn)
	values.Walk(&err, c.signatures, opts, fn)
	values.Walk(&err, c.validatorSignatures, opts, fn)
	return err
}

func (c *AccountTransaction) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.payments)
	values.Commit(&err, c.votes)
	values.Commit(&err, c.signatures)
	values.Commit(&err, c.validatorSignatures)
	values.Commit(&err, c.history)

	return err
}

type AccountAnchorChain struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	label  string
	parent *Account

	root *Chain2
	bpt  *Chain2
}

func (c *AccountAnchorChain) Key() *record.Key { return c.key }

func (c *AccountAnchorChain) Root() *Chain2 {
	return values.GetOrCreate(&c.root, func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("Root"), "anchor(%[4]v)-root", c.label+" "+"root")
	})
}

func (c *AccountAnchorChain) BPT() *Chain2 {
	return values.GetOrCreate(&c.bpt, func() *Chain2 {
		return newChain2(c, c.logger.L, c.store, c.key.Append("BPT"), "anchor(%[4]v)-bpt", c.label+" "+"bpt")
	})
}

func (c *AccountAnchorChain) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for anchor chain")
	}

	switch key.Get(0) {
	case "Root":
		return c.Root(), key.SliceI(1), nil
	case "BPT":
		return c.BPT(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for anchor chain")
	}
}

func (c *AccountAnchorChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.root) {
		return true
	}
	if values.IsDirty(c.bpt) {
		return true
	}

	return false
}

func (c *AccountAnchorChain) dirtyChains() []*MerkleManager {
	if c == nil {
		return nil
	}

	var chains []*MerkleManager

	chains = append(chains, c.root.dirtyChains()...)
	chains = append(chains, c.bpt.dirtyChains()...)

	return chains
}

func (c *AccountAnchorChain) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.Walk(&err, c.root, opts, fn)
	values.Walk(&err, c.bpt, opts, fn)
	return err
}

func (c *AccountAnchorChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.root)
	values.Commit(&err, c.bpt)

	return err
}

type AccountData struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	label  string
	parent *Account

	entry       values.Counted[[32]byte]
	transaction map[accountDataTransactionKey]values.Value[[32]byte]
}

func (c *AccountData) Key() *record.Key { return c.key }

type accountDataTransactionKey struct {
	EntryHash [32]byte
}

func keyForAccountDataTransaction(entryHash [32]byte) accountDataTransactionKey {
	return accountDataTransactionKey{entryHash}
}

func (c *AccountData) Entry() values.Counted[[32]byte] {
	return values.GetOrCreate(&c.entry, func() values.Counted[[32]byte] {
		return values.NewCounted(c.logger.L, c.store, c.key.Append("Entry"), c.label+" "+"entry", values.WrappedFactory(values.HashWrapper))
	})
}

func (c *AccountData) Transaction(entryHash [32]byte) values.Value[[32]byte] {
	return values.GetOrCreateMap(&c.transaction, keyForAccountDataTransaction(entryHash), func() values.Value[[32]byte] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Transaction", entryHash), c.label+" "+"transaction"+" "+hex.EncodeToString(entryHash[:]), false, values.Wrapped(values.HashWrapper))
	})
}

func (c *AccountData) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for data")
	}

	switch key.Get(0) {
	case "Entry":
		return c.Entry(), key.SliceI(1), nil
	case "Transaction":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for data")
		}
		entryHash, okEntryHash := key.Get(1).([32]byte)
		if !okEntryHash {
			return nil, nil, errors.InternalError.With("bad key for data")
		}
		v := c.Transaction(entryHash)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for data")
	}
}

func (c *AccountData) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.entry) {
		return true
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *AccountData) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	return err
}

func (c *AccountData) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.entry)
	for _, v := range c.transaction {
		values.Commit(&err, v)
	}

	return err
}

type Message struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	label  string
	parent *Batch

	main     values.Value[messaging.Message]
	cause    values.Set[*url.TxID]
	produced values.Set[*url.TxID]
	signers  values.Set[*url.URL]
}

func (c *Message) Key() *record.Key { return c.key }

func (c *Message) getMain() values.Value[messaging.Message] {
	return values.GetOrCreate(&c.main, func() values.Value[messaging.Message] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Main"), c.label+" "+"main", false, values.Union(messaging.UnmarshalMessage))
	})
}

func (c *Message) Cause() values.Set[*url.TxID] {
	return values.GetOrCreate(&c.cause, func() values.Set[*url.TxID] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Cause"), c.label+" "+"cause", values.Wrapped(values.TxidWrapper), values.CompareTxid)
	})
}

func (c *Message) Produced() values.Set[*url.TxID] {
	return values.GetOrCreate(&c.produced, func() values.Set[*url.TxID] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Produced"), c.label+" "+"produced", values.Wrapped(values.TxidWrapper), values.CompareTxid)
	})
}

func (c *Message) Signers() values.Set[*url.URL] {
	return values.GetOrCreate(&c.signers, func() values.Set[*url.URL] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Signers"), c.label+" "+"signers", values.Wrapped(values.UrlWrapper), values.CompareUrl)
	})
}

func (c *Message) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for message")
	}

	switch key.Get(0) {
	case "Main":
		return c.getMain(), key.SliceI(1), nil
	case "Cause":
		return c.Cause(), key.SliceI(1), nil
	case "Produced":
		return c.Produced(), key.SliceI(1), nil
	case "Signers":
		return c.Signers(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for message")
	}
}

func (c *Message) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.main) {
		return true
	}
	if values.IsDirty(c.cause) {
		return true
	}
	if values.IsDirty(c.produced) {
		return true
	}
	if values.IsDirty(c.signers) {
		return true
	}

	return false
}

func (c *Message) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.Walk(&err, c.main, opts, fn)
	return err
}

func (c *Message) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.main)
	values.Commit(&err, c.cause)
	values.Commit(&err, c.produced)
	values.Commit(&err, c.signers)

	return err
}

type Transaction struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	label  string
	parent *Batch

	main       values.Value[*SigOrTxn]
	status     values.Value[*protocol.TransactionStatus]
	produced   values.Set[*url.TxID]
	signatures map[transactionSignaturesKey]values.Value[*sigSetData]
	chains     values.Set[*TransactionChainEntry]
}

func (c *Transaction) Key() *record.Key { return c.key }

type transactionSignaturesKey struct {
	Signer [32]byte
}

func keyForTransactionSignatures(signer *url.URL) transactionSignaturesKey {
	return transactionSignaturesKey{values.MapKeyUrl(signer)}
}

func (c *Transaction) Main() values.Value[*SigOrTxn] {
	return values.GetOrCreate(&c.main, func() values.Value[*SigOrTxn] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Main"), c.label+" "+"main", false, values.Struct[SigOrTxn]())
	})
}

func (c *Transaction) Status() values.Value[*protocol.TransactionStatus] {
	return values.GetOrCreate(&c.status, func() values.Value[*protocol.TransactionStatus] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Status"), c.label+" "+"status", true, values.Struct[protocol.TransactionStatus]())
	})
}

func (c *Transaction) Produced() values.Set[*url.TxID] {
	return values.GetOrCreate(&c.produced, func() values.Set[*url.TxID] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Produced"), c.label+" "+"produced", values.Wrapped(values.TxidWrapper), values.CompareTxid)
	})
}

func (c *Transaction) getSignatures(signer *url.URL) values.Value[*sigSetData] {
	return values.GetOrCreateMap(&c.signatures, keyForTransactionSignatures(signer), func() values.Value[*sigSetData] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Signatures", signer), c.label+" "+"signatures"+" "+signer.RawString(), true, values.Struct[sigSetData]())
	})
}

func (c *Transaction) Chains() values.Set[*TransactionChainEntry] {
	return values.GetOrCreate(&c.chains, func() values.Set[*TransactionChainEntry] {
		return values.NewSet(c.logger.L, c.store, c.key.Append("Chains"), c.label+" "+"chains", values.Struct[TransactionChainEntry](), func(u, v *TransactionChainEntry) int { return u.Compare(v) })
	})
}

func (c *Transaction) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for transaction")
	}

	switch key.Get(0) {
	case "Main":
		return c.Main(), key.SliceI(1), nil
	case "Status":
		return c.Status(), key.SliceI(1), nil
	case "Produced":
		return c.Produced(), key.SliceI(1), nil
	case "Signatures":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for transaction")
		}
		signer, okSigner := key.Get(1).(*url.URL)
		if !okSigner {
			return nil, nil, errors.InternalError.With("bad key for transaction")
		}
		v := c.getSignatures(signer)
		return v, key.SliceI(2), nil
	case "Chains":
		return c.Chains(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for transaction")
	}
}

func (c *Transaction) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.main) {
		return true
	}
	if values.IsDirty(c.status) {
		return true
	}
	if values.IsDirty(c.produced) {
		return true
	}
	for _, v := range c.signatures {
		if v.IsDirty() {
			return true
		}
	}
	if values.IsDirty(c.chains) {
		return true
	}

	return false
}

func (c *Transaction) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.Walk(&err, c.main, opts, fn)
	values.Walk(&err, c.status, opts, fn)
	values.Walk(&err, c.produced, opts, fn)
	for _, v := range c.signatures {
		values.Walk(&err, v, opts, fn)
	}
	return err
}

func (c *Transaction) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.main)
	values.Commit(&err, c.status)
	values.Commit(&err, c.produced)
	for _, v := range c.signatures {
		values.Commit(&err, v)
	}
	values.Commit(&err, c.chains)

	return err
}

type SystemData struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	label  string
	parent *Batch

	syntheticIndexIndex map[systemDataSyntheticIndexIndexKey]values.Value[uint64]
}

func (c *SystemData) Key() *record.Key { return c.key }

type systemDataSyntheticIndexIndexKey struct {
	Block uint64
}

func keyForSystemDataSyntheticIndexIndex(block uint64) systemDataSyntheticIndexIndexKey {
	return systemDataSyntheticIndexIndexKey{block}
}

func (c *SystemData) SyntheticIndexIndex(block uint64) values.Value[uint64] {
	return values.GetOrCreateMap(&c.syntheticIndexIndex, keyForSystemDataSyntheticIndexIndex(block), func() values.Value[uint64] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("SyntheticIndexIndex", block), c.label+" "+"synthetic index index"+" "+strconv.FormatUint(block, 10), false, values.Wrapped(values.UintWrapper))
	})
}

func (c *SystemData) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for system data")
	}

	switch key.Get(0) {
	case "SyntheticIndexIndex":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for system data")
		}
		block, okBlock := key.Get(1).(uint64)
		if !okBlock {
			return nil, nil, errors.InternalError.With("bad key for system data")
		}
		v := c.SyntheticIndexIndex(block)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for system data")
	}
}

func (c *SystemData) IsDirty() bool {
	if c == nil {
		return false
	}

	for _, v := range c.syntheticIndexIndex {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *SystemData) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	return err
}

func (c *SystemData) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	for _, v := range c.syntheticIndexIndex {
		values.Commit(&err, v)
	}

	return err
}

type MerkleManager struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       *record.Key
	label     string
	typ       merkle.ChainType
	name      string
	markPower int64
	markFreq  int64
	markMask  int64

	head         values.Value[*MerkleState]
	states       map[merkleManagerStatesKey]values.Value[*MerkleState]
	elementIndex map[merkleManagerElementIndexKey]values.Value[uint64]
	element      map[merkleManagerElementKey]values.Value[[]byte]
}

func (c *MerkleManager) Key() *record.Key { return c.key }

type merkleManagerStatesKey struct {
	Index uint64
}

func keyForMerkleManagerStates(index uint64) merkleManagerStatesKey {
	return merkleManagerStatesKey{index}
}

type merkleManagerElementIndexKey struct {
	Hash [32]byte
}

func keyForMerkleManagerElementIndex(hash []byte) merkleManagerElementIndexKey {
	return merkleManagerElementIndexKey{values.MapKeyBytes(hash)}
}

type merkleManagerElementKey struct {
	Index uint64
}

func keyForMerkleManagerElement(index uint64) merkleManagerElementKey {
	return merkleManagerElementKey{index}
}

func (c *MerkleManager) Head() values.Value[*MerkleState] {
	return values.GetOrCreate(&c.head, func() values.Value[*MerkleState] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Head"), c.label+" "+"head", true, values.Struct[MerkleState]())
	})
}

func (c *MerkleManager) States(index uint64) values.Value[*MerkleState] {
	return values.GetOrCreateMap(&c.states, keyForMerkleManagerStates(index), func() values.Value[*MerkleState] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("States", index), c.label+" "+"states"+" "+strconv.FormatUint(index, 10), false, values.Struct[MerkleState]())
	})
}

func (c *MerkleManager) ElementIndex(hash []byte) values.Value[uint64] {
	return values.GetOrCreateMap(&c.elementIndex, keyForMerkleManagerElementIndex(hash), func() values.Value[uint64] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("ElementIndex", hash), c.label+" "+"element index"+" "+hex.EncodeToString(hash), false, values.Wrapped(values.UintWrapper))
	})
}

func (c *MerkleManager) Element(index uint64) values.Value[[]byte] {
	return values.GetOrCreateMap(&c.element, keyForMerkleManagerElement(index), func() values.Value[[]byte] {
		return values.NewValue(c.logger.L, c.store, c.key.Append("Element", index), c.label+" "+"element"+" "+strconv.FormatUint(index, 10), false, values.Wrapped(values.BytesWrapper))
	})
}

func (c *MerkleManager) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for merkle manager")
	}

	switch key.Get(0) {
	case "Head":
		return c.Head(), key.SliceI(1), nil
	case "States":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager")
		}
		index, okIndex := key.Get(1).(uint64)
		if !okIndex {
			return nil, nil, errors.InternalError.With("bad key for merkle manager")
		}
		v := c.States(index)
		return v, key.SliceI(2), nil
	case "ElementIndex":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager")
		}
		hash, okHash := key.Get(1).([]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for merkle manager")
		}
		v := c.ElementIndex(hash)
		return v, key.SliceI(2), nil
	case "Element":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager")
		}
		index, okIndex := key.Get(1).(uint64)
		if !okIndex {
			return nil, nil, errors.InternalError.With("bad key for merkle manager")
		}
		v := c.Element(index)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for merkle manager")
	}
}

func (c *MerkleManager) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.head) {
		return true
	}
	for _, v := range c.states {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.elementIndex {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.element {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *MerkleManager) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.Walk(&err, c.head, opts, fn)
	for _, v := range c.states {
		values.Walk(&err, v, opts, fn)
	}
	return err
}

func (c *MerkleManager) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.head)
	for _, v := range c.states {
		values.Commit(&err, v)
	}
	for _, v := range c.elementIndex {
		values.Commit(&err, v)
	}
	for _, v := range c.element {
		values.Commit(&err, v)
	}

	return err
}
