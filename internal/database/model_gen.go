package database

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/database/record"
	"gitlab.com/accumulatenetwork/accumulate/internal/errors"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/smt/managed"
	"gitlab.com/accumulatenetwork/accumulate/smt/storage"
)

type Account struct {
	logger  logging.OptionalLogger
	store   record.Store
	key     record.Key
	batch   *Batch
	label   string
	chains2 map[storage.Key]*managed.Chain

	main                   *record.Value[protocol.Account]
	pending                *record.Set[*url.TxID]
	syntheticForAnchor     map[storage.Key]*record.Set[*url.TxID]
	mainChain              *managed.Chain
	scratchChain           *managed.Chain
	signatureChain         *managed.Chain
	rootChain              *managed.Chain
	anchorChain            map[storage.Key]*AccountAnchorChain
	syntheticSequenceChain map[storage.Key]*managed.Chain
	mainMajorIndexChain    *managed.Chain
	chains                 *record.Set[string]
	syntheticAnchors       *record.Set[[32]byte]
	directory              *record.Counted[*url.URL]
	data                   *AccountData
}

func (c *Account) Main() *record.Value[protocol.Account] {
	return getOrCreateField(&c.main, func() *record.Value[protocol.Account] {
		return record.NewValue(c.logger.L, c.store, c.key.Append("Main"), c.label+" main", false,
			record.Union(protocol.UnmarshalAccount))
	})
}

func (c *Account) Pending() *record.Set[*url.TxID] {
	return getOrCreateField(&c.pending, func() *record.Set[*url.TxID] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("Pending"), c.label+" pending",
			record.Wrapped(record.TxidWrapper), record.CompareTxid)
	})
}

func (c *Account) SyntheticForAnchor(anchor [32]byte) *record.Set[*url.TxID] {
	return getOrCreateMap(&c.syntheticForAnchor, c.key.Append("SyntheticForAnchor", anchor), func() *record.Set[*url.TxID] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("SyntheticForAnchor", anchor), c.label+" synthetic for anchor",
			record.Wrapped(record.TxidWrapper), record.CompareTxid)
	})
}

func (c *Account) MainChain() *managed.Chain {
	return getOrCreateField(&c.mainChain, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("MainChain"), markPower, managed.ChainTypeTransaction,
			"main", c.label+" main chain")
	})
}

func (c *Account) ScratchChain() *managed.Chain {
	return getOrCreateField(&c.scratchChain, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("ScratchChain"), markPower, managed.ChainTypeTransaction,
			"scratch", c.label+" scratch chain")
	})
}

func (c *Account) SignatureChain() *managed.Chain {
	return getOrCreateField(&c.signatureChain, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("SignatureChain"), markPower, managed.ChainTypeTransaction,
			"signature", c.label+" signature chain")
	})
}

func (c *Account) RootChain() *managed.Chain {
	return getOrCreateField(&c.rootChain, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("RootChain"), markPower, managed.ChainTypeTransaction,
			"root", c.label+" root chain")
	})
}

func (c *Account) AnchorChain(subnetId string) *AccountAnchorChain {
	return getOrCreateMap(&c.anchorChain, c.key.Append("AnchorChain", subnetId), func() *AccountAnchorChain {
		v := new(AccountAnchorChain)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("AnchorChain", subnetId)
		v.parent = c
		return v
	})
}

func (c *Account) SyntheticSequenceChain(subnetId string) *managed.Chain {
	return getOrCreateMap(&c.syntheticSequenceChain, c.key.Append("SyntheticSequenceChain", subnetId), func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("SyntheticSequenceChain", subnetId), markPower, managed.ChainTypeTransaction,
			"synthetic-sequence(%[2]v)", c.label+" synthetic sequence chain")
	})
}

func (c *Account) MainMajorIndexChain() *managed.Chain {
	return getOrCreateField(&c.mainMajorIndexChain, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("MainMajorIndexChain"), markPower, managed.ChainTypeIndex,
			"main-major-index", c.label+" main major index chain")
	})
}

func (c *Account) Chains() *record.Set[string] {
	return getOrCreateField(&c.chains, func() *record.Set[string] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("Chains"), c.label+" chains",
			record.Wrapped(record.StringWrapper), record.CompareString)
	})
}

func (c *Account) SyntheticAnchors() *record.Set[[32]byte] {
	return getOrCreateField(&c.syntheticAnchors, func() *record.Set[[32]byte] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("SyntheticAnchors"), c.label+" synthetic anchors",
			record.Wrapped(record.HashWrapper), record.CompareHash)
	})
}

func (c *Account) Directory() *record.Counted[*url.URL] {
	return getOrCreateField(&c.directory, func() *record.Counted[*url.URL] {
		return record.NewCounted(c.logger.L, c.store, c.key.Append("Directory"), c.label+" directory", record.WrappedFactory(record.UrlWrapper))
	})
}

func (c *Account) Data() *AccountData {
	return getOrCreateField(&c.data, func() *AccountData {
		v := new(AccountData)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("Data")
		v.parent = c
		return v
	})
}

func (c *Account) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Main":
		return c.Main(), key[1:], nil
	case "Pending":
		return c.Pending(), key[1:], nil
	case "SyntheticForAnchor":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		anchor, okAnchor := key[1].([32]byte)
		if !okAnchor {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		v := c.SyntheticForAnchor(anchor)
		return v, key[2:], nil
	case "MainChain":
		return c.MainChain(), key[1:], nil
	case "ScratchChain":
		return c.ScratchChain(), key[1:], nil
	case "SignatureChain":
		return c.SignatureChain(), key[1:], nil
	case "RootChain":
		return c.RootChain(), key[1:], nil
	case "AnchorChain":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		subnetId, okSubnetId := key[1].(string)
		if !okSubnetId {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		v := c.AnchorChain(subnetId)
		return v, key[2:], nil
	case "SyntheticSequenceChain":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		subnetId, okSubnetId := key[1].(string)
		if !okSubnetId {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		v := c.SyntheticSequenceChain(subnetId)
		return v, key[2:], nil
	case "MainMajorIndexChain":
		return c.MainMajorIndexChain(), key[1:], nil
	case "Chains":
		return c.Chains(), key[1:], nil
	case "SyntheticAnchors":
		return c.SyntheticAnchors(), key[1:], nil
	case "Directory":
		return c.Directory(), key[1:], nil
	case "Data":
		return c.Data(), key[1:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
	}
}

func (c *Account) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.main) {
		return true
	}
	if fieldIsDirty(c.pending) {
		return true
	}
	for _, v := range c.syntheticForAnchor {
		if v.IsDirty() {
			return true
		}
	}
	if fieldIsDirty(c.mainChain) {
		return true
	}
	if fieldIsDirty(c.scratchChain) {
		return true
	}
	if fieldIsDirty(c.signatureChain) {
		return true
	}
	if fieldIsDirty(c.rootChain) {
		return true
	}
	for _, v := range c.anchorChain {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.syntheticSequenceChain {
		if v.IsDirty() {
			return true
		}
	}
	if fieldIsDirty(c.mainMajorIndexChain) {
		return true
	}
	if fieldIsDirty(c.chains) {
		return true
	}
	if fieldIsDirty(c.syntheticAnchors) {
		return true
	}
	if fieldIsDirty(c.directory) {
		return true
	}
	if fieldIsDirty(c.data) {
		return true
	}

	return false
}

func (c *Account) resolveChain(name string) (chain *managed.Chain, ok bool) {
	if name == "main" {
		return c.MainChain(), true
	}
	if name == "scratch" {
		return c.ScratchChain(), true
	}
	if name == "signature" {
		return c.SignatureChain(), true
	}
	if name == "root" {
		return c.RootChain(), true
	}
	if name == "main-major-index" {
		return c.MainMajorIndexChain(), true
	}
	tryResolveChainParam(&chain, &ok, name, "anchor(", 1, func(params []string, name string) (*managed.Chain, bool) {
		ok := true
		paramSubnetId := parseChainParam(&ok, params[0], record.ParseString)
		if !ok {
			return nil, false
		}

		return c.AnchorChain(paramSubnetId).resolveChain(name)
	})
	tryResolveChainParam(&chain, &ok, name, "synthetic-sequence(", 1, func(params []string, name string) (*managed.Chain, bool) {
		ok := true
		paramSubnetId := parseChainParam(&ok, params[0], record.ParseString)
		if !ok {
			return nil, false
		}

		return c.SyntheticSequenceChain(paramSubnetId), true
	})
	return
}

func (c *Account) dirtyChains() []*managed.Chain {
	if c == nil {
		return nil
	}

	var chains []*managed.Chain

	if fieldIsDirty(c.mainChain) {
		chains = append(chains, c.mainChain)
	}
	if fieldIsDirty(c.scratchChain) {
		chains = append(chains, c.scratchChain)
	}
	if fieldIsDirty(c.signatureChain) {
		chains = append(chains, c.signatureChain)
	}
	if fieldIsDirty(c.rootChain) {
		chains = append(chains, c.rootChain)
	}
	for _, v := range c.anchorChain {
		chains = append(chains, v.dirtyChains()...)
	}
	for _, v := range c.syntheticSequenceChain {
		if v.IsDirty() {
			chains = append(chains, v)
		}
	}
	if fieldIsDirty(c.mainMajorIndexChain) {
		chains = append(chains, c.mainMajorIndexChain)
	}

	return chains
}

func (c *Account) baseCommit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.main)
	commitField(&err, c.pending)
	for _, v := range c.syntheticForAnchor {
		commitField(&err, v)
	}
	commitField(&err, c.mainChain)
	commitField(&err, c.scratchChain)
	commitField(&err, c.signatureChain)
	commitField(&err, c.rootChain)
	for _, v := range c.anchorChain {
		commitField(&err, v)
	}
	for _, v := range c.syntheticSequenceChain {
		commitField(&err, v)
	}
	commitField(&err, c.mainMajorIndexChain)
	commitField(&err, c.chains)
	commitField(&err, c.syntheticAnchors)
	commitField(&err, c.directory)
	commitField(&err, c.data)

	return nil
}

type AccountAnchorChain struct {
	logger logging.OptionalLogger
	store  record.Store
	key    record.Key
	parent *Account

	root *managed.Chain
	bpt  *managed.Chain
}

func (c *AccountAnchorChain) Root() *managed.Chain {
	return getOrCreateField(&c.root, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("Root"), markPower, managed.ChainTypeAnchor,
			"anchor(%[2]v)-root", "anchor chain %[2]v root")
	})
}

func (c *AccountAnchorChain) BPT() *managed.Chain {
	return getOrCreateField(&c.bpt, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("BPT"), markPower, managed.ChainTypeAnchor,
			"anchor(%[2]v)-bpt", "anchor chain %[2]v bpt")
	})
}

func (c *AccountAnchorChain) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Root":
		return c.Root(), key[1:], nil
	case "BPT":
		return c.BPT(), key[1:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for anchor chain")
	}
}

func (c *AccountAnchorChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.root) {
		return true
	}
	if fieldIsDirty(c.bpt) {
		return true
	}

	return false
}

func (c *AccountAnchorChain) resolveChain(name string) (chain *managed.Chain, ok bool) {
	if name == "root" {
		return c.Root(), true
	}
	if name == "bpt" {
		return c.BPT(), true
	}
	return
}

func (c *AccountAnchorChain) dirtyChains() []*managed.Chain {
	if c == nil {
		return nil
	}

	var chains []*managed.Chain

	if fieldIsDirty(c.root) {
		chains = append(chains, c.root)
	}
	if fieldIsDirty(c.bpt) {
		chains = append(chains, c.bpt)
	}

	return chains
}

func (c *AccountAnchorChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.root)
	commitField(&err, c.bpt)

	return nil
}

type AccountData struct {
	logger logging.OptionalLogger
	store  record.Store
	key    record.Key
	parent *Account

	entry       *record.Counted[[32]byte]
	transaction map[storage.Key]*record.Value[[32]byte]
}

func (c *AccountData) Entry() *record.Counted[[32]byte] {
	return getOrCreateField(&c.entry, func() *record.Counted[[32]byte] {
		return record.NewCounted(c.logger.L, c.store, c.key.Append("Entry"), "data entry", record.WrappedFactory(record.HashWrapper))
	})
}

func (c *AccountData) Transaction(entryHash [32]byte) *record.Value[[32]byte] {
	return getOrCreateMap(&c.transaction, c.key.Append("Transaction", entryHash), func() *record.Value[[32]byte] {
		return record.NewValue(c.logger.L, c.store, c.key.Append("Transaction", entryHash), "data transaction %[3]x", false,
			record.Wrapped(record.HashWrapper))
	})
}

func (c *AccountData) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Entry":
		return c.Entry(), key[1:], nil
	case "Transaction":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for data")
		}
		entryHash, okEntryHash := key[1].([32]byte)
		if !okEntryHash {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for data")
		}
		v := c.Transaction(entryHash)
		return v, key[2:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for data")
	}
}

func (c *AccountData) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.entry) {
		return true
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *AccountData) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.entry)
	for _, v := range c.transaction {
		commitField(&err, v)
	}

	return nil
}

func getOrCreateField[T any](ptr **T, create func() *T) *T {
	if *ptr != nil {
		return *ptr
	}

	*ptr = create()
	return *ptr
}

func getOrCreateMap[T any](ptr *map[storage.Key]T, key record.Key, create func() T) T {
	if *ptr == nil {
		*ptr = map[storage.Key]T{}
	}

	k := key.Hash()
	if v, ok := (*ptr)[k]; ok {
		return v
	}

	v := create()
	(*ptr)[k] = v
	return v
}

func commitField[T any, PT record.RecordPtr[T]](lastErr *error, field PT) {
	if *lastErr != nil || field == nil {
		return
	}

	*lastErr = field.Commit()
}

func fieldIsDirty[T any, PT record.RecordPtr[T]](field PT) bool {
	return field != nil && field.IsDirty()
}
