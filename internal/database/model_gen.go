// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package database

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

//lint:file-ignore S1008,U1000 generated code

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	record "gitlab.com/accumulatenetwork/accumulate/pkg/database"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/bpt"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/values"
	"gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/messaging"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type Batch struct {
	logger      logging.OptionalLogger
	store       record.Store
	done        bool
	writable    bool
	id          string
	nextChildId int64
	parent      *Batch
	observer    Observer

	bpt         *bpt.BPT
	account     map[accountMapKey]*Account
	message     map[messageMapKey]*Message
	transaction map[transactionMapKey]*Transaction
	systemData  map[systemDataMapKey]*SystemData
}

func (c *Batch) Key() *record.Key { return nil }

type accountKey struct {
	Url *url.URL
}

type accountMapKey struct {
	Url [32]byte
}

func (k accountKey) ForMap() accountMapKey {
	return accountMapKey{values.MapKeyUrl(k.Url)}
}

type messageKey struct {
	Hash [32]byte
}

type messageMapKey struct {
	Hash [32]byte
}

func (k messageKey) ForMap() messageMapKey {
	return messageMapKey{k.Hash}
}

type transactionKey struct {
	Hash [32]byte
}

type transactionMapKey struct {
	Hash [32]byte
}

func (k transactionKey) ForMap() transactionMapKey {
	return transactionMapKey{k.Hash}
}

type systemDataKey struct {
	Partition string
}

type systemDataMapKey struct {
	Partition string
}

func (k systemDataKey) ForMap() systemDataMapKey {
	return systemDataMapKey{k.Partition}
}

func (c *Batch) BPT() *bpt.BPT {
	return values.GetOrCreate(c, &c.bpt, (*Batch).newBPT)
}

func (c *Batch) newBPT() *bpt.BPT {
	return newBPT(c, c.logger.L, c.store, (*record.Key)(nil).Append("BPT"), "bpt")
}

func (c *Batch) getAccount(url *url.URL) *Account {
	return values.GetOrCreateMap(c, &c.account, accountKey{url}, (*Batch).newAccount)
}

func (c *Batch) newAccount(k accountKey) *Account {
	v := new(Account)
	v.logger = c.logger
	v.store = c.store
	v.key = (*record.Key)(nil).Append("Account", k.Url)
	v.parent = c
	return v
}

func (c *Batch) Message(hash [32]byte) *Message {
	return values.GetOrCreateMap(c, &c.message, messageKey{hash}, (*Batch).newMessage)
}

func (c *Batch) newMessage(k messageKey) *Message {
	v := new(Message)
	v.logger = c.logger
	v.store = c.store
	v.key = (*record.Key)(nil).Append("Message", k.Hash)
	v.parent = c
	return v
}

func (c *Batch) getTransaction(hash [32]byte) *Transaction {
	return values.GetOrCreateMap(c, &c.transaction, transactionKey{hash}, (*Batch).newTransaction)
}

func (c *Batch) newTransaction(k transactionKey) *Transaction {
	v := new(Transaction)
	v.logger = c.logger
	v.store = c.store
	v.key = (*record.Key)(nil).Append("Transaction", k.Hash)
	v.parent = c
	return v
}

func (c *Batch) SystemData(partition string) *SystemData {
	return values.GetOrCreateMap(c, &c.systemData, systemDataKey{partition}, (*Batch).newSystemData)
}

func (c *Batch) newSystemData(k systemDataKey) *SystemData {
	v := new(SystemData)
	v.logger = c.logger
	v.store = c.store
	v.key = (*record.Key)(nil).Append("SystemData", k.Partition)
	v.parent = c
	return v
}

func (c *Batch) baseResolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for batch (1)")
	}

	switch key.Get(0) {
	case "BPT":
		return c.BPT(), key.SliceI(1), nil
	case "Account":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for batch (2)")
		}
		url, okUrl := key.Get(1).(*url.URL)
		if !okUrl {
			return nil, nil, errors.InternalError.With("bad key for batch (3)")
		}
		v := c.getAccount(url)
		return v, key.SliceI(2), nil
	case "Message":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for batch (4)")
		}
		hash, okHash := key.Get(1).([32]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for batch (5)")
		}
		v := c.Message(hash)
		return v, key.SliceI(2), nil
	case "Transaction":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for batch (6)")
		}
		hash, okHash := key.Get(1).([32]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for batch (7)")
		}
		v := c.getTransaction(hash)
		return v, key.SliceI(2), nil
	case "SystemData":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for batch (8)")
		}
		partition, okPartition := key.Get(1).(string)
		if !okPartition {
			return nil, nil, errors.InternalError.With("bad key for batch (9)")
		}
		v := c.SystemData(partition)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for batch (10)")
	}
}

func (c *Batch) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.bpt) {
		return true
	}
	for _, v := range c.account {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.message {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.systemData {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *Batch) dirtyChains() []*MerkleManager {
	if c == nil {
		return nil
	}

	var chains []*MerkleManager

	for _, v := range c.account {
		chains = append(chains, v.dirtyChains()...)
	}

	return chains
}

func (c *Batch) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.bpt, c.newBPT, opts, fn)
	values.WalkMap(&err, c.account, c.newAccount, nil, opts, fn)
	values.WalkMap(&err, c.message, c.newMessage, nil, opts, fn)
	values.WalkMap(&err, c.transaction, c.newTransaction, nil, opts, fn)
	values.WalkMap(&err, c.systemData, c.newSystemData, nil, opts, fn)
	return err
}

func (c *Batch) baseCommit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.bpt)
	for _, v := range c.account {
		values.Commit(&err, v)
	}
	for _, v := range c.message {
		values.Commit(&err, v)
	}
	for _, v := range c.transaction {
		values.Commit(&err, v)
	}
	for _, v := range c.systemData {
		values.Commit(&err, v)
	}

	return err
}

type Account struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *Batch

	url                    values.Value[*url.URL]
	main                   values.Value[protocol.Account]
	pending                values.Set[*url.TxID]
	syntheticForAnchor     map[accountSyntheticForAnchorMapKey]values.Set[*url.TxID]
	directory              values.Set[*url.URL]
	events                 *AccountEvents
	transaction            map[accountTransactionMapKey]*AccountTransaction
	mainChain              *Chain2
	scratchChain           *Chain2
	signatureChain         *Chain2
	rootChain              *Chain2
	bptChain               *Chain2
	anchorSequenceChain    *Chain2
	majorBlockChain        *Chain2
	syntheticSequenceChain map[accountSyntheticSequenceChainMapKey]*Chain2
	anchorChain            map[accountAnchorChainMapKey]*AccountAnchorChain
	chains                 values.Set[*protocol.ChainMetadata]
	syntheticAnchors       values.Set[[32]byte]
	data                   *AccountData
}

func (c *Account) Key() *record.Key { return c.key }

type accountSyntheticForAnchorKey struct {
	Anchor [32]byte
}

type accountSyntheticForAnchorMapKey struct {
	Anchor [32]byte
}

func (k accountSyntheticForAnchorKey) ForMap() accountSyntheticForAnchorMapKey {
	return accountSyntheticForAnchorMapKey{k.Anchor}
}

type accountTransactionKey struct {
	Hash [32]byte
}

type accountTransactionMapKey struct {
	Hash [32]byte
}

func (k accountTransactionKey) ForMap() accountTransactionMapKey {
	return accountTransactionMapKey{k.Hash}
}

type accountSyntheticSequenceChainKey struct {
	Partition string
}

type accountSyntheticSequenceChainMapKey struct {
	Partition string
}

func (k accountSyntheticSequenceChainKey) ForMap() accountSyntheticSequenceChainMapKey {
	return accountSyntheticSequenceChainMapKey{k.Partition}
}

type accountAnchorChainKey struct {
	Partition string
}

type accountAnchorChainMapKey struct {
	Partition string
}

func (k accountAnchorChainKey) ForMap() accountAnchorChainMapKey {
	return accountAnchorChainMapKey{k.Partition}
}

func (c *Account) getUrl() values.Value[*url.URL] {
	return values.GetOrCreate(c, &c.url, (*Account).newUrl)
}

func (c *Account) newUrl() values.Value[*url.URL] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Url"), false, values.Wrapped(values.UrlWrapper))
}

func (c *Account) Main() values.Value[protocol.Account] {
	return values.GetOrCreate(c, &c.main, (*Account).newMain)
}

func (c *Account) newMain() values.Value[protocol.Account] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Main"), false, values.Union(protocol.UnmarshalAccount))
}

func (c *Account) Pending() values.Set[*url.TxID] {
	return values.GetOrCreate(c, &c.pending, (*Account).newPending)
}

func (c *Account) newPending() values.Set[*url.TxID] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Pending"), values.Wrapped(values.TxidWrapper), values.CompareTxid)
}

func (c *Account) SyntheticForAnchor(anchor [32]byte) values.Set[*url.TxID] {
	return values.GetOrCreateMap(c, &c.syntheticForAnchor, accountSyntheticForAnchorKey{anchor}, (*Account).newSyntheticForAnchor)
}

func (c *Account) newSyntheticForAnchor(k accountSyntheticForAnchorKey) values.Set[*url.TxID] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("SyntheticForAnchor", k.Anchor), values.Wrapped(values.TxidWrapper), values.CompareTxid)
}

func (c *Account) Directory() values.Set[*url.URL] {
	return values.GetOrCreate(c, &c.directory, (*Account).newDirectory)
}

func (c *Account) newDirectory() values.Set[*url.URL] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Directory"), values.Wrapped(values.UrlWrapper), values.CompareUrl)
}

func (c *Account) Events() *AccountEvents {
	return values.GetOrCreate(c, &c.events, (*Account).newEvents)
}

func (c *Account) newEvents() *AccountEvents {
	v := new(AccountEvents)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Events")
	v.parent = c
	return v
}

func (c *Account) Transaction(hash [32]byte) *AccountTransaction {
	return values.GetOrCreateMap(c, &c.transaction, accountTransactionKey{hash}, (*Account).newTransaction)
}

func (c *Account) newTransaction(k accountTransactionKey) *AccountTransaction {
	v := new(AccountTransaction)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Transaction", k.Hash)
	v.parent = c
	return v
}

func (c *Account) MainChain() *Chain2 {
	return values.GetOrCreate(c, &c.mainChain, (*Account).newMainChain)
}

func (c *Account) newMainChain() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("MainChain"), "main")
}

func (c *Account) ScratchChain() *Chain2 {
	return values.GetOrCreate(c, &c.scratchChain, (*Account).newScratchChain)
}

func (c *Account) newScratchChain() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("ScratchChain"), "scratch")
}

func (c *Account) SignatureChain() *Chain2 {
	return values.GetOrCreate(c, &c.signatureChain, (*Account).newSignatureChain)
}

func (c *Account) newSignatureChain() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("SignatureChain"), "signature")
}

func (c *Account) RootChain() *Chain2 {
	return values.GetOrCreate(c, &c.rootChain, (*Account).newRootChain)
}

func (c *Account) newRootChain() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("RootChain"), "root")
}

func (c *Account) BptChain() *Chain2 {
	return values.GetOrCreate(c, &c.bptChain, (*Account).newBptChain)
}

func (c *Account) newBptChain() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("BptChain"), "bpt")
}

func (c *Account) AnchorSequenceChain() *Chain2 {
	return values.GetOrCreate(c, &c.anchorSequenceChain, (*Account).newAnchorSequenceChain)
}

func (c *Account) newAnchorSequenceChain() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("AnchorSequenceChain"), "anchor-sequence")
}

func (c *Account) MajorBlockChain() *Chain2 {
	return values.GetOrCreate(c, &c.majorBlockChain, (*Account).newMajorBlockChain)
}

func (c *Account) newMajorBlockChain() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("MajorBlockChain"), "major-block")
}

func (c *Account) getSyntheticSequenceChain(partition string) *Chain2 {
	return values.GetOrCreateMap(c, &c.syntheticSequenceChain, accountSyntheticSequenceChainKey{partition}, (*Account).newSyntheticSequenceChain)
}

func (c *Account) newSyntheticSequenceChain(k accountSyntheticSequenceChainKey) *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("SyntheticSequenceChain", k.Partition), "synthetic-sequence(%[4]v)")
}

func (c *Account) getAnchorChain(partition string) *AccountAnchorChain {
	return values.GetOrCreateMap(c, &c.anchorChain, accountAnchorChainKey{partition}, (*Account).newAnchorChain)
}

func (c *Account) newAnchorChain(k accountAnchorChainKey) *AccountAnchorChain {
	v := new(AccountAnchorChain)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("AnchorChain", k.Partition)
	v.parent = c
	return v
}

func (c *Account) Chains() values.Set[*protocol.ChainMetadata] {
	return values.GetOrCreate(c, &c.chains, (*Account).newChains)
}

func (c *Account) newChains() values.Set[*protocol.ChainMetadata] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Chains"), values.Struct[protocol.ChainMetadata](), func(u, v *protocol.ChainMetadata) int { return u.Compare(v) })
}

func (c *Account) SyntheticAnchors() values.Set[[32]byte] {
	return values.GetOrCreate(c, &c.syntheticAnchors, (*Account).newSyntheticAnchors)
}

func (c *Account) newSyntheticAnchors() values.Set[[32]byte] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("SyntheticAnchors"), values.Wrapped(values.HashWrapper), values.CompareHash)
}

func (c *Account) Data() *AccountData {
	return values.GetOrCreate(c, &c.data, (*Account).newData)
}

func (c *Account) newData() *AccountData {
	v := new(AccountData)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Data")
	v.parent = c
	return v
}

func (c *Account) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for account (1)")
	}

	switch key.Get(0) {
	case "Url":
		return c.getUrl(), key.SliceI(1), nil
	case "Main":
		return c.Main(), key.SliceI(1), nil
	case "Pending":
		return c.Pending(), key.SliceI(1), nil
	case "SyntheticForAnchor":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account (2)")
		}
		anchor, okAnchor := key.Get(1).([32]byte)
		if !okAnchor {
			return nil, nil, errors.InternalError.With("bad key for account (3)")
		}
		v := c.SyntheticForAnchor(anchor)
		return v, key.SliceI(2), nil
	case "Directory":
		return c.Directory(), key.SliceI(1), nil
	case "Events":
		return c.Events(), key.SliceI(1), nil
	case "Transaction":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account (4)")
		}
		hash, okHash := key.Get(1).([32]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for account (5)")
		}
		v := c.Transaction(hash)
		return v, key.SliceI(2), nil
	case "MainChain":
		return c.MainChain(), key.SliceI(1), nil
	case "ScratchChain":
		return c.ScratchChain(), key.SliceI(1), nil
	case "SignatureChain":
		return c.SignatureChain(), key.SliceI(1), nil
	case "RootChain":
		return c.RootChain(), key.SliceI(1), nil
	case "BptChain":
		return c.BptChain(), key.SliceI(1), nil
	case "AnchorSequenceChain":
		return c.AnchorSequenceChain(), key.SliceI(1), nil
	case "MajorBlockChain":
		return c.MajorBlockChain(), key.SliceI(1), nil
	case "SyntheticSequenceChain":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account (6)")
		}
		partition, okPartition := key.Get(1).(string)
		if !okPartition {
			return nil, nil, errors.InternalError.With("bad key for account (7)")
		}
		v := c.getSyntheticSequenceChain(partition)
		return v, key.SliceI(2), nil
	case "AnchorChain":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for account (8)")
		}
		partition, okPartition := key.Get(1).(string)
		if !okPartition {
			return nil, nil, errors.InternalError.With("bad key for account (9)")
		}
		v := c.getAnchorChain(partition)
		return v, key.SliceI(2), nil
	case "Chains":
		return c.Chains(), key.SliceI(1), nil
	case "SyntheticAnchors":
		return c.SyntheticAnchors(), key.SliceI(1), nil
	case "Data":
		return c.Data(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for account (10)")
	}
}

func (c *Account) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.url) {
		return true
	}
	if values.IsDirty(c.main) {
		return true
	}
	if values.IsDirty(c.pending) {
		return true
	}
	for _, v := range c.syntheticForAnchor {
		if v.IsDirty() {
			return true
		}
	}
	if values.IsDirty(c.directory) {
		return true
	}
	if values.IsDirty(c.events) {
		return true
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}
	if values.IsDirty(c.mainChain) {
		return true
	}
	if values.IsDirty(c.scratchChain) {
		return true
	}
	if values.IsDirty(c.signatureChain) {
		return true
	}
	if values.IsDirty(c.rootChain) {
		return true
	}
	if values.IsDirty(c.bptChain) {
		return true
	}
	if values.IsDirty(c.anchorSequenceChain) {
		return true
	}
	if values.IsDirty(c.majorBlockChain) {
		return true
	}
	for _, v := range c.syntheticSequenceChain {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.anchorChain {
		if v.IsDirty() {
			return true
		}
	}
	if values.IsDirty(c.chains) {
		return true
	}
	if values.IsDirty(c.syntheticAnchors) {
		return true
	}
	if values.IsDirty(c.data) {
		return true
	}

	return false
}

func (c *Account) dirtyChains() []*MerkleManager {
	if c == nil {
		return nil
	}

	var chains []*MerkleManager

	chains = append(chains, c.mainChain.dirtyChains()...)
	chains = append(chains, c.scratchChain.dirtyChains()...)
	chains = append(chains, c.signatureChain.dirtyChains()...)
	chains = append(chains, c.rootChain.dirtyChains()...)
	chains = append(chains, c.bptChain.dirtyChains()...)
	chains = append(chains, c.anchorSequenceChain.dirtyChains()...)
	chains = append(chains, c.majorBlockChain.dirtyChains()...)
	for _, v := range c.syntheticSequenceChain {
		chains = append(chains, v.dirtyChains()...)
	}
	for _, v := range c.anchorChain {
		chains = append(chains, v.dirtyChains()...)
	}

	return chains
}

func (c *Account) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.url, c.newUrl, opts, fn)
	values.WalkField(&err, c.main, c.newMain, opts, fn)
	values.WalkField(&err, c.pending, c.newPending, opts, fn)
	values.WalkMap(&err, c.syntheticForAnchor, c.newSyntheticForAnchor, nil, opts, fn)
	values.WalkField(&err, c.directory, c.newDirectory, opts, fn)
	values.WalkField(&err, c.events, c.newEvents, opts, fn)
	values.WalkMap(&err, c.transaction, c.newTransaction, c.getTransactionKeys, opts, fn)
	values.WalkField(&err, c.mainChain, c.newMainChain, opts, fn)
	values.WalkField(&err, c.scratchChain, c.newScratchChain, opts, fn)
	values.WalkField(&err, c.signatureChain, c.newSignatureChain, opts, fn)
	values.WalkField(&err, c.rootChain, c.newRootChain, opts, fn)
	values.WalkField(&err, c.bptChain, c.newBptChain, opts, fn)
	values.WalkField(&err, c.anchorSequenceChain, c.newAnchorSequenceChain, opts, fn)
	values.WalkField(&err, c.majorBlockChain, c.newMajorBlockChain, opts, fn)
	values.WalkMap(&err, c.syntheticSequenceChain, c.newSyntheticSequenceChain, c.getSyntheticSequenceKeys, opts, fn)
	values.WalkMap(&err, c.anchorChain, c.newAnchorChain, c.getAnchorKeys, opts, fn)
	values.WalkField(&err, c.chains, c.newChains, opts, fn)
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.syntheticAnchors, c.newSyntheticAnchors, opts, fn)
	}
	values.WalkField(&err, c.data, c.newData, opts, fn)
	return err
}

func (c *Account) baseCommit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.url)
	values.Commit(&err, c.main)
	values.Commit(&err, c.pending)
	for _, v := range c.syntheticForAnchor {
		values.Commit(&err, v)
	}
	values.Commit(&err, c.directory)
	values.Commit(&err, c.events)
	for _, v := range c.transaction {
		values.Commit(&err, v)
	}
	values.Commit(&err, c.mainChain)
	values.Commit(&err, c.scratchChain)
	values.Commit(&err, c.signatureChain)
	values.Commit(&err, c.rootChain)
	values.Commit(&err, c.bptChain)
	values.Commit(&err, c.anchorSequenceChain)
	values.Commit(&err, c.majorBlockChain)
	for _, v := range c.syntheticSequenceChain {
		values.Commit(&err, v)
	}
	for _, v := range c.anchorChain {
		values.Commit(&err, v)
	}
	values.Commit(&err, c.chains)
	values.Commit(&err, c.syntheticAnchors)
	values.Commit(&err, c.data)

	return err
}

type AccountEvents struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *Account

	minor   *AccountEventsMinor
	major   *AccountEventsMajor
	backlog *AccountEventsBacklog
	bpt     *bpt.BPT
}

func (c *AccountEvents) Key() *record.Key { return c.key }

func (c *AccountEvents) Minor() *AccountEventsMinor {
	return values.GetOrCreate(c, &c.minor, (*AccountEvents).newMinor)
}

func (c *AccountEvents) newMinor() *AccountEventsMinor {
	v := new(AccountEventsMinor)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Minor")
	v.parent = c
	return v
}

func (c *AccountEvents) Major() *AccountEventsMajor {
	return values.GetOrCreate(c, &c.major, (*AccountEvents).newMajor)
}

func (c *AccountEvents) newMajor() *AccountEventsMajor {
	v := new(AccountEventsMajor)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Major")
	v.parent = c
	return v
}

func (c *AccountEvents) Backlog() *AccountEventsBacklog {
	return values.GetOrCreate(c, &c.backlog, (*AccountEvents).newBacklog)
}

func (c *AccountEvents) newBacklog() *AccountEventsBacklog {
	v := new(AccountEventsBacklog)
	v.logger = c.logger
	v.store = c.store
	v.key = c.key.Append("Backlog")
	v.parent = c
	return v
}

func (c *AccountEvents) BPT() *bpt.BPT {
	return values.GetOrCreate(c, &c.bpt, (*AccountEvents).newBPT)
}

func (c *AccountEvents) newBPT() *bpt.BPT {
	return newBPT(c, c.logger.L, c.store, c.key.Append("BPT"), "events-bpt")
}

func (c *AccountEvents) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for events (1)")
	}

	switch key.Get(0) {
	case "Minor":
		return c.Minor(), key.SliceI(1), nil
	case "Major":
		return c.Major(), key.SliceI(1), nil
	case "Backlog":
		return c.Backlog(), key.SliceI(1), nil
	case "BPT":
		return c.BPT(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for events (2)")
	}
}

func (c *AccountEvents) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.minor) {
		return true
	}
	if values.IsDirty(c.major) {
		return true
	}
	if values.IsDirty(c.backlog) {
		return true
	}
	if values.IsDirty(c.bpt) {
		return true
	}

	return false
}

func (c *AccountEvents) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.minor, c.newMinor, opts, fn)
	values.WalkField(&err, c.major, c.newMajor, opts, fn)
	values.WalkField(&err, c.backlog, c.newBacklog, opts, fn)
	values.WalkField(&err, c.bpt, c.newBPT, opts, fn)
	return err
}

func (c *AccountEvents) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.minor)
	values.Commit(&err, c.major)
	values.Commit(&err, c.backlog)
	values.Commit(&err, c.bpt)

	return err
}

type AccountEventsMinor struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *AccountEvents

	blocks values.Set[uint64]
	votes  map[accountEventsMinorVotesMapKey]values.Set[*protocol.AuthoritySignature]
}

func (c *AccountEventsMinor) Key() *record.Key { return c.key }

type accountEventsMinorVotesKey struct {
	Block uint64
}

type accountEventsMinorVotesMapKey struct {
	Block uint64
}

func (k accountEventsMinorVotesKey) ForMap() accountEventsMinorVotesMapKey {
	return accountEventsMinorVotesMapKey{k.Block}
}

func (c *AccountEventsMinor) Blocks() values.Set[uint64] {
	return values.GetOrCreate(c, &c.blocks, (*AccountEventsMinor).newBlocks)
}

func (c *AccountEventsMinor) newBlocks() values.Set[uint64] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Blocks"), values.Wrapped(values.UintWrapper), values.CompareUint)
}

func (c *AccountEventsMinor) Votes(block uint64) values.Set[*protocol.AuthoritySignature] {
	return values.GetOrCreateMap(c, &c.votes, accountEventsMinorVotesKey{block}, (*AccountEventsMinor).newVotes)
}

func (c *AccountEventsMinor) baseNewVotes(k accountEventsMinorVotesKey) values.Set[*protocol.AuthoritySignature] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Votes", k.Block), values.Struct[protocol.AuthoritySignature](), compareHeldAuthSig)
}

func (c *AccountEventsMinor) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for minor (1)")
	}

	switch key.Get(0) {
	case "Blocks":
		return c.Blocks(), key.SliceI(1), nil
	case "Votes":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for minor (2)")
		}
		block, okBlock := key.Get(1).(uint64)
		if !okBlock {
			return nil, nil, errors.InternalError.With("bad key for minor (3)")
		}
		v := c.Votes(block)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for minor (4)")
	}
}

func (c *AccountEventsMinor) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.blocks) {
		return true
	}
	for _, v := range c.votes {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *AccountEventsMinor) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.blocks, c.newBlocks, opts, fn)
	values.WalkMap(&err, c.votes, c.newVotes, c.getVoteKeys, opts, fn)
	return err
}

func (c *AccountEventsMinor) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.blocks)
	for _, v := range c.votes {
		values.Commit(&err, v)
	}

	return err
}

type AccountEventsMajor struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *AccountEvents

	blocks  values.Set[uint64]
	pending map[accountEventsMajorPendingMapKey]values.Set[*url.TxID]
}

func (c *AccountEventsMajor) Key() *record.Key { return c.key }

type accountEventsMajorPendingKey struct {
	Block uint64
}

type accountEventsMajorPendingMapKey struct {
	Block uint64
}

func (k accountEventsMajorPendingKey) ForMap() accountEventsMajorPendingMapKey {
	return accountEventsMajorPendingMapKey{k.Block}
}

func (c *AccountEventsMajor) Blocks() values.Set[uint64] {
	return values.GetOrCreate(c, &c.blocks, (*AccountEventsMajor).newBlocks)
}

func (c *AccountEventsMajor) newBlocks() values.Set[uint64] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Blocks"), values.Wrapped(values.UintWrapper), values.CompareUint)
}

func (c *AccountEventsMajor) Pending(block uint64) values.Set[*url.TxID] {
	return values.GetOrCreateMap(c, &c.pending, accountEventsMajorPendingKey{block}, (*AccountEventsMajor).newPending)
}

func (c *AccountEventsMajor) baseNewPending(k accountEventsMajorPendingKey) values.Set[*url.TxID] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Pending", k.Block), values.Wrapped(values.TxidWrapper), values.CompareTxid)
}

func (c *AccountEventsMajor) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for major (1)")
	}

	switch key.Get(0) {
	case "Blocks":
		return c.Blocks(), key.SliceI(1), nil
	case "Pending":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for major (2)")
		}
		block, okBlock := key.Get(1).(uint64)
		if !okBlock {
			return nil, nil, errors.InternalError.With("bad key for major (3)")
		}
		v := c.Pending(block)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for major (4)")
	}
}

func (c *AccountEventsMajor) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.blocks) {
		return true
	}
	for _, v := range c.pending {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *AccountEventsMajor) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.blocks, c.newBlocks, opts, fn)
	values.WalkMap(&err, c.pending, c.newPending, c.getPendingKeys, opts, fn)
	return err
}

func (c *AccountEventsMajor) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.blocks)
	for _, v := range c.pending {
		values.Commit(&err, v)
	}

	return err
}

type AccountEventsBacklog struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *AccountEvents

	expired values.Set[*url.TxID]
}

func (c *AccountEventsBacklog) Key() *record.Key { return c.key }

func (c *AccountEventsBacklog) Expired() values.Set[*url.TxID] {
	return values.GetOrCreate(c, &c.expired, (*AccountEventsBacklog).newExpired)
}

func (c *AccountEventsBacklog) baseNewExpired() values.Set[*url.TxID] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Expired"), values.Wrapped(values.TxidWrapper), values.CompareTxid)
}

func (c *AccountEventsBacklog) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for backlog (1)")
	}

	switch key.Get(0) {
	case "Expired":
		return c.Expired(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for backlog (2)")
	}
}

func (c *AccountEventsBacklog) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.expired) {
		return true
	}

	return false
}

func (c *AccountEventsBacklog) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.expired, c.newExpired, opts, fn)
	return err
}

func (c *AccountEventsBacklog) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.expired)

	return err
}

type AccountTransaction struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *Account

	payments            values.Set[[32]byte]
	votes               values.Set[*VoteEntry]
	signatures          values.Set[*SignatureSetEntry]
	validatorSignatures values.Set[protocol.KeySignature]
	history             values.Set[uint64]
}

func (c *AccountTransaction) Key() *record.Key { return c.key }

func (c *AccountTransaction) Payments() values.Set[[32]byte] {
	return values.GetOrCreate(c, &c.payments, (*AccountTransaction).newPayments)
}

func (c *AccountTransaction) newPayments() values.Set[[32]byte] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Payments"), values.Wrapped(values.HashWrapper), values.CompareHash)
}

func (c *AccountTransaction) Votes() values.Set[*VoteEntry] {
	return values.GetOrCreate(c, &c.votes, (*AccountTransaction).newVotes)
}

func (c *AccountTransaction) newVotes() values.Set[*VoteEntry] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Votes"), values.Struct[VoteEntry](), compareVoteEntries)
}

func (c *AccountTransaction) Signatures() values.Set[*SignatureSetEntry] {
	return values.GetOrCreate(c, &c.signatures, (*AccountTransaction).newSignatures)
}

func (c *AccountTransaction) newSignatures() values.Set[*SignatureSetEntry] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Signatures"), values.Struct[SignatureSetEntry](), compareSignatureSetEntries)
}

func (c *AccountTransaction) ValidatorSignatures() values.Set[protocol.KeySignature] {
	return values.GetOrCreate(c, &c.validatorSignatures, (*AccountTransaction).newValidatorSignatures)
}

func (c *AccountTransaction) newValidatorSignatures() values.Set[protocol.KeySignature] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("ValidatorSignatures"), values.Union(protocol.UnmarshalKeySignature), compareSignatureByKey)
}

func (c *AccountTransaction) History() values.Set[uint64] {
	return values.GetOrCreate(c, &c.history, (*AccountTransaction).newHistory)
}

func (c *AccountTransaction) newHistory() values.Set[uint64] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("History"), values.Wrapped(values.UintWrapper), values.CompareUint)
}

func (c *AccountTransaction) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for transaction (1)")
	}

	switch key.Get(0) {
	case "Payments":
		return c.Payments(), key.SliceI(1), nil
	case "Votes":
		return c.Votes(), key.SliceI(1), nil
	case "Signatures":
		return c.Signatures(), key.SliceI(1), nil
	case "ValidatorSignatures":
		return c.ValidatorSignatures(), key.SliceI(1), nil
	case "History":
		return c.History(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for transaction (2)")
	}
}

func (c *AccountTransaction) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.payments) {
		return true
	}
	if values.IsDirty(c.votes) {
		return true
	}
	if values.IsDirty(c.signatures) {
		return true
	}
	if values.IsDirty(c.validatorSignatures) {
		return true
	}
	if values.IsDirty(c.history) {
		return true
	}

	return false
}

func (c *AccountTransaction) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.payments, c.newPayments, opts, fn)
	values.WalkField(&err, c.votes, c.newVotes, opts, fn)
	values.WalkField(&err, c.signatures, c.newSignatures, opts, fn)
	values.WalkField(&err, c.validatorSignatures, c.newValidatorSignatures, opts, fn)
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.history, c.newHistory, opts, fn)
	}
	return err
}

func (c *AccountTransaction) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.payments)
	values.Commit(&err, c.votes)
	values.Commit(&err, c.signatures)
	values.Commit(&err, c.validatorSignatures)
	values.Commit(&err, c.history)

	return err
}

type AccountAnchorChain struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *Account

	root *Chain2
	bpt  *Chain2
}

func (c *AccountAnchorChain) Key() *record.Key { return c.key }

func (c *AccountAnchorChain) Root() *Chain2 {
	return values.GetOrCreate(c, &c.root, (*AccountAnchorChain).newRoot)
}

func (c *AccountAnchorChain) newRoot() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("Root"), "anchor(%[4]v)-root")
}

func (c *AccountAnchorChain) BPT() *Chain2 {
	return values.GetOrCreate(c, &c.bpt, (*AccountAnchorChain).newBPT)
}

func (c *AccountAnchorChain) newBPT() *Chain2 {
	return newChain2(c, c.logger.L, c.store, c.key.Append("BPT"), "anchor(%[4]v)-bpt")
}

func (c *AccountAnchorChain) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for anchor chain (1)")
	}

	switch key.Get(0) {
	case "Root":
		return c.Root(), key.SliceI(1), nil
	case "BPT":
		return c.BPT(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for anchor chain (2)")
	}
}

func (c *AccountAnchorChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.root) {
		return true
	}
	if values.IsDirty(c.bpt) {
		return true
	}

	return false
}

func (c *AccountAnchorChain) dirtyChains() []*MerkleManager {
	if c == nil {
		return nil
	}

	var chains []*MerkleManager

	chains = append(chains, c.root.dirtyChains()...)
	chains = append(chains, c.bpt.dirtyChains()...)

	return chains
}

func (c *AccountAnchorChain) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.root, c.newRoot, opts, fn)
	values.WalkField(&err, c.bpt, c.newBPT, opts, fn)
	return err
}

func (c *AccountAnchorChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.root)
	values.Commit(&err, c.bpt)

	return err
}

type AccountData struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *Account

	entry       values.Counted[[32]byte]
	transaction map[accountDataTransactionMapKey]values.Value[[32]byte]
}

func (c *AccountData) Key() *record.Key { return c.key }

type accountDataTransactionKey struct {
	EntryHash [32]byte
}

type accountDataTransactionMapKey struct {
	EntryHash [32]byte
}

func (k accountDataTransactionKey) ForMap() accountDataTransactionMapKey {
	return accountDataTransactionMapKey{k.EntryHash}
}

func (c *AccountData) Entry() values.Counted[[32]byte] {
	return values.GetOrCreate(c, &c.entry, (*AccountData).newEntry)
}

func (c *AccountData) newEntry() values.Counted[[32]byte] {
	return values.NewCounted(c.logger.L, c.store, c.key.Append("Entry"), values.WrappedFactory(values.HashWrapper))
}

func (c *AccountData) Transaction(entryHash [32]byte) values.Value[[32]byte] {
	return values.GetOrCreateMap(c, &c.transaction, accountDataTransactionKey{entryHash}, (*AccountData).newTransaction)
}

func (c *AccountData) newTransaction(k accountDataTransactionKey) values.Value[[32]byte] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Transaction", k.EntryHash), false, values.Wrapped(values.HashWrapper))
}

func (c *AccountData) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for data (1)")
	}

	switch key.Get(0) {
	case "Entry":
		return c.Entry(), key.SliceI(1), nil
	case "Transaction":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for data (2)")
		}
		entryHash, okEntryHash := key.Get(1).([32]byte)
		if !okEntryHash {
			return nil, nil, errors.InternalError.With("bad key for data (3)")
		}
		v := c.Transaction(entryHash)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for data (4)")
	}
}

func (c *AccountData) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.entry) {
		return true
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *AccountData) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.entry, c.newEntry, opts, fn)
	}
	if !opts.IgnoreIndices {
		values.WalkMap(&err, c.transaction, c.newTransaction, nil, opts, fn)
	}
	return err
}

func (c *AccountData) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.entry)
	for _, v := range c.transaction {
		values.Commit(&err, v)
	}

	return err
}

type Message struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *Batch

	main     values.Value[messaging.Message]
	cause    values.Set[*url.TxID]
	produced values.Set[*url.TxID]
	signers  values.Set[*url.URL]
}

func (c *Message) Key() *record.Key { return c.key }

func (c *Message) getMain() values.Value[messaging.Message] {
	return values.GetOrCreate(c, &c.main, (*Message).newMain)
}

func (c *Message) newMain() values.Value[messaging.Message] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Main"), false, values.Union(messaging.UnmarshalMessage))
}

func (c *Message) Cause() values.Set[*url.TxID] {
	return values.GetOrCreate(c, &c.cause, (*Message).newCause)
}

func (c *Message) newCause() values.Set[*url.TxID] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Cause"), values.Wrapped(values.TxidWrapper), values.CompareTxid)
}

func (c *Message) Produced() values.Set[*url.TxID] {
	return values.GetOrCreate(c, &c.produced, (*Message).newProduced)
}

func (c *Message) newProduced() values.Set[*url.TxID] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Produced"), values.Wrapped(values.TxidWrapper), values.CompareTxid)
}

func (c *Message) Signers() values.Set[*url.URL] {
	return values.GetOrCreate(c, &c.signers, (*Message).newSigners)
}

func (c *Message) newSigners() values.Set[*url.URL] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Signers"), values.Wrapped(values.UrlWrapper), values.CompareUrl)
}

func (c *Message) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for message (1)")
	}

	switch key.Get(0) {
	case "Main":
		return c.getMain(), key.SliceI(1), nil
	case "Cause":
		return c.Cause(), key.SliceI(1), nil
	case "Produced":
		return c.Produced(), key.SliceI(1), nil
	case "Signers":
		return c.Signers(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for message (2)")
	}
}

func (c *Message) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.main) {
		return true
	}
	if values.IsDirty(c.cause) {
		return true
	}
	if values.IsDirty(c.produced) {
		return true
	}
	if values.IsDirty(c.signers) {
		return true
	}

	return false
}

func (c *Message) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.main, c.newMain, opts, fn)
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.cause, c.newCause, opts, fn)
	}
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.produced, c.newProduced, opts, fn)
	}
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.signers, c.newSigners, opts, fn)
	}
	return err
}

func (c *Message) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.main)
	values.Commit(&err, c.cause)
	values.Commit(&err, c.produced)
	values.Commit(&err, c.signers)

	return err
}

type Transaction struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *Batch

	main       values.Value[*SigOrTxn]
	status     values.Value[*protocol.TransactionStatus]
	produced   values.Set[*url.TxID]
	signatures map[transactionSignaturesMapKey]values.Value[*sigSetData]
	chains     values.Set[*TransactionChainEntry]
}

func (c *Transaction) Key() *record.Key { return c.key }

type transactionSignaturesKey struct {
	Signer *url.URL
}

type transactionSignaturesMapKey struct {
	Signer [32]byte
}

func (k transactionSignaturesKey) ForMap() transactionSignaturesMapKey {
	return transactionSignaturesMapKey{values.MapKeyUrl(k.Signer)}
}

func (c *Transaction) Main() values.Value[*SigOrTxn] {
	return values.GetOrCreate(c, &c.main, (*Transaction).newMain)
}

func (c *Transaction) newMain() values.Value[*SigOrTxn] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Main"), false, values.Struct[SigOrTxn]())
}

func (c *Transaction) getStatus() values.Value[*protocol.TransactionStatus] {
	return values.GetOrCreate(c, &c.status, (*Transaction).newStatus)
}

func (c *Transaction) newStatus() values.Value[*protocol.TransactionStatus] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Status"), true, values.Struct[protocol.TransactionStatus]())
}

func (c *Transaction) Produced() values.Set[*url.TxID] {
	return values.GetOrCreate(c, &c.produced, (*Transaction).newProduced)
}

func (c *Transaction) newProduced() values.Set[*url.TxID] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Produced"), values.Wrapped(values.TxidWrapper), values.CompareTxid)
}

func (c *Transaction) getSignatures(signer *url.URL) values.Value[*sigSetData] {
	return values.GetOrCreateMap(c, &c.signatures, transactionSignaturesKey{signer}, (*Transaction).newSignatures)
}

func (c *Transaction) newSignatures(k transactionSignaturesKey) values.Value[*sigSetData] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Signatures", k.Signer), true, values.Struct[sigSetData]())
}

func (c *Transaction) Chains() values.Set[*TransactionChainEntry] {
	return values.GetOrCreate(c, &c.chains, (*Transaction).newChains)
}

func (c *Transaction) newChains() values.Set[*TransactionChainEntry] {
	return values.NewSet(c.logger.L, c.store, c.key.Append("Chains"), values.Struct[TransactionChainEntry](), func(u, v *TransactionChainEntry) int { return u.Compare(v) })
}

func (c *Transaction) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for transaction (1)")
	}

	switch key.Get(0) {
	case "Main":
		return c.Main(), key.SliceI(1), nil
	case "Status":
		return c.getStatus(), key.SliceI(1), nil
	case "Produced":
		return c.Produced(), key.SliceI(1), nil
	case "Signatures":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for transaction (2)")
		}
		signer, okSigner := key.Get(1).(*url.URL)
		if !okSigner {
			return nil, nil, errors.InternalError.With("bad key for transaction (3)")
		}
		v := c.getSignatures(signer)
		return v, key.SliceI(2), nil
	case "Chains":
		return c.Chains(), key.SliceI(1), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for transaction (4)")
	}
}

func (c *Transaction) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.main) {
		return true
	}
	if values.IsDirty(c.status) {
		return true
	}
	if values.IsDirty(c.produced) {
		return true
	}
	for _, v := range c.signatures {
		if v.IsDirty() {
			return true
		}
	}
	if values.IsDirty(c.chains) {
		return true
	}

	return false
}

func (c *Transaction) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.main, c.newMain, opts, fn)
	values.WalkField(&err, c.status, c.newStatus, opts, fn)
	values.WalkField(&err, c.produced, c.newProduced, opts, fn)
	values.WalkMap(&err, c.signatures, c.newSignatures, nil, opts, fn)
	if !opts.IgnoreIndices {
		values.WalkField(&err, c.chains, c.newChains, opts, fn)
	}
	return err
}

func (c *Transaction) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.main)
	values.Commit(&err, c.status)
	values.Commit(&err, c.produced)
	for _, v := range c.signatures {
		values.Commit(&err, v)
	}
	values.Commit(&err, c.chains)

	return err
}

type SystemData struct {
	logger logging.OptionalLogger
	store  record.Store
	key    *record.Key
	parent *Batch

	syntheticIndexIndex map[systemDataSyntheticIndexIndexMapKey]values.Value[uint64]
}

func (c *SystemData) Key() *record.Key { return c.key }

type systemDataSyntheticIndexIndexKey struct {
	Block uint64
}

type systemDataSyntheticIndexIndexMapKey struct {
	Block uint64
}

func (k systemDataSyntheticIndexIndexKey) ForMap() systemDataSyntheticIndexIndexMapKey {
	return systemDataSyntheticIndexIndexMapKey{k.Block}
}

func (c *SystemData) SyntheticIndexIndex(block uint64) values.Value[uint64] {
	return values.GetOrCreateMap(c, &c.syntheticIndexIndex, systemDataSyntheticIndexIndexKey{block}, (*SystemData).newSyntheticIndexIndex)
}

func (c *SystemData) newSyntheticIndexIndex(k systemDataSyntheticIndexIndexKey) values.Value[uint64] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("SyntheticIndexIndex", k.Block), false, values.Wrapped(values.UintWrapper))
}

func (c *SystemData) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for system data (1)")
	}

	switch key.Get(0) {
	case "SyntheticIndexIndex":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for system data (2)")
		}
		block, okBlock := key.Get(1).(uint64)
		if !okBlock {
			return nil, nil, errors.InternalError.With("bad key for system data (3)")
		}
		v := c.SyntheticIndexIndex(block)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for system data (4)")
	}
}

func (c *SystemData) IsDirty() bool {
	if c == nil {
		return false
	}

	for _, v := range c.syntheticIndexIndex {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *SystemData) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	if !opts.IgnoreIndices {
		values.WalkMap(&err, c.syntheticIndexIndex, c.newSyntheticIndexIndex, nil, opts, fn)
	}
	return err
}

func (c *SystemData) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	for _, v := range c.syntheticIndexIndex {
		values.Commit(&err, v)
	}

	return err
}

type MerkleManager struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       *record.Key
	typ       merkle.ChainType
	name      string
	markPower int64
	markFreq  int64
	markMask  int64

	head         values.Value[*merkle.State]
	states       map[merkleManagerStatesMapKey]values.Value[*merkle.State]
	elementIndex map[merkleManagerElementIndexMapKey]values.Value[uint64]
	element      map[merkleManagerElementMapKey]values.Value[[]byte]
}

func (c *MerkleManager) Key() *record.Key { return c.key }

type merkleManagerStatesKey struct {
	Index uint64
}

type merkleManagerStatesMapKey struct {
	Index uint64
}

func (k merkleManagerStatesKey) ForMap() merkleManagerStatesMapKey {
	return merkleManagerStatesMapKey{k.Index}
}

type merkleManagerElementIndexKey struct {
	Hash []byte
}

type merkleManagerElementIndexMapKey struct {
	Hash [32]byte
}

func (k merkleManagerElementIndexKey) ForMap() merkleManagerElementIndexMapKey {
	return merkleManagerElementIndexMapKey{values.MapKeyBytes(k.Hash)}
}

type merkleManagerElementKey struct {
	Index uint64
}

type merkleManagerElementMapKey struct {
	Index uint64
}

func (k merkleManagerElementKey) ForMap() merkleManagerElementMapKey {
	return merkleManagerElementMapKey{k.Index}
}

func (c *MerkleManager) Head() values.Value[*merkle.State] {
	return values.GetOrCreate(c, &c.head, (*MerkleManager).newHead)
}

func (c *MerkleManager) newHead() values.Value[*merkle.State] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Head"), true, values.Struct[merkle.State]())
}

func (c *MerkleManager) States(index uint64) values.Value[*merkle.State] {
	return values.GetOrCreateMap(c, &c.states, merkleManagerStatesKey{index}, (*MerkleManager).newStates)
}

func (c *MerkleManager) newStates(k merkleManagerStatesKey) values.Value[*merkle.State] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("States", k.Index), false, values.Struct[merkle.State]())
}

func (c *MerkleManager) ElementIndex(hash []byte) values.Value[uint64] {
	return values.GetOrCreateMap(c, &c.elementIndex, merkleManagerElementIndexKey{hash}, (*MerkleManager).newElementIndex)
}

func (c *MerkleManager) newElementIndex(k merkleManagerElementIndexKey) values.Value[uint64] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("ElementIndex", k.Hash), false, values.Wrapped(values.UintWrapper))
}

func (c *MerkleManager) Element(index uint64) values.Value[[]byte] {
	return values.GetOrCreateMap(c, &c.element, merkleManagerElementKey{index}, (*MerkleManager).newElement)
}

func (c *MerkleManager) newElement(k merkleManagerElementKey) values.Value[[]byte] {
	return values.NewValue(c.logger.L, c.store, c.key.Append("Element", k.Index), false, values.Wrapped(values.BytesWrapper))
}

func (c *MerkleManager) Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for merkle manager (1)")
	}

	switch key.Get(0) {
	case "Head":
		return c.Head(), key.SliceI(1), nil
	case "States":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (2)")
		}
		index, okIndex := key.Get(1).(uint64)
		if !okIndex {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (3)")
		}
		v := c.States(index)
		return v, key.SliceI(2), nil
	case "ElementIndex":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (4)")
		}
		hash, okHash := key.Get(1).([]byte)
		if !okHash {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (5)")
		}
		v := c.ElementIndex(hash)
		return v, key.SliceI(2), nil
	case "Element":
		if key.Len() < 2 {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (6)")
		}
		index, okIndex := key.Get(1).(uint64)
		if !okIndex {
			return nil, nil, errors.InternalError.With("bad key for merkle manager (7)")
		}
		v := c.Element(index)
		return v, key.SliceI(2), nil
	default:
		return nil, nil, errors.InternalError.With("bad key for merkle manager (8)")
	}
}

func (c *MerkleManager) IsDirty() bool {
	if c == nil {
		return false
	}

	if values.IsDirty(c.head) {
		return true
	}
	for _, v := range c.states {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.elementIndex {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.element {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *MerkleManager) Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}
	values.WalkField(&err, c.head, c.newHead, opts, fn)
	values.WalkMap(&err, c.states, c.newStates, c.getMarkPoints, opts, fn)
	if !opts.IgnoreIndices {
		values.WalkMap(&err, c.elementIndex, c.newElementIndex, nil, opts, fn)
	}
	if !opts.IgnoreIndices {
		values.WalkMap(&err, c.element, c.newElement, nil, opts, fn)
	}
	return err
}

func (c *MerkleManager) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	values.Commit(&err, c.head)
	for _, v := range c.states {
		values.Commit(&err, v)
	}
	for _, v := range c.elementIndex {
		values.Commit(&err, v)
	}
	for _, v := range c.element {
		values.Commit(&err, v)
	}

	return err
}
