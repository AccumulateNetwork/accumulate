package database

// GENERATED BY go run ./tools/cmd/gen-record. DO NOT EDIT.

import (
	"gitlab.com/accumulatenetwork/accumulate/internal/database/record"
	"gitlab.com/accumulatenetwork/accumulate/internal/errors"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/smt/managed"
	"gitlab.com/accumulatenetwork/accumulate/smt/storage"
)

type ChangeSet struct {
	logger   logging.OptionalLogger
	store    record.Store
	done     bool
	writable bool
	id       string
	nextId   uint64
	kvStore  storage.KeyValueTxn

	account     map[storage.Key]*Account
	transaction map[storage.Key]*Transaction
}

func (c *ChangeSet) Account(url *url.URL) *Account {
	return getOrCreateMap(&c.account, record.Key{}.Append("Account", url), func() *Account {
		v := new(Account)
		v.logger = c.logger
		v.store = c.store
		v.key = record.Key{}.Append("Account", url)
		v.container = c
		return v
	})
}

func (c *ChangeSet) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Account":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for change set")
		}
		url, okUrl := key[1].(*url.URL)
		if !okUrl {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for change set")
		}
		v := c.Account(url)
		return v, key[2:], nil
	case "Transaction":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for change set")
		}
		hash, okHash := key[1].([]byte)
		if !okHash {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for change set")
		}
		v := c.Transaction(hash)
		return v, key[2:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for change set")
	}
}

func (c *ChangeSet) IsDirty() bool {
	if c == nil {
		return false
	}

	for _, v := range c.account {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *ChangeSet) dirtyChains() []*managed.Chain {
	if c == nil {
		return nil
	}

	var chains []*managed.Chain

	for _, v := range c.account {
		chains = append(chains, v.dirtyChains()...)
	}

	return chains
}

func (c *ChangeSet) baseCommit() error {
	if c == nil {
		return nil
	}

	var err error
	for _, v := range c.account {
		commitField(&err, v)
	}
	for _, v := range c.transaction {
		commitField(&err, v)
	}

	return nil
}

type Account struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       record.Key
	container *ChangeSet

	state                         *record.Wrapped[protocol.Account]
	pending                       *record.Set[*url.TxID]
	syntheticForAnchor            map[storage.Key]*record.Set[*url.TxID]
	mainChain                     *managed.Chain
	signatureChain                *managed.Chain
	rootChain                     *AccountRootChain
	syntheticChain                *managed.Chain
	anchorChain                   map[storage.Key]*AccountAnchorChain
	mainIndexChain                *MajorMinorIndexChain
	signatureIndexChain           *MajorMinorIndexChain
	syntheticIndexChain           *MajorMinorIndexChain
	rootIndexChain                *MajorMinorIndexChain
	anchorIndexChain              map[storage.Key]*AccountAnchorIndexChain
	syntheticProducedChain        map[storage.Key]*managed.Chain
	chains                        *record.Set[*protocol.ChainMetadata]
	syntheticAnchors              *record.Set[[32]byte]
	directory                     *record.Counted[*url.URL]
	data                          *AccountData
	blockChainUpdates             *record.Set[*ChainUpdate]
	producedSyntheticTransactions *record.Set[*BlockStateSynthTxnEntry]
}

func (c *Account) State() *record.Wrapped[protocol.Account] {
	return getOrCreateField(&c.state, func() *record.Wrapped[protocol.Account] {
		return record.NewWrapped(c.logger.L, c.store, c.key.Append("State"), "account %[2]v state", false, record.NewWrapper(record.UnionWrapper(protocol.UnmarshalAccount)))
	})
}

func (c *Account) Pending() *record.Set[*url.TxID] {
	return getOrCreateField(&c.pending, func() *record.Set[*url.TxID] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("Pending"), "account %[2]v pending", record.NewWrapperSlice(record.TxidWrapper), record.CompareTxid)
	})
}

func (c *Account) SyntheticForAnchor(anchor [32]byte) *record.Set[*url.TxID] {
	return getOrCreateMap(&c.syntheticForAnchor, c.key.Append("SyntheticForAnchor", anchor), func() *record.Set[*url.TxID] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("SyntheticForAnchor", anchor), "account %[2]v synthetic for anchor %[4]x", record.NewWrapperSlice(record.TxidWrapper), record.CompareTxid)
	})
}

func (c *Account) MainChain() *managed.Chain {
	return getOrCreateField(&c.mainChain, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("MainChain"), markPower, managed.ChainTypeTransaction, "main", "account %[2]v main chain")
	})
}

func (c *Account) SignatureChain() *managed.Chain {
	return getOrCreateField(&c.signatureChain, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("SignatureChain"), markPower, managed.ChainTypeTransaction, "signature", "account %[2]v signature chain")
	})
}

func (c *Account) RootChain() *AccountRootChain {
	return getOrCreateField(&c.rootChain, func() *AccountRootChain {
		v := new(AccountRootChain)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("RootChain")
		v.container = c
		return v
	})
}

func (c *Account) SyntheticChain() *managed.Chain {
	return getOrCreateField(&c.syntheticChain, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("SyntheticChain"), markPower, managed.ChainTypeTransaction, "synthetic", "account %[2]v synthetic chain")
	})
}

func (c *Account) AnchorChain(subnetId string) *AccountAnchorChain {
	return getOrCreateMap(&c.anchorChain, c.key.Append("AnchorChain", subnetId), func() *AccountAnchorChain {
		v := new(AccountAnchorChain)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("AnchorChain", subnetId)
		v.container = c
		return v
	})
}

func (c *Account) MainIndexChain() *MajorMinorIndexChain {
	return getOrCreateField(&c.mainIndexChain, func() *MajorMinorIndexChain {
		return newMajorMinorIndexChain(c, c.logger.L, c.store, c.key.Append("MainIndexChain"), "main-index", "account %[2]v main index chain")
	})
}

func (c *Account) SignatureIndexChain() *MajorMinorIndexChain {
	return getOrCreateField(&c.signatureIndexChain, func() *MajorMinorIndexChain {
		return newMajorMinorIndexChain(c, c.logger.L, c.store, c.key.Append("SignatureIndexChain"), "signature-index", "account %[2]v signature index chain")
	})
}

func (c *Account) SyntheticIndexChain() *MajorMinorIndexChain {
	return getOrCreateField(&c.syntheticIndexChain, func() *MajorMinorIndexChain {
		return newMajorMinorIndexChain(c, c.logger.L, c.store, c.key.Append("SyntheticIndexChain"), "synthetic-index", "account %[2]v synthetic index chain")
	})
}

func (c *Account) RootIndexChain() *MajorMinorIndexChain {
	return getOrCreateField(&c.rootIndexChain, func() *MajorMinorIndexChain {
		return newMajorMinorIndexChain(c, c.logger.L, c.store, c.key.Append("RootIndexChain"), "root-index", "account %[2]v root index chain")
	})
}

func (c *Account) AnchorIndexChain(subnetId string) *AccountAnchorIndexChain {
	return getOrCreateMap(&c.anchorIndexChain, c.key.Append("AnchorIndexChain", subnetId), func() *AccountAnchorIndexChain {
		v := new(AccountAnchorIndexChain)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("AnchorIndexChain", subnetId)
		v.container = c
		return v
	})
}

func (c *Account) SyntheticProducedChain(subnetId string) *managed.Chain {
	return getOrCreateMap(&c.syntheticProducedChain, c.key.Append("SyntheticProducedChain", subnetId), func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("SyntheticProducedChain", subnetId), markPower, managed.ChainTypeIndex, "synthetic-produced(%[4]v)", "account %[2]v synthetic produced chain %[4]v")
	})
}

func (c *Account) Chains() *record.Set[*protocol.ChainMetadata] {
	return getOrCreateField(&c.chains, func() *record.Set[*protocol.ChainMetadata] {
		new := func() (v *protocol.ChainMetadata) { return new(protocol.ChainMetadata) }
		cmp := func(u, v *protocol.ChainMetadata) int { return u.Compare(v) }
		return record.NewSet(c.logger.L, c.store, c.key.Append("Chains"), "account %[2]v chains", record.NewSlice(new), cmp)
	})
}

func (c *Account) SyntheticAnchors() *record.Set[[32]byte] {
	return getOrCreateField(&c.syntheticAnchors, func() *record.Set[[32]byte] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("SyntheticAnchors"), "account %[2]v synthetic anchors", record.NewWrapperSlice(record.HashWrapper), record.CompareHash)
	})
}

func (c *Account) Directory() *record.Counted[*url.URL] {
	return getOrCreateField(&c.directory, func() *record.Counted[*url.URL] {

		return record.NewCounted(c.logger.L, c.store, c.key.Append("Directory"), "account %[2]v directory", record.NewCountableWrapped(record.UrlWrapper))
	})
}

func (c *Account) Data() *AccountData {
	return getOrCreateField(&c.data, func() *AccountData {
		v := new(AccountData)
		v.logger = c.logger
		v.store = c.store
		v.key = c.key.Append("Data")
		v.container = c
		return v
	})
}

func (c *Account) BlockChainUpdates() *record.Set[*ChainUpdate] {
	return getOrCreateField(&c.blockChainUpdates, func() *record.Set[*ChainUpdate] {
		new := func() (v *ChainUpdate) { return new(ChainUpdate) }
		cmp := func(u, v *ChainUpdate) int { return u.Compare(v) }
		return record.NewSet(c.logger.L, c.store, c.key.Append("BlockChainUpdates"), "account %[2]v block chain updates", record.NewSlice(new), cmp)
	})
}

func (c *Account) ProducedSyntheticTransactions() *record.Set[*BlockStateSynthTxnEntry] {
	return getOrCreateField(&c.producedSyntheticTransactions, func() *record.Set[*BlockStateSynthTxnEntry] {
		new := func() (v *BlockStateSynthTxnEntry) { return new(BlockStateSynthTxnEntry) }
		cmp := func(u, v *BlockStateSynthTxnEntry) int { return u.Compare(v) }
		return record.NewSet(c.logger.L, c.store, c.key.Append("ProducedSyntheticTransactions"), "account %[2]v produced synthetic transactions", record.NewSlice(new), cmp)
	})
}

func (c *Account) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "State":
		return c.State(), key[1:], nil
	case "Pending":
		return c.Pending(), key[1:], nil
	case "SyntheticForAnchor":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		anchor, okAnchor := key[1].([32]byte)
		if !okAnchor {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		v := c.SyntheticForAnchor(anchor)
		return v, key[2:], nil
	case "MainChain":
		return c.MainChain(), key[1:], nil
	case "SignatureChain":
		return c.SignatureChain(), key[1:], nil
	case "RootChain":
		return c.RootChain(), key[1:], nil
	case "SyntheticChain":
		return c.SyntheticChain(), key[1:], nil
	case "AnchorChain":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		subnetId, okSubnetId := key[1].(string)
		if !okSubnetId {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		v := c.AnchorChain(subnetId)
		return v, key[2:], nil
	case "MainIndexChain":
		return c.MainIndexChain(), key[1:], nil
	case "SignatureIndexChain":
		return c.SignatureIndexChain(), key[1:], nil
	case "SyntheticIndexChain":
		return c.SyntheticIndexChain(), key[1:], nil
	case "RootIndexChain":
		return c.RootIndexChain(), key[1:], nil
	case "AnchorIndexChain":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		subnetId, okSubnetId := key[1].(string)
		if !okSubnetId {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		v := c.AnchorIndexChain(subnetId)
		return v, key[2:], nil
	case "SyntheticProducedChain":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		subnetId, okSubnetId := key[1].(string)
		if !okSubnetId {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
		}
		v := c.SyntheticProducedChain(subnetId)
		return v, key[2:], nil
	case "Chains":
		return c.Chains(), key[1:], nil
	case "SyntheticAnchors":
		return c.SyntheticAnchors(), key[1:], nil
	case "Directory":
		return c.Directory(), key[1:], nil
	case "Data":
		return c.Data(), key[1:], nil
	case "BlockChainUpdates":
		return c.BlockChainUpdates(), key[1:], nil
	case "ProducedSyntheticTransactions":
		return c.ProducedSyntheticTransactions(), key[1:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for account")
	}
}

func (c *Account) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.state) {
		return true
	}
	if fieldIsDirty(c.pending) {
		return true
	}
	for _, v := range c.syntheticForAnchor {
		if v.IsDirty() {
			return true
		}
	}
	if fieldIsDirty(c.mainChain) {
		return true
	}
	if fieldIsDirty(c.signatureChain) {
		return true
	}
	if fieldIsDirty(c.rootChain) {
		return true
	}
	if fieldIsDirty(c.syntheticChain) {
		return true
	}
	for _, v := range c.anchorChain {
		if v.IsDirty() {
			return true
		}
	}
	if fieldIsDirty(c.mainIndexChain) {
		return true
	}
	if fieldIsDirty(c.signatureIndexChain) {
		return true
	}
	if fieldIsDirty(c.syntheticIndexChain) {
		return true
	}
	if fieldIsDirty(c.rootIndexChain) {
		return true
	}
	for _, v := range c.anchorIndexChain {
		if v.IsDirty() {
			return true
		}
	}
	for _, v := range c.syntheticProducedChain {
		if v.IsDirty() {
			return true
		}
	}
	if fieldIsDirty(c.chains) {
		return true
	}
	if fieldIsDirty(c.syntheticAnchors) {
		return true
	}
	if fieldIsDirty(c.directory) {
		return true
	}
	if fieldIsDirty(c.data) {
		return true
	}
	if fieldIsDirty(c.blockChainUpdates) {
		return true
	}
	if fieldIsDirty(c.producedSyntheticTransactions) {
		return true
	}

	return false
}

func (c *Account) resolveChain(name string) (chain *managed.Chain, ok bool) {
	if name == "main" {
		return c.MainChain(), true
	}
	if name == "signature" {
		return c.SignatureChain(), true
	}
	if name == "synthetic" {
		return c.SyntheticChain(), true
	}
	tryResolveChain(&chain, &ok, name, "root-", c.RootChain)
	tryResolveChainParam(&chain, &ok, name, "anchor(", 1, func(params []string, name string) (*managed.Chain, bool) {
		ok := true
		paramSubnetId := parseChainParam(&ok, params[0], record.ParseString)
		if !ok {
			return nil, false
		}

		return c.AnchorChain(paramSubnetId).resolveChain(name)
	})
	tryResolveChain(&chain, &ok, name, "main-index-", c.MainIndexChain)
	tryResolveChain(&chain, &ok, name, "signature-index-", c.SignatureIndexChain)
	tryResolveChain(&chain, &ok, name, "synthetic-index-", c.SyntheticIndexChain)
	tryResolveChain(&chain, &ok, name, "root-index-", c.RootIndexChain)
	tryResolveChainParam(&chain, &ok, name, "anchor-index(", 1, func(params []string, name string) (*managed.Chain, bool) {
		ok := true
		paramSubnetId := parseChainParam(&ok, params[0], record.ParseString)
		if !ok {
			return nil, false
		}

		return c.AnchorIndexChain(paramSubnetId).resolveChain(name)
	})
	tryResolveChainParam(&chain, &ok, name, "synthetic-produced(", 1, func(params []string, name string) (*managed.Chain, bool) {
		ok := true
		paramSubnetId := parseChainParam(&ok, params[0], record.ParseString)
		if !ok {
			return nil, false
		}

		return c.SyntheticProducedChain(paramSubnetId), true
	})
	return
}

func (c *Account) dirtyChains() []*managed.Chain {
	if c == nil {
		return nil
	}

	var chains []*managed.Chain

	if fieldIsDirty(c.mainChain) {
		chains = append(chains, c.mainChain)
	}
	if fieldIsDirty(c.signatureChain) {
		chains = append(chains, c.signatureChain)
	}
	chains = append(chains, c.rootChain.dirtyChains()...)
	if fieldIsDirty(c.syntheticChain) {
		chains = append(chains, c.syntheticChain)
	}
	for _, v := range c.anchorChain {
		chains = append(chains, v.dirtyChains()...)
	}
	chains = append(chains, c.mainIndexChain.dirtyChains()...)
	chains = append(chains, c.signatureIndexChain.dirtyChains()...)
	chains = append(chains, c.syntheticIndexChain.dirtyChains()...)
	chains = append(chains, c.rootIndexChain.dirtyChains()...)
	for _, v := range c.anchorIndexChain {
		chains = append(chains, v.dirtyChains()...)
	}
	for _, v := range c.syntheticProducedChain {
		if v.IsDirty() {
			chains = append(chains, v)
		}
	}

	return chains
}

func (c *Account) baseCommit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.state)
	commitField(&err, c.pending)
	for _, v := range c.syntheticForAnchor {
		commitField(&err, v)
	}
	commitField(&err, c.mainChain)
	commitField(&err, c.signatureChain)
	commitField(&err, c.rootChain)
	commitField(&err, c.syntheticChain)
	for _, v := range c.anchorChain {
		commitField(&err, v)
	}
	commitField(&err, c.mainIndexChain)
	commitField(&err, c.signatureIndexChain)
	commitField(&err, c.syntheticIndexChain)
	commitField(&err, c.rootIndexChain)
	for _, v := range c.anchorIndexChain {
		commitField(&err, v)
	}
	for _, v := range c.syntheticProducedChain {
		commitField(&err, v)
	}
	commitField(&err, c.chains)
	commitField(&err, c.syntheticAnchors)
	commitField(&err, c.directory)
	commitField(&err, c.data)
	commitField(&err, c.blockChainUpdates)
	commitField(&err, c.producedSyntheticTransactions)

	return nil
}

type AccountRootChain struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       record.Key
	container *Account

	minor *managed.Chain
	major *managed.Chain
}

func (c *AccountRootChain) Minor() *managed.Chain {
	return getOrCreateField(&c.minor, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("Minor"), markPower, managed.ChainTypeAnchor, "root-minor", "account %[2]v root chain minor")
	})
}

func (c *AccountRootChain) Major() *managed.Chain {
	return getOrCreateField(&c.major, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("Major"), markPower, managed.ChainTypeAnchor, "root-major", "account %[2]v root chain major")
	})
}

func (c *AccountRootChain) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Minor":
		return c.Minor(), key[1:], nil
	case "Major":
		return c.Major(), key[1:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for root chain")
	}
}

func (c *AccountRootChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.minor) {
		return true
	}
	if fieldIsDirty(c.major) {
		return true
	}

	return false
}

func (c *AccountRootChain) resolveChain(name string) (chain *managed.Chain, ok bool) {
	if name == "minor" {
		return c.Minor(), true
	}
	if name == "major" {
		return c.Major(), true
	}
	return
}

func (c *AccountRootChain) dirtyChains() []*managed.Chain {
	if c == nil {
		return nil
	}

	var chains []*managed.Chain

	if fieldIsDirty(c.minor) {
		chains = append(chains, c.minor)
	}
	if fieldIsDirty(c.major) {
		chains = append(chains, c.major)
	}

	return chains
}

func (c *AccountRootChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.minor)
	commitField(&err, c.major)

	return nil
}

type AccountAnchorChain struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       record.Key
	container *Account

	root *managed.Chain
	bpt  *managed.Chain
}

func (c *AccountAnchorChain) Root() *managed.Chain {
	return getOrCreateField(&c.root, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("Root"), markPower, managed.ChainTypeAnchor, "anchor(%[4]v)-root", "account %[2]v anchor chain %[4]v root")
	})
}

func (c *AccountAnchorChain) BPT() *managed.Chain {
	return getOrCreateField(&c.bpt, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("BPT"), markPower, managed.ChainTypeAnchor, "anchor(%[4]v)-bpt", "account %[2]v anchor chain %[4]v bpt")
	})
}

func (c *AccountAnchorChain) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Root":
		return c.Root(), key[1:], nil
	case "BPT":
		return c.BPT(), key[1:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for anchor chain")
	}
}

func (c *AccountAnchorChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.root) {
		return true
	}
	if fieldIsDirty(c.bpt) {
		return true
	}

	return false
}

func (c *AccountAnchorChain) resolveChain(name string) (chain *managed.Chain, ok bool) {
	if name == "root" {
		return c.Root(), true
	}
	if name == "bpt" {
		return c.BPT(), true
	}
	return
}

func (c *AccountAnchorChain) dirtyChains() []*managed.Chain {
	if c == nil {
		return nil
	}

	var chains []*managed.Chain

	if fieldIsDirty(c.root) {
		chains = append(chains, c.root)
	}
	if fieldIsDirty(c.bpt) {
		chains = append(chains, c.bpt)
	}

	return chains
}

func (c *AccountAnchorChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.root)
	commitField(&err, c.bpt)

	return nil
}

type AccountAnchorIndexChain struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       record.Key
	container *Account

	root *MajorMinorIndexChain
	bpt  *MajorMinorIndexChain
}

func (c *AccountAnchorIndexChain) Root() *MajorMinorIndexChain {
	return getOrCreateField(&c.root, func() *MajorMinorIndexChain {
		return newMajorMinorIndexChain(c, c.logger.L, c.store, c.key.Append("Root"), "anchor-index(%[4]v)-root", "account %[2]v anchor index chain %[4]v root")
	})
}

func (c *AccountAnchorIndexChain) BPT() *MajorMinorIndexChain {
	return getOrCreateField(&c.bpt, func() *MajorMinorIndexChain {
		return newMajorMinorIndexChain(c, c.logger.L, c.store, c.key.Append("BPT"), "anchor-index(%[4]v)-bpt", "account %[2]v anchor index chain %[4]v bpt")
	})
}

func (c *AccountAnchorIndexChain) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Root":
		return c.Root(), key[1:], nil
	case "BPT":
		return c.BPT(), key[1:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for anchor index chain")
	}
}

func (c *AccountAnchorIndexChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.root) {
		return true
	}
	if fieldIsDirty(c.bpt) {
		return true
	}

	return false
}

func (c *AccountAnchorIndexChain) resolveChain(name string) (chain *managed.Chain, ok bool) {
	tryResolveChain(&chain, &ok, name, "root-", c.Root)
	tryResolveChain(&chain, &ok, name, "bpt-", c.BPT)
	return
}

func (c *AccountAnchorIndexChain) dirtyChains() []*managed.Chain {
	if c == nil {
		return nil
	}

	var chains []*managed.Chain

	chains = append(chains, c.root.dirtyChains()...)
	chains = append(chains, c.bpt.dirtyChains()...)

	return chains
}

func (c *AccountAnchorIndexChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.root)
	commitField(&err, c.bpt)

	return nil
}

type AccountData struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       record.Key
	container *Account

	entry       *record.Counted[[32]byte]
	transaction map[storage.Key]*record.Wrapped[[32]byte]
}

func (c *AccountData) Entry() *record.Counted[[32]byte] {
	return getOrCreateField(&c.entry, func() *record.Counted[[32]byte] {

		return record.NewCounted(c.logger.L, c.store, c.key.Append("Entry"), "account %[2]v data entry", record.NewCountableWrapped(record.HashWrapper))
	})
}

func (c *AccountData) Transaction(entryHash [32]byte) *record.Wrapped[[32]byte] {
	return getOrCreateMap(&c.transaction, c.key.Append("Transaction", entryHash), func() *record.Wrapped[[32]byte] {
		return record.NewWrapped(c.logger.L, c.store, c.key.Append("Transaction", entryHash), "account %[2]v data transaction %[5]x", false, record.NewWrapper(record.HashWrapper))
	})
}

func (c *AccountData) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Entry":
		return c.Entry(), key[1:], nil
	case "Transaction":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for data")
		}
		entryHash, okEntryHash := key[1].([32]byte)
		if !okEntryHash {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for data")
		}
		v := c.Transaction(entryHash)
		return v, key[2:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for data")
	}
}

func (c *AccountData) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.entry) {
		return true
	}
	for _, v := range c.transaction {
		if v.IsDirty() {
			return true
		}
	}

	return false
}

func (c *AccountData) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.entry)
	for _, v := range c.transaction {
		commitField(&err, v)
	}

	return nil
}

type Transaction struct {
	logger    logging.OptionalLogger
	store     record.Store
	key       record.Key
	container *ChangeSet

	value            *record.Value[*protocol.Transaction]
	status           *record.Value[*protocol.TransactionStatus]
	produced         *record.Set[*url.TxID]
	systemSignatures *SystemSignatureSet
	signatures       map[storage.Key]*VersionedSignatureSet
	signers          *record.Set[*url.URL]
	chains           *record.Set[*TransactionChainEntry]
	signature        *record.Wrapped[protocol.Signature]
	txID             *record.Wrapped[*url.TxID]
}

func (c *Transaction) Value() *record.Value[*protocol.Transaction] {
	return getOrCreateField(&c.value, func() *record.Value[*protocol.Transaction] {
		new := func() (v *protocol.Transaction) { return new(protocol.Transaction) }
		return record.NewValue(c.logger.L, c.store, c.key.Append("Value"), "transaction %[2]x value", false, new)
	})
}

func (c *Transaction) Status() *record.Value[*protocol.TransactionStatus] {
	return getOrCreateField(&c.status, func() *record.Value[*protocol.TransactionStatus] {
		new := func() (v *protocol.TransactionStatus) { return new(protocol.TransactionStatus) }
		return record.NewValue(c.logger.L, c.store, c.key.Append("Status"), "transaction %[2]x status", true, new)
	})
}

func (c *Transaction) Produced() *record.Set[*url.TxID] {
	return getOrCreateField(&c.produced, func() *record.Set[*url.TxID] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("Produced"), "transaction %[2]x produced", record.NewWrapperSlice(record.TxidWrapper), record.CompareTxid)
	})
}

func (c *Transaction) SystemSignatures() *SystemSignatureSet {
	return getOrCreateField(&c.systemSignatures, func() *SystemSignatureSet {
		return newSystemSignatureSet(c, c.logger.L, c.store, c.key.Append("SystemSignatures"), "transaction(%[2]x)-system-signatures", "transaction %[2]x system signatures")
	})
}

func (c *Transaction) Signers() *record.Set[*url.URL] {
	return getOrCreateField(&c.signers, func() *record.Set[*url.URL] {
		return record.NewSet(c.logger.L, c.store, c.key.Append("Signers"), "transaction %[2]x signers", record.NewWrapperSlice(record.UrlWrapper), record.CompareUrl)
	})
}

func (c *Transaction) Chains() *record.Set[*TransactionChainEntry] {
	return getOrCreateField(&c.chains, func() *record.Set[*TransactionChainEntry] {
		new := func() (v *TransactionChainEntry) { return new(TransactionChainEntry) }
		cmp := func(u, v *TransactionChainEntry) int { return u.Compare(v) }
		return record.NewSet(c.logger.L, c.store, c.key.Append("Chains"), "transaction %[2]x chains", record.NewSlice(new), cmp)
	})
}

func (c *Transaction) Signature() *record.Wrapped[protocol.Signature] {
	return getOrCreateField(&c.signature, func() *record.Wrapped[protocol.Signature] {
		return record.NewWrapped(c.logger.L, c.store, c.key.Append("Signature"), "transaction %[2]x signature", false, record.NewWrapper(record.UnionWrapper(protocol.UnmarshalSignature)))
	})
}

func (c *Transaction) TxID() *record.Wrapped[*url.TxID] {
	return getOrCreateField(&c.txID, func() *record.Wrapped[*url.TxID] {
		return record.NewWrapped(c.logger.L, c.store, c.key.Append("TxID"), "transaction %[2]x tx id", false, record.NewWrapper(record.TxidWrapper))
	})
}

func (c *Transaction) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Value":
		return c.Value(), key[1:], nil
	case "Status":
		return c.Status(), key[1:], nil
	case "Produced":
		return c.Produced(), key[1:], nil
	case "SystemSignatures":
		return c.SystemSignatures(), key[1:], nil
	case "Signatures":
		if len(key) < 2 {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for transaction")
		}
		signer, okSigner := key[1].(*url.URL)
		if !okSigner {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for transaction")
		}
		v := c.Signatures(signer)
		return v, key[2:], nil
	case "Signers":
		return c.Signers(), key[1:], nil
	case "Chains":
		return c.Chains(), key[1:], nil
	case "Signature":
		return c.Signature(), key[1:], nil
	case "TxID":
		return c.TxID(), key[1:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for transaction")
	}
}

func (c *Transaction) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.value) {
		return true
	}
	if fieldIsDirty(c.status) {
		return true
	}
	if fieldIsDirty(c.produced) {
		return true
	}
	if fieldIsDirty(c.systemSignatures) {
		return true
	}
	for _, v := range c.signatures {
		if v.IsDirty() {
			return true
		}
	}
	if fieldIsDirty(c.signers) {
		return true
	}
	if fieldIsDirty(c.chains) {
		return true
	}
	if fieldIsDirty(c.signature) {
		return true
	}
	if fieldIsDirty(c.txID) {
		return true
	}

	return false
}

func (c *Transaction) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.value)
	commitField(&err, c.status)
	commitField(&err, c.produced)
	commitField(&err, c.systemSignatures)
	for _, v := range c.signatures {
		commitField(&err, v)
	}
	commitField(&err, c.signers)
	commitField(&err, c.chains)
	commitField(&err, c.signature)
	commitField(&err, c.txID)

	return nil
}

type MajorMinorIndexChain struct {
	logger logging.OptionalLogger
	store  record.Store
	key    record.Key
	name   string
	label  string

	minor *managed.Chain
	major *managed.Chain
}

func (c *MajorMinorIndexChain) Minor() *managed.Chain {
	return getOrCreateField(&c.minor, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("Minor"), markPower, managed.ChainTypeIndex, c.name+"-minor", c.label+" minor")
	})
}

func (c *MajorMinorIndexChain) Major() *managed.Chain {
	return getOrCreateField(&c.major, func() *managed.Chain {
		return managed.NewChain(c.logger.L, c.store, c.key.Append("Major"), markPower, managed.ChainTypeIndex, c.name+"-major", c.label+" major")
	})
}

func (c *MajorMinorIndexChain) Resolve(key record.Key) (record.Record, record.Key, error) {
	switch key[0] {
	case "Minor":
		return c.Minor(), key[1:], nil
	case "Major":
		return c.Major(), key[1:], nil
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for major minor index chain")
	}
}

func (c *MajorMinorIndexChain) IsDirty() bool {
	if c == nil {
		return false
	}

	if fieldIsDirty(c.minor) {
		return true
	}
	if fieldIsDirty(c.major) {
		return true
	}

	return false
}

func (c *MajorMinorIndexChain) resolveChain(name string) (chain *managed.Chain, ok bool) {
	if name == "minor" {
		return c.Minor(), true
	}
	if name == "major" {
		return c.Major(), true
	}
	return
}

func (c *MajorMinorIndexChain) dirtyChains() []*managed.Chain {
	if c == nil {
		return nil
	}

	var chains []*managed.Chain

	if fieldIsDirty(c.minor) {
		chains = append(chains, c.minor)
	}
	if fieldIsDirty(c.major) {
		chains = append(chains, c.major)
	}

	return chains
}

func (c *MajorMinorIndexChain) Commit() error {
	if c == nil {
		return nil
	}

	var err error
	commitField(&err, c.minor)
	commitField(&err, c.major)

	return nil
}

func getOrCreateField[T any](ptr **T, create func() *T) *T {
	if *ptr != nil {
		return *ptr
	}

	*ptr = create()
	return *ptr
}

func getOrCreateMap[T any](ptr *map[storage.Key]*T, key record.Key, create func() *T) *T {
	if *ptr == nil {
		*ptr = map[storage.Key]*T{}
	}

	k := key.Hash()
	if v, ok := (*ptr)[k]; ok {
		return v
	}

	v := create()
	(*ptr)[k] = v
	return v
}

func commitField[T any, PT record.RecordPtr[T]](lastErr *error, field PT) {
	if *lastErr != nil || field == nil {
		return
	}

	*lastErr = field.Commit()
}

func fieldIsDirty[T any, PT record.RecordPtr[T]](field PT) bool {
	return field != nil && field.IsDirty()
}
