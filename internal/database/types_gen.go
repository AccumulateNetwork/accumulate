package database

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type SignatureSet struct {
	fieldsSet  []bool
	Signatures []protocol.Signature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
}

type txSyntheticTxns struct {
	fieldsSet []bool
	Txids     [][32]byte `json:"txids,omitempty" form:"txids" query:"txids" validate:"required"`
}

func (v *SignatureSet) Equal(u *SignatureSet) bool {
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(v.Signatures[i] == u.Signatures[i]) {
			return false
		}
	}

	return true
}

func (v *txSyntheticTxns) Equal(u *txSyntheticTxns) bool {
	if len(v.Txids) != len(u.Txids) {
		return false
	}
	for i := range v.Txids {
		if !(v.Txids[i] == u.Txids[i]) {
			return false
		}
	}

	return true
}

var fieldNames_SignatureSet = []string{
	1: "Signatures",
}

func (v *SignatureSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_SignatureSet)
	return buffer.Bytes(), err
}

func (v *SignatureSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_txSyntheticTxns = []string{
	1: "Txids",
}

func (v *txSyntheticTxns) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Txids) == 0) {
		for _, v := range v.Txids {
			writer.WriteHash(1, &v)
		}
	}

	_, _, err := writer.Reset(fieldNames_txSyntheticTxns)
	return buffer.Bytes(), err
}

func (v *txSyntheticTxns) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Txids is missing")
	} else if len(v.Txids) == 0 {
		errs = append(errs, "field Txids is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *SignatureSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		ok := reader.ReadValue(1, func(b []byte) error {
			x, err := protocol.UnmarshalSignature(b)
			if err == nil {
				v.Signatures = append(v.Signatures, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SignatureSet)
	v.fieldsSet = seen
	return err
}

func (v *txSyntheticTxns) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *txSyntheticTxns) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadHash(1); ok {
			v.Txids = append(v.Txids, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_txSyntheticTxns)
	v.fieldsSet = seen
	return err
}

func (v *SignatureSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Signatures []json.RawMessage `json:"signatures,omitempty"`
	}{}
	u.Signatures = make([]json.RawMessage, len(v.Signatures))
	for i, x := range v.Signatures {
		if y, err := json.Marshal(x); err != nil {
			return nil, fmt.Errorf("error encoding Signatures: %w", err)
		} else {
			u.Signatures[i] = y
		}
	}
	return json.Marshal(&u)
}

func (v *txSyntheticTxns) MarshalJSON() ([]byte, error) {
	u := struct {
		Txids []string `json:"txids,omitempty"`
	}{}
	u.Txids = make([]string, len(v.Txids))
	for i, x := range v.Txids {
		u.Txids[i] = encoding.ChainToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *SignatureSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Signatures []json.RawMessage `json:"signatures,omitempty"`
	}{}
	u.Signatures = make([]json.RawMessage, len(v.Signatures))
	for i, x := range v.Signatures {
		if y, err := json.Marshal(x); err != nil {
			return fmt.Errorf("error encoding Signatures: %w", err)
		} else {
			u.Signatures[i] = y
		}
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Signatures = make([]protocol.Signature, len(u.Signatures))
	for i, x := range u.Signatures {
		if y, err := protocol.UnmarshalSignatureJSON(x); err != nil {
			return fmt.Errorf("error decoding Signatures: %w", err)
		} else {
			v.Signatures[i] = y
		}
	}
	return nil
}

func (v *txSyntheticTxns) UnmarshalJSON(data []byte) error {
	u := struct {
		Txids []string `json:"txids,omitempty"`
	}{}
	u.Txids = make([]string, len(v.Txids))
	for i, x := range v.Txids {
		u.Txids[i] = encoding.ChainToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Txids = make([][32]byte, len(u.Txids))
	for i, x := range u.Txids {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Txids: %w", err)
		} else {
			v.Txids[i] = x
		}
	}
	return nil
}
