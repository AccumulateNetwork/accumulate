// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package database

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type BlockStateSynthTxnEntry struct {
	fieldsSet   []bool
	Account     *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Transaction []byte   `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	ChainEntry  uint64   `json:"chainEntry,omitempty" form:"chainEntry" query:"chainEntry" validate:"required"`
	extraData   []byte
}

type SigOrTxn struct {
	fieldsSet   []bool
	Transaction *protocol.Transaction `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signature   protocol.Signature    `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Txid        *url.TxID             `json:"txid,omitempty" form:"txid" query:"txid" validate:"required"`
	extraData   []byte
}

type SigSetEntry struct {
	fieldsSet        []bool
	Type             protocol.SignatureType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	KeyEntryIndex    uint64                 `json:"keyEntryIndex,omitempty" form:"keyEntryIndex" query:"keyEntryIndex" validate:"required"`
	SignatureHash    [32]byte               `json:"signatureHash,omitempty" form:"signatureHash" query:"signatureHash" validate:"required"`
	ValidatorKeyHash *[32]byte              `json:"validatorKeyHash,omitempty" form:"validatorKeyHash" query:"validatorKeyHash" validate:"required"`
	extraData        []byte
}

type SignatureSetEntry struct {
	fieldsSet []bool
	// KeyIndex is the index of the public key entry in the signer.
	KeyIndex uint64 `json:"keyIndex" form:"keyIndex" query:"keyIndex" validate:"required"`
	// Version is the signer version.
	Version uint64 `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	// Path is the authority/delegation path.
	Path []*url.URL `json:"path,omitempty" form:"path" query:"path" validate:"required"`
	// Hash is the hash of the signature.
	Hash      [32]byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	extraData []byte
}

type TransactionChainEntry struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	// Chain is the name of the chain.
	Chain string `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	// ChainIndex is the index of the entry in the chain's index chain.
	ChainIndex uint64 `json:"chainIndex,omitempty" form:"chainIndex" query:"chainIndex" validate:"required"`
	// AnchorIndex is the index of the entry in the anchor chain's index chain.
	AnchorIndex uint64 `json:"anchorIndex,omitempty" form:"anchorIndex" query:"anchorIndex" validate:"required"`
	extraData   []byte
}

type VoteEntry struct {
	fieldsSet []bool
	// Authority is the URL of the authority.
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	// Hash is the hash of the signature.
	Hash      [32]byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	extraData []byte
}

type sigSetData struct {
	fieldsSet []bool
	Version   uint64        `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Entries   []SigSetEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

func (v *BlockStateSynthTxnEntry) Copy() *BlockStateSynthTxnEntry {
	u := new(BlockStateSynthTxnEntry)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Transaction = encoding.BytesCopy(v.Transaction)
	u.ChainEntry = v.ChainEntry
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockStateSynthTxnEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *SigOrTxn) Copy() *SigOrTxn {
	u := new(SigOrTxn)

	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if v.Signature != nil {
		u.Signature = protocol.CopySignature(v.Signature)
	}
	if v.Txid != nil {
		u.Txid = v.Txid
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SigOrTxn) CopyAsInterface() interface{} { return v.Copy() }

func (v *SigSetEntry) Copy() *SigSetEntry {
	u := new(SigSetEntry)

	u.Type = v.Type
	u.KeyEntryIndex = v.KeyEntryIndex
	u.SignatureHash = v.SignatureHash
	if v.ValidatorKeyHash != nil {
		u.ValidatorKeyHash = new([32]byte)
		*u.ValidatorKeyHash = *v.ValidatorKeyHash
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SigSetEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureSetEntry) Copy() *SignatureSetEntry {
	u := new(SignatureSetEntry)

	u.KeyIndex = v.KeyIndex
	u.Version = v.Version
	u.Path = make([]*url.URL, len(v.Path))
	for i, v := range v.Path {
		v := v
		if v != nil {
			u.Path[i] = v
		}
	}
	u.Hash = v.Hash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SignatureSetEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionChainEntry) Copy() *TransactionChainEntry {
	u := new(TransactionChainEntry)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Chain = v.Chain
	u.ChainIndex = v.ChainIndex
	u.AnchorIndex = v.AnchorIndex
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *TransactionChainEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *VoteEntry) Copy() *VoteEntry {
	u := new(VoteEntry)

	if v.Authority != nil {
		u.Authority = v.Authority
	}
	u.Hash = v.Hash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *VoteEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *sigSetData) Copy() *sigSetData {
	u := new(sigSetData)

	u.Version = v.Version
	u.Entries = make([]SigSetEntry, len(v.Entries))
	for i, v := range v.Entries {
		v := v
		u.Entries[i] = *(&v).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *sigSetData) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockStateSynthTxnEntry) Equal(u *BlockStateSynthTxnEntry) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(bytes.Equal(v.Transaction, u.Transaction)) {
		return false
	}
	if !(v.ChainEntry == u.ChainEntry) {
		return false
	}

	return true
}

func (v *SigOrTxn) Equal(u *SigOrTxn) bool {
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}
	if !(protocol.EqualSignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Txid == u.Txid:
		// equal
	case v.Txid == nil || u.Txid == nil:
		return false
	case !((v.Txid).Equal(u.Txid)):
		return false
	}

	return true
}

func (v *SigSetEntry) Equal(u *SigSetEntry) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.KeyEntryIndex == u.KeyEntryIndex) {
		return false
	}
	if !(v.SignatureHash == u.SignatureHash) {
		return false
	}
	switch {
	case v.ValidatorKeyHash == u.ValidatorKeyHash:
		// equal
	case v.ValidatorKeyHash == nil || u.ValidatorKeyHash == nil:
		return false
	case !(*v.ValidatorKeyHash == *u.ValidatorKeyHash):
		return false
	}

	return true
}

func (v *SignatureSetEntry) Equal(u *SignatureSetEntry) bool {
	if !(v.KeyIndex == u.KeyIndex) {
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if len(v.Path) != len(u.Path) {
		return false
	}
	for i := range v.Path {
		if !((v.Path[i]).Equal(u.Path[i])) {
			return false
		}
	}
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *TransactionChainEntry) Equal(u *TransactionChainEntry) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}
	if !(v.ChainIndex == u.ChainIndex) {
		return false
	}
	if !(v.AnchorIndex == u.AnchorIndex) {
		return false
	}

	return true
}

func (v *VoteEntry) Equal(u *VoteEntry) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *sigSetData) Equal(u *sigSetData) bool {
	if !(v.Version == u.Version) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((&v.Entries[i]).Equal(&u.Entries[i])) {
			return false
		}
	}

	return true
}

var fieldNames_BlockStateSynthTxnEntry = []string{
	1: "Account",
	2: "Transaction",
	3: "ChainEntry",
}

var fieldTypes_BlockStateSynthTxnEntry = []string{
	1: "string",
	2: "bytes",
	3: "uint64",
}

func (v *BlockStateSynthTxnEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Transaction) == 0) {
		writer.WriteBytes(2, v.Transaction)
	}
	if !(v.ChainEntry == 0) {
		writer.WriteUint(3, v.ChainEntry)
	}

	_, _, err := writer.Reset(fieldNames_BlockStateSynthTxnEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockStateSynthTxnEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transaction is missing")
	} else if len(v.Transaction) == 0 {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ChainEntry is missing")
	} else if v.ChainEntry == 0 {
		errs = append(errs, "field ChainEntry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SigOrTxn = []string{
	1: "Transaction",
	2: "Signature",
	3: "Txid",
}

var fieldTypes_SigOrTxn = []string{
	1: "protocol.Transaction",
	2: "protocol.Signature",
	3: "string",
}

func (v *SigOrTxn) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Transaction == nil) {
		writer.WriteValue(1, v.Transaction.MarshalBinary)
	}
	if !(protocol.EqualSignature(v.Signature, nil)) {
		writer.WriteValue(2, v.Signature.MarshalBinary)
	}
	if !(v.Txid == nil) {
		writer.WriteTxid(3, v.Txid)
	}

	_, _, err := writer.Reset(fieldNames_SigOrTxn)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SigOrTxn) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == nil {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signature is missing")
	} else if protocol.EqualSignature(v.Signature, nil) {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Txid is missing")
	} else if v.Txid == nil {
		errs = append(errs, "field Txid is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SigSetEntry = []string{
	1: "Type",
	2: "KeyEntryIndex",
	3: "SignatureHash",
	4: "ValidatorKeyHash",
}

var fieldTypes_SigSetEntry = []string{
	1: "string",
	2: "uint64",
	3: "bytes32",
	4: "bytes32",
}

func (v *SigSetEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	if !(v.KeyEntryIndex == 0) {
		writer.WriteUint(2, v.KeyEntryIndex)
	}
	if !(v.SignatureHash == ([32]byte{})) {
		writer.WriteHash(3, &v.SignatureHash)
	}
	if !(v.ValidatorKeyHash == nil) {
		writer.WriteHash(4, v.ValidatorKeyHash)
	}

	_, _, err := writer.Reset(fieldNames_SigSetEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SigSetEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field KeyEntryIndex is missing")
	} else if v.KeyEntryIndex == 0 {
		errs = append(errs, "field KeyEntryIndex is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field SignatureHash is missing")
	} else if v.SignatureHash == ([32]byte{}) {
		errs = append(errs, "field SignatureHash is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ValidatorKeyHash is missing")
	} else if v.ValidatorKeyHash == nil {
		errs = append(errs, "field ValidatorKeyHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SignatureSetEntry = []string{
	1: "KeyIndex",
	2: "Version",
	3: "Path",
	4: "Hash",
}

var fieldTypes_SignatureSetEntry = []string{
	1: "uint64",
	2: "uint64",
	3: "string[]",
	4: "bytes32",
}

func (v *SignatureSetEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteUint(1, v.KeyIndex)
	if !(v.Version == 0) {
		writer.WriteUint(2, v.Version)
	}
	if !(len(v.Path) == 0) {
		for _, v := range v.Path {
			writer.WriteUrl(3, v)
		}
	}
	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(4, &v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_SignatureSetEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SignatureSetEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field KeyIndex is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Path is missing")
	} else if len(v.Path) == 0 {
		errs = append(errs, "field Path is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Hash is missing")
	} else if v.Hash == ([32]byte{}) {
		errs = append(errs, "field Hash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionChainEntry = []string{
	1: "Account",
	2: "Chain",
	3: "ChainIndex",
	4: "AnchorIndex",
}

var fieldTypes_TransactionChainEntry = []string{
	1: "string",
	2: "string",
	3: "uint64",
	4: "uint64",
}

func (v *TransactionChainEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(2, v.Chain)
	}
	if !(v.ChainIndex == 0) {
		writer.WriteUint(3, v.ChainIndex)
	}
	if !(v.AnchorIndex == 0) {
		writer.WriteUint(4, v.AnchorIndex)
	}

	_, _, err := writer.Reset(fieldNames_TransactionChainEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TransactionChainEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ChainIndex is missing")
	} else if v.ChainIndex == 0 {
		errs = append(errs, "field ChainIndex is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field AnchorIndex is missing")
	} else if v.AnchorIndex == 0 {
		errs = append(errs, "field AnchorIndex is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_VoteEntry = []string{
	1: "Authority",
	2: "Hash",
}

var fieldTypes_VoteEntry = []string{
	1: "string",
	2: "bytes32",
}

func (v *VoteEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Authority == nil) {
		writer.WriteUrl(1, v.Authority)
	}
	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(2, &v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_VoteEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *VoteEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Hash is missing")
	} else if v.Hash == ([32]byte{}) {
		errs = append(errs, "field Hash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_sigSetData = []string{
	1: "Version",
	2: "Entries",
}

var fieldTypes_sigSetData = []string{
	1: "uint64",
	2: "SigSetEntry[]",
}

func (v *sigSetData) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Version == 0) {
		writer.WriteUint(1, v.Version)
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_sigSetData)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *sigSetData) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *BlockStateSynthTxnEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockStateSynthTxnEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Transaction = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.ChainEntry = x
	}

	seen, err := reader.Reset(fieldNames_BlockStateSynthTxnEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SigOrTxn) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SigOrTxn) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.Transaction); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
		v.Transaction = x
	}
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := protocol.UnmarshalSignatureFrom(r)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	if x, ok := reader.ReadTxid(3); ok {
		v.Txid = x
	}

	seen, err := reader.Reset(fieldNames_SigOrTxn)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SigSetEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SigSetEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.SignatureType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.KeyEntryIndex = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.SignatureHash = *x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.ValidatorKeyHash = x
	}

	seen, err := reader.Reset(fieldNames_SigSetEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SignatureSetEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureSetEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.KeyIndex = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Version = x
	}
	for {
		if x, ok := reader.ReadUrl(3); ok {
			v.Path = append(v.Path, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadHash(4); ok {
		v.Hash = *x
	}

	seen, err := reader.Reset(fieldNames_SignatureSetEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TransactionChainEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionChainEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Chain = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.ChainIndex = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.AnchorIndex = x
	}

	seen, err := reader.Reset(fieldNames_TransactionChainEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *VoteEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *VoteEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Authority = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.Hash = *x
	}

	seen, err := reader.Reset(fieldNames_VoteEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *sigSetData) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *sigSetData) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Version = x
	}
	for {
		if x := new(SigSetEntry); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Entries = append(v.Entries, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_sigSetData)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func initEip712TypeDictionary() {

	encoding.SchemaDictionary["BlockStateSynthTxnEntry"] = &[]encoding.TypeField{
		{"account", "string"},
		{"transaction", "bytes"},
		{"chainEntry", "uint64"},
	}

	encoding.SchemaDictionary["SigOrTxn"] = &[]encoding.TypeField{
		{"transaction", "protocol.Transaction"},
		{"signature", "protocol.Signature"},
		{"txid", "string"},
	}

	encoding.SchemaDictionary["SigSetEntry"] = &[]encoding.TypeField{
		{"type", "string"},
		{"keyEntryIndex", "uint64"},
		{"signatureHash", "bytes32"},
		{"validatorKeyHash", "bytes32"},
	}

	encoding.SchemaDictionary["SignatureSetEntry"] = &[]encoding.TypeField{
		{"keyIndex", "uint64"},
		{"version", "uint64"},
		{"path", "string[]"},
		{"hash", "bytes32"},
	}

	encoding.SchemaDictionary["TransactionChainEntry"] = &[]encoding.TypeField{
		{"account", "string"},
		{"chain", "string"},
		{"chainIndex", "uint64"},
		{"anchorIndex", "uint64"},
	}

	encoding.SchemaDictionary["VoteEntry"] = &[]encoding.TypeField{
		{"authority", "string"},
		{"hash", "bytes32"},
	}

	encoding.SchemaDictionary["sigSetData"] = &[]encoding.TypeField{
		{"version", "uint64"},
		{"entries", "SigSetEntry[]"},
	}

	encoding.ResolveTypeDefinitions()
}

func (v *BlockStateSynthTxnEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Account     *url.URL `json:"account,omitempty"`
		Transaction *string  `json:"transaction,omitempty"`
		ChainEntry  uint64   `json:"chainEntry,omitempty"`
		ExtraData   *string  `json:"$epilogue,omitempty"`
	}{}
	if !(v.Account == nil) {
		u.Account = v.Account
	}
	if !(len(v.Transaction) == 0) {
		u.Transaction = encoding.BytesToJSON(v.Transaction)
	}
	if !(v.ChainEntry == 0) {
		u.ChainEntry = v.ChainEntry
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SigOrTxn) MarshalJSON() ([]byte, error) {
	u := struct {
		Transaction *protocol.Transaction                           `json:"transaction,omitempty"`
		Signature   *encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
		Txid        *url.TxID                                       `json:"txid,omitempty"`
		ExtraData   *string                                         `json:"$epilogue,omitempty"`
	}{}
	if !(v.Transaction == nil) {
		u.Transaction = v.Transaction
	}
	if !(protocol.EqualSignature(v.Signature, nil)) {
		u.Signature = &encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	}
	if !(v.Txid == nil) {
		u.Txid = v.Txid
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SigSetEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type             protocol.SignatureType `json:"type,omitempty"`
		KeyEntryIndex    uint64                 `json:"keyEntryIndex,omitempty"`
		SignatureHash    *string                `json:"signatureHash,omitempty"`
		ValidatorKeyHash *string                `json:"validatorKeyHash,omitempty"`
		ExtraData        *string                `json:"$epilogue,omitempty"`
	}{}
	if !(v.Type == 0) {
		u.Type = v.Type
	}
	if !(v.KeyEntryIndex == 0) {
		u.KeyEntryIndex = v.KeyEntryIndex
	}
	if !(v.SignatureHash == ([32]byte{})) {
		u.SignatureHash = encoding.ChainToJSON(&v.SignatureHash)
	}
	if !(v.ValidatorKeyHash == nil) {
		u.ValidatorKeyHash = encoding.ChainToJSON(v.ValidatorKeyHash)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SignatureSetEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		KeyIndex  uint64                      `json:"keyIndex"`
		Version   uint64                      `json:"version,omitempty"`
		Path      encoding.JsonList[*url.URL] `json:"path,omitempty"`
		Hash      *string                     `json:"hash,omitempty"`
		ExtraData *string                     `json:"$epilogue,omitempty"`
	}{}
	u.KeyIndex = v.KeyIndex
	if !(v.Version == 0) {
		u.Version = v.Version
	}
	if !(len(v.Path) == 0) {
		u.Path = v.Path
	}
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(&v.Hash)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *VoteEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Authority *url.URL `json:"authority,omitempty"`
		Hash      *string  `json:"hash,omitempty"`
		ExtraData *string  `json:"$epilogue,omitempty"`
	}{}
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(&v.Hash)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *sigSetData) MarshalJSON() ([]byte, error) {
	u := struct {
		Version   uint64                         `json:"version,omitempty"`
		Entries   encoding.JsonList[SigSetEntry] `json:"entries,omitempty"`
		ExtraData *string                        `json:"$epilogue,omitempty"`
	}{}
	if !(v.Version == 0) {
		u.Version = v.Version
	}
	if !(len(v.Entries) == 0) {
		u.Entries = v.Entries
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *BlockStateSynthTxnEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Account     *url.URL `json:"account,omitempty"`
		Transaction *string  `json:"transaction,omitempty"`
		ChainEntry  uint64   `json:"chainEntry,omitempty"`
		ExtraData   *string  `json:"$epilogue,omitempty"`
	}{}
	u.Account = v.Account
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	u.ChainEntry = v.ChainEntry
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Account = u.Account
	if x, err := encoding.BytesFromJSON(u.Transaction); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	v.ChainEntry = u.ChainEntry
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SigOrTxn) UnmarshalJSON(data []byte) error {
	u := struct {
		Transaction *protocol.Transaction                           `json:"transaction,omitempty"`
		Signature   *encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
		Txid        *url.TxID                                       `json:"txid,omitempty"`
		ExtraData   *string                                         `json:"$epilogue,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.Signature = &encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	u.Txid = v.Txid
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Transaction = u.Transaction
	if u.Signature != nil {
		v.Signature = u.Signature.Value
	}

	v.Txid = u.Txid
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SigSetEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type             protocol.SignatureType `json:"type,omitempty"`
		KeyEntryIndex    uint64                 `json:"keyEntryIndex,omitempty"`
		SignatureHash    *string                `json:"signatureHash,omitempty"`
		ValidatorKeyHash *string                `json:"validatorKeyHash,omitempty"`
		ExtraData        *string                `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type
	u.KeyEntryIndex = v.KeyEntryIndex
	u.SignatureHash = encoding.ChainToJSON(&v.SignatureHash)
	u.ValidatorKeyHash = encoding.ChainToJSON(v.ValidatorKeyHash)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Type = u.Type
	v.KeyEntryIndex = u.KeyEntryIndex
	if x, err := encoding.ChainFromJSON(u.SignatureHash); err != nil {
		return fmt.Errorf("error decoding SignatureHash: %w", err)
	} else {
		v.SignatureHash = *x
	}
	if u.ValidatorKeyHash != nil {
		if x, err := encoding.ChainFromJSON(u.ValidatorKeyHash); err != nil {
			return fmt.Errorf("error decoding ValidatorKeyHash: %w", err)
		} else {
			v.ValidatorKeyHash = x
		}
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SignatureSetEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		KeyIndex  uint64                      `json:"keyIndex"`
		Version   uint64                      `json:"version,omitempty"`
		Path      encoding.JsonList[*url.URL] `json:"path,omitempty"`
		Hash      *string                     `json:"hash,omitempty"`
		ExtraData *string                     `json:"$epilogue,omitempty"`
	}{}
	u.KeyIndex = v.KeyIndex
	u.Version = v.Version
	u.Path = v.Path
	u.Hash = encoding.ChainToJSON(&v.Hash)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.KeyIndex = u.KeyIndex
	v.Version = u.Version
	v.Path = u.Path
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = *x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *VoteEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Authority *url.URL `json:"authority,omitempty"`
		Hash      *string  `json:"hash,omitempty"`
		ExtraData *string  `json:"$epilogue,omitempty"`
	}{}
	u.Authority = v.Authority
	u.Hash = encoding.ChainToJSON(&v.Hash)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Authority = u.Authority
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = *x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *sigSetData) UnmarshalJSON(data []byte) error {
	u := struct {
		Version   uint64                         `json:"version,omitempty"`
		Entries   encoding.JsonList[SigSetEntry] `json:"entries,omitempty"`
		ExtraData *string                        `json:"$epilogue,omitempty"`
	}{}
	u.Version = v.Version
	u.Entries = v.Entries
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Version = u.Version
	v.Entries = u.Entries
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}
