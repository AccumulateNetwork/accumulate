package database

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type BlockStateSynthTxnEntry struct {
	fieldsSet   []bool
	Account     *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Transaction []byte   `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	ChainEntry  uint64   `json:"chainEntry,omitempty" form:"chainEntry" query:"chainEntry" validate:"required"`
	extraData   []byte
}

type ChainUpdate struct {
	fieldsSet   []bool
	Account     *url.URL           `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Name        string             `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type        protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Index       uint64             `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	SourceIndex uint64             `json:"sourceIndex,omitempty" form:"sourceIndex" query:"sourceIndex" validate:"required"`
	SourceBlock uint64             `json:"sourceBlock,omitempty" form:"sourceBlock" query:"sourceBlock" validate:"required"`
	Entry       []byte             `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData   []byte
}

type SigOrTxn struct {
	fieldsSet   []bool
	Transaction *protocol.Transaction `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signature   protocol.Signature    `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	Txid        *url.TxID             `json:"txid,omitempty" form:"txid" query:"txid" validate:"required"`
	extraData   []byte
}

type SigSetEntry struct {
	fieldsSet     []bool
	System        bool                   `json:"system,omitempty" form:"system" query:"system" validate:"required"`
	Type          protocol.SignatureType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	KeyEntryIndex uint64                 `json:"keyEntryIndex,omitempty" form:"keyEntryIndex" query:"keyEntryIndex" validate:"required"`
	SignatureHash [32]byte               `json:"signatureHash,omitempty" form:"signatureHash" query:"signatureHash" validate:"required"`
	extraData     []byte
}

type TransactionChainEntry struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	// Chain is the name of the chain.
	Chain string `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	// ChainIndex is the index of the entry in the chain's index chain.
	ChainIndex uint64 `json:"chainIndex,omitempty" form:"chainIndex" query:"chainIndex" validate:"required"`
	// AnchorIndex is the index of the entry in the anchor chain's index chain.
	AnchorIndex uint64 `json:"anchorIndex,omitempty" form:"anchorIndex" query:"anchorIndex" validate:"required"`
	extraData   []byte
}

type accountState struct {
	fieldsSet []bool
	// Main is the main state of the account.
	Main protocol.Account `json:"main,omitempty" form:"main" query:"main" validate:"required"`
	// Chains is the state of the account's chains.
	Chains []*merkleState `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
	// Pending is the state of the account's pending transactions.
	Pending []*url.TxID `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	// Directory lists the account's sub-accounts.
	Directory []*url.URL `json:"directory,omitempty" form:"directory" query:"directory" validate:"required"`
	extraData []byte
}

type merkleState struct {
	fieldsSet []bool
	Name      string             `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Count     uint64             `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	Pending   [][]byte           `json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	Entries   [][]byte           `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type sigSetData struct {
	fieldsSet []bool
	Version   uint64        `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Entries   []SigSetEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type signatureSection struct {
	fieldsSet  []bool
	Signatures []protocol.Signature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	extraData  []byte
}

type snapshotHeader struct {
	fieldsSet []bool
	// Version is the snapshot format version.
	Version uint64 `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	// Height is the snapshot's block height.
	Height uint64 `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	// RootHash is the snapshot's root hash.
	RootHash  [32]byte `json:"rootHash,omitempty" form:"rootHash" query:"rootHash" validate:"required"`
	extraData []byte
}

type transactionSection struct {
	fieldsSet    []bool
	Transactions []*transactionState `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	extraData    []byte
}

type transactionState struct {
	fieldsSet   []bool
	hash        [32]byte
	Transaction *protocol.Transaction       `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	State       *protocol.TransactionStatus `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	Signatures  []*sigSetData               `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	extraData   []byte
}

func (v *BlockStateSynthTxnEntry) Copy() *BlockStateSynthTxnEntry {
	u := new(BlockStateSynthTxnEntry)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Transaction = encoding.BytesCopy(v.Transaction)
	u.ChainEntry = v.ChainEntry

	return u
}

func (v *BlockStateSynthTxnEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainUpdate) Copy() *ChainUpdate {
	u := new(ChainUpdate)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesCopy(v.Entry)

	return u
}

func (v *ChainUpdate) CopyAsInterface() interface{} { return v.Copy() }

func (v *SigOrTxn) Copy() *SigOrTxn {
	u := new(SigOrTxn)

	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if v.Signature != nil {
		u.Signature = (v.Signature).CopyAsInterface().(protocol.Signature)
	}
	if v.Txid != nil {
		u.Txid = v.Txid
	}

	return u
}

func (v *SigOrTxn) CopyAsInterface() interface{} { return v.Copy() }

func (v *SigSetEntry) Copy() *SigSetEntry {
	u := new(SigSetEntry)

	u.System = v.System
	u.Type = v.Type
	u.KeyEntryIndex = v.KeyEntryIndex
	u.SignatureHash = v.SignatureHash

	return u
}

func (v *SigSetEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *TransactionChainEntry) Copy() *TransactionChainEntry {
	u := new(TransactionChainEntry)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Chain = v.Chain
	u.ChainIndex = v.ChainIndex
	u.AnchorIndex = v.AnchorIndex

	return u
}

func (v *TransactionChainEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *accountState) Copy() *accountState {
	u := new(accountState)

	if v.Main != nil {
		u.Main = (v.Main).CopyAsInterface().(protocol.Account)
	}
	u.Chains = make([]*merkleState, len(v.Chains))
	for i, v := range v.Chains {
		if v != nil {
			u.Chains[i] = (v).Copy()
		}
	}
	u.Pending = make([]*url.TxID, len(v.Pending))
	for i, v := range v.Pending {
		if v != nil {
			u.Pending[i] = v
		}
	}
	u.Directory = make([]*url.URL, len(v.Directory))
	for i, v := range v.Directory {
		if v != nil {
			u.Directory[i] = v
		}
	}

	return u
}

func (v *accountState) CopyAsInterface() interface{} { return v.Copy() }

func (v *merkleState) Copy() *merkleState {
	u := new(merkleState)

	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.Pending = make([][]byte, len(v.Pending))
	for i, v := range v.Pending {
		u.Pending[i] = encoding.BytesCopy(v)
	}
	u.Entries = make([][]byte, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *merkleState) CopyAsInterface() interface{} { return v.Copy() }

func (v *sigSetData) Copy() *sigSetData {
	u := new(sigSetData)

	u.Version = v.Version
	u.Entries = make([]SigSetEntry, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = *(&v).Copy()
	}

	return u
}

func (v *sigSetData) CopyAsInterface() interface{} { return v.Copy() }

func (v *signatureSection) Copy() *signatureSection {
	u := new(signatureSection)

	u.Signatures = make([]protocol.Signature, len(v.Signatures))
	for i, v := range v.Signatures {
		if v != nil {
			u.Signatures[i] = (v).CopyAsInterface().(protocol.Signature)
		}
	}

	return u
}

func (v *signatureSection) CopyAsInterface() interface{} { return v.Copy() }

func (v *snapshotHeader) Copy() *snapshotHeader {
	u := new(snapshotHeader)

	u.Version = v.Version
	u.Height = v.Height
	u.RootHash = v.RootHash

	return u
}

func (v *snapshotHeader) CopyAsInterface() interface{} { return v.Copy() }

func (v *transactionSection) Copy() *transactionSection {
	u := new(transactionSection)

	u.Transactions = make([]*transactionState, len(v.Transactions))
	for i, v := range v.Transactions {
		if v != nil {
			u.Transactions[i] = (v).Copy()
		}
	}

	return u
}

func (v *transactionSection) CopyAsInterface() interface{} { return v.Copy() }

func (v *transactionState) Copy() *transactionState {
	u := new(transactionState)

	if v.Transaction != nil {
		u.Transaction = (v.Transaction).Copy()
	}
	if v.State != nil {
		u.State = (v.State).Copy()
	}
	u.Signatures = make([]*sigSetData, len(v.Signatures))
	for i, v := range v.Signatures {
		if v != nil {
			u.Signatures[i] = (v).Copy()
		}
	}

	return u
}

func (v *transactionState) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockStateSynthTxnEntry) Equal(u *BlockStateSynthTxnEntry) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(bytes.Equal(v.Transaction, u.Transaction)) {
		return false
	}
	if !(v.ChainEntry == u.ChainEntry) {
		return false
	}

	return true
}

func (v *ChainUpdate) Equal(u *ChainUpdate) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !(v.SourceIndex == u.SourceIndex) {
		return false
	}
	if !(v.SourceBlock == u.SourceBlock) {
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}

	return true
}

func (v *SigOrTxn) Equal(u *SigOrTxn) bool {
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}
	if !(protocol.EqualSignature(v.Signature, u.Signature)) {
		return false
	}
	switch {
	case v.Txid == u.Txid:
		// equal
	case v.Txid == nil || u.Txid == nil:
		return false
	case !((v.Txid).Equal(u.Txid)):
		return false
	}

	return true
}

func (v *SigSetEntry) Equal(u *SigSetEntry) bool {
	if !(v.System == u.System) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.KeyEntryIndex == u.KeyEntryIndex) {
		return false
	}
	if !(v.SignatureHash == u.SignatureHash) {
		return false
	}

	return true
}

func (v *TransactionChainEntry) Equal(u *TransactionChainEntry) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}
	if !(v.ChainIndex == u.ChainIndex) {
		return false
	}
	if !(v.AnchorIndex == u.AnchorIndex) {
		return false
	}

	return true
}

func (v *accountState) Equal(u *accountState) bool {
	if !(protocol.EqualAccount(v.Main, u.Main)) {
		return false
	}
	if len(v.Chains) != len(u.Chains) {
		return false
	}
	for i := range v.Chains {
		if !((v.Chains[i]).Equal(u.Chains[i])) {
			return false
		}
	}
	if len(v.Pending) != len(u.Pending) {
		return false
	}
	for i := range v.Pending {
		if !((v.Pending[i]).Equal(u.Pending[i])) {
			return false
		}
	}
	if len(v.Directory) != len(u.Directory) {
		return false
	}
	for i := range v.Directory {
		if !((v.Directory[i]).Equal(u.Directory[i])) {
			return false
		}
	}

	return true
}

func (v *merkleState) Equal(u *merkleState) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if len(v.Pending) != len(u.Pending) {
		return false
	}
	for i := range v.Pending {
		if !(bytes.Equal(v.Pending[i], u.Pending[i])) {
			return false
		}
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(bytes.Equal(v.Entries[i], u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *sigSetData) Equal(u *sigSetData) bool {
	if !(v.Version == u.Version) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((&v.Entries[i]).Equal(&u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *signatureSection) Equal(u *signatureSection) bool {
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(protocol.EqualSignature(v.Signatures[i], u.Signatures[i])) {
			return false
		}
	}

	return true
}

func (v *snapshotHeader) Equal(u *snapshotHeader) bool {
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if !(v.RootHash == u.RootHash) {
		return false
	}

	return true
}

func (v *transactionSection) Equal(u *transactionSection) bool {
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((v.Transactions[i]).Equal(u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *transactionState) Equal(u *transactionState) bool {
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}
	switch {
	case v.State == u.State:
		// equal
	case v.State == nil || u.State == nil:
		return false
	case !((v.State).Equal(u.State)):
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !((v.Signatures[i]).Equal(u.Signatures[i])) {
			return false
		}
	}

	return true
}

var fieldNames_BlockStateSynthTxnEntry = []string{
	1: "Account",
	2: "Transaction",
	3: "ChainEntry",
}

func (v *BlockStateSynthTxnEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Transaction) == 0) {
		writer.WriteBytes(2, v.Transaction)
	}
	if !(v.ChainEntry == 0) {
		writer.WriteUint(3, v.ChainEntry)
	}

	_, _, err := writer.Reset(fieldNames_BlockStateSynthTxnEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockStateSynthTxnEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Transaction is missing")
	} else if len(v.Transaction) == 0 {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ChainEntry is missing")
	} else if v.ChainEntry == 0 {
		errs = append(errs, "field ChainEntry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ChainUpdate = []string{
	1: "Account",
	2: "Name",
	3: "Type",
	4: "Index",
	5: "SourceIndex",
	6: "SourceBlock",
	7: "Entry",
}

func (v *ChainUpdate) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Name) == 0) {
		writer.WriteString(2, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(3, v.Type)
	}
	if !(v.Index == 0) {
		writer.WriteUint(4, v.Index)
	}
	if !(v.SourceIndex == 0) {
		writer.WriteUint(5, v.SourceIndex)
	}
	if !(v.SourceBlock == 0) {
		writer.WriteUint(6, v.SourceBlock)
	}
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(7, v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_ChainUpdate)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainUpdate) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field SourceIndex is missing")
	} else if v.SourceIndex == 0 {
		errs = append(errs, "field SourceIndex is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field SourceBlock is missing")
	} else if v.SourceBlock == 0 {
		errs = append(errs, "field SourceBlock is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Entry is missing")
	} else if len(v.Entry) == 0 {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SigOrTxn = []string{
	1: "Transaction",
	2: "Signature",
	3: "Txid",
}

func (v *SigOrTxn) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Transaction == nil) {
		writer.WriteValue(1, v.Transaction.MarshalBinary)
	}
	if !(v.Signature == nil) {
		writer.WriteValue(2, v.Signature.MarshalBinary)
	}
	if !(v.Txid == nil) {
		writer.WriteTxid(3, v.Txid)
	}

	_, _, err := writer.Reset(fieldNames_SigOrTxn)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SigOrTxn) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == nil {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signature is missing")
	} else if v.Signature == nil {
		errs = append(errs, "field Signature is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Txid is missing")
	} else if v.Txid == nil {
		errs = append(errs, "field Txid is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SigSetEntry = []string{
	1: "System",
	2: "Type",
	3: "KeyEntryIndex",
	4: "SignatureHash",
}

func (v *SigSetEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(!v.System) {
		writer.WriteBool(1, v.System)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.KeyEntryIndex == 0) {
		writer.WriteUint(3, v.KeyEntryIndex)
	}
	if !(v.SignatureHash == ([32]byte{})) {
		writer.WriteHash(4, &v.SignatureHash)
	}

	_, _, err := writer.Reset(fieldNames_SigSetEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SigSetEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field System is missing")
	} else if !v.System {
		errs = append(errs, "field System is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field KeyEntryIndex is missing")
	} else if v.KeyEntryIndex == 0 {
		errs = append(errs, "field KeyEntryIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field SignatureHash is missing")
	} else if v.SignatureHash == ([32]byte{}) {
		errs = append(errs, "field SignatureHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TransactionChainEntry = []string{
	1: "Account",
	2: "Chain",
	3: "ChainIndex",
	4: "AnchorIndex",
}

func (v *TransactionChainEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Account == nil) {
		writer.WriteUrl(1, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(2, v.Chain)
	}
	if !(v.ChainIndex == 0) {
		writer.WriteUint(3, v.ChainIndex)
	}
	if !(v.AnchorIndex == 0) {
		writer.WriteUint(4, v.AnchorIndex)
	}

	_, _, err := writer.Reset(fieldNames_TransactionChainEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TransactionChainEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ChainIndex is missing")
	} else if v.ChainIndex == 0 {
		errs = append(errs, "field ChainIndex is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field AnchorIndex is missing")
	} else if v.AnchorIndex == 0 {
		errs = append(errs, "field AnchorIndex is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_accountState = []string{
	1: "Main",
	2: "Chains",
	3: "Pending",
	4: "Directory",
}

func (v *accountState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Main == nil) {
		writer.WriteValue(1, v.Main.MarshalBinary)
	}
	if !(len(v.Chains) == 0) {
		for _, v := range v.Chains {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	if !(len(v.Pending) == 0) {
		for _, v := range v.Pending {
			writer.WriteTxid(3, v)
		}
	}
	if !(len(v.Directory) == 0) {
		for _, v := range v.Directory {
			writer.WriteUrl(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_accountState)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *accountState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Main is missing")
	} else if v.Main == nil {
		errs = append(errs, "field Main is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chains is missing")
	} else if len(v.Chains) == 0 {
		errs = append(errs, "field Chains is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Pending is missing")
	} else if len(v.Pending) == 0 {
		errs = append(errs, "field Pending is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Directory is missing")
	} else if len(v.Directory) == 0 {
		errs = append(errs, "field Directory is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_merkleState = []string{
	1: "Name",
	2: "Type",
	3: "Count",
	4: "Pending",
	5: "Entries",
}

func (v *merkleState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.Count == 0) {
		writer.WriteUint(3, v.Count)
	}
	if !(len(v.Pending) == 0) {
		for _, v := range v.Pending {
			writer.WriteBytes(4, v)
		}
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteBytes(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_merkleState)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *merkleState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Pending is missing")
	} else if len(v.Pending) == 0 {
		errs = append(errs, "field Pending is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_sigSetData = []string{
	1: "Version",
	2: "Entries",
}

func (v *sigSetData) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Version == 0) {
		writer.WriteUint(1, v.Version)
	}
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_sigSetData)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *sigSetData) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_signatureSection = []string{
	1: "Signatures",
}

func (v *signatureSection) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_signatureSection)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *signatureSection) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_snapshotHeader = []string{
	1: "Version",
	2: "Height",
	3: "RootHash",
}

func (v *snapshotHeader) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Version == 0) {
		writer.WriteUint(1, v.Version)
	}
	if !(v.Height == 0) {
		writer.WriteUint(2, v.Height)
	}
	if !(v.RootHash == ([32]byte{})) {
		writer.WriteHash(3, &v.RootHash)
	}

	_, _, err := writer.Reset(fieldNames_snapshotHeader)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *snapshotHeader) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Version is missing")
	} else if v.Version == 0 {
		errs = append(errs, "field Version is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field RootHash is missing")
	} else if v.RootHash == ([32]byte{}) {
		errs = append(errs, "field RootHash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_transactionSection = []string{
	1: "Transactions",
}

func (v *transactionSection) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_transactionSection)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *transactionSection) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_transactionState = []string{
	1: "Transaction",
	2: "State",
	3: "Signatures",
}

func (v *transactionState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Transaction == nil) {
		writer.WriteValue(1, v.Transaction.MarshalBinary)
	}
	if !(v.State == nil) {
		writer.WriteValue(2, v.State.MarshalBinary)
	}
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_transactionState)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *transactionState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transaction is missing")
	} else if v.Transaction == nil {
		errs = append(errs, "field Transaction is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field State is missing")
	} else if v.State == nil {
		errs = append(errs, "field State is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *BlockStateSynthTxnEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockStateSynthTxnEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.Transaction = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.ChainEntry = x
	}

	seen, err := reader.Reset(fieldNames_BlockStateSynthTxnEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainUpdate) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainUpdate) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Name = x
	}
	if x := new(protocol.ChainType); reader.ReadEnum(3, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Index = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.SourceIndex = x
	}
	if x, ok := reader.ReadUint(6); ok {
		v.SourceBlock = x
	}
	if x, ok := reader.ReadBytes(7); ok {
		v.Entry = x
	}

	seen, err := reader.Reset(fieldNames_ChainUpdate)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SigOrTxn) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SigOrTxn) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.Transaction); reader.ReadValue(1, x.UnmarshalBinary) {
		v.Transaction = x
	}
	reader.ReadValue(2, func(b []byte) error {
		x, err := protocol.UnmarshalSignature(b)
		if err == nil {
			v.Signature = x
		}
		return err
	})
	if x, ok := reader.ReadTxid(3); ok {
		v.Txid = x
	}

	seen, err := reader.Reset(fieldNames_SigOrTxn)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SigSetEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SigSetEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadBool(1); ok {
		v.System = x
	}
	if x := new(protocol.SignatureType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.KeyEntryIndex = x
	}
	if x, ok := reader.ReadHash(4); ok {
		v.SignatureHash = *x
	}

	seen, err := reader.Reset(fieldNames_SigSetEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TransactionChainEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TransactionChainEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Chain = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.ChainIndex = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.AnchorIndex = x
	}

	seen, err := reader.Reset(fieldNames_TransactionChainEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *accountState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *accountState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.Main = x
		}
		return err
	})
	for {
		if x := new(merkleState); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Chains = append(v.Chains, x)
		} else {
			break
		}
	}
	for {
		if x, ok := reader.ReadTxid(3); ok {
			v.Pending = append(v.Pending, x)
		} else {
			break
		}
	}
	for {
		if x, ok := reader.ReadUrl(4); ok {
			v.Directory = append(v.Directory, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_accountState)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *merkleState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *merkleState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x := new(protocol.ChainType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Count = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.Pending = append(v.Pending, x)
		} else {
			break
		}
	}
	for {
		if x, ok := reader.ReadBytes(5); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_merkleState)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *sigSetData) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *sigSetData) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Version = x
	}
	for {
		if x := new(SigSetEntry); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Entries = append(v.Entries, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_sigSetData)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *signatureSection) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *signatureSection) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		ok := reader.ReadValue(1, func(b []byte) error {
			x, err := protocol.UnmarshalSignature(b)
			if err == nil {
				v.Signatures = append(v.Signatures, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_signatureSection)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *snapshotHeader) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *snapshotHeader) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Version = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Height = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.RootHash = *x
	}

	seen, err := reader.Reset(fieldNames_snapshotHeader)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *transactionSection) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *transactionSection) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(transactionState); reader.ReadValue(1, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_transactionSection)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *transactionState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *transactionState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.Transaction); reader.ReadValue(1, x.UnmarshalBinary) {
		v.Transaction = x
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(2, x.UnmarshalBinary) {
		v.State = x
	}
	for {
		if x := new(sigSetData); reader.ReadValue(3, x.UnmarshalBinary) {
			v.Signatures = append(v.Signatures, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_transactionState)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockStateSynthTxnEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Account     *url.URL `json:"account,omitempty"`
		Transaction *string  `json:"transaction,omitempty"`
		ChainEntry  uint64   `json:"chainEntry,omitempty"`
	}{}
	u.Account = v.Account
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	u.ChainEntry = v.ChainEntry
	return json.Marshal(&u)
}

func (v *ChainUpdate) MarshalJSON() ([]byte, error) {
	u := struct {
		Account     *url.URL           `json:"account,omitempty"`
		Name        string             `json:"name,omitempty"`
		Type        protocol.ChainType `json:"type,omitempty"`
		Index       uint64             `json:"index,omitempty"`
		SourceIndex uint64             `json:"sourceIndex,omitempty"`
		SourceBlock uint64             `json:"sourceBlock,omitempty"`
		Entry       *string            `json:"entry,omitempty"`
	}{}
	u.Account = v.Account
	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesToJSON(v.Entry)
	return json.Marshal(&u)
}

func (v *SigOrTxn) MarshalJSON() ([]byte, error) {
	u := struct {
		Transaction *protocol.Transaction                          `json:"transaction,omitempty"`
		Signature   encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
		Txid        *url.TxID                                      `json:"txid,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.Signature = encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	u.Txid = v.Txid
	return json.Marshal(&u)
}

func (v *SigSetEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		System        bool                   `json:"system,omitempty"`
		Type          protocol.SignatureType `json:"type,omitempty"`
		KeyEntryIndex uint64                 `json:"keyEntryIndex,omitempty"`
		SignatureHash string                 `json:"signatureHash,omitempty"`
	}{}
	u.System = v.System
	u.Type = v.Type
	u.KeyEntryIndex = v.KeyEntryIndex
	u.SignatureHash = encoding.ChainToJSON(v.SignatureHash)
	return json.Marshal(&u)
}

func (v *accountState) MarshalJSON() ([]byte, error) {
	u := struct {
		Main      encoding.JsonUnmarshalWith[protocol.Account] `json:"main,omitempty"`
		Chains    encoding.JsonList[*merkleState]              `json:"chains,omitempty"`
		Pending   encoding.JsonList[*url.TxID]                 `json:"pending,omitempty"`
		Directory encoding.JsonList[*url.URL]                  `json:"directory,omitempty"`
	}{}
	u.Main = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Main, Func: protocol.UnmarshalAccountJSON}
	u.Chains = v.Chains
	u.Pending = v.Pending
	u.Directory = v.Directory
	return json.Marshal(&u)
}

func (v *merkleState) MarshalJSON() ([]byte, error) {
	u := struct {
		Name    string                     `json:"name,omitempty"`
		Type    protocol.ChainType         `json:"type,omitempty"`
		Count   uint64                     `json:"count,omitempty"`
		Pending encoding.JsonList[*string] `json:"pending,omitempty"`
		Entries encoding.JsonList[*string] `json:"entries,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.Pending = make(encoding.JsonList[*string], len(v.Pending))
	for i, x := range v.Pending {
		u.Pending[i] = encoding.BytesToJSON(x)
	}
	u.Entries = make(encoding.JsonList[*string], len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *sigSetData) MarshalJSON() ([]byte, error) {
	u := struct {
		Version uint64                         `json:"version,omitempty"`
		Entries encoding.JsonList[SigSetEntry] `json:"entries,omitempty"`
	}{}
	u.Version = v.Version
	u.Entries = v.Entries
	return json.Marshal(&u)
}

func (v *signatureSection) MarshalJSON() ([]byte, error) {
	u := struct {
		Signatures encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
	}{}
	u.Signatures = encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	return json.Marshal(&u)
}

func (v *snapshotHeader) MarshalJSON() ([]byte, error) {
	u := struct {
		Version  uint64 `json:"version,omitempty"`
		Height   uint64 `json:"height,omitempty"`
		RootHash string `json:"rootHash,omitempty"`
	}{}
	u.Version = v.Version
	u.Height = v.Height
	u.RootHash = encoding.ChainToJSON(v.RootHash)
	return json.Marshal(&u)
}

func (v *transactionSection) MarshalJSON() ([]byte, error) {
	u := struct {
		Transactions encoding.JsonList[*transactionState] `json:"transactions,omitempty"`
	}{}
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *transactionState) MarshalJSON() ([]byte, error) {
	u := struct {
		Transaction *protocol.Transaction          `json:"transaction,omitempty"`
		State       *protocol.TransactionStatus    `json:"state,omitempty"`
		Signatures  encoding.JsonList[*sigSetData] `json:"signatures,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.State = v.State
	u.Signatures = v.Signatures
	return json.Marshal(&u)
}

func (v *BlockStateSynthTxnEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Account     *url.URL `json:"account,omitempty"`
		Transaction *string  `json:"transaction,omitempty"`
		ChainEntry  uint64   `json:"chainEntry,omitempty"`
	}{}
	u.Account = v.Account
	u.Transaction = encoding.BytesToJSON(v.Transaction)
	u.ChainEntry = v.ChainEntry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account
	if x, err := encoding.BytesFromJSON(u.Transaction); err != nil {
		return fmt.Errorf("error decoding Transaction: %w", err)
	} else {
		v.Transaction = x
	}
	v.ChainEntry = u.ChainEntry
	return nil
}

func (v *ChainUpdate) UnmarshalJSON(data []byte) error {
	u := struct {
		Account     *url.URL           `json:"account,omitempty"`
		Name        string             `json:"name,omitempty"`
		Type        protocol.ChainType `json:"type,omitempty"`
		Index       uint64             `json:"index,omitempty"`
		SourceIndex uint64             `json:"sourceIndex,omitempty"`
		SourceBlock uint64             `json:"sourceBlock,omitempty"`
		Entry       *string            `json:"entry,omitempty"`
	}{}
	u.Account = v.Account
	u.Name = v.Name
	u.Type = v.Type
	u.Index = v.Index
	u.SourceIndex = v.SourceIndex
	u.SourceBlock = v.SourceBlock
	u.Entry = encoding.BytesToJSON(v.Entry)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account
	v.Name = u.Name
	v.Type = u.Type
	v.Index = u.Index
	v.SourceIndex = u.SourceIndex
	v.SourceBlock = u.SourceBlock
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	return nil
}

func (v *SigOrTxn) UnmarshalJSON(data []byte) error {
	u := struct {
		Transaction *protocol.Transaction                          `json:"transaction,omitempty"`
		Signature   encoding.JsonUnmarshalWith[protocol.Signature] `json:"signature,omitempty"`
		Txid        *url.TxID                                      `json:"txid,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.Signature = encoding.JsonUnmarshalWith[protocol.Signature]{Value: v.Signature, Func: protocol.UnmarshalSignatureJSON}
	u.Txid = v.Txid
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transaction = u.Transaction
	v.Signature = u.Signature.Value

	v.Txid = u.Txid
	return nil
}

func (v *SigSetEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		System        bool                   `json:"system,omitempty"`
		Type          protocol.SignatureType `json:"type,omitempty"`
		KeyEntryIndex uint64                 `json:"keyEntryIndex,omitempty"`
		SignatureHash string                 `json:"signatureHash,omitempty"`
	}{}
	u.System = v.System
	u.Type = v.Type
	u.KeyEntryIndex = v.KeyEntryIndex
	u.SignatureHash = encoding.ChainToJSON(v.SignatureHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.System = u.System
	v.Type = u.Type
	v.KeyEntryIndex = u.KeyEntryIndex
	if x, err := encoding.ChainFromJSON(u.SignatureHash); err != nil {
		return fmt.Errorf("error decoding SignatureHash: %w", err)
	} else {
		v.SignatureHash = x
	}
	return nil
}

func (v *accountState) UnmarshalJSON(data []byte) error {
	u := struct {
		Main      encoding.JsonUnmarshalWith[protocol.Account] `json:"main,omitempty"`
		Chains    encoding.JsonList[*merkleState]              `json:"chains,omitempty"`
		Pending   encoding.JsonList[*url.TxID]                 `json:"pending,omitempty"`
		Directory encoding.JsonList[*url.URL]                  `json:"directory,omitempty"`
	}{}
	u.Main = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Main, Func: protocol.UnmarshalAccountJSON}
	u.Chains = v.Chains
	u.Pending = v.Pending
	u.Directory = v.Directory
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Main = u.Main.Value

	v.Chains = u.Chains
	v.Pending = u.Pending
	v.Directory = u.Directory
	return nil
}

func (v *merkleState) UnmarshalJSON(data []byte) error {
	u := struct {
		Name    string                     `json:"name,omitempty"`
		Type    protocol.ChainType         `json:"type,omitempty"`
		Count   uint64                     `json:"count,omitempty"`
		Pending encoding.JsonList[*string] `json:"pending,omitempty"`
		Entries encoding.JsonList[*string] `json:"entries,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Count = v.Count
	u.Pending = make(encoding.JsonList[*string], len(v.Pending))
	for i, x := range v.Pending {
		u.Pending[i] = encoding.BytesToJSON(x)
	}
	u.Entries = make(encoding.JsonList[*string], len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Name = u.Name
	v.Type = u.Type
	v.Count = u.Count
	v.Pending = make([][]byte, len(u.Pending))
	for i, x := range u.Pending {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Pending: %w", err)
		} else {
			v.Pending[i] = x
		}
	}
	v.Entries = make([][]byte, len(u.Entries))
	for i, x := range u.Entries {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Entries: %w", err)
		} else {
			v.Entries[i] = x
		}
	}
	return nil
}

func (v *sigSetData) UnmarshalJSON(data []byte) error {
	u := struct {
		Version uint64                         `json:"version,omitempty"`
		Entries encoding.JsonList[SigSetEntry] `json:"entries,omitempty"`
	}{}
	u.Version = v.Version
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Version = u.Version
	v.Entries = u.Entries
	return nil
}

func (v *signatureSection) UnmarshalJSON(data []byte) error {
	u := struct {
		Signatures encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
	}{}
	u.Signatures = encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Signatures = make([]protocol.Signature, len(u.Signatures.Value))
	for i, x := range u.Signatures.Value {
		v.Signatures[i] = x
	}
	return nil
}

func (v *snapshotHeader) UnmarshalJSON(data []byte) error {
	u := struct {
		Version  uint64 `json:"version,omitempty"`
		Height   uint64 `json:"height,omitempty"`
		RootHash string `json:"rootHash,omitempty"`
	}{}
	u.Version = v.Version
	u.Height = v.Height
	u.RootHash = encoding.ChainToJSON(v.RootHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Version = u.Version
	v.Height = u.Height
	if x, err := encoding.ChainFromJSON(u.RootHash); err != nil {
		return fmt.Errorf("error decoding RootHash: %w", err)
	} else {
		v.RootHash = x
	}
	return nil
}

func (v *transactionSection) UnmarshalJSON(data []byte) error {
	u := struct {
		Transactions encoding.JsonList[*transactionState] `json:"transactions,omitempty"`
	}{}
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transactions = u.Transactions
	return nil
}

func (v *transactionState) UnmarshalJSON(data []byte) error {
	u := struct {
		Transaction *protocol.Transaction          `json:"transaction,omitempty"`
		State       *protocol.TransactionStatus    `json:"state,omitempty"`
		Signatures  encoding.JsonList[*sigSetData] `json:"signatures,omitempty"`
	}{}
	u.Transaction = v.Transaction
	u.State = v.State
	u.Signatures = v.Signatures
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transaction = u.Transaction
	v.State = u.State
	v.Signatures = u.Signatures
	return nil
}
