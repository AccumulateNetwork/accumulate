// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package core

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type GlobalValues struct {
	memoize globalValueMemos
	Oracle  *protocol.AcmeOracle        `json:"oracle,omitempty" form:"oracle" query:"oracle" validate:"required"`
	Globals *protocol.NetworkGlobals    `json:"globals,omitempty" form:"globals" query:"globals" validate:"required"`
	Network *protocol.NetworkDefinition `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Routing *protocol.RoutingTable      `json:"routing,omitempty" form:"routing" query:"routing" validate:"required"`
	// ExecutorVersion is the active executor version.
	ExecutorVersion protocol.ExecutorVersion `json:"executorVersion,omitempty" form:"executorVersion" query:"executorVersion"`
}

func (v *GlobalValues) Copy() *GlobalValues {
	u := new(GlobalValues)

	if v.Oracle != nil {
		u.Oracle = (v.Oracle).Copy()
	}
	if v.Globals != nil {
		u.Globals = (v.Globals).Copy()
	}
	if v.Network != nil {
		u.Network = (v.Network).Copy()
	}
	if v.Routing != nil {
		u.Routing = (v.Routing).Copy()
	}
	u.ExecutorVersion = v.ExecutorVersion

	return u
}

func (v *GlobalValues) CopyAsInterface() interface{} { return v.Copy() }

func (v *GlobalValues) Equal(u *GlobalValues) bool {
	switch {
	case v.Oracle == u.Oracle:
		// equal
	case v.Oracle == nil || u.Oracle == nil:
		return false
	case !((v.Oracle).Equal(u.Oracle)):
		return false
	}
	switch {
	case v.Globals == u.Globals:
		// equal
	case v.Globals == nil || u.Globals == nil:
		return false
	case !((v.Globals).Equal(u.Globals)):
		return false
	}
	switch {
	case v.Network == u.Network:
		// equal
	case v.Network == nil || u.Network == nil:
		return false
	case !((v.Network).Equal(u.Network)):
		return false
	}
	switch {
	case v.Routing == u.Routing:
		// equal
	case v.Routing == nil || u.Routing == nil:
		return false
	case !((v.Routing).Equal(u.Routing)):
		return false
	}
	if !(v.ExecutorVersion == u.ExecutorVersion) {
		return false
	}

	return true
}
