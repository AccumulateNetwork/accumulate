// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package api

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/core"
	"gitlab.com/accumulatenetwork/accumulate/internal/node/config"
	errors2 "gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/messaging"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type ChainEntry struct {
	Height uint64      `json:"height" form:"height" query:"height" validate:"required"`
	Entry  []byte      `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	State  [][]byte    `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	Value  interface{} `json:"value,omitempty" form:"value" query:"value" validate:"required"`
}

type ChainIdQuery struct {
	ChainId []byte `json:"chainId,omitempty" form:"chainId" query:"chainId" validate:"required"`
}

type ChainQueryResponse struct {
	Type          string          `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	MainChain     *MerkleState    `json:"mainChain,omitempty" form:"mainChain" query:"mainChain" validate:"required"`
	Chains        []ChainState    `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
	Data          interface{}     `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	ChainId       []byte          `json:"chainId,omitempty" form:"chainId" query:"chainId" validate:"required"`
	Receipt       *GeneralReceipt `json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	LastBlockTime *time.Time      `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
}

type ChainState struct {
	fieldsSet []bool
	Name      string             `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Height    uint64             `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots     [][]byte           `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
	extraData []byte
}

type DataEntryQuery struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	EntryHash [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash"`
	extraData []byte
}

type DataEntryQueryResponse struct {
	fieldsSet     []bool
	EntryHash     [32]byte           `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	Entry         protocol.DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	TxId          *url.TxID          `json:"txId,omitempty" form:"txId" query:"txId" validate:"required"`
	CauseTxId     *url.TxID          `json:"causeTxId,omitempty" form:"causeTxId" query:"causeTxId" validate:"required"`
	LastBlockTime *time.Time         `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type DataEntrySetQuery struct {
	UrlQuery
	QueryPagination
	QueryOptions
}

type DescriptionResponse struct {
	PartitionId   string                 `json:"partitionId,omitempty" form:"partitionId" query:"partitionId" validate:"required"`
	NetworkType   protocol.PartitionType `json:"networkType,omitempty" form:"networkType" query:"networkType" validate:"required"`
	Network       NetworkDescription     `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	NetworkAnchor [32]byte               `json:"networkAnchor,omitempty" form:"networkAnchor" query:"networkAnchor" validate:"required"`
	Values        core.GlobalValues      `json:"values,omitempty" form:"values" query:"values" validate:"required"`
	Error         *errors2.Error         `json:"error,omitempty" form:"error" query:"error" validate:"required"`
}

type DirectoryQuery struct {
	UrlQuery
	QueryPagination
	QueryOptions
}

type ExecuteRequest struct {
	Envelope  *messaging.Envelope `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	CheckOnly bool                `json:"checkOnly,omitempty" form:"checkOnly" query:"checkOnly"`
}

type GeneralQuery struct {
	UrlQuery
	QueryOptions
}

type GeneralReceipt struct {
	fieldsSet      []bool
	LocalBlock     uint64         `json:"localBlock,omitempty" form:"localBlock" query:"localBlock" validate:"required"`
	LocalBlockTime *time.Time     `json:"localBlockTime,omitempty" form:"localBlockTime" query:"localBlockTime" validate:"required"`
	DirectoryBlock uint64         `json:"directoryBlock,omitempty" form:"directoryBlock" query:"directoryBlock" validate:"required"`
	MajorBlock     uint64         `json:"majorBlock,omitempty" form:"majorBlock" query:"majorBlock" validate:"required"`
	Proof          merkle.Receipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	Error          string         `json:"error,omitempty" form:"error" query:"error" validate:"required"`
	extraData      []byte
}

type KeyPage struct {
	Version uint64 `json:"version,omitempty" form:"version" query:"version"`
}

type KeyPageIndexQuery struct {
	UrlQuery
	Key []byte `json:"key,omitempty" form:"key" query:"key" validate:"required"`
}

type MajorBlocksQuery struct {
	UrlQuery
	QueryPagination
}

type MajorQueryResponse struct {

	// MajorBlockIndex is the index of the major block..
	MajorBlockIndex uint64 `json:"majorBlockIndex,omitempty" form:"majorBlockIndex" query:"majorBlockIndex" validate:"required"`
	// MajorBlockTime is the start time of the major block..
	MajorBlockTime *time.Time    `json:"majorBlockTime,omitempty" form:"majorBlockTime" query:"majorBlockTime" validate:"required"`
	MinorBlocks    []*MinorBlock `json:"minorBlocks,omitempty" form:"minorBlocks" query:"minorBlocks" validate:"required"`
	LastBlockTime  *time.Time    `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
}

type MerkleState struct {
	Height uint64   `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots  [][]byte `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
}

type MetricsQuery struct {
	Metric   string        `json:"metric,omitempty" form:"metric" query:"metric" validate:"required"`
	Duration time.Duration `json:"duration,omitempty" form:"duration" query:"duration" validate:"required"`
}

type MetricsResponse struct {
	Value interface{} `json:"value,omitempty" form:"value" query:"value" validate:"required"`
}

type MinorBlock struct {

	// BlockIndex is the index of the block. Only include when indexing the root anchor chain.
	BlockIndex uint64 `json:"blockIndex,omitempty" form:"blockIndex" query:"blockIndex" validate:"required"`
	// BlockTime is the start time of the block..
	BlockTime *time.Time `json:"blockTime,omitempty" form:"blockTime" query:"blockTime" validate:"required"`
}

type MinorBlocksQuery struct {
	UrlQuery
	QueryPagination
	TxFetchMode     TxFetchMode     `json:"txFetchMode,omitempty" form:"txFetchMode" query:"txFetchMode"`
	BlockFilterMode BlockFilterMode `json:"blockFilterMode,omitempty" form:"blockFilterMode" query:"blockFilterMode"`
}

type MinorQueryResponse struct {
	MinorBlock
	// TxCount shows how many transactions this block contains.
	TxCount       uint64                      `json:"txCount,omitempty" form:"txCount" query:"txCount" validate:"required"`
	TxIds         [][]byte                    `json:"txIds,omitempty" form:"txIds" query:"txIds" validate:"required"`
	Transactions  []*TransactionQueryResponse `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	LastBlockTime *time.Time                  `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
}

type MultiResponse struct {
	Type          string        `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Items         []interface{} `json:"items,omitempty" form:"items" query:"items" validate:"required"`
	Start         uint64        `json:"start" form:"start" query:"start" validate:"required"`
	Count         uint64        `json:"count" form:"count" query:"count" validate:"required"`
	Total         uint64        `json:"total" form:"total" query:"total" validate:"required"`
	OtherItems    []interface{} `json:"otherItems,omitempty" form:"otherItems" query:"otherItems" validate:"required"`
	LastBlockTime *time.Time    `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
}

type NetworkDescription struct {
	fieldsSet  []bool
	Id         string                 `json:"id,omitempty" form:"id" query:"id" validate:"required" toml:"id" mapstructure:"id"`
	Partitions []PartitionDescription `json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required" toml:"partitions" mapstructure:"partitions"`
	extraData  []byte
}

type NodeDescription struct {
	fieldsSet []bool
	Address   string          `json:"address,omitempty" form:"address" query:"address" validate:"required" toml:"address" mapstructure:"address"`
	Type      config.NodeType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	extraData []byte
}

type PartitionDescription struct {
	fieldsSet []bool
	Id        string                 `json:"id,omitempty" form:"id" query:"id" validate:"required" toml:"id" mapstructure:"id"`
	Type      protocol.PartitionType `json:"type,omitempty" form:"type" query:"type" validate:"required" toml:"type" mapstructure:"type"`
	BasePort  int64                  `json:"basePort,omitempty" form:"basePort" query:"basePort" validate:"required" toml:"port" mapstructure:"port"`
	Nodes     []NodeDescription      `json:"nodes,omitempty" form:"nodes" query:"nodes" validate:"required" toml:"nodes" mapstructure:"nodes"`
	extraData []byte
}

type QueryOptions struct {
	Expand  bool   `json:"expand,omitempty" form:"expand" query:"expand"`
	Height  uint64 `json:"height,omitempty" form:"height" query:"height"`
	Scratch bool   `json:"scratch,omitempty" form:"scratch" query:"scratch"`
	Prove   bool   `json:"prove,omitempty" form:"prove" query:"prove"`
	// IncludeRemote tells QueryTx not to ignore remote transactions.
	IncludeRemote bool `json:"includeRemote,omitempty" form:"includeRemote" query:"includeRemote"`
}

type QueryPagination struct {
	Start uint64 `json:"start,omitempty" form:"start" query:"start"`
	Count uint64 `json:"count,omitempty" form:"count" query:"count"`
}

type ResponseDataEntry struct {
	fieldsSet     []bool
	EntryHash     [32]byte           `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	Entry         protocol.DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	TxId          *url.TxID          `json:"txId,omitempty" form:"txId" query:"txId" validate:"required"`
	CauseTxId     *url.TxID          `json:"causeTxId,omitempty" form:"causeTxId" query:"causeTxId" validate:"required"`
	LastBlockTime *time.Time         `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type ResponseDataEntrySet struct {
	fieldsSet     []bool
	DataEntries   []ResponseDataEntry `json:"dataEntries,omitempty" form:"dataEntries" query:"dataEntries" validate:"required"`
	Total         uint64              `json:"total,omitempty" form:"total" query:"total" validate:"required"`
	LastBlockTime *time.Time          `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type ResponseKeyPageIndex struct {
	fieldsSet     []bool
	Authority     *url.URL   `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	Signer        *url.URL   `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	Index         uint64     `json:"index" form:"index" query:"index" validate:"required"`
	LastBlockTime *time.Time `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
	extraData     []byte
}

type SignatureBook struct {
	Authority *url.URL         `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	Pages     []*SignaturePage `json:"pages,omitempty" form:"pages" query:"pages" validate:"required"`
}

type SignaturePage struct {
	Signer     SignerMetadata       `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	Signatures []protocol.Signature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
}

type Signer struct {
	PublicKey     []byte                 `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Timestamp     uint64                 `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	Url           *url.URL               `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Version       uint64                 `json:"version,omitempty" form:"version" query:"version"`
	SignatureType protocol.SignatureType `json:"signatureType,omitempty" form:"signatureType" query:"signatureType"`
	// UseSimpleHash tells the API to use the signature's simple metadata hash as the initiator hash instead of its Merkle hash.
	UseSimpleHash bool `json:"useSimpleHash,omitempty" form:"useSimpleHash" query:"useSimpleHash"`
}

type SignerMetadata struct {
	Type            protocol.AccountType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Url             *url.URL             `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	AcceptThreshold uint64               `json:"acceptThreshold,omitempty" form:"acceptThreshold" query:"acceptThreshold" validate:"required"`
}

type StatusResponse struct {
	Ok                        bool      `json:"ok,omitempty" form:"ok" query:"ok" validate:"required"`
	BvnHeight                 int64     `json:"bvnHeight,omitempty" form:"bvnHeight" query:"bvnHeight" validate:"required"`
	DnHeight                  int64     `json:"dnHeight,omitempty" form:"dnHeight" query:"dnHeight" validate:"required"`
	BvnTime                   time.Time `json:"bvnTime,omitempty" form:"bvnTime" query:"bvnTime" validate:"required"`
	DnTime                    time.Time `json:"dnTime,omitempty" form:"dnTime" query:"dnTime" validate:"required"`
	LastDirectoryAnchorHeight uint64    `json:"lastDirectoryAnchorHeight,omitempty" form:"lastDirectoryAnchorHeight" query:"lastDirectoryAnchorHeight" validate:"required"`
	BvnRootHash               [32]byte  `json:"bvnRootHash,omitempty" form:"bvnRootHash" query:"bvnRootHash" validate:"required"`
	DnRootHash                [32]byte  `json:"dnRootHash,omitempty" form:"dnRootHash" query:"dnRootHash" validate:"required"`
	BvnBptHash                [32]byte  `json:"bvnBptHash,omitempty" form:"bvnBptHash" query:"bvnBptHash" validate:"required"`
	DnBptHash                 [32]byte  `json:"dnBptHash,omitempty" form:"dnBptHash" query:"dnBptHash" validate:"required"`
}

type SyntheticTransactionRequest struct {
	Source         *url.URL `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	Destination    *url.URL `json:"destination,omitempty" form:"destination" query:"destination" validate:"required"`
	SequenceNumber uint64   `json:"sequenceNumber,omitempty" form:"sequenceNumber" query:"sequenceNumber"`
	Anchor         bool     `json:"anchor,omitempty" form:"anchor" query:"anchor"`
}

type TokenDeposit struct {
	Url    *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Amount big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	Txid   []byte   `json:"txid,omitempty" form:"txid" query:"txid" validate:"required"`
}

type TokenSend struct {
	From *url.URL       `json:"from,omitempty" form:"from" query:"from" validate:"required"`
	To   []TokenDeposit `json:"to,omitempty" form:"to" query:"to" validate:"required"`
}

type TransactionQueryResponse struct {
	Type            string                      `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	MainChain       *MerkleState                `json:"mainChain,omitempty" form:"mainChain" query:"mainChain" validate:"required"`
	Data            interface{}                 `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	Origin          *url.URL                    `json:"origin,omitempty" form:"origin" query:"origin" validate:"required"`
	TransactionHash []byte                      `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash" validate:"required"`
	Txid            *url.TxID                   `json:"txid,omitempty" form:"txid" query:"txid" validate:"required"`
	Transaction     *protocol.Transaction       `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signatures      []protocol.Signature        `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	Status          *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	Produced        []*url.TxID                 `json:"produced,omitempty" form:"produced" query:"produced" validate:"required"`
	Receipts        []*TxReceipt                `json:"receipts,omitempty" form:"receipts" query:"receipts" validate:"required"`
	SignatureBooks  []*SignatureBook            `json:"signatureBooks,omitempty" form:"signatureBooks" query:"signatureBooks" validate:"required"`
	LastBlockTime   *time.Time                  `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
}

type TxHistoryQuery struct {
	UrlQuery
	QueryPagination
	Scratch bool `json:"scratch,omitempty" form:"scratch" query:"scratch"`
}

type TxReceipt struct {
	fieldsSet []bool
	GeneralReceipt
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Chain     string   `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	extraData []byte
}

type TxRequest struct {
	CheckOnly  bool     `json:"checkOnly,omitempty" form:"checkOnly" query:"checkOnly"`
	IsEnvelope bool     `json:"isEnvelope,omitempty" form:"isEnvelope" query:"isEnvelope"`
	Origin     *url.URL `json:"origin,omitempty" form:"origin" query:"origin" validate:"required"`
	Signer     Signer   `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	Signature  []byte   `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	// KeyPage is deprecated.
	KeyPage  KeyPage     `json:"keyPage,omitempty" form:"keyPage" query:"keyPage" validate:"required"`
	TxHash   []byte      `json:"txHash,omitempty" form:"txHash" query:"txHash"`
	Payload  interface{} `json:"payload,omitempty" form:"payload" query:"payload" validate:"required"`
	Memo     string      `json:"memo,omitempty" form:"memo" query:"memo"`
	Metadata []byte      `json:"metadata,omitempty" form:"metadata" query:"metadata"`
}

type TxResponse struct {
	TransactionHash []byte      `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash" validate:"required"`
	Txid            *url.TxID   `json:"txid,omitempty" form:"txid" query:"txid" validate:"required"`
	SignatureHashes [][]byte    `json:"signatureHashes,omitempty" form:"signatureHashes" query:"signatureHashes" validate:"required"`
	SimpleHash      []byte      `json:"simpleHash,omitempty" form:"simpleHash" query:"simpleHash" validate:"required"`
	Code            uint64      `json:"code,omitempty" form:"code" query:"code" validate:"required"`
	Message         string      `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Delivered       bool        `json:"delivered,omitempty" form:"delivered" query:"delivered" validate:"required"`
	Result          interface{} `json:"result,omitempty" form:"result" query:"result" validate:"required"`
	LastBlockTime   *time.Time  `json:"lastBlockTime,omitempty" form:"lastBlockTime" query:"lastBlockTime" validate:"required"`
}

type TxnQuery struct {
	QueryOptions
	Txid    []byte        `json:"txid,omitempty" form:"txid" query:"txid"`
	TxIdUrl *url.TxID     `json:"txIdUrl,omitempty" form:"txIdUrl" query:"txIdUrl"`
	Wait    time.Duration `json:"wait,omitempty" form:"wait" query:"wait"`
	// IgnorePending tells QueryTx to ignore pending transactions.
	IgnorePending bool `json:"ignorePending,omitempty" form:"ignorePending" query:"ignorePending"`
}

type UrlQuery struct {
	Url *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
}

type VersionResponse struct {
	Version        string `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Commit         string `json:"commit,omitempty" form:"commit" query:"commit" validate:"required"`
	VersionIsKnown bool   `json:"versionIsKnown,omitempty" form:"versionIsKnown" query:"versionIsKnown" validate:"required"`
	IsTestNet      bool   `json:"isTestNet,omitempty" form:"isTestNet" query:"isTestNet" validate:"required"`
}

func (v *ChainState) Copy() *ChainState {
	u := new(ChainState)

	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Roots = make([][]byte, len(v.Roots))
	for i, v := range v.Roots {
		v := v
		u.Roots[i] = encoding.BytesCopy(v)
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ChainState) CopyAsInterface() interface{} { return v.Copy() }

func (v *DataEntryQuery) Copy() *DataEntryQuery {
	u := new(DataEntryQuery)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.EntryHash = v.EntryHash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *DataEntryQuery) CopyAsInterface() interface{} { return v.Copy() }

func (v *DataEntryQueryResponse) Copy() *DataEntryQueryResponse {
	u := new(DataEntryQueryResponse)

	u.EntryHash = v.EntryHash
	if v.Entry != nil {
		u.Entry = protocol.CopyDataEntry(v.Entry)
	}
	if v.TxId != nil {
		u.TxId = v.TxId
	}
	if v.CauseTxId != nil {
		u.CauseTxId = v.CauseTxId
	}
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *DataEntryQueryResponse) CopyAsInterface() interface{} { return v.Copy() }

func (v *GeneralReceipt) Copy() *GeneralReceipt {
	u := new(GeneralReceipt)

	u.LocalBlock = v.LocalBlock
	if v.LocalBlockTime != nil {
		u.LocalBlockTime = new(time.Time)
		*u.LocalBlockTime = *v.LocalBlockTime
	}
	u.DirectoryBlock = v.DirectoryBlock
	u.MajorBlock = v.MajorBlock
	u.Proof = *(&v.Proof).Copy()
	u.Error = v.Error
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *GeneralReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *NetworkDescription) Copy() *NetworkDescription {
	u := new(NetworkDescription)

	u.Id = v.Id
	u.Partitions = make([]PartitionDescription, len(v.Partitions))
	for i, v := range v.Partitions {
		v := v
		u.Partitions[i] = *(&v).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NetworkDescription) CopyAsInterface() interface{} { return v.Copy() }

func (v *NodeDescription) Copy() *NodeDescription {
	u := new(NodeDescription)

	u.Address = v.Address
	u.Type = v.Type
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *NodeDescription) CopyAsInterface() interface{} { return v.Copy() }

func (v *PartitionDescription) Copy() *PartitionDescription {
	u := new(PartitionDescription)

	u.Id = v.Id
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = make([]NodeDescription, len(v.Nodes))
	for i, v := range v.Nodes {
		v := v
		u.Nodes[i] = *(&v).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *PartitionDescription) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseDataEntry) Copy() *ResponseDataEntry {
	u := new(ResponseDataEntry)

	u.EntryHash = v.EntryHash
	if v.Entry != nil {
		u.Entry = protocol.CopyDataEntry(v.Entry)
	}
	if v.TxId != nil {
		u.TxId = v.TxId
	}
	if v.CauseTxId != nil {
		u.CauseTxId = v.CauseTxId
	}
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ResponseDataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseDataEntrySet) Copy() *ResponseDataEntrySet {
	u := new(ResponseDataEntrySet)

	u.DataEntries = make([]ResponseDataEntry, len(v.DataEntries))
	for i, v := range v.DataEntries {
		v := v
		u.DataEntries[i] = *(&v).Copy()
	}
	u.Total = v.Total
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ResponseDataEntrySet) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseKeyPageIndex) Copy() *ResponseKeyPageIndex {
	u := new(ResponseKeyPageIndex)

	if v.Authority != nil {
		u.Authority = v.Authority
	}
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.Index = v.Index
	if v.LastBlockTime != nil {
		u.LastBlockTime = new(time.Time)
		*u.LastBlockTime = *v.LastBlockTime
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ResponseKeyPageIndex) CopyAsInterface() interface{} { return v.Copy() }

func (v *TxReceipt) Copy() *TxReceipt {
	u := new(TxReceipt)

	u.GeneralReceipt = *v.GeneralReceipt.Copy()
	if v.Account != nil {
		u.Account = v.Account
	}
	u.Chain = v.Chain
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *TxReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainEntry) Equal(u *ChainEntry) bool {
	if !(v.Height == u.Height) {
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}
	if !(v.Value == u.Value) {
		return false
	}

	return true
}

func (v *ChainIdQuery) Equal(u *ChainIdQuery) bool {
	if !(bytes.Equal(v.ChainId, u.ChainId)) {
		return false
	}

	return true
}

func (v *ChainQueryResponse) Equal(u *ChainQueryResponse) bool {
	if !(v.Type == u.Type) {
		return false
	}
	switch {
	case v.MainChain == u.MainChain:
		// equal
	case v.MainChain == nil || u.MainChain == nil:
		return false
	case !((v.MainChain).Equal(u.MainChain)):
		return false
	}
	if len(v.Chains) != len(u.Chains) {
		return false
	}
	for i := range v.Chains {
		if !((&v.Chains[i]).Equal(&u.Chains[i])) {
			return false
		}
	}
	if !(v.Data == u.Data) {
		return false
	}
	if !(bytes.Equal(v.ChainId, u.ChainId)) {
		return false
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *ChainState) Equal(u *ChainState) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.Roots) != len(u.Roots) {
		return false
	}
	for i := range v.Roots {
		if !(bytes.Equal(v.Roots[i], u.Roots[i])) {
			return false
		}
	}

	return true
}

func (v *DataEntryQuery) Equal(u *DataEntryQuery) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	return true
}

func (v *DataEntryQueryResponse) Equal(u *DataEntryQueryResponse) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}
	if !(protocol.EqualDataEntry(v.Entry, u.Entry)) {
		return false
	}
	switch {
	case v.TxId == u.TxId:
		// equal
	case v.TxId == nil || u.TxId == nil:
		return false
	case !((v.TxId).Equal(u.TxId)):
		return false
	}
	switch {
	case v.CauseTxId == u.CauseTxId:
		// equal
	case v.CauseTxId == nil || u.CauseTxId == nil:
		return false
	case !((v.CauseTxId).Equal(u.CauseTxId)):
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *DataEntrySetQuery) Equal(u *DataEntrySetQuery) bool {
	if !v.UrlQuery.Equal(&u.UrlQuery) {
		return false
	}
	if !v.QueryPagination.Equal(&u.QueryPagination) {
		return false
	}
	if !v.QueryOptions.Equal(&u.QueryOptions) {
		return false
	}

	return true
}

func (v *DescriptionResponse) Equal(u *DescriptionResponse) bool {
	if !(v.PartitionId == u.PartitionId) {
		return false
	}
	if !(v.NetworkType == u.NetworkType) {
		return false
	}
	if !((&v.Network).Equal(&u.Network)) {
		return false
	}
	if !(v.NetworkAnchor == u.NetworkAnchor) {
		return false
	}
	if !((&v.Values).Equal(&u.Values)) {
		return false
	}
	switch {
	case v.Error == u.Error:
		// equal
	case v.Error == nil || u.Error == nil:
		return false
	case !((v.Error).Equal(u.Error)):
		return false
	}

	return true
}

func (v *DirectoryQuery) Equal(u *DirectoryQuery) bool {
	if !v.UrlQuery.Equal(&u.UrlQuery) {
		return false
	}
	if !v.QueryPagination.Equal(&u.QueryPagination) {
		return false
	}
	if !v.QueryOptions.Equal(&u.QueryOptions) {
		return false
	}

	return true
}

func (v *ExecuteRequest) Equal(u *ExecuteRequest) bool {
	switch {
	case v.Envelope == u.Envelope:
		// equal
	case v.Envelope == nil || u.Envelope == nil:
		return false
	case !((v.Envelope).Equal(u.Envelope)):
		return false
	}
	if !(v.CheckOnly == u.CheckOnly) {
		return false
	}

	return true
}

func (v *GeneralQuery) Equal(u *GeneralQuery) bool {
	if !v.UrlQuery.Equal(&u.UrlQuery) {
		return false
	}
	if !v.QueryOptions.Equal(&u.QueryOptions) {
		return false
	}

	return true
}

func (v *GeneralReceipt) Equal(u *GeneralReceipt) bool {
	if !(v.LocalBlock == u.LocalBlock) {
		return false
	}
	switch {
	case v.LocalBlockTime == u.LocalBlockTime:
		// equal
	case v.LocalBlockTime == nil || u.LocalBlockTime == nil:
		return false
	case !((*v.LocalBlockTime).Equal(*u.LocalBlockTime)):
		return false
	}
	if !(v.DirectoryBlock == u.DirectoryBlock) {
		return false
	}
	if !(v.MajorBlock == u.MajorBlock) {
		return false
	}
	if !((&v.Proof).Equal(&u.Proof)) {
		return false
	}
	if !(v.Error == u.Error) {
		return false
	}

	return true
}

func (v *KeyPage) Equal(u *KeyPage) bool {
	if !(v.Version == u.Version) {
		return false
	}

	return true
}

func (v *KeyPageIndexQuery) Equal(u *KeyPageIndexQuery) bool {
	if !v.UrlQuery.Equal(&u.UrlQuery) {
		return false
	}
	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}

	return true
}

func (v *MajorBlocksQuery) Equal(u *MajorBlocksQuery) bool {
	if !v.UrlQuery.Equal(&u.UrlQuery) {
		return false
	}
	if !v.QueryPagination.Equal(&u.QueryPagination) {
		return false
	}

	return true
}

func (v *MajorQueryResponse) Equal(u *MajorQueryResponse) bool {
	if !(v.MajorBlockIndex == u.MajorBlockIndex) {
		return false
	}
	switch {
	case v.MajorBlockTime == u.MajorBlockTime:
		// equal
	case v.MajorBlockTime == nil || u.MajorBlockTime == nil:
		return false
	case !((*v.MajorBlockTime).Equal(*u.MajorBlockTime)):
		return false
	}
	if len(v.MinorBlocks) != len(u.MinorBlocks) {
		return false
	}
	for i := range v.MinorBlocks {
		if !((v.MinorBlocks[i]).Equal(u.MinorBlocks[i])) {
			return false
		}
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *MerkleState) Equal(u *MerkleState) bool {
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.Roots) != len(u.Roots) {
		return false
	}
	for i := range v.Roots {
		if !(bytes.Equal(v.Roots[i], u.Roots[i])) {
			return false
		}
	}

	return true
}

func (v *MetricsQuery) Equal(u *MetricsQuery) bool {
	if !(v.Metric == u.Metric) {
		return false
	}
	if !(v.Duration == u.Duration) {
		return false
	}

	return true
}

func (v *MetricsResponse) Equal(u *MetricsResponse) bool {
	if !(v.Value == u.Value) {
		return false
	}

	return true
}

func (v *MinorBlock) Equal(u *MinorBlock) bool {
	if !(v.BlockIndex == u.BlockIndex) {
		return false
	}
	switch {
	case v.BlockTime == u.BlockTime:
		// equal
	case v.BlockTime == nil || u.BlockTime == nil:
		return false
	case !((*v.BlockTime).Equal(*u.BlockTime)):
		return false
	}

	return true
}

func (v *MinorBlocksQuery) Equal(u *MinorBlocksQuery) bool {
	if !v.UrlQuery.Equal(&u.UrlQuery) {
		return false
	}
	if !v.QueryPagination.Equal(&u.QueryPagination) {
		return false
	}
	if !(v.TxFetchMode == u.TxFetchMode) {
		return false
	}
	if !(v.BlockFilterMode == u.BlockFilterMode) {
		return false
	}

	return true
}

func (v *MinorQueryResponse) Equal(u *MinorQueryResponse) bool {
	if !v.MinorBlock.Equal(&u.MinorBlock) {
		return false
	}
	if !(v.TxCount == u.TxCount) {
		return false
	}
	if len(v.TxIds) != len(u.TxIds) {
		return false
	}
	for i := range v.TxIds {
		if !(bytes.Equal(v.TxIds[i], u.TxIds[i])) {
			return false
		}
	}
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((v.Transactions[i]).Equal(u.Transactions[i])) {
			return false
		}
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *MultiResponse) Equal(u *MultiResponse) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if len(v.Items) != len(u.Items) {
		return false
	}
	for i := range v.Items {
		if !(v.Items[i] == u.Items[i]) {
			return false
		}
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.OtherItems) != len(u.OtherItems) {
		return false
	}
	for i := range v.OtherItems {
		if !(v.OtherItems[i] == u.OtherItems[i]) {
			return false
		}
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *NetworkDescription) Equal(u *NetworkDescription) bool {
	if !(v.Id == u.Id) {
		return false
	}
	if len(v.Partitions) != len(u.Partitions) {
		return false
	}
	for i := range v.Partitions {
		if !((&v.Partitions[i]).Equal(&u.Partitions[i])) {
			return false
		}
	}

	return true
}

func (v *NodeDescription) Equal(u *NodeDescription) bool {
	if !(v.Address == u.Address) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}

	return true
}

func (v *PartitionDescription) Equal(u *PartitionDescription) bool {
	if !(v.Id == u.Id) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.BasePort == u.BasePort) {
		return false
	}
	if len(v.Nodes) != len(u.Nodes) {
		return false
	}
	for i := range v.Nodes {
		if !((&v.Nodes[i]).Equal(&u.Nodes[i])) {
			return false
		}
	}

	return true
}

func (v *QueryOptions) Equal(u *QueryOptions) bool {
	if !(v.Expand == u.Expand) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}
	if !(v.Prove == u.Prove) {
		return false
	}
	if !(v.IncludeRemote == u.IncludeRemote) {
		return false
	}

	return true
}

func (v *QueryPagination) Equal(u *QueryPagination) bool {
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}

	return true
}

func (v *ResponseDataEntry) Equal(u *ResponseDataEntry) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}
	if !(protocol.EqualDataEntry(v.Entry, u.Entry)) {
		return false
	}
	switch {
	case v.TxId == u.TxId:
		// equal
	case v.TxId == nil || u.TxId == nil:
		return false
	case !((v.TxId).Equal(u.TxId)):
		return false
	}
	switch {
	case v.CauseTxId == u.CauseTxId:
		// equal
	case v.CauseTxId == nil || u.CauseTxId == nil:
		return false
	case !((v.CauseTxId).Equal(u.CauseTxId)):
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *ResponseDataEntrySet) Equal(u *ResponseDataEntrySet) bool {
	if len(v.DataEntries) != len(u.DataEntries) {
		return false
	}
	for i := range v.DataEntries {
		if !((&v.DataEntries[i]).Equal(&u.DataEntries[i])) {
			return false
		}
	}
	if !(v.Total == u.Total) {
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *ResponseKeyPageIndex) Equal(u *ResponseKeyPageIndex) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *SignatureBook) Equal(u *SignatureBook) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	if len(v.Pages) != len(u.Pages) {
		return false
	}
	for i := range v.Pages {
		if !((v.Pages[i]).Equal(u.Pages[i])) {
			return false
		}
	}

	return true
}

func (v *SignaturePage) Equal(u *SignaturePage) bool {
	if !((&v.Signer).Equal(&u.Signer)) {
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(protocol.EqualSignature(v.Signatures[i], u.Signatures[i])) {
			return false
		}
	}

	return true
}

func (v *Signer) Equal(u *Signer) bool {
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(v.Timestamp == u.Timestamp) {
		return false
	}
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.SignatureType == u.SignatureType) {
		return false
	}
	if !(v.UseSimpleHash == u.UseSimpleHash) {
		return false
	}

	return true
}

func (v *SignerMetadata) Equal(u *SignerMetadata) bool {
	if !(v.Type == u.Type) {
		return false
	}
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.AcceptThreshold == u.AcceptThreshold) {
		return false
	}

	return true
}

func (v *StatusResponse) Equal(u *StatusResponse) bool {
	if !(v.Ok == u.Ok) {
		return false
	}
	if !(v.BvnHeight == u.BvnHeight) {
		return false
	}
	if !(v.DnHeight == u.DnHeight) {
		return false
	}
	if !((v.BvnTime).Equal(u.BvnTime)) {
		return false
	}
	if !((v.DnTime).Equal(u.DnTime)) {
		return false
	}
	if !(v.LastDirectoryAnchorHeight == u.LastDirectoryAnchorHeight) {
		return false
	}
	if !(v.BvnRootHash == u.BvnRootHash) {
		return false
	}
	if !(v.DnRootHash == u.DnRootHash) {
		return false
	}
	if !(v.BvnBptHash == u.BvnBptHash) {
		return false
	}
	if !(v.DnBptHash == u.DnBptHash) {
		return false
	}

	return true
}

func (v *SyntheticTransactionRequest) Equal(u *SyntheticTransactionRequest) bool {
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	switch {
	case v.Destination == u.Destination:
		// equal
	case v.Destination == nil || u.Destination == nil:
		return false
	case !((v.Destination).Equal(u.Destination)):
		return false
	}
	if !(v.SequenceNumber == u.SequenceNumber) {
		return false
	}
	if !(v.Anchor == u.Anchor) {
		return false
	}

	return true
}

func (v *TokenDeposit) Equal(u *TokenDeposit) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !((&v.Amount).Cmp(&u.Amount) == 0) {
		return false
	}
	if !(bytes.Equal(v.Txid, u.Txid)) {
		return false
	}

	return true
}

func (v *TokenSend) Equal(u *TokenSend) bool {
	switch {
	case v.From == u.From:
		// equal
	case v.From == nil || u.From == nil:
		return false
	case !((v.From).Equal(u.From)):
		return false
	}
	if len(v.To) != len(u.To) {
		return false
	}
	for i := range v.To {
		if !((&v.To[i]).Equal(&u.To[i])) {
			return false
		}
	}

	return true
}

func (v *TransactionQueryResponse) Equal(u *TransactionQueryResponse) bool {
	if !(v.Type == u.Type) {
		return false
	}
	switch {
	case v.MainChain == u.MainChain:
		// equal
	case v.MainChain == nil || u.MainChain == nil:
		return false
	case !((v.MainChain).Equal(u.MainChain)):
		return false
	}
	if !(v.Data == u.Data) {
		return false
	}
	switch {
	case v.Origin == u.Origin:
		// equal
	case v.Origin == nil || u.Origin == nil:
		return false
	case !((v.Origin).Equal(u.Origin)):
		return false
	}
	if !(bytes.Equal(v.TransactionHash, u.TransactionHash)) {
		return false
	}
	switch {
	case v.Txid == u.Txid:
		// equal
	case v.Txid == nil || u.Txid == nil:
		return false
	case !((v.Txid).Equal(u.Txid)):
		return false
	}
	switch {
	case v.Transaction == u.Transaction:
		// equal
	case v.Transaction == nil || u.Transaction == nil:
		return false
	case !((v.Transaction).Equal(u.Transaction)):
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(protocol.EqualSignature(v.Signatures[i], u.Signatures[i])) {
			return false
		}
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}
	if len(v.Produced) != len(u.Produced) {
		return false
	}
	for i := range v.Produced {
		if !((v.Produced[i]).Equal(u.Produced[i])) {
			return false
		}
	}
	if len(v.Receipts) != len(u.Receipts) {
		return false
	}
	for i := range v.Receipts {
		if !((v.Receipts[i]).Equal(u.Receipts[i])) {
			return false
		}
	}
	if len(v.SignatureBooks) != len(u.SignatureBooks) {
		return false
	}
	for i := range v.SignatureBooks {
		if !((v.SignatureBooks[i]).Equal(u.SignatureBooks[i])) {
			return false
		}
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *TxHistoryQuery) Equal(u *TxHistoryQuery) bool {
	if !v.UrlQuery.Equal(&u.UrlQuery) {
		return false
	}
	if !v.QueryPagination.Equal(&u.QueryPagination) {
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *TxReceipt) Equal(u *TxReceipt) bool {
	if !v.GeneralReceipt.Equal(&u.GeneralReceipt) {
		return false
	}
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}

	return true
}

func (v *TxRequest) Equal(u *TxRequest) bool {
	if !(v.CheckOnly == u.CheckOnly) {
		return false
	}
	if !(v.IsEnvelope == u.IsEnvelope) {
		return false
	}
	switch {
	case v.Origin == u.Origin:
		// equal
	case v.Origin == nil || u.Origin == nil:
		return false
	case !((v.Origin).Equal(u.Origin)):
		return false
	}
	if !((&v.Signer).Equal(&u.Signer)) {
		return false
	}
	if !(bytes.Equal(v.Signature, u.Signature)) {
		return false
	}
	if !((&v.KeyPage).Equal(&u.KeyPage)) {
		return false
	}
	if !(bytes.Equal(v.TxHash, u.TxHash)) {
		return false
	}
	if !(v.Payload == u.Payload) {
		return false
	}
	if !(v.Memo == u.Memo) {
		return false
	}
	if !(bytes.Equal(v.Metadata, u.Metadata)) {
		return false
	}

	return true
}

func (v *TxResponse) Equal(u *TxResponse) bool {
	if !(bytes.Equal(v.TransactionHash, u.TransactionHash)) {
		return false
	}
	switch {
	case v.Txid == u.Txid:
		// equal
	case v.Txid == nil || u.Txid == nil:
		return false
	case !((v.Txid).Equal(u.Txid)):
		return false
	}
	if len(v.SignatureHashes) != len(u.SignatureHashes) {
		return false
	}
	for i := range v.SignatureHashes {
		if !(bytes.Equal(v.SignatureHashes[i], u.SignatureHashes[i])) {
			return false
		}
	}
	if !(bytes.Equal(v.SimpleHash, u.SimpleHash)) {
		return false
	}
	if !(v.Code == u.Code) {
		return false
	}
	if !(v.Message == u.Message) {
		return false
	}
	if !(v.Delivered == u.Delivered) {
		return false
	}
	if !(v.Result == u.Result) {
		return false
	}
	switch {
	case v.LastBlockTime == u.LastBlockTime:
		// equal
	case v.LastBlockTime == nil || u.LastBlockTime == nil:
		return false
	case !((*v.LastBlockTime).Equal(*u.LastBlockTime)):
		return false
	}

	return true
}

func (v *TxnQuery) Equal(u *TxnQuery) bool {
	if !v.QueryOptions.Equal(&u.QueryOptions) {
		return false
	}
	if !(bytes.Equal(v.Txid, u.Txid)) {
		return false
	}
	switch {
	case v.TxIdUrl == u.TxIdUrl:
		// equal
	case v.TxIdUrl == nil || u.TxIdUrl == nil:
		return false
	case !((v.TxIdUrl).Equal(u.TxIdUrl)):
		return false
	}
	if !(v.Wait == u.Wait) {
		return false
	}
	if !(v.IgnorePending == u.IgnorePending) {
		return false
	}

	return true
}

func (v *UrlQuery) Equal(u *UrlQuery) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}

	return true
}

func (v *VersionResponse) Equal(u *VersionResponse) bool {
	if !(v.Version == u.Version) {
		return false
	}
	if !(v.Commit == u.Commit) {
		return false
	}
	if !(v.VersionIsKnown == u.VersionIsKnown) {
		return false
	}
	if !(v.IsTestNet == u.IsTestNet) {
		return false
	}

	return true
}

var fieldNames_ChainState = []string{
	1: "Name",
	2: "Type",
	3: "Height",
	4: "Roots",
}

func (v *ChainState) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.Height == 0) {
		writer.WriteUint(3, v.Height)
	}
	if !(len(v.Roots) == 0) {
		for _, v := range v.Roots {
			writer.WriteBytes(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ChainState)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Roots is missing")
	} else if len(v.Roots) == 0 {
		errs = append(errs, "field Roots is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DataEntryQuery = []string{
	1: "Url",
	2: "EntryHash",
}

func (v *DataEntryQuery) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(2, &v.EntryHash)
	}

	_, _, err := writer.Reset(fieldNames_DataEntryQuery)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DataEntryQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DataEntryQueryResponse = []string{
	1: "EntryHash",
	2: "Entry",
	3: "TxId",
	4: "CauseTxId",
	5: "LastBlockTime",
}

func (v *DataEntryQueryResponse) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(1, &v.EntryHash)
	}
	if !(protocol.EqualDataEntry(v.Entry, nil)) {
		writer.WriteValue(2, v.Entry.MarshalBinary)
	}
	if !(v.TxId == nil) {
		writer.WriteTxid(3, v.TxId)
	}
	if !(v.CauseTxId == nil) {
		writer.WriteTxid(4, v.CauseTxId)
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(5, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_DataEntryQueryResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DataEntryQueryResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Entry is missing")
	} else if protocol.EqualDataEntry(v.Entry, nil) {
		errs = append(errs, "field Entry is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TxId is missing")
	} else if v.TxId == nil {
		errs = append(errs, "field TxId is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field CauseTxId is missing")
	} else if v.CauseTxId == nil {
		errs = append(errs, "field CauseTxId is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_GeneralReceipt = []string{
	1: "LocalBlock",
	2: "LocalBlockTime",
	3: "DirectoryBlock",
	4: "MajorBlock",
	5: "Proof",
	6: "Error",
}

func (v *GeneralReceipt) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.LocalBlock == 0) {
		writer.WriteUint(1, v.LocalBlock)
	}
	if !(v.LocalBlockTime == nil) {
		writer.WriteTime(2, *v.LocalBlockTime)
	}
	if !(v.DirectoryBlock == 0) {
		writer.WriteUint(3, v.DirectoryBlock)
	}
	if !(v.MajorBlock == 0) {
		writer.WriteUint(4, v.MajorBlock)
	}
	if !((v.Proof).Equal(new(merkle.Receipt))) {
		writer.WriteValue(5, v.Proof.MarshalBinary)
	}
	if !(len(v.Error) == 0) {
		writer.WriteString(6, v.Error)
	}

	_, _, err := writer.Reset(fieldNames_GeneralReceipt)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *GeneralReceipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field LocalBlock is missing")
	} else if v.LocalBlock == 0 {
		errs = append(errs, "field LocalBlock is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field LocalBlockTime is missing")
	} else if v.LocalBlockTime == nil {
		errs = append(errs, "field LocalBlockTime is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field DirectoryBlock is missing")
	} else if v.DirectoryBlock == 0 {
		errs = append(errs, "field DirectoryBlock is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field MajorBlock is missing")
	} else if v.MajorBlock == 0 {
		errs = append(errs, "field MajorBlock is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Proof is missing")
	} else if (v.Proof).Equal(new(merkle.Receipt)) {
		errs = append(errs, "field Proof is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Error is missing")
	} else if len(v.Error) == 0 {
		errs = append(errs, "field Error is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NetworkDescription = []string{
	1: "Id",
	2: "Partitions",
}

func (v *NetworkDescription) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Id) == 0) {
		writer.WriteString(1, v.Id)
	}
	if !(len(v.Partitions) == 0) {
		for _, v := range v.Partitions {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_NetworkDescription)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NetworkDescription) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Id is missing")
	} else if len(v.Id) == 0 {
		errs = append(errs, "field Id is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Partitions is missing")
	} else if len(v.Partitions) == 0 {
		errs = append(errs, "field Partitions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_NodeDescription = []string{
	1: "Address",
	2: "Type",
}

func (v *NodeDescription) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Address) == 0) {
		writer.WriteString(1, v.Address)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}

	_, _, err := writer.Reset(fieldNames_NodeDescription)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *NodeDescription) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Address is missing")
	} else if len(v.Address) == 0 {
		errs = append(errs, "field Address is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_PartitionDescription = []string{
	1: "Id",
	2: "Type",
	3: "BasePort",
	4: "Nodes",
}

func (v *PartitionDescription) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Id) == 0) {
		writer.WriteString(1, v.Id)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.BasePort == 0) {
		writer.WriteInt(3, v.BasePort)
	}
	if !(len(v.Nodes) == 0) {
		for _, v := range v.Nodes {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_PartitionDescription)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *PartitionDescription) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Id is missing")
	} else if len(v.Id) == 0 {
		errs = append(errs, "field Id is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field BasePort is missing")
	} else if v.BasePort == 0 {
		errs = append(errs, "field BasePort is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Nodes is missing")
	} else if len(v.Nodes) == 0 {
		errs = append(errs, "field Nodes is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseDataEntry = []string{
	1: "EntryHash",
	2: "Entry",
	3: "TxId",
	4: "CauseTxId",
	5: "LastBlockTime",
}

func (v *ResponseDataEntry) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(1, &v.EntryHash)
	}
	if !(protocol.EqualDataEntry(v.Entry, nil)) {
		writer.WriteValue(2, v.Entry.MarshalBinary)
	}
	if !(v.TxId == nil) {
		writer.WriteTxid(3, v.TxId)
	}
	if !(v.CauseTxId == nil) {
		writer.WriteTxid(4, v.CauseTxId)
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(5, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_ResponseDataEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Entry is missing")
	} else if protocol.EqualDataEntry(v.Entry, nil) {
		errs = append(errs, "field Entry is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TxId is missing")
	} else if v.TxId == nil {
		errs = append(errs, "field TxId is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field CauseTxId is missing")
	} else if v.CauseTxId == nil {
		errs = append(errs, "field CauseTxId is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseDataEntrySet = []string{
	1: "DataEntries",
	2: "Total",
	3: "LastBlockTime",
}

func (v *ResponseDataEntrySet) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.DataEntries) == 0) {
		for _, v := range v.DataEntries {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}
	if !(v.Total == 0) {
		writer.WriteUint(2, v.Total)
	}
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(3, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_ResponseDataEntrySet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseDataEntrySet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field DataEntries is missing")
	} else if len(v.DataEntries) == 0 {
		errs = append(errs, "field DataEntries is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseKeyPageIndex = []string{
	1: "Authority",
	2: "Signer",
	3: "Index",
	4: "LastBlockTime",
}

func (v *ResponseKeyPageIndex) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Authority == nil) {
		writer.WriteUrl(1, v.Authority)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(2, v.Signer)
	}
	writer.WriteUint(3, v.Index)
	if !(v.LastBlockTime == nil) {
		writer.WriteTime(4, *v.LastBlockTime)
	}

	_, _, err := writer.Reset(fieldNames_ResponseKeyPageIndex)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Index is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field LastBlockTime is missing")
	} else if v.LastBlockTime == nil {
		errs = append(errs, "field LastBlockTime is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TxReceipt = []string{
	1: "GeneralReceipt",
	2: "Account",
	3: "Chain",
}

func (v *TxReceipt) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, v.GeneralReceipt.MarshalBinary)
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(3, v.Chain)
	}

	_, _, err := writer.Reset(fieldNames_TxReceipt)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TxReceipt) IsValid() error {
	var errs []string

	if err := v.GeneralReceipt.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *ChainState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x := new(protocol.ChainType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Height = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.Roots = append(v.Roots, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ChainState)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DataEntryQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataEntryQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.EntryHash = *x
	}

	seen, err := reader.Reset(fieldNames_DataEntryQuery)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DataEntryQueryResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataEntryQueryResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.EntryHash = *x
	}
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := protocol.UnmarshalDataEntryFrom(r)
		if err == nil {
			v.Entry = x
		}
		return err
	})
	if x, ok := reader.ReadTxid(3); ok {
		v.TxId = x
	}
	if x, ok := reader.ReadTxid(4); ok {
		v.CauseTxId = x
	}
	if x, ok := reader.ReadTime(5); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_DataEntryQueryResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *GeneralReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *GeneralReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.LocalBlock = x
	}
	if x, ok := reader.ReadTime(2); ok {
		v.LocalBlockTime = &x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.DirectoryBlock = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.MajorBlock = x
	}
	if x := new(merkle.Receipt); reader.ReadValue(5, x.UnmarshalBinaryFrom) {
		v.Proof = *x
	}
	if x, ok := reader.ReadString(6); ok {
		v.Error = x
	}

	seen, err := reader.Reset(fieldNames_GeneralReceipt)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NetworkDescription) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NetworkDescription) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Id = x
	}
	for {
		if x := new(PartitionDescription); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Partitions = append(v.Partitions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_NetworkDescription)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *NodeDescription) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *NodeDescription) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Address = x
	}
	if x := new(config.NodeType); reader.ReadEnum(2, x) {
		v.Type = *x
	}

	seen, err := reader.Reset(fieldNames_NodeDescription)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *PartitionDescription) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *PartitionDescription) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Id = x
	}
	if x := new(protocol.PartitionType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.BasePort = x
	}
	for {
		if x := new(NodeDescription); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
			v.Nodes = append(v.Nodes, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_PartitionDescription)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.EntryHash = *x
	}
	reader.ReadValue(2, func(r io.Reader) error {
		x, err := protocol.UnmarshalDataEntryFrom(r)
		if err == nil {
			v.Entry = x
		}
		return err
	})
	if x, ok := reader.ReadTxid(3); ok {
		v.TxId = x
	}
	if x, ok := reader.ReadTxid(4); ok {
		v.CauseTxId = x
	}
	if x, ok := reader.ReadTime(5); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_ResponseDataEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseDataEntrySet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseDataEntrySet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(ResponseDataEntry); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
			v.DataEntries = append(v.DataEntries, *x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Total = x
	}
	if x, ok := reader.ReadTime(3); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_ResponseDataEntrySet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Authority = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(4); ok {
		v.LastBlockTime = &x
	}

	seen, err := reader.Reset(fieldNames_ResponseKeyPageIndex)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TxReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TxReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.GeneralReceipt.UnmarshalBinaryFrom)
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Chain = x
	}

	seen, err := reader.Reset(fieldNames_TxReceipt)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Height uint64                     `json:"height"`
		Entry  *string                    `json:"entry,omitempty"`
		State  encoding.JsonList[*string] `json:"state,omitempty"`
		Value  interface{}                `json:"value,omitempty"`
	}{}
	u.Height = v.Height
	if !(len(v.Entry) == 0) {
		u.Entry = encoding.BytesToJSON(v.Entry)
	}
	if !(len(v.State) == 0) {
		u.State = make(encoding.JsonList[*string], len(v.State))
		for i, x := range v.State {
			u.State[i] = encoding.BytesToJSON(x)
		}
	}
	if !(v.Value == nil) {
		u.Value = encoding.AnyToJSON(v.Value)
	}
	return json.Marshal(&u)
}

func (v *ChainIdQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		ChainId *string `json:"chainId,omitempty"`
	}{}
	if !(len(v.ChainId) == 0) {
		u.ChainId = encoding.BytesToJSON(v.ChainId)
	}
	return json.Marshal(&u)
}

func (v *ChainQueryResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          string                        `json:"type,omitempty"`
		MainChain     *MerkleState                  `json:"mainChain,omitempty"`
		MerkleState   *MerkleState                  `json:"merkleState,omitempty"`
		Chains        encoding.JsonList[ChainState] `json:"chains,omitempty"`
		Data          interface{}                   `json:"data,omitempty"`
		ChainId       *string                       `json:"chainId,omitempty"`
		Receipt       *GeneralReceipt               `json:"receipt,omitempty"`
		LastBlockTime *time.Time                    `json:"lastBlockTime,omitempty"`
	}{}
	if !(len(v.Type) == 0) {
		u.Type = v.Type
	}
	if !(v.MainChain == nil) {
		u.MainChain = v.MainChain
		u.MerkleState = v.MainChain
	}
	if !(len(v.Chains) == 0) {
		u.Chains = v.Chains
	}
	if !(v.Data == nil) {
		u.Data = encoding.AnyToJSON(v.Data)
	}
	if !(len(v.ChainId) == 0) {
		u.ChainId = encoding.BytesToJSON(v.ChainId)
	}
	if !(v.Receipt == nil) {
		u.Receipt = v.Receipt
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	return json.Marshal(&u)
}

func (v *ChainState) MarshalJSON() ([]byte, error) {
	u := struct {
		Name      string                     `json:"name,omitempty"`
		Type      protocol.ChainType         `json:"type,omitempty"`
		Height    uint64                     `json:"height,omitempty"`
		Count     uint64                     `json:"count,omitempty"`
		Roots     encoding.JsonList[*string] `json:"roots,omitempty"`
		ExtraData *string                    `json:"$epilogue,omitempty"`
	}{}
	if !(len(v.Name) == 0) {
		u.Name = v.Name
	}
	if !(v.Type == 0) {
		u.Type = v.Type
	}
	if !(v.Height == 0) {
		u.Height = v.Height
		u.Count = v.Height
	}
	if !(len(v.Roots) == 0) {
		u.Roots = make(encoding.JsonList[*string], len(v.Roots))
		for i, x := range v.Roots {
			u.Roots[i] = encoding.BytesToJSON(x)
		}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *DataEntryQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url       *url.URL `json:"url,omitempty"`
		EntryHash *string  `json:"entryHash,omitempty"`
		ExtraData *string  `json:"$epilogue,omitempty"`
	}{}
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.EntryHash == ([32]byte{})) {
		u.EntryHash = encoding.ChainToJSON(&v.EntryHash)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *DataEntryQueryResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		EntryHash     *string                                         `json:"entryHash,omitempty"`
		Entry         *encoding.JsonUnmarshalWith[protocol.DataEntry] `json:"entry,omitempty"`
		TxId          *url.TxID                                       `json:"txId,omitempty"`
		CauseTxId     *url.TxID                                       `json:"causeTxId,omitempty"`
		LastBlockTime *time.Time                                      `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                         `json:"$epilogue,omitempty"`
	}{}
	if !(v.EntryHash == ([32]byte{})) {
		u.EntryHash = encoding.ChainToJSON(&v.EntryHash)
	}
	if !(protocol.EqualDataEntry(v.Entry, nil)) {
		u.Entry = &encoding.JsonUnmarshalWith[protocol.DataEntry]{Value: v.Entry, Func: protocol.UnmarshalDataEntryJSON}
	}
	if !(v.TxId == nil) {
		u.TxId = v.TxId
	}
	if !(v.CauseTxId == nil) {
		u.CauseTxId = v.CauseTxId
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *DataEntrySetQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url           *url.URL `json:"url,omitempty"`
		Start         uint64   `json:"start,omitempty"`
		Count         uint64   `json:"count,omitempty"`
		Expand        bool     `json:"expand,omitempty"`
		ExpandChains  bool     `json:"expandChains,omitempty"`
		Height        uint64   `json:"height,omitempty"`
		Scratch       bool     `json:"scratch,omitempty"`
		Prove         bool     `json:"prove,omitempty"`
		IncludeRemote bool     `json:"includeRemote,omitempty"`
	}{}
	if !(v.UrlQuery.Url == nil) {
		u.Url = v.UrlQuery.Url
	}
	if !(v.QueryPagination.Start == 0) {
		u.Start = v.QueryPagination.Start
	}
	if !(v.QueryPagination.Count == 0) {
		u.Count = v.QueryPagination.Count
	}
	if !(!v.QueryOptions.Expand) {
		u.Expand = v.QueryOptions.Expand
		u.ExpandChains = v.QueryOptions.Expand
	}
	if !(v.QueryOptions.Height == 0) {
		u.Height = v.QueryOptions.Height
	}
	if !(!v.QueryOptions.Scratch) {
		u.Scratch = v.QueryOptions.Scratch
	}
	if !(!v.QueryOptions.Prove) {
		u.Prove = v.QueryOptions.Prove
	}
	if !(!v.QueryOptions.IncludeRemote) {
		u.IncludeRemote = v.QueryOptions.IncludeRemote
	}
	return json.Marshal(&u)
}

func (v *DescriptionResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		PartitionId   string                 `json:"partitionId,omitempty"`
		NetworkType   protocol.PartitionType `json:"networkType,omitempty"`
		Network       NetworkDescription     `json:"network,omitempty"`
		NetworkAnchor *string                `json:"networkAnchor,omitempty"`
		Values        core.GlobalValues      `json:"values,omitempty"`
		Error         *errors2.Error         `json:"error,omitempty"`
	}{}
	if !(len(v.PartitionId) == 0) {
		u.PartitionId = v.PartitionId
	}
	if !(v.NetworkType == 0) {
		u.NetworkType = v.NetworkType
	}
	if !((v.Network).Equal(new(NetworkDescription))) {
		u.Network = v.Network
	}
	if !(v.NetworkAnchor == ([32]byte{})) {
		u.NetworkAnchor = encoding.ChainToJSON(&v.NetworkAnchor)
	}
	if !((v.Values).Equal(new(core.GlobalValues))) {
		u.Values = v.Values
	}
	if !(v.Error == nil) {
		u.Error = v.Error
	}
	return json.Marshal(&u)
}

func (v *DirectoryQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url           *url.URL `json:"url,omitempty"`
		Start         uint64   `json:"start,omitempty"`
		Count         uint64   `json:"count,omitempty"`
		Expand        bool     `json:"expand,omitempty"`
		ExpandChains  bool     `json:"expandChains,omitempty"`
		Height        uint64   `json:"height,omitempty"`
		Scratch       bool     `json:"scratch,omitempty"`
		Prove         bool     `json:"prove,omitempty"`
		IncludeRemote bool     `json:"includeRemote,omitempty"`
	}{}
	if !(v.UrlQuery.Url == nil) {
		u.Url = v.UrlQuery.Url
	}
	if !(v.QueryPagination.Start == 0) {
		u.Start = v.QueryPagination.Start
	}
	if !(v.QueryPagination.Count == 0) {
		u.Count = v.QueryPagination.Count
	}
	if !(!v.QueryOptions.Expand) {
		u.Expand = v.QueryOptions.Expand
		u.ExpandChains = v.QueryOptions.Expand
	}
	if !(v.QueryOptions.Height == 0) {
		u.Height = v.QueryOptions.Height
	}
	if !(!v.QueryOptions.Scratch) {
		u.Scratch = v.QueryOptions.Scratch
	}
	if !(!v.QueryOptions.Prove) {
		u.Prove = v.QueryOptions.Prove
	}
	if !(!v.QueryOptions.IncludeRemote) {
		u.IncludeRemote = v.QueryOptions.IncludeRemote
	}
	return json.Marshal(&u)
}

func (v *GeneralQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url           *url.URL `json:"url,omitempty"`
		Expand        bool     `json:"expand,omitempty"`
		ExpandChains  bool     `json:"expandChains,omitempty"`
		Height        uint64   `json:"height,omitempty"`
		Scratch       bool     `json:"scratch,omitempty"`
		Prove         bool     `json:"prove,omitempty"`
		IncludeRemote bool     `json:"includeRemote,omitempty"`
	}{}
	if !(v.UrlQuery.Url == nil) {
		u.Url = v.UrlQuery.Url
	}
	if !(!v.QueryOptions.Expand) {
		u.Expand = v.QueryOptions.Expand
		u.ExpandChains = v.QueryOptions.Expand
	}
	if !(v.QueryOptions.Height == 0) {
		u.Height = v.QueryOptions.Height
	}
	if !(!v.QueryOptions.Scratch) {
		u.Scratch = v.QueryOptions.Scratch
	}
	if !(!v.QueryOptions.Prove) {
		u.Prove = v.QueryOptions.Prove
	}
	if !(!v.QueryOptions.IncludeRemote) {
		u.IncludeRemote = v.QueryOptions.IncludeRemote
	}
	return json.Marshal(&u)
}

func (v *GeneralReceipt) MarshalJSON() ([]byte, error) {
	u := struct {
		LocalBlock     uint64         `json:"localBlock,omitempty"`
		LocalBlockTime *time.Time     `json:"localBlockTime,omitempty"`
		DirectoryBlock uint64         `json:"directoryBlock,omitempty"`
		MajorBlock     uint64         `json:"majorBlock,omitempty"`
		Proof          merkle.Receipt `json:"proof,omitempty"`
		Receipt        merkle.Receipt `json:"receipt,omitempty"`
		Error          string         `json:"error,omitempty"`
		ExtraData      *string        `json:"$epilogue,omitempty"`
	}{}
	if !(v.LocalBlock == 0) {
		u.LocalBlock = v.LocalBlock
	}
	if !(v.LocalBlockTime == nil) {
		u.LocalBlockTime = v.LocalBlockTime
	}
	if !(v.DirectoryBlock == 0) {
		u.DirectoryBlock = v.DirectoryBlock
	}
	if !(v.MajorBlock == 0) {
		u.MajorBlock = v.MajorBlock
	}
	if !((v.Proof).Equal(new(merkle.Receipt))) {
		u.Proof = v.Proof
		u.Receipt = v.Proof
	}
	if !(len(v.Error) == 0) {
		u.Error = v.Error
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *KeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
		Version uint64 `json:"version,omitempty"`
		Height  uint64 `json:"height,omitempty"`
	}{}
	if !(v.Version == 0) {
		u.Version = v.Version
		u.Height = v.Version
	}
	return json.Marshal(&u)
}

func (v *KeyPageIndexQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	if !(v.UrlQuery.Url == nil) {
		u.Url = v.UrlQuery.Url
	}
	if !(len(v.Key) == 0) {
		u.Key = encoding.BytesToJSON(v.Key)
	}
	return json.Marshal(&u)
}

func (v *MajorBlocksQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url   *url.URL `json:"url,omitempty"`
		Start uint64   `json:"start,omitempty"`
		Count uint64   `json:"count,omitempty"`
	}{}
	if !(v.UrlQuery.Url == nil) {
		u.Url = v.UrlQuery.Url
	}
	if !(v.QueryPagination.Start == 0) {
		u.Start = v.QueryPagination.Start
	}
	if !(v.QueryPagination.Count == 0) {
		u.Count = v.QueryPagination.Count
	}
	return json.Marshal(&u)
}

func (v *MajorQueryResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		MajorBlockIndex uint64                         `json:"majorBlockIndex,omitempty"`
		MajorBlockTime  *time.Time                     `json:"majorBlockTime,omitempty"`
		MinorBlocks     encoding.JsonList[*MinorBlock] `json:"minorBlocks,omitempty"`
		LastBlockTime   *time.Time                     `json:"lastBlockTime,omitempty"`
	}{}
	if !(v.MajorBlockIndex == 0) {
		u.MajorBlockIndex = v.MajorBlockIndex
	}
	if !(v.MajorBlockTime == nil) {
		u.MajorBlockTime = v.MajorBlockTime
	}
	if !(len(v.MinorBlocks) == 0) {
		u.MinorBlocks = v.MinorBlocks
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	return json.Marshal(&u)
}

func (v *MerkleState) MarshalJSON() ([]byte, error) {
	u := struct {
		Height uint64                     `json:"height,omitempty"`
		Count  uint64                     `json:"count,omitempty"`
		Roots  encoding.JsonList[*string] `json:"roots,omitempty"`
	}{}
	if !(v.Height == 0) {
		u.Height = v.Height
		u.Count = v.Height
	}
	if !(len(v.Roots) == 0) {
		u.Roots = make(encoding.JsonList[*string], len(v.Roots))
		for i, x := range v.Roots {
			u.Roots[i] = encoding.BytesToJSON(x)
		}
	}
	return json.Marshal(&u)
}

func (v *MetricsQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	if !(len(v.Metric) == 0) {
		u.Metric = v.Metric
	}
	if !(v.Duration == 0) {
		u.Duration = encoding.DurationToJSON(v.Duration)
	}
	return json.Marshal(&u)
}

func (v *MetricsResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	if !(v.Value == nil) {
		u.Value = encoding.AnyToJSON(v.Value)
	}
	return json.Marshal(&u)
}

func (v *MinorBlocksQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url             *url.URL        `json:"url,omitempty"`
		Start           uint64          `json:"start,omitempty"`
		Count           uint64          `json:"count,omitempty"`
		TxFetchMode     TxFetchMode     `json:"txFetchMode,omitempty"`
		BlockFilterMode BlockFilterMode `json:"blockFilterMode,omitempty"`
	}{}
	if !(v.UrlQuery.Url == nil) {
		u.Url = v.UrlQuery.Url
	}
	if !(v.QueryPagination.Start == 0) {
		u.Start = v.QueryPagination.Start
	}
	if !(v.QueryPagination.Count == 0) {
		u.Count = v.QueryPagination.Count
	}
	if !(v.TxFetchMode == 0) {
		u.TxFetchMode = v.TxFetchMode
	}
	if !(v.BlockFilterMode == 0) {
		u.BlockFilterMode = v.BlockFilterMode
	}
	return json.Marshal(&u)
}

func (v *MinorQueryResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		BlockIndex    uint64                                       `json:"blockIndex,omitempty"`
		BlockTime     *time.Time                                   `json:"blockTime,omitempty"`
		TxCount       uint64                                       `json:"txCount,omitempty"`
		TxIds         encoding.JsonList[*string]                   `json:"txIds,omitempty"`
		Transactions  encoding.JsonList[*TransactionQueryResponse] `json:"transactions,omitempty"`
		LastBlockTime *time.Time                                   `json:"lastBlockTime,omitempty"`
	}{}
	if !(v.MinorBlock.BlockIndex == 0) {
		u.BlockIndex = v.MinorBlock.BlockIndex
	}
	if !(v.MinorBlock.BlockTime == nil) {
		u.BlockTime = v.MinorBlock.BlockTime
	}
	if !(v.TxCount == 0) {
		u.TxCount = v.TxCount
	}
	if !(len(v.TxIds) == 0) {
		u.TxIds = make(encoding.JsonList[*string], len(v.TxIds))
		for i, x := range v.TxIds {
			u.TxIds[i] = encoding.BytesToJSON(x)
		}
	}
	if !(len(v.Transactions) == 0) {
		u.Transactions = v.Transactions
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	return json.Marshal(&u)
}

func (v *MultiResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type          string                         `json:"type,omitempty"`
		Items         encoding.JsonList[interface{}] `json:"items,omitempty"`
		Start         uint64                         `json:"start"`
		Count         uint64                         `json:"count"`
		Total         uint64                         `json:"total"`
		OtherItems    encoding.JsonList[interface{}] `json:"otherItems,omitempty"`
		LastBlockTime *time.Time                     `json:"lastBlockTime,omitempty"`
	}{}
	if !(len(v.Type) == 0) {
		u.Type = v.Type
	}
	if !(len(v.Items) == 0) {
		u.Items = make(encoding.JsonList[interface{}], len(v.Items))
		for i, x := range v.Items {
			u.Items[i] = encoding.AnyToJSON(x)
		}
	}
	u.Start = v.Start
	u.Count = v.Count
	u.Total = v.Total
	if !(len(v.OtherItems) == 0) {
		u.OtherItems = make(encoding.JsonList[interface{}], len(v.OtherItems))
		for i, x := range v.OtherItems {
			u.OtherItems[i] = encoding.AnyToJSON(x)
		}
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	return json.Marshal(&u)
}

func (v *NetworkDescription) MarshalJSON() ([]byte, error) {
	u := struct {
		Id         string                                  `json:"id,omitempty"`
		Partitions encoding.JsonList[PartitionDescription] `json:"partitions,omitempty"`
		Subnets    encoding.JsonList[PartitionDescription] `json:"subnets,omitempty"`
		ExtraData  *string                                 `json:"$epilogue,omitempty"`
	}{}
	if !(len(v.Id) == 0) {
		u.Id = v.Id
	}
	if !(len(v.Partitions) == 0) {
		u.Partitions = v.Partitions
		u.Subnets = v.Partitions
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *PartitionDescription) MarshalJSON() ([]byte, error) {
	u := struct {
		Id        string                             `json:"id,omitempty"`
		Type      protocol.PartitionType             `json:"type,omitempty"`
		BasePort  int64                              `json:"basePort,omitempty"`
		Nodes     encoding.JsonList[NodeDescription] `json:"nodes,omitempty"`
		ExtraData *string                            `json:"$epilogue,omitempty"`
	}{}
	if !(len(v.Id) == 0) {
		u.Id = v.Id
	}
	if !(v.Type == 0) {
		u.Type = v.Type
	}
	if !(v.BasePort == 0) {
		u.BasePort = v.BasePort
	}
	if !(len(v.Nodes) == 0) {
		u.Nodes = v.Nodes
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *QueryOptions) MarshalJSON() ([]byte, error) {
	u := struct {
		Expand        bool   `json:"expand,omitempty"`
		ExpandChains  bool   `json:"expandChains,omitempty"`
		Height        uint64 `json:"height,omitempty"`
		Scratch       bool   `json:"scratch,omitempty"`
		Prove         bool   `json:"prove,omitempty"`
		IncludeRemote bool   `json:"includeRemote,omitempty"`
	}{}
	if !(!v.Expand) {
		u.Expand = v.Expand
		u.ExpandChains = v.Expand
	}
	if !(v.Height == 0) {
		u.Height = v.Height
	}
	if !(!v.Scratch) {
		u.Scratch = v.Scratch
	}
	if !(!v.Prove) {
		u.Prove = v.Prove
	}
	if !(!v.IncludeRemote) {
		u.IncludeRemote = v.IncludeRemote
	}
	return json.Marshal(&u)
}

func (v *ResponseDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		EntryHash     *string                                         `json:"entryHash,omitempty"`
		Entry         *encoding.JsonUnmarshalWith[protocol.DataEntry] `json:"entry,omitempty"`
		TxId          *url.TxID                                       `json:"txId,omitempty"`
		CauseTxId     *url.TxID                                       `json:"causeTxId,omitempty"`
		LastBlockTime *time.Time                                      `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                         `json:"$epilogue,omitempty"`
	}{}
	if !(v.EntryHash == ([32]byte{})) {
		u.EntryHash = encoding.ChainToJSON(&v.EntryHash)
	}
	if !(protocol.EqualDataEntry(v.Entry, nil)) {
		u.Entry = &encoding.JsonUnmarshalWith[protocol.DataEntry]{Value: v.Entry, Func: protocol.UnmarshalDataEntryJSON}
	}
	if !(v.TxId == nil) {
		u.TxId = v.TxId
	}
	if !(v.CauseTxId == nil) {
		u.CauseTxId = v.CauseTxId
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ResponseDataEntrySet) MarshalJSON() ([]byte, error) {
	u := struct {
		DataEntries   encoding.JsonList[ResponseDataEntry] `json:"dataEntries,omitempty"`
		Total         uint64                               `json:"total,omitempty"`
		LastBlockTime *time.Time                           `json:"lastBlockTime,omitempty"`
		ExtraData     *string                              `json:"$epilogue,omitempty"`
	}{}
	if !(len(v.DataEntries) == 0) {
		u.DataEntries = v.DataEntries
	}
	if !(v.Total == 0) {
		u.Total = v.Total
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ResponseKeyPageIndex) MarshalJSON() ([]byte, error) {
	u := struct {
		Authority     *url.URL   `json:"authority,omitempty"`
		KeyBook       *url.URL   `json:"keyBook,omitempty"`
		Signer        *url.URL   `json:"signer,omitempty"`
		KeyPage       *url.URL   `json:"keyPage,omitempty"`
		Index         uint64     `json:"index"`
		LastBlockTime *time.Time `json:"lastBlockTime,omitempty"`
		ExtraData     *string    `json:"$epilogue,omitempty"`
	}{}
	if !(v.Authority == nil) {
		u.Authority = v.Authority
		u.KeyBook = v.Authority
	}
	if !(v.Signer == nil) {
		u.Signer = v.Signer
		u.KeyPage = v.Signer
	}
	u.Index = v.Index
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SignatureBook) MarshalJSON() ([]byte, error) {
	u := struct {
		Authority *url.URL                          `json:"authority,omitempty"`
		Pages     encoding.JsonList[*SignaturePage] `json:"pages,omitempty"`
	}{}
	if !(v.Authority == nil) {
		u.Authority = v.Authority
	}
	if !(len(v.Pages) == 0) {
		u.Pages = v.Pages
	}
	return json.Marshal(&u)
}

func (v *SignaturePage) MarshalJSON() ([]byte, error) {
	u := struct {
		Signer     SignerMetadata                                      `json:"signer,omitempty"`
		Signatures *encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
	}{}
	if !((v.Signer).Equal(new(SignerMetadata))) {
		u.Signer = v.Signer
	}
	if !(len(v.Signatures) == 0) {
		u.Signatures = &encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	}
	return json.Marshal(&u)
}

func (v *Signer) MarshalJSON() ([]byte, error) {
	u := struct {
		PublicKey     *string                `json:"publicKey,omitempty"`
		Timestamp     uint64                 `json:"timestamp,omitempty"`
		Nonce         uint64                 `json:"nonce,omitempty"`
		Url           *url.URL               `json:"url,omitempty"`
		Version       uint64                 `json:"version,omitempty"`
		SignatureType protocol.SignatureType `json:"signatureType,omitempty"`
		UseSimpleHash bool                   `json:"useSimpleHash,omitempty"`
	}{}
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(v.Timestamp == 0) {
		u.Timestamp = v.Timestamp
		u.Nonce = v.Timestamp
	}
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !(v.Version == 0) {
		u.Version = v.Version
	}
	if !(v.SignatureType == 0) {
		u.SignatureType = v.SignatureType
	}
	if !(!v.UseSimpleHash) {
		u.UseSimpleHash = v.UseSimpleHash
	}
	return json.Marshal(&u)
}

func (v *StatusResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Ok                        bool      `json:"ok,omitempty"`
		BvnHeight                 int64     `json:"bvnHeight,omitempty"`
		DnHeight                  int64     `json:"dnHeight,omitempty"`
		BvnTime                   time.Time `json:"bvnTime,omitempty"`
		DnTime                    time.Time `json:"dnTime,omitempty"`
		LastDirectoryAnchorHeight uint64    `json:"lastDirectoryAnchorHeight,omitempty"`
		BvnRootHash               *string   `json:"bvnRootHash,omitempty"`
		DnRootHash                *string   `json:"dnRootHash,omitempty"`
		BvnBptHash                *string   `json:"bvnBptHash,omitempty"`
		DnBptHash                 *string   `json:"dnBptHash,omitempty"`
	}{}
	if !(!v.Ok) {
		u.Ok = v.Ok
	}
	if !(v.BvnHeight == 0) {
		u.BvnHeight = v.BvnHeight
	}
	if !(v.DnHeight == 0) {
		u.DnHeight = v.DnHeight
	}
	if !(v.BvnTime == (time.Time{})) {
		u.BvnTime = v.BvnTime
	}
	if !(v.DnTime == (time.Time{})) {
		u.DnTime = v.DnTime
	}
	if !(v.LastDirectoryAnchorHeight == 0) {
		u.LastDirectoryAnchorHeight = v.LastDirectoryAnchorHeight
	}
	if !(v.BvnRootHash == ([32]byte{})) {
		u.BvnRootHash = encoding.ChainToJSON(&v.BvnRootHash)
	}
	if !(v.DnRootHash == ([32]byte{})) {
		u.DnRootHash = encoding.ChainToJSON(&v.DnRootHash)
	}
	if !(v.BvnBptHash == ([32]byte{})) {
		u.BvnBptHash = encoding.ChainToJSON(&v.BvnBptHash)
	}
	if !(v.DnBptHash == ([32]byte{})) {
		u.DnBptHash = encoding.ChainToJSON(&v.DnBptHash)
	}
	return json.Marshal(&u)
}

func (v *TokenDeposit) MarshalJSON() ([]byte, error) {
	u := struct {
		Url    *url.URL `json:"url,omitempty"`
		Amount *string  `json:"amount,omitempty"`
		Txid   *string  `json:"txid,omitempty"`
	}{}
	if !(v.Url == nil) {
		u.Url = v.Url
	}
	if !((v.Amount).Cmp(new(big.Int)) == 0) {
		u.Amount = encoding.BigintToJSON(&v.Amount)
	}
	if !(len(v.Txid) == 0) {
		u.Txid = encoding.BytesToJSON(v.Txid)
	}
	return json.Marshal(&u)
}

func (v *TokenSend) MarshalJSON() ([]byte, error) {
	u := struct {
		From *url.URL                        `json:"from,omitempty"`
		To   encoding.JsonList[TokenDeposit] `json:"to,omitempty"`
	}{}
	if !(v.From == nil) {
		u.From = v.From
	}
	if !(len(v.To) == 0) {
		u.To = v.To
	}
	return json.Marshal(&u)
}

func (v *TransactionQueryResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            string                                              `json:"type,omitempty"`
		MainChain       *MerkleState                                        `json:"mainChain,omitempty"`
		MerkleState     *MerkleState                                        `json:"merkleState,omitempty"`
		Data            interface{}                                         `json:"data,omitempty"`
		Origin          *url.URL                                            `json:"origin,omitempty"`
		Sponsor         *url.URL                                            `json:"sponsor,omitempty"`
		TransactionHash *string                                             `json:"transactionHash,omitempty"`
		Txid            *url.TxID                                           `json:"txid,omitempty"`
		Transaction     *protocol.Transaction                               `json:"transaction,omitempty"`
		Signatures      *encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
		Status          *protocol.TransactionStatus                         `json:"status,omitempty"`
		Produced        encoding.JsonList[*url.TxID]                        `json:"produced,omitempty"`
		SyntheticTxids  encoding.JsonList[*url.TxID]                        `json:"syntheticTxids,omitempty"`
		Receipts        encoding.JsonList[*TxReceipt]                       `json:"receipts,omitempty"`
		SignatureBooks  encoding.JsonList[*SignatureBook]                   `json:"signatureBooks,omitempty"`
		LastBlockTime   *time.Time                                          `json:"lastBlockTime,omitempty"`
	}{}
	if !(len(v.Type) == 0) {
		u.Type = v.Type
	}
	if !(v.MainChain == nil) {
		u.MainChain = v.MainChain
		u.MerkleState = v.MainChain
	}
	if !(v.Data == nil) {
		u.Data = encoding.AnyToJSON(v.Data)
	}
	if !(v.Origin == nil) {
		u.Origin = v.Origin
		u.Sponsor = v.Origin
	}
	if !(len(v.TransactionHash) == 0) {
		u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	}
	if !(v.Txid == nil) {
		u.Txid = v.Txid
	}
	if !(v.Transaction == nil) {
		u.Transaction = v.Transaction
	}
	if !(len(v.Signatures) == 0) {
		u.Signatures = &encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	}
	if !(v.Status == nil) {
		u.Status = v.Status
	}
	if !(len(v.Produced) == 0) {
		u.Produced = v.Produced
		u.SyntheticTxids = v.Produced
	}
	if !(len(v.Receipts) == 0) {
		u.Receipts = v.Receipts
	}
	if !(len(v.SignatureBooks) == 0) {
		u.SignatureBooks = v.SignatureBooks
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	return json.Marshal(&u)
}

func (v *TxHistoryQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url     *url.URL `json:"url,omitempty"`
		Start   uint64   `json:"start,omitempty"`
		Count   uint64   `json:"count,omitempty"`
		Scratch bool     `json:"scratch,omitempty"`
	}{}
	if !(v.UrlQuery.Url == nil) {
		u.Url = v.UrlQuery.Url
	}
	if !(v.QueryPagination.Start == 0) {
		u.Start = v.QueryPagination.Start
	}
	if !(v.QueryPagination.Count == 0) {
		u.Count = v.QueryPagination.Count
	}
	if !(!v.Scratch) {
		u.Scratch = v.Scratch
	}
	return json.Marshal(&u)
}

func (v *TxReceipt) MarshalJSON() ([]byte, error) {
	u := struct {
		LocalBlock     uint64         `json:"localBlock,omitempty"`
		LocalBlockTime *time.Time     `json:"localBlockTime,omitempty"`
		DirectoryBlock uint64         `json:"directoryBlock,omitempty"`
		MajorBlock     uint64         `json:"majorBlock,omitempty"`
		Proof          merkle.Receipt `json:"proof,omitempty"`
		Receipt        merkle.Receipt `json:"receipt,omitempty"`
		Error          string         `json:"error,omitempty"`
		Account        *url.URL       `json:"account,omitempty"`
		Chain          string         `json:"chain,omitempty"`
		ExtraData      *string        `json:"$epilogue,omitempty"`
	}{}
	if !(v.GeneralReceipt.LocalBlock == 0) {
		u.LocalBlock = v.GeneralReceipt.LocalBlock
	}
	if !(v.GeneralReceipt.LocalBlockTime == nil) {
		u.LocalBlockTime = v.GeneralReceipt.LocalBlockTime
	}
	if !(v.GeneralReceipt.DirectoryBlock == 0) {
		u.DirectoryBlock = v.GeneralReceipt.DirectoryBlock
	}
	if !(v.GeneralReceipt.MajorBlock == 0) {
		u.MajorBlock = v.GeneralReceipt.MajorBlock
	}
	if !((v.GeneralReceipt.Proof).Equal(new(merkle.Receipt))) {
		u.Proof = v.GeneralReceipt.Proof
		u.Receipt = v.GeneralReceipt.Proof
	}
	if !(len(v.GeneralReceipt.Error) == 0) {
		u.Error = v.GeneralReceipt.Error
	}
	if !(v.Account == nil) {
		u.Account = v.Account
	}
	if !(len(v.Chain) == 0) {
		u.Chain = v.Chain
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *TxRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		CheckOnly  bool        `json:"checkOnly,omitempty"`
		IsEnvelope bool        `json:"isEnvelope,omitempty"`
		Origin     *url.URL    `json:"origin,omitempty"`
		Sponsor    *url.URL    `json:"sponsor,omitempty"`
		Signer     Signer      `json:"signer,omitempty"`
		Signature  *string     `json:"signature,omitempty"`
		KeyPage    KeyPage     `json:"keyPage,omitempty"`
		TxHash     *string     `json:"txHash,omitempty"`
		Payload    interface{} `json:"payload,omitempty"`
		Memo       string      `json:"memo,omitempty"`
		Metadata   *string     `json:"metadata,omitempty"`
	}{}
	if !(!v.CheckOnly) {
		u.CheckOnly = v.CheckOnly
	}
	if !(!v.IsEnvelope) {
		u.IsEnvelope = v.IsEnvelope
	}
	if !(v.Origin == nil) {
		u.Origin = v.Origin
		u.Sponsor = v.Origin
	}
	if !((v.Signer).Equal(new(Signer))) {
		u.Signer = v.Signer
	}
	if !(len(v.Signature) == 0) {
		u.Signature = encoding.BytesToJSON(v.Signature)
	}
	if !((v.KeyPage).Equal(new(KeyPage))) {
		u.KeyPage = v.KeyPage
	}
	if !(len(v.TxHash) == 0) {
		u.TxHash = encoding.BytesToJSON(v.TxHash)
	}
	if !(v.Payload == nil) {
		u.Payload = encoding.AnyToJSON(v.Payload)
	}
	if !(len(v.Memo) == 0) {
		u.Memo = v.Memo
	}
	if !(len(v.Metadata) == 0) {
		u.Metadata = encoding.BytesToJSON(v.Metadata)
	}
	return json.Marshal(&u)
}

func (v *TxResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		TransactionHash *string                    `json:"transactionHash,omitempty"`
		Txid            *url.TxID                  `json:"txid,omitempty"`
		SignatureHashes encoding.JsonList[*string] `json:"signatureHashes,omitempty"`
		SimpleHash      *string                    `json:"simpleHash,omitempty"`
		Hash            *string                    `json:"hash,omitempty"`
		Code            uint64                     `json:"code,omitempty"`
		Message         string                     `json:"message,omitempty"`
		Delivered       bool                       `json:"delivered,omitempty"`
		Result          interface{}                `json:"result,omitempty"`
		LastBlockTime   *time.Time                 `json:"lastBlockTime,omitempty"`
	}{}
	if !(len(v.TransactionHash) == 0) {
		u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	}
	if !(v.Txid == nil) {
		u.Txid = v.Txid
	}
	if !(len(v.SignatureHashes) == 0) {
		u.SignatureHashes = make(encoding.JsonList[*string], len(v.SignatureHashes))
		for i, x := range v.SignatureHashes {
			u.SignatureHashes[i] = encoding.BytesToJSON(x)
		}
	}
	if !(len(v.SimpleHash) == 0) {
		u.SimpleHash = encoding.BytesToJSON(v.SimpleHash)
		u.Hash = encoding.BytesToJSON(v.SimpleHash)
	}
	if !(v.Code == 0) {
		u.Code = v.Code
	}
	if !(len(v.Message) == 0) {
		u.Message = v.Message
	}
	if !(!v.Delivered) {
		u.Delivered = v.Delivered
	}
	if !(v.Result == nil) {
		u.Result = encoding.AnyToJSON(v.Result)
	}
	if !(v.LastBlockTime == nil) {
		u.LastBlockTime = v.LastBlockTime
	}
	return json.Marshal(&u)
}

func (v *TxnQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Expand        bool        `json:"expand,omitempty"`
		ExpandChains  bool        `json:"expandChains,omitempty"`
		Height        uint64      `json:"height,omitempty"`
		Scratch       bool        `json:"scratch,omitempty"`
		Prove         bool        `json:"prove,omitempty"`
		IncludeRemote bool        `json:"includeRemote,omitempty"`
		Txid          *string     `json:"txid,omitempty"`
		TxIdUrl       *url.TxID   `json:"txIdUrl,omitempty"`
		Wait          interface{} `json:"wait,omitempty"`
		IgnorePending bool        `json:"ignorePending,omitempty"`
	}{}
	if !(!v.QueryOptions.Expand) {
		u.Expand = v.QueryOptions.Expand
		u.ExpandChains = v.QueryOptions.Expand
	}
	if !(v.QueryOptions.Height == 0) {
		u.Height = v.QueryOptions.Height
	}
	if !(!v.QueryOptions.Scratch) {
		u.Scratch = v.QueryOptions.Scratch
	}
	if !(!v.QueryOptions.Prove) {
		u.Prove = v.QueryOptions.Prove
	}
	if !(!v.QueryOptions.IncludeRemote) {
		u.IncludeRemote = v.QueryOptions.IncludeRemote
	}
	if !(len(v.Txid) == 0) {
		u.Txid = encoding.BytesToJSON(v.Txid)
	}
	if !(v.TxIdUrl == nil) {
		u.TxIdUrl = v.TxIdUrl
	}
	if !(v.Wait == 0) {
		u.Wait = encoding.DurationToJSON(v.Wait)
	}
	if !(!v.IgnorePending) {
		u.IgnorePending = v.IgnorePending
	}
	return json.Marshal(&u)
}

func (v *ChainEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Height uint64                     `json:"height"`
		Entry  *string                    `json:"entry,omitempty"`
		State  encoding.JsonList[*string] `json:"state,omitempty"`
		Value  interface{}                `json:"value,omitempty"`
	}{}
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	u.Value = encoding.AnyToJSON(v.Value)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Height = u.Height
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	if x, err := encoding.AnyFromJSON(u.Value); err != nil {
		return fmt.Errorf("error decoding Value: %w", err)
	} else {
		v.Value = x
	}
	return nil
}

func (v *ChainIdQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		ChainId *string `json:"chainId,omitempty"`
	}{}
	u.ChainId = encoding.BytesToJSON(v.ChainId)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.ChainId); err != nil {
		return fmt.Errorf("error decoding ChainId: %w", err)
	} else {
		v.ChainId = x
	}
	return nil
}

func (v *ChainQueryResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          string                        `json:"type,omitempty"`
		MainChain     *MerkleState                  `json:"mainChain,omitempty"`
		MerkleState   *MerkleState                  `json:"merkleState,omitempty"`
		Chains        encoding.JsonList[ChainState] `json:"chains,omitempty"`
		Data          interface{}                   `json:"data,omitempty"`
		ChainId       *string                       `json:"chainId,omitempty"`
		Receipt       *GeneralReceipt               `json:"receipt,omitempty"`
		LastBlockTime *time.Time                    `json:"lastBlockTime,omitempty"`
	}{}
	u.Type = v.Type
	u.MainChain = v.MainChain
	u.MerkleState = v.MainChain
	u.Chains = v.Chains
	u.Data = encoding.AnyToJSON(v.Data)
	u.ChainId = encoding.BytesToJSON(v.ChainId)
	u.Receipt = v.Receipt
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Type = u.Type
	if !(u.MainChain == nil) {
		v.MainChain = u.MainChain
	} else {
		v.MainChain = u.MerkleState
	}
	v.Chains = u.Chains
	if x, err := encoding.AnyFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	if x, err := encoding.BytesFromJSON(u.ChainId); err != nil {
		return fmt.Errorf("error decoding ChainId: %w", err)
	} else {
		v.ChainId = x
	}
	v.Receipt = u.Receipt
	v.LastBlockTime = u.LastBlockTime
	return nil
}

func (v *ChainState) UnmarshalJSON(data []byte) error {
	u := struct {
		Name      string                     `json:"name,omitempty"`
		Type      protocol.ChainType         `json:"type,omitempty"`
		Height    uint64                     `json:"height,omitempty"`
		Count     uint64                     `json:"count,omitempty"`
		Roots     encoding.JsonList[*string] `json:"roots,omitempty"`
		ExtraData *string                    `json:"$epilogue,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make(encoding.JsonList[*string], len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Name = u.Name
	v.Type = u.Type
	if !(u.Height == 0) {
		v.Height = u.Height
	} else {
		v.Height = u.Count
	}
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots: %w", err)
		} else {
			v.Roots[i] = x
		}
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *DataEntryQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url       *url.URL `json:"url,omitempty"`
		EntryHash *string  `json:"entryHash,omitempty"`
		ExtraData *string  `json:"$epilogue,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(&v.EntryHash)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = *x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *DataEntryQueryResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		EntryHash     *string                                         `json:"entryHash,omitempty"`
		Entry         *encoding.JsonUnmarshalWith[protocol.DataEntry] `json:"entry,omitempty"`
		TxId          *url.TxID                                       `json:"txId,omitempty"`
		CauseTxId     *url.TxID                                       `json:"causeTxId,omitempty"`
		LastBlockTime *time.Time                                      `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                         `json:"$epilogue,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(&v.EntryHash)
	u.Entry = &encoding.JsonUnmarshalWith[protocol.DataEntry]{Value: v.Entry, Func: protocol.UnmarshalDataEntryJSON}
	u.TxId = v.TxId
	u.CauseTxId = v.CauseTxId
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = *x
	}
	if u.Entry != nil {
		v.Entry = u.Entry.Value
	}

	v.TxId = u.TxId
	v.CauseTxId = u.CauseTxId
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *DataEntrySetQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url           *url.URL `json:"url,omitempty"`
		Start         uint64   `json:"start,omitempty"`
		Count         uint64   `json:"count,omitempty"`
		Expand        bool     `json:"expand,omitempty"`
		ExpandChains  bool     `json:"expandChains,omitempty"`
		Height        uint64   `json:"height,omitempty"`
		Scratch       bool     `json:"scratch,omitempty"`
		Prove         bool     `json:"prove,omitempty"`
		IncludeRemote bool     `json:"includeRemote,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Scratch = v.QueryOptions.Scratch
	u.Prove = v.QueryOptions.Prove
	u.IncludeRemote = v.QueryOptions.IncludeRemote
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	v.QueryPagination.Start = u.Start
	v.QueryPagination.Count = u.Count
	if !(u.Expand == false) {
		v.QueryOptions.Expand = u.Expand
	} else {
		v.QueryOptions.Expand = u.ExpandChains
	}
	v.QueryOptions.Height = u.Height
	v.QueryOptions.Scratch = u.Scratch
	v.QueryOptions.Prove = u.Prove
	v.QueryOptions.IncludeRemote = u.IncludeRemote
	return nil
}

func (v *DescriptionResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		PartitionId   string                 `json:"partitionId,omitempty"`
		NetworkType   protocol.PartitionType `json:"networkType,omitempty"`
		Network       NetworkDescription     `json:"network,omitempty"`
		NetworkAnchor *string                `json:"networkAnchor,omitempty"`
		Values        core.GlobalValues      `json:"values,omitempty"`
		Error         *errors2.Error         `json:"error,omitempty"`
	}{}
	u.PartitionId = v.PartitionId
	u.NetworkType = v.NetworkType
	u.Network = v.Network
	u.NetworkAnchor = encoding.ChainToJSON(&v.NetworkAnchor)
	u.Values = v.Values
	u.Error = v.Error
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.PartitionId = u.PartitionId
	v.NetworkType = u.NetworkType
	v.Network = u.Network
	if x, err := encoding.ChainFromJSON(u.NetworkAnchor); err != nil {
		return fmt.Errorf("error decoding NetworkAnchor: %w", err)
	} else {
		v.NetworkAnchor = *x
	}
	v.Values = u.Values
	v.Error = u.Error
	return nil
}

func (v *DirectoryQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url           *url.URL `json:"url,omitempty"`
		Start         uint64   `json:"start,omitempty"`
		Count         uint64   `json:"count,omitempty"`
		Expand        bool     `json:"expand,omitempty"`
		ExpandChains  bool     `json:"expandChains,omitempty"`
		Height        uint64   `json:"height,omitempty"`
		Scratch       bool     `json:"scratch,omitempty"`
		Prove         bool     `json:"prove,omitempty"`
		IncludeRemote bool     `json:"includeRemote,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Scratch = v.QueryOptions.Scratch
	u.Prove = v.QueryOptions.Prove
	u.IncludeRemote = v.QueryOptions.IncludeRemote
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	v.QueryPagination.Start = u.Start
	v.QueryPagination.Count = u.Count
	if !(u.Expand == false) {
		v.QueryOptions.Expand = u.Expand
	} else {
		v.QueryOptions.Expand = u.ExpandChains
	}
	v.QueryOptions.Height = u.Height
	v.QueryOptions.Scratch = u.Scratch
	v.QueryOptions.Prove = u.Prove
	v.QueryOptions.IncludeRemote = u.IncludeRemote
	return nil
}

func (v *GeneralQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url           *url.URL `json:"url,omitempty"`
		Expand        bool     `json:"expand,omitempty"`
		ExpandChains  bool     `json:"expandChains,omitempty"`
		Height        uint64   `json:"height,omitempty"`
		Scratch       bool     `json:"scratch,omitempty"`
		Prove         bool     `json:"prove,omitempty"`
		IncludeRemote bool     `json:"includeRemote,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Scratch = v.QueryOptions.Scratch
	u.Prove = v.QueryOptions.Prove
	u.IncludeRemote = v.QueryOptions.IncludeRemote
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	if !(u.Expand == false) {
		v.QueryOptions.Expand = u.Expand
	} else {
		v.QueryOptions.Expand = u.ExpandChains
	}
	v.QueryOptions.Height = u.Height
	v.QueryOptions.Scratch = u.Scratch
	v.QueryOptions.Prove = u.Prove
	v.QueryOptions.IncludeRemote = u.IncludeRemote
	return nil
}

func (v *GeneralReceipt) UnmarshalJSON(data []byte) error {
	u := struct {
		LocalBlock     uint64         `json:"localBlock,omitempty"`
		LocalBlockTime *time.Time     `json:"localBlockTime,omitempty"`
		DirectoryBlock uint64         `json:"directoryBlock,omitempty"`
		MajorBlock     uint64         `json:"majorBlock,omitempty"`
		Proof          merkle.Receipt `json:"proof,omitempty"`
		Receipt        merkle.Receipt `json:"receipt,omitempty"`
		Error          string         `json:"error,omitempty"`
		ExtraData      *string        `json:"$epilogue,omitempty"`
	}{}
	u.LocalBlock = v.LocalBlock
	u.LocalBlockTime = v.LocalBlockTime
	u.DirectoryBlock = v.DirectoryBlock
	u.MajorBlock = v.MajorBlock
	u.Proof = v.Proof
	u.Receipt = v.Proof
	u.Error = v.Error
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.LocalBlock = u.LocalBlock
	v.LocalBlockTime = u.LocalBlockTime
	v.DirectoryBlock = u.DirectoryBlock
	v.MajorBlock = u.MajorBlock
	if !(u.Proof.Equal(&merkle.Receipt{})) {
		v.Proof = u.Proof
	} else {
		v.Proof = u.Receipt
	}
	v.Error = u.Error
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *KeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
		Version uint64 `json:"version,omitempty"`
		Height  uint64 `json:"height,omitempty"`
	}{}
	u.Version = v.Version
	u.Height = v.Version
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(u.Version == 0) {
		v.Version = u.Version
	} else {
		v.Version = u.Height
	}
	return nil
}

func (v *KeyPageIndexQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Key = encoding.BytesToJSON(v.Key)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	return nil
}

func (v *MajorBlocksQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url   *url.URL `json:"url,omitempty"`
		Start uint64   `json:"start,omitempty"`
		Count uint64   `json:"count,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	v.QueryPagination.Start = u.Start
	v.QueryPagination.Count = u.Count
	return nil
}

func (v *MajorQueryResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		MajorBlockIndex uint64                         `json:"majorBlockIndex,omitempty"`
		MajorBlockTime  *time.Time                     `json:"majorBlockTime,omitempty"`
		MinorBlocks     encoding.JsonList[*MinorBlock] `json:"minorBlocks,omitempty"`
		LastBlockTime   *time.Time                     `json:"lastBlockTime,omitempty"`
	}{}
	u.MajorBlockIndex = v.MajorBlockIndex
	u.MajorBlockTime = v.MajorBlockTime
	u.MinorBlocks = v.MinorBlocks
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.MajorBlockIndex = u.MajorBlockIndex
	v.MajorBlockTime = u.MajorBlockTime
	v.MinorBlocks = u.MinorBlocks
	v.LastBlockTime = u.LastBlockTime
	return nil
}

func (v *MerkleState) UnmarshalJSON(data []byte) error {
	u := struct {
		Height uint64                     `json:"height,omitempty"`
		Count  uint64                     `json:"count,omitempty"`
		Roots  encoding.JsonList[*string] `json:"roots,omitempty"`
	}{}
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make(encoding.JsonList[*string], len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(u.Height == 0) {
		v.Height = u.Height
	} else {
		v.Height = u.Count
	}
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots: %w", err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}

func (v *MetricsQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Metric = u.Metric
	if x, err := encoding.DurationFromJSON(u.Duration); err != nil {
		return fmt.Errorf("error decoding Duration: %w", err)
	} else {
		v.Duration = x
	}
	return nil
}

func (v *MetricsResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	u.Value = encoding.AnyToJSON(v.Value)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.AnyFromJSON(u.Value); err != nil {
		return fmt.Errorf("error decoding Value: %w", err)
	} else {
		v.Value = x
	}
	return nil
}

func (v *MinorBlocksQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url             *url.URL        `json:"url,omitempty"`
		Start           uint64          `json:"start,omitempty"`
		Count           uint64          `json:"count,omitempty"`
		TxFetchMode     TxFetchMode     `json:"txFetchMode,omitempty"`
		BlockFilterMode BlockFilterMode `json:"blockFilterMode,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	u.TxFetchMode = v.TxFetchMode
	u.BlockFilterMode = v.BlockFilterMode
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	v.QueryPagination.Start = u.Start
	v.QueryPagination.Count = u.Count
	v.TxFetchMode = u.TxFetchMode
	v.BlockFilterMode = u.BlockFilterMode
	return nil
}

func (v *MinorQueryResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		BlockIndex    uint64                                       `json:"blockIndex,omitempty"`
		BlockTime     *time.Time                                   `json:"blockTime,omitempty"`
		TxCount       uint64                                       `json:"txCount,omitempty"`
		TxIds         encoding.JsonList[*string]                   `json:"txIds,omitempty"`
		Transactions  encoding.JsonList[*TransactionQueryResponse] `json:"transactions,omitempty"`
		LastBlockTime *time.Time                                   `json:"lastBlockTime,omitempty"`
	}{}
	u.BlockIndex = v.MinorBlock.BlockIndex
	u.BlockTime = v.MinorBlock.BlockTime
	u.TxCount = v.TxCount
	u.TxIds = make(encoding.JsonList[*string], len(v.TxIds))
	for i, x := range v.TxIds {
		u.TxIds[i] = encoding.BytesToJSON(x)
	}
	u.Transactions = v.Transactions
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.MinorBlock.BlockIndex = u.BlockIndex
	v.MinorBlock.BlockTime = u.BlockTime
	v.TxCount = u.TxCount
	v.TxIds = make([][]byte, len(u.TxIds))
	for i, x := range u.TxIds {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding TxIds: %w", err)
		} else {
			v.TxIds[i] = x
		}
	}
	v.Transactions = u.Transactions
	v.LastBlockTime = u.LastBlockTime
	return nil
}

func (v *MultiResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type          string                         `json:"type,omitempty"`
		Items         encoding.JsonList[interface{}] `json:"items,omitempty"`
		Start         uint64                         `json:"start"`
		Count         uint64                         `json:"count"`
		Total         uint64                         `json:"total"`
		OtherItems    encoding.JsonList[interface{}] `json:"otherItems,omitempty"`
		LastBlockTime *time.Time                     `json:"lastBlockTime,omitempty"`
	}{}
	u.Type = v.Type
	u.Items = make(encoding.JsonList[interface{}], len(v.Items))
	for i, x := range v.Items {
		u.Items[i] = encoding.AnyToJSON(x)
	}
	u.Start = v.Start
	u.Count = v.Count
	u.Total = v.Total
	u.OtherItems = make(encoding.JsonList[interface{}], len(v.OtherItems))
	for i, x := range v.OtherItems {
		u.OtherItems[i] = encoding.AnyToJSON(x)
	}
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Type = u.Type
	v.Items = make([]interface{}, len(u.Items))
	for i, x := range u.Items {
		if x, err := encoding.AnyFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Items: %w", err)
		} else {
			v.Items[i] = x
		}
	}
	v.Start = u.Start
	v.Count = u.Count
	v.Total = u.Total
	v.OtherItems = make([]interface{}, len(u.OtherItems))
	for i, x := range u.OtherItems {
		if x, err := encoding.AnyFromJSON(x); err != nil {
			return fmt.Errorf("error decoding OtherItems: %w", err)
		} else {
			v.OtherItems[i] = x
		}
	}
	v.LastBlockTime = u.LastBlockTime
	return nil
}

func (v *NetworkDescription) UnmarshalJSON(data []byte) error {
	u := struct {
		Id         string                                  `json:"id,omitempty"`
		Partitions encoding.JsonList[PartitionDescription] `json:"partitions,omitempty"`
		Subnets    encoding.JsonList[PartitionDescription] `json:"subnets,omitempty"`
		ExtraData  *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.Id = v.Id
	u.Partitions = v.Partitions
	u.Subnets = v.Partitions
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Id = u.Id
	if !(len(u.Partitions) == 0) {
		v.Partitions = u.Partitions
	} else {
		v.Partitions = u.Subnets
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *PartitionDescription) UnmarshalJSON(data []byte) error {
	u := struct {
		Id        string                             `json:"id,omitempty"`
		Type      protocol.PartitionType             `json:"type,omitempty"`
		BasePort  int64                              `json:"basePort,omitempty"`
		Nodes     encoding.JsonList[NodeDescription] `json:"nodes,omitempty"`
		ExtraData *string                            `json:"$epilogue,omitempty"`
	}{}
	u.Id = v.Id
	u.Type = v.Type
	u.BasePort = v.BasePort
	u.Nodes = v.Nodes
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Id = u.Id
	v.Type = u.Type
	v.BasePort = u.BasePort
	v.Nodes = u.Nodes
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *QueryOptions) UnmarshalJSON(data []byte) error {
	u := struct {
		Expand        bool   `json:"expand,omitempty"`
		ExpandChains  bool   `json:"expandChains,omitempty"`
		Height        uint64 `json:"height,omitempty"`
		Scratch       bool   `json:"scratch,omitempty"`
		Prove         bool   `json:"prove,omitempty"`
		IncludeRemote bool   `json:"includeRemote,omitempty"`
	}{}
	u.Expand = v.Expand
	u.ExpandChains = v.Expand
	u.Height = v.Height
	u.Scratch = v.Scratch
	u.Prove = v.Prove
	u.IncludeRemote = v.IncludeRemote
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(u.Expand == false) {
		v.Expand = u.Expand
	} else {
		v.Expand = u.ExpandChains
	}
	v.Height = u.Height
	v.Scratch = u.Scratch
	v.Prove = u.Prove
	v.IncludeRemote = u.IncludeRemote
	return nil
}

func (v *ResponseDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		EntryHash     *string                                         `json:"entryHash,omitempty"`
		Entry         *encoding.JsonUnmarshalWith[protocol.DataEntry] `json:"entry,omitempty"`
		TxId          *url.TxID                                       `json:"txId,omitempty"`
		CauseTxId     *url.TxID                                       `json:"causeTxId,omitempty"`
		LastBlockTime *time.Time                                      `json:"lastBlockTime,omitempty"`
		ExtraData     *string                                         `json:"$epilogue,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(&v.EntryHash)
	u.Entry = &encoding.JsonUnmarshalWith[protocol.DataEntry]{Value: v.Entry, Func: protocol.UnmarshalDataEntryJSON}
	u.TxId = v.TxId
	u.CauseTxId = v.CauseTxId
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = *x
	}
	if u.Entry != nil {
		v.Entry = u.Entry.Value
	}

	v.TxId = u.TxId
	v.CauseTxId = u.CauseTxId
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ResponseDataEntrySet) UnmarshalJSON(data []byte) error {
	u := struct {
		DataEntries   encoding.JsonList[ResponseDataEntry] `json:"dataEntries,omitempty"`
		Total         uint64                               `json:"total,omitempty"`
		LastBlockTime *time.Time                           `json:"lastBlockTime,omitempty"`
		ExtraData     *string                              `json:"$epilogue,omitempty"`
	}{}
	u.DataEntries = v.DataEntries
	u.Total = v.Total
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.DataEntries = u.DataEntries
	v.Total = u.Total
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ResponseKeyPageIndex) UnmarshalJSON(data []byte) error {
	u := struct {
		Authority     *url.URL   `json:"authority,omitempty"`
		KeyBook       *url.URL   `json:"keyBook,omitempty"`
		Signer        *url.URL   `json:"signer,omitempty"`
		KeyPage       *url.URL   `json:"keyPage,omitempty"`
		Index         uint64     `json:"index"`
		LastBlockTime *time.Time `json:"lastBlockTime,omitempty"`
		ExtraData     *string    `json:"$epilogue,omitempty"`
	}{}
	u.Authority = v.Authority
	u.KeyBook = v.Authority
	u.Signer = v.Signer
	u.KeyPage = v.Signer
	u.Index = v.Index
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(u.Authority == nil) {
		v.Authority = u.Authority
	} else {
		v.Authority = u.KeyBook
	}
	if !(u.Signer == nil) {
		v.Signer = u.Signer
	} else {
		v.Signer = u.KeyPage
	}
	v.Index = u.Index
	v.LastBlockTime = u.LastBlockTime
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SignatureBook) UnmarshalJSON(data []byte) error {
	u := struct {
		Authority *url.URL                          `json:"authority,omitempty"`
		Pages     encoding.JsonList[*SignaturePage] `json:"pages,omitempty"`
	}{}
	u.Authority = v.Authority
	u.Pages = v.Pages
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Authority = u.Authority
	v.Pages = u.Pages
	return nil
}

func (v *SignaturePage) UnmarshalJSON(data []byte) error {
	u := struct {
		Signer     SignerMetadata                                      `json:"signer,omitempty"`
		Signatures *encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
	}{}
	u.Signer = v.Signer
	u.Signatures = &encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Signer = u.Signer
	if u.Signatures != nil && u.Signatures.Value != nil {
		v.Signatures = make([]protocol.Signature, len(u.Signatures.Value))
		for i, x := range u.Signatures.Value {
			v.Signatures[i] = x
		}
	}
	return nil
}

func (v *Signer) UnmarshalJSON(data []byte) error {
	u := struct {
		PublicKey     *string                `json:"publicKey,omitempty"`
		Timestamp     uint64                 `json:"timestamp,omitempty"`
		Nonce         uint64                 `json:"nonce,omitempty"`
		Url           *url.URL               `json:"url,omitempty"`
		Version       uint64                 `json:"version,omitempty"`
		SignatureType protocol.SignatureType `json:"signatureType,omitempty"`
		UseSimpleHash bool                   `json:"useSimpleHash,omitempty"`
	}{}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Timestamp = v.Timestamp
	u.Nonce = v.Timestamp
	u.Url = v.Url
	u.Version = v.Version
	u.SignatureType = v.SignatureType
	u.UseSimpleHash = v.UseSimpleHash
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if !(u.Timestamp == 0) {
		v.Timestamp = u.Timestamp
	} else {
		v.Timestamp = u.Nonce
	}
	v.Url = u.Url
	v.Version = u.Version
	v.SignatureType = u.SignatureType
	v.UseSimpleHash = u.UseSimpleHash
	return nil
}

func (v *StatusResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Ok                        bool      `json:"ok,omitempty"`
		BvnHeight                 int64     `json:"bvnHeight,omitempty"`
		DnHeight                  int64     `json:"dnHeight,omitempty"`
		BvnTime                   time.Time `json:"bvnTime,omitempty"`
		DnTime                    time.Time `json:"dnTime,omitempty"`
		LastDirectoryAnchorHeight uint64    `json:"lastDirectoryAnchorHeight,omitempty"`
		BvnRootHash               *string   `json:"bvnRootHash,omitempty"`
		DnRootHash                *string   `json:"dnRootHash,omitempty"`
		BvnBptHash                *string   `json:"bvnBptHash,omitempty"`
		DnBptHash                 *string   `json:"dnBptHash,omitempty"`
	}{}
	u.Ok = v.Ok
	u.BvnHeight = v.BvnHeight
	u.DnHeight = v.DnHeight
	u.BvnTime = v.BvnTime
	u.DnTime = v.DnTime
	u.LastDirectoryAnchorHeight = v.LastDirectoryAnchorHeight
	u.BvnRootHash = encoding.ChainToJSON(&v.BvnRootHash)
	u.DnRootHash = encoding.ChainToJSON(&v.DnRootHash)
	u.BvnBptHash = encoding.ChainToJSON(&v.BvnBptHash)
	u.DnBptHash = encoding.ChainToJSON(&v.DnBptHash)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Ok = u.Ok
	v.BvnHeight = u.BvnHeight
	v.DnHeight = u.DnHeight
	v.BvnTime = u.BvnTime
	v.DnTime = u.DnTime
	v.LastDirectoryAnchorHeight = u.LastDirectoryAnchorHeight
	if x, err := encoding.ChainFromJSON(u.BvnRootHash); err != nil {
		return fmt.Errorf("error decoding BvnRootHash: %w", err)
	} else {
		v.BvnRootHash = *x
	}
	if x, err := encoding.ChainFromJSON(u.DnRootHash); err != nil {
		return fmt.Errorf("error decoding DnRootHash: %w", err)
	} else {
		v.DnRootHash = *x
	}
	if x, err := encoding.ChainFromJSON(u.BvnBptHash); err != nil {
		return fmt.Errorf("error decoding BvnBptHash: %w", err)
	} else {
		v.BvnBptHash = *x
	}
	if x, err := encoding.ChainFromJSON(u.DnBptHash); err != nil {
		return fmt.Errorf("error decoding DnBptHash: %w", err)
	} else {
		v.DnBptHash = *x
	}
	return nil
}

func (v *TokenDeposit) UnmarshalJSON(data []byte) error {
	u := struct {
		Url    *url.URL `json:"url,omitempty"`
		Amount *string  `json:"amount,omitempty"`
		Txid   *string  `json:"txid,omitempty"`
	}{}
	u.Url = v.Url
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Txid = encoding.BytesToJSON(v.Txid)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	if x, err := encoding.BytesFromJSON(u.Txid); err != nil {
		return fmt.Errorf("error decoding Txid: %w", err)
	} else {
		v.Txid = x
	}
	return nil
}

func (v *TokenSend) UnmarshalJSON(data []byte) error {
	u := struct {
		From *url.URL                        `json:"from,omitempty"`
		To   encoding.JsonList[TokenDeposit] `json:"to,omitempty"`
	}{}
	u.From = v.From
	u.To = v.To
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.From = u.From
	v.To = u.To
	return nil
}

func (v *TransactionQueryResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            string                                              `json:"type,omitempty"`
		MainChain       *MerkleState                                        `json:"mainChain,omitempty"`
		MerkleState     *MerkleState                                        `json:"merkleState,omitempty"`
		Data            interface{}                                         `json:"data,omitempty"`
		Origin          *url.URL                                            `json:"origin,omitempty"`
		Sponsor         *url.URL                                            `json:"sponsor,omitempty"`
		TransactionHash *string                                             `json:"transactionHash,omitempty"`
		Txid            *url.TxID                                           `json:"txid,omitempty"`
		Transaction     *protocol.Transaction                               `json:"transaction,omitempty"`
		Signatures      *encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
		Status          *protocol.TransactionStatus                         `json:"status,omitempty"`
		Produced        encoding.JsonList[*url.TxID]                        `json:"produced,omitempty"`
		SyntheticTxids  encoding.JsonList[*url.TxID]                        `json:"syntheticTxids,omitempty"`
		Receipts        encoding.JsonList[*TxReceipt]                       `json:"receipts,omitempty"`
		SignatureBooks  encoding.JsonList[*SignatureBook]                   `json:"signatureBooks,omitempty"`
		LastBlockTime   *time.Time                                          `json:"lastBlockTime,omitempty"`
	}{}
	u.Type = v.Type
	u.MainChain = v.MainChain
	u.MerkleState = v.MainChain
	u.Data = encoding.AnyToJSON(v.Data)
	u.Origin = v.Origin
	u.Sponsor = v.Origin
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	u.Txid = v.Txid
	u.Transaction = v.Transaction
	u.Signatures = &encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	u.Status = v.Status
	u.Produced = v.Produced
	u.SyntheticTxids = v.Produced
	u.Receipts = v.Receipts
	u.SignatureBooks = v.SignatureBooks
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Type = u.Type
	if !(u.MainChain == nil) {
		v.MainChain = u.MainChain
	} else {
		v.MainChain = u.MerkleState
	}
	if x, err := encoding.AnyFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	if !(u.Origin == nil) {
		v.Origin = u.Origin
	} else {
		v.Origin = u.Sponsor
	}
	if x, err := encoding.BytesFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	v.Txid = u.Txid
	v.Transaction = u.Transaction
	if u.Signatures != nil && u.Signatures.Value != nil {
		v.Signatures = make([]protocol.Signature, len(u.Signatures.Value))
		for i, x := range u.Signatures.Value {
			v.Signatures[i] = x
		}
	}
	v.Status = u.Status
	if !(len(u.Produced) == 0) {
		v.Produced = u.Produced
	} else {
		v.Produced = u.SyntheticTxids
	}
	v.Receipts = u.Receipts
	v.SignatureBooks = u.SignatureBooks
	v.LastBlockTime = u.LastBlockTime
	return nil
}

func (v *TxHistoryQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url     *url.URL `json:"url,omitempty"`
		Start   uint64   `json:"start,omitempty"`
		Count   uint64   `json:"count,omitempty"`
		Scratch bool     `json:"scratch,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	u.Scratch = v.Scratch
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	v.QueryPagination.Start = u.Start
	v.QueryPagination.Count = u.Count
	v.Scratch = u.Scratch
	return nil
}

func (v *TxReceipt) UnmarshalJSON(data []byte) error {
	u := struct {
		LocalBlock     uint64         `json:"localBlock,omitempty"`
		LocalBlockTime *time.Time     `json:"localBlockTime,omitempty"`
		DirectoryBlock uint64         `json:"directoryBlock,omitempty"`
		MajorBlock     uint64         `json:"majorBlock,omitempty"`
		Proof          merkle.Receipt `json:"proof,omitempty"`
		Receipt        merkle.Receipt `json:"receipt,omitempty"`
		Error          string         `json:"error,omitempty"`
		Account        *url.URL       `json:"account,omitempty"`
		Chain          string         `json:"chain,omitempty"`
		ExtraData      *string        `json:"$epilogue,omitempty"`
	}{}
	u.LocalBlock = v.GeneralReceipt.LocalBlock
	u.LocalBlockTime = v.GeneralReceipt.LocalBlockTime
	u.DirectoryBlock = v.GeneralReceipt.DirectoryBlock
	u.MajorBlock = v.GeneralReceipt.MajorBlock
	u.Proof = v.GeneralReceipt.Proof
	u.Receipt = v.GeneralReceipt.Proof
	u.Error = v.GeneralReceipt.Error
	u.Account = v.Account
	u.Chain = v.Chain
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.GeneralReceipt.LocalBlock = u.LocalBlock
	v.GeneralReceipt.LocalBlockTime = u.LocalBlockTime
	v.GeneralReceipt.DirectoryBlock = u.DirectoryBlock
	v.GeneralReceipt.MajorBlock = u.MajorBlock
	if !(u.Proof.Equal(&merkle.Receipt{})) {
		v.GeneralReceipt.Proof = u.Proof
	} else {
		v.GeneralReceipt.Proof = u.Receipt
	}
	v.GeneralReceipt.Error = u.Error
	v.Account = u.Account
	v.Chain = u.Chain
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *TxRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		CheckOnly  bool        `json:"checkOnly,omitempty"`
		IsEnvelope bool        `json:"isEnvelope,omitempty"`
		Origin     *url.URL    `json:"origin,omitempty"`
		Sponsor    *url.URL    `json:"sponsor,omitempty"`
		Signer     Signer      `json:"signer,omitempty"`
		Signature  *string     `json:"signature,omitempty"`
		KeyPage    KeyPage     `json:"keyPage,omitempty"`
		TxHash     *string     `json:"txHash,omitempty"`
		Payload    interface{} `json:"payload,omitempty"`
		Memo       string      `json:"memo,omitempty"`
		Metadata   *string     `json:"metadata,omitempty"`
	}{}
	u.CheckOnly = v.CheckOnly
	u.IsEnvelope = v.IsEnvelope
	u.Origin = v.Origin
	u.Sponsor = v.Origin
	u.Signer = v.Signer
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.KeyPage = v.KeyPage
	u.TxHash = encoding.BytesToJSON(v.TxHash)
	u.Payload = encoding.AnyToJSON(v.Payload)
	u.Memo = v.Memo
	u.Metadata = encoding.BytesToJSON(v.Metadata)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.CheckOnly = u.CheckOnly
	v.IsEnvelope = u.IsEnvelope
	if !(u.Origin == nil) {
		v.Origin = u.Origin
	} else {
		v.Origin = u.Sponsor
	}
	v.Signer = u.Signer
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.KeyPage = u.KeyPage
	if x, err := encoding.BytesFromJSON(u.TxHash); err != nil {
		return fmt.Errorf("error decoding TxHash: %w", err)
	} else {
		v.TxHash = x
	}
	if x, err := encoding.AnyFromJSON(u.Payload); err != nil {
		return fmt.Errorf("error decoding Payload: %w", err)
	} else {
		v.Payload = x
	}
	v.Memo = u.Memo
	if x, err := encoding.BytesFromJSON(u.Metadata); err != nil {
		return fmt.Errorf("error decoding Metadata: %w", err)
	} else {
		v.Metadata = x
	}
	return nil
}

func (v *TxResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		TransactionHash *string                    `json:"transactionHash,omitempty"`
		Txid            *url.TxID                  `json:"txid,omitempty"`
		SignatureHashes encoding.JsonList[*string] `json:"signatureHashes,omitempty"`
		SimpleHash      *string                    `json:"simpleHash,omitempty"`
		Hash            *string                    `json:"hash,omitempty"`
		Code            uint64                     `json:"code,omitempty"`
		Message         string                     `json:"message,omitempty"`
		Delivered       bool                       `json:"delivered,omitempty"`
		Result          interface{}                `json:"result,omitempty"`
		LastBlockTime   *time.Time                 `json:"lastBlockTime,omitempty"`
	}{}
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	u.Txid = v.Txid
	u.SignatureHashes = make(encoding.JsonList[*string], len(v.SignatureHashes))
	for i, x := range v.SignatureHashes {
		u.SignatureHashes[i] = encoding.BytesToJSON(x)
	}
	u.SimpleHash = encoding.BytesToJSON(v.SimpleHash)
	u.Hash = encoding.BytesToJSON(v.SimpleHash)
	u.Code = v.Code
	u.Message = v.Message
	u.Delivered = v.Delivered
	u.Result = encoding.AnyToJSON(v.Result)
	u.LastBlockTime = v.LastBlockTime
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.TransactionHash); err != nil {
		return fmt.Errorf("error decoding TransactionHash: %w", err)
	} else {
		v.TransactionHash = x
	}
	v.Txid = u.Txid
	v.SignatureHashes = make([][]byte, len(u.SignatureHashes))
	for i, x := range u.SignatureHashes {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding SignatureHashes: %w", err)
		} else {
			v.SignatureHashes[i] = x
		}
	}
	if !(u.SimpleHash == nil) {
		if x, err := encoding.BytesFromJSON(u.SimpleHash); err != nil {
			return fmt.Errorf("error decoding SimpleHash: %w", err)
		} else {
			v.SimpleHash = x
		}
	} else {
		if x, err := encoding.BytesFromJSON(u.Hash); err != nil {
			return fmt.Errorf("error decoding SimpleHash: %w", err)
		} else {
			v.SimpleHash = x
		}
	}
	v.Code = u.Code
	v.Message = u.Message
	v.Delivered = u.Delivered
	if x, err := encoding.AnyFromJSON(u.Result); err != nil {
		return fmt.Errorf("error decoding Result: %w", err)
	} else {
		v.Result = x
	}
	v.LastBlockTime = u.LastBlockTime
	return nil
}

func (v *TxnQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Expand        bool        `json:"expand,omitempty"`
		ExpandChains  bool        `json:"expandChains,omitempty"`
		Height        uint64      `json:"height,omitempty"`
		Scratch       bool        `json:"scratch,omitempty"`
		Prove         bool        `json:"prove,omitempty"`
		IncludeRemote bool        `json:"includeRemote,omitempty"`
		Txid          *string     `json:"txid,omitempty"`
		TxIdUrl       *url.TxID   `json:"txIdUrl,omitempty"`
		Wait          interface{} `json:"wait,omitempty"`
		IgnorePending bool        `json:"ignorePending,omitempty"`
	}{}
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Scratch = v.QueryOptions.Scratch
	u.Prove = v.QueryOptions.Prove
	u.IncludeRemote = v.QueryOptions.IncludeRemote
	u.Txid = encoding.BytesToJSON(v.Txid)
	u.TxIdUrl = v.TxIdUrl
	u.Wait = encoding.DurationToJSON(v.Wait)
	u.IgnorePending = v.IgnorePending
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(u.Expand == false) {
		v.QueryOptions.Expand = u.Expand
	} else {
		v.QueryOptions.Expand = u.ExpandChains
	}
	v.QueryOptions.Height = u.Height
	v.QueryOptions.Scratch = u.Scratch
	v.QueryOptions.Prove = u.Prove
	v.QueryOptions.IncludeRemote = u.IncludeRemote
	if x, err := encoding.BytesFromJSON(u.Txid); err != nil {
		return fmt.Errorf("error decoding Txid: %w", err)
	} else {
		v.Txid = x
	}
	v.TxIdUrl = u.TxIdUrl
	if x, err := encoding.DurationFromJSON(u.Wait); err != nil {
		return fmt.Errorf("error decoding Wait: %w", err)
	} else {
		v.Wait = x
	}
	v.IgnorePending = u.IgnorePending
	return nil
}
