package api

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/config"
	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/types/api/query"
)

type ChainIdQuery struct {
	ChainId []byte `json:"chainId,omitempty" form:"chainId" query:"chainId" validate:"required"`
}

type ChainQueryResponse struct {
	Type      string             `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	MainChain *MerkleState       `json:"mainChain,omitempty" form:"mainChain" query:"mainChain" validate:"required"`
	Chains    []query.ChainState `json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
	Data      interface{}        `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	ChainId   []byte             `json:"chainId,omitempty" form:"chainId" query:"chainId" validate:"required"`
}

type DataEntry struct {
	fieldsSet []bool
	Data      [][]byte `json:"data,omitempty" form:"data" query:"data" validate:"required"`
}

type DataEntryQuery struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	EntryHash [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash"`
}

type DataEntryQueryResponse struct {
	fieldsSet []bool
	EntryHash [32]byte  `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	Entry     DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
}

type DataEntrySetQuery struct {
	UrlQuery
	QueryPagination
	QueryOptions
}

type DescriptionResponse struct {
	Subnet config.Network `json:"subnet,omitempty" form:"subnet" query:"subnet" validate:"required"`
}

type DirectoryQuery struct {
	UrlQuery
	QueryPagination
	QueryOptions
}

type GeneralQuery struct {
	UrlQuery
	QueryOptions
}

type KeyPage struct {
	Height uint64 `json:"height,omitempty" form:"height" query:"height" validate:"required"`
}

type KeyPageIndexQuery struct {
	UrlQuery
	Key []byte `json:"key,omitempty" form:"key" query:"key" validate:"required"`
}

type MerkleState struct {
	Height uint64   `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots  [][]byte `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
}

type MetricsQuery struct {
	Metric   string        `json:"metric,omitempty" form:"metric" query:"metric" validate:"required"`
	Duration time.Duration `json:"duration,omitempty" form:"duration" query:"duration" validate:"required"`
}

type MetricsResponse struct {
	Value interface{} `json:"value,omitempty" form:"value" query:"value" validate:"required"`
}

type MultiResponse struct {
	Type       string        `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Items      []interface{} `json:"items,omitempty" form:"items" query:"items" validate:"required"`
	Start      uint64        `json:"start" form:"start" query:"start" validate:"required"`
	Count      uint64        `json:"count" form:"count" query:"count" validate:"required"`
	Total      uint64        `json:"total" form:"total" query:"total" validate:"required"`
	OtherItems []interface{} `json:"otherItems,omitempty" form:"otherItems" query:"otherItems" validate:"required"`
}

type QueryOptions struct {
	Expand bool   `json:"expand,omitempty" form:"expand" query:"expand"`
	Height uint64 `json:"height,omitempty" form:"height" query:"height"`
	Prove  bool   `json:"prove,omitempty" form:"prove" query:"prove"`
}

type QueryPagination struct {
	Start uint64 `json:"start,omitempty" form:"start" query:"start"`
	Count uint64 `json:"count,omitempty" form:"count" query:"count"`
}

type Signer struct {
	PublicKey     []byte                 `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Timestamp     uint64                 `json:"timestamp,omitempty" form:"timestamp" query:"timestamp" validate:"required"`
	Url           *url.URL               `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	SignatureType protocol.SignatureType `json:"signatureType,omitempty" form:"signatureType" query:"signatureType"`
}

type StatusResponse struct {
	Ok bool `json:"ok,omitempty" form:"ok" query:"ok" validate:"required"`
}

type TokenDeposit struct {
	Url    *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Amount big.Int  `json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	Txid   []byte   `json:"txid,omitempty" form:"txid" query:"txid" validate:"required"`
}

type TokenSend struct {
	From *url.URL       `json:"from,omitempty" form:"from" query:"from" validate:"required"`
	To   []TokenDeposit `json:"to,omitempty" form:"to" query:"to" validate:"required"`
}

type TransactionQueryResponse struct {
	Type               string                      `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	MainChain          *MerkleState                `json:"mainChain,omitempty" form:"mainChain" query:"mainChain" validate:"required"`
	Data               interface{}                 `json:"data,omitempty" form:"data" query:"data" validate:"required"`
	Origin             *url.URL                    `json:"origin,omitempty" form:"origin" query:"origin" validate:"required"`
	TransactionHash    []byte                      `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash" validate:"required"`
	Transaction        *protocol.Transaction       `json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Signatures         []protocol.Signature        `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	Status             *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	SyntheticTxids     [][32]byte                  `json:"syntheticTxids,omitempty" form:"syntheticTxids" query:"syntheticTxids" validate:"required"`
	Receipts           []*query.TxReceipt          `json:"receipts,omitempty" form:"receipts" query:"receipts" validate:"required"`
	SignatureThreshold uint64                      `json:"signatureThreshold,omitempty" form:"signatureThreshold" query:"signatureThreshold" validate:"required"`
	Invalidated        bool                        `json:"invalidated,omitempty" form:"invalidated" query:"invalidated" validate:"required"`
}

type TxHistoryQuery struct {
	UrlQuery
	QueryPagination
}

type TxRequest struct {
	CheckOnly  bool        `json:"checkOnly,omitempty" form:"checkOnly" query:"checkOnly"`
	IsEnvelope bool        `json:"isEnvelope,omitempty" form:"isEnvelope" query:"isEnvelope"`
	Origin     *url.URL    `json:"origin,omitempty" form:"origin" query:"origin" validate:"required"`
	Signer     Signer      `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	Signature  []byte      `json:"signature,omitempty" form:"signature" query:"signature" validate:"required"`
	KeyPage    KeyPage     `json:"keyPage,omitempty" form:"keyPage" query:"keyPage" validate:"required"`
	TxHash     []byte      `json:"txHash,omitempty" form:"txHash" query:"txHash"`
	Payload    interface{} `json:"payload,omitempty" form:"payload" query:"payload" validate:"required"`
	Memo       string      `json:"memo,omitempty" form:"memo" query:"memo"`
	Metadata   []byte      `json:"metadata,omitempty" form:"metadata" query:"metadata"`
}

type TxResponse struct {
	TransactionHash []byte      `json:"transactionHash,omitempty" form:"transactionHash" query:"transactionHash" validate:"required"`
	EnvelopeHash    []byte      `json:"envelopeHash,omitempty" form:"envelopeHash" query:"envelopeHash" validate:"required"`
	SimpleHash      []byte      `json:"simpleHash,omitempty" form:"simpleHash" query:"simpleHash" validate:"required"`
	Code            uint64      `json:"code,omitempty" form:"code" query:"code" validate:"required"`
	Message         string      `json:"message,omitempty" form:"message" query:"message" validate:"required"`
	Delivered       bool        `json:"delivered,omitempty" form:"delivered" query:"delivered" validate:"required"`
	Result          interface{} `json:"result,omitempty" form:"result" query:"result" validate:"required"`
}

type TxnQuery struct {
	QueryOptions
	Txid []byte        `json:"txid,omitempty" form:"txid" query:"txid" validate:"required"`
	Wait time.Duration `json:"wait,omitempty" form:"wait" query:"wait"`
}

type UrlQuery struct {
	Url *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
}

type VersionResponse struct {
	Version        string `json:"version,omitempty" form:"version" query:"version" validate:"required"`
	Commit         string `json:"commit,omitempty" form:"commit" query:"commit" validate:"required"`
	VersionIsKnown bool   `json:"versionIsKnown,omitempty" form:"versionIsKnown" query:"versionIsKnown" validate:"required"`
}

func (v *DataEntry) Equal(u *DataEntry) bool {
	if len(v.Data) != len(u.Data) {
		return false
	}
	for i := range v.Data {
		if !(bytes.Equal(v.Data[i], u.Data[i])) {
			return false
		}
	}

	return true
}

func (v *DataEntryQuery) Equal(u *DataEntryQuery) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	return true
}

func (v *DataEntryQueryResponse) Equal(u *DataEntryQueryResponse) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}
	if !((&v.Entry).Equal(&u.Entry)) {
		return false
	}

	return true
}

var fieldNames_DataEntry = []string{
	1: "Data",
}

func (v *DataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Data) == 0) {
		for _, v := range v.Data {
			writer.WriteBytes(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_DataEntry)
	return buffer.Bytes(), err
}

func (v *DataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Data is missing")
	} else if len(v.Data) == 0 {
		errs = append(errs, "field Data is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DataEntryQuery = []string{
	1: "Url",
	2: "EntryHash",
}

func (v *DataEntryQuery) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Url == nil) {
		writer.WriteUrl(1, v.Url)
	}
	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(2, &v.EntryHash)
	}

	_, _, err := writer.Reset(fieldNames_DataEntryQuery)
	return buffer.Bytes(), err
}

func (v *DataEntryQuery) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DataEntryQueryResponse = []string{
	1: "EntryHash",
	2: "Entry",
}

func (v *DataEntryQueryResponse) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(1, &v.EntryHash)
	}
	if !((v.Entry).Equal(new(DataEntry))) {
		writer.WriteValue(2, &v.Entry)
	}

	_, _, err := writer.Reset(fieldNames_DataEntryQueryResponse)
	return buffer.Bytes(), err
}

func (v *DataEntryQueryResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if (v.Entry).Equal(new(DataEntry)) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *DataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadBytes(1); ok {
			v.Data = append(v.Data, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_DataEntry)
	v.fieldsSet = seen
	return err
}

func (v *DataEntryQuery) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataEntryQuery) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Url = x
	}
	if x, ok := reader.ReadHash(2); ok {
		v.EntryHash = *x
	}

	seen, err := reader.Reset(fieldNames_DataEntryQuery)
	v.fieldsSet = seen
	return err
}

func (v *DataEntryQueryResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DataEntryQueryResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.EntryHash = *x
	}
	if x := new(DataEntry); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Entry = *x
	}

	seen, err := reader.Reset(fieldNames_DataEntryQueryResponse)
	v.fieldsSet = seen
	return err
}

func (v *ChainIdQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		ChainId *string `json:"chainId,omitempty"`
	}{}
	u.ChainId = encoding.BytesToJSON(v.ChainId)
	return json.Marshal(&u)
}

func (v *ChainQueryResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type        string             `json:"type,omitempty"`
		MainChain   *MerkleState       `json:"mainChain,omitempty"`
		MerkleState *MerkleState       `json:"merkleState,omitempty"`
		Chains      []query.ChainState `json:"chains,omitempty"`
		Data        interface{}        `json:"data,omitempty"`
		ChainId     *string            `json:"chainId,omitempty"`
	}{}
	u.Type = v.Type
	u.MainChain = v.MainChain
	u.MerkleState = v.MainChain
	u.Chains = v.Chains
	u.Data = encoding.AnyToJSON(v.Data)
	u.ChainId = encoding.BytesToJSON(v.ChainId)
	return json.Marshal(&u)
}

func (v *DataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Data []*string `json:"data,omitempty"`
	}{}
	u.Data = make([]*string, len(v.Data))
	for i, x := range v.Data {
		u.Data[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *DataEntryQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url       *url.URL `json:"url,omitempty"`
		EntryHash string   `json:"entryHash,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}

func (v *DataEntryQueryResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		EntryHash string    `json:"entryHash,omitempty"`
		Entry     DataEntry `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *DataEntrySetQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url          *url.URL `json:"url,omitempty"`
		Start        uint64   `json:"start,omitempty"`
		Count        uint64   `json:"count,omitempty"`
		Expand       bool     `json:"expand,omitempty"`
		ExpandChains bool     `json:"expandChains,omitempty"`
		Height       uint64   `json:"height,omitempty"`
		Prove        bool     `json:"prove,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Prove = v.QueryOptions.Prove
	return json.Marshal(&u)
}

func (v *DirectoryQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url          *url.URL `json:"url,omitempty"`
		Start        uint64   `json:"start,omitempty"`
		Count        uint64   `json:"count,omitempty"`
		Expand       bool     `json:"expand,omitempty"`
		ExpandChains bool     `json:"expandChains,omitempty"`
		Height       uint64   `json:"height,omitempty"`
		Prove        bool     `json:"prove,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Prove = v.QueryOptions.Prove
	return json.Marshal(&u)
}

func (v *GeneralQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url          *url.URL `json:"url,omitempty"`
		Expand       bool     `json:"expand,omitempty"`
		ExpandChains bool     `json:"expandChains,omitempty"`
		Height       uint64   `json:"height,omitempty"`
		Prove        bool     `json:"prove,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Prove = v.QueryOptions.Prove
	return json.Marshal(&u)
}

func (v *KeyPageIndexQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Key = encoding.BytesToJSON(v.Key)
	return json.Marshal(&u)
}

func (v *MerkleState) MarshalJSON() ([]byte, error) {
	u := struct {
		Height uint64    `json:"height,omitempty"`
		Count  uint64    `json:"count,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *MetricsQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	return json.Marshal(&u)
}

func (v *MetricsResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	u.Value = encoding.AnyToJSON(v.Value)
	return json.Marshal(&u)
}

func (v *MultiResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       string        `json:"type,omitempty"`
		Items      []interface{} `json:"items,omitempty"`
		Start      uint64        `json:"start"`
		Count      uint64        `json:"count"`
		Total      uint64        `json:"total"`
		OtherItems []interface{} `json:"otherItems,omitempty"`
	}{}
	u.Type = v.Type
	u.Items = make([]interface{}, len(v.Items))
	for i, x := range v.Items {
		u.Items[i] = encoding.AnyToJSON(x)
	}
	u.Start = v.Start
	u.Count = v.Count
	u.Total = v.Total
	u.OtherItems = make([]interface{}, len(v.OtherItems))
	for i, x := range v.OtherItems {
		u.OtherItems[i] = encoding.AnyToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *QueryOptions) MarshalJSON() ([]byte, error) {
	u := struct {
		Expand       bool   `json:"expand,omitempty"`
		ExpandChains bool   `json:"expandChains,omitempty"`
		Height       uint64 `json:"height,omitempty"`
		Prove        bool   `json:"prove,omitempty"`
	}{}
	u.Expand = v.Expand
	u.ExpandChains = v.Expand
	u.Height = v.Height
	u.Prove = v.Prove
	return json.Marshal(&u)
}

func (v *Signer) MarshalJSON() ([]byte, error) {
	u := struct {
		PublicKey     *string                `json:"publicKey,omitempty"`
		Timestamp     uint64                 `json:"timestamp,omitempty"`
		Nonce         uint64                 `json:"nonce,omitempty"`
		Url           *url.URL               `json:"url,omitempty"`
		SignatureType protocol.SignatureType `json:"signatureType,omitempty"`
	}{}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Timestamp = v.Timestamp
	u.Nonce = v.Timestamp
	u.Url = v.Url
	u.SignatureType = v.SignatureType
	return json.Marshal(&u)
}

func (v *TokenDeposit) MarshalJSON() ([]byte, error) {
	u := struct {
		Url    *url.URL `json:"url,omitempty"`
		Amount *string  `json:"amount,omitempty"`
		Txid   *string  `json:"txid,omitempty"`
	}{}
	u.Url = v.Url
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Txid = encoding.BytesToJSON(v.Txid)
	return json.Marshal(&u)
}

func (v *TransactionQueryResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type               string                      `json:"type,omitempty"`
		MainChain          *MerkleState                `json:"mainChain,omitempty"`
		MerkleState        *MerkleState                `json:"merkleState,omitempty"`
		Data               interface{}                 `json:"data,omitempty"`
		Origin             *url.URL                    `json:"origin,omitempty"`
		Sponsor            *url.URL                    `json:"sponsor,omitempty"`
		TransactionHash    *string                     `json:"transactionHash,omitempty"`
		Txid               *string                     `json:"txid,omitempty"`
		Transaction        *protocol.Transaction       `json:"transaction,omitempty"`
		Signatures         []json.RawMessage           `json:"signatures,omitempty"`
		Status             *protocol.TransactionStatus `json:"status,omitempty"`
		SyntheticTxids     []string                    `json:"syntheticTxids,omitempty"`
		Receipts           []*query.TxReceipt          `json:"receipts,omitempty"`
		SignatureThreshold uint64                      `json:"signatureThreshold,omitempty"`
		Invalidated        bool                        `json:"invalidated,omitempty"`
	}{}
	u.Type = v.Type
	u.MainChain = v.MainChain
	u.MerkleState = v.MainChain
	u.Data = encoding.AnyToJSON(v.Data)
	u.Origin = v.Origin
	u.Sponsor = v.Origin
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	u.Txid = encoding.BytesToJSON(v.TransactionHash)
	u.Transaction = v.Transaction
	u.Signatures = make([]json.RawMessage, len(v.Signatures))
	for i, x := range v.Signatures {
		if y, err := json.Marshal(x); err != nil {
			return nil, fmt.Errorf("error encoding Signatures: %w", err)
		} else {
			u.Signatures[i] = y
		}
	}
	u.Status = v.Status
	u.SyntheticTxids = make([]string, len(v.SyntheticTxids))
	for i, x := range v.SyntheticTxids {
		u.SyntheticTxids[i] = encoding.ChainToJSON(x)
	}
	u.Receipts = v.Receipts
	u.SignatureThreshold = v.SignatureThreshold
	u.Invalidated = v.Invalidated
	return json.Marshal(&u)
}

func (v *TxHistoryQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Url   *url.URL `json:"url,omitempty"`
		Start uint64   `json:"start,omitempty"`
		Count uint64   `json:"count,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	return json.Marshal(&u)
}

func (v *TxRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		CheckOnly  bool        `json:"checkOnly,omitempty"`
		IsEnvelope bool        `json:"isEnvelope,omitempty"`
		Origin     *url.URL    `json:"origin,omitempty"`
		Sponsor    *url.URL    `json:"sponsor,omitempty"`
		Signer     Signer      `json:"signer,omitempty"`
		Signature  *string     `json:"signature,omitempty"`
		KeyPage    KeyPage     `json:"keyPage,omitempty"`
		TxHash     *string     `json:"txHash,omitempty"`
		Payload    interface{} `json:"payload,omitempty"`
		Memo       string      `json:"memo,omitempty"`
		Metadata   *string     `json:"metadata,omitempty"`
	}{}
	u.CheckOnly = v.CheckOnly
	u.IsEnvelope = v.IsEnvelope
	u.Origin = v.Origin
	u.Sponsor = v.Origin
	u.Signer = v.Signer
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.KeyPage = v.KeyPage
	u.TxHash = encoding.BytesToJSON(v.TxHash)
	u.Payload = encoding.AnyToJSON(v.Payload)
	u.Memo = v.Memo
	u.Metadata = encoding.BytesToJSON(v.Metadata)
	return json.Marshal(&u)
}

func (v *TxResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		TransactionHash *string     `json:"transactionHash,omitempty"`
		Txid            *string     `json:"txid,omitempty"`
		EnvelopeHash    *string     `json:"envelopeHash,omitempty"`
		SimpleHash      *string     `json:"simpleHash,omitempty"`
		Hash            *string     `json:"hash,omitempty"`
		Code            uint64      `json:"code,omitempty"`
		Message         string      `json:"message,omitempty"`
		Delivered       bool        `json:"delivered,omitempty"`
		Result          interface{} `json:"result,omitempty"`
	}{}
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	u.Txid = encoding.BytesToJSON(v.TransactionHash)
	u.EnvelopeHash = encoding.BytesToJSON(v.EnvelopeHash)
	u.SimpleHash = encoding.BytesToJSON(v.SimpleHash)
	u.Hash = encoding.BytesToJSON(v.SimpleHash)
	u.Code = v.Code
	u.Message = v.Message
	u.Delivered = v.Delivered
	u.Result = encoding.AnyToJSON(v.Result)
	return json.Marshal(&u)
}

func (v *TxnQuery) MarshalJSON() ([]byte, error) {
	u := struct {
		Expand       bool        `json:"expand,omitempty"`
		ExpandChains bool        `json:"expandChains,omitempty"`
		Height       uint64      `json:"height,omitempty"`
		Prove        bool        `json:"prove,omitempty"`
		Txid         *string     `json:"txid,omitempty"`
		Wait         interface{} `json:"wait,omitempty"`
	}{}
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Prove = v.QueryOptions.Prove
	u.Txid = encoding.BytesToJSON(v.Txid)
	u.Wait = encoding.DurationToJSON(v.Wait)
	return json.Marshal(&u)
}

func (v *ChainIdQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		ChainId *string `json:"chainId,omitempty"`
	}{}
	u.ChainId = encoding.BytesToJSON(v.ChainId)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.ChainId); err != nil {
		return fmt.Errorf("error decoding ChainId: %w", err)
	} else {
		v.ChainId = x
	}
	return nil
}

func (v *ChainQueryResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type        string             `json:"type,omitempty"`
		MainChain   *MerkleState       `json:"mainChain,omitempty"`
		MerkleState *MerkleState       `json:"merkleState,omitempty"`
		Chains      []query.ChainState `json:"chains,omitempty"`
		Data        interface{}        `json:"data,omitempty"`
		ChainId     *string            `json:"chainId,omitempty"`
	}{}
	u.Type = v.Type
	u.MainChain = v.MainChain
	u.MerkleState = v.MainChain
	u.Chains = v.Chains
	u.Data = encoding.AnyToJSON(v.Data)
	u.ChainId = encoding.BytesToJSON(v.ChainId)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	if u.MainChain != nil {
		v.MainChain = u.MainChain
	} else {
		v.MainChain = u.MerkleState
	}
	v.Chains = u.Chains
	if x, err := encoding.AnyFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	if x, err := encoding.BytesFromJSON(u.ChainId); err != nil {
		return fmt.Errorf("error decoding ChainId: %w", err)
	} else {
		v.ChainId = x
	}
	return nil
}

func (v *DataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Data []*string `json:"data,omitempty"`
	}{}
	u.Data = make([]*string, len(v.Data))
	for i, x := range v.Data {
		u.Data[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Data = make([][]byte, len(u.Data))
	for i, x := range u.Data {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Data: %w", err)
		} else {
			v.Data[i] = x
		}
	}
	return nil
}

func (v *DataEntryQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url       *url.URL `json:"url,omitempty"`
		EntryHash string   `json:"entryHash,omitempty"`
	}{}
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}

func (v *DataEntryQueryResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		EntryHash string    `json:"entryHash,omitempty"`
		Entry     DataEntry `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	v.Entry = u.Entry
	return nil
}

func (v *DataEntrySetQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url          *url.URL `json:"url,omitempty"`
		Start        uint64   `json:"start,omitempty"`
		Count        uint64   `json:"count,omitempty"`
		Expand       bool     `json:"expand,omitempty"`
		ExpandChains bool     `json:"expandChains,omitempty"`
		Height       uint64   `json:"height,omitempty"`
		Prove        bool     `json:"prove,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Prove = v.QueryOptions.Prove
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	v.QueryPagination.Start = u.Start
	v.QueryPagination.Count = u.Count
	if u.Expand != false {
		v.QueryOptions.Expand = u.Expand
	} else {
		v.QueryOptions.Expand = u.ExpandChains
	}
	v.QueryOptions.Height = u.Height
	v.QueryOptions.Prove = u.Prove
	return nil
}

func (v *DirectoryQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url          *url.URL `json:"url,omitempty"`
		Start        uint64   `json:"start,omitempty"`
		Count        uint64   `json:"count,omitempty"`
		Expand       bool     `json:"expand,omitempty"`
		ExpandChains bool     `json:"expandChains,omitempty"`
		Height       uint64   `json:"height,omitempty"`
		Prove        bool     `json:"prove,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Prove = v.QueryOptions.Prove
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	v.QueryPagination.Start = u.Start
	v.QueryPagination.Count = u.Count
	if u.Expand != false {
		v.QueryOptions.Expand = u.Expand
	} else {
		v.QueryOptions.Expand = u.ExpandChains
	}
	v.QueryOptions.Height = u.Height
	v.QueryOptions.Prove = u.Prove
	return nil
}

func (v *GeneralQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url          *url.URL `json:"url,omitempty"`
		Expand       bool     `json:"expand,omitempty"`
		ExpandChains bool     `json:"expandChains,omitempty"`
		Height       uint64   `json:"height,omitempty"`
		Prove        bool     `json:"prove,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Prove = v.QueryOptions.Prove
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	if u.Expand != false {
		v.QueryOptions.Expand = u.Expand
	} else {
		v.QueryOptions.Expand = u.ExpandChains
	}
	v.QueryOptions.Height = u.Height
	v.QueryOptions.Prove = u.Prove
	return nil
}

func (v *KeyPageIndexQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url *url.URL `json:"url,omitempty"`
		Key *string  `json:"key,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Key = encoding.BytesToJSON(v.Key)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	return nil
}

func (v *MerkleState) UnmarshalJSON(data []byte) error {
	u := struct {
		Height uint64    `json:"height,omitempty"`
		Count  uint64    `json:"count,omitempty"`
		Roots  []*string `json:"roots,omitempty"`
	}{}
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make([]*string, len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Height != 0 {
		v.Height = u.Height
	} else {
		v.Height = u.Count
	}
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots: %w", err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}

func (v *MetricsQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Metric   string      `json:"metric,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
	}{}
	u.Metric = v.Metric
	u.Duration = encoding.DurationToJSON(v.Duration)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Metric = u.Metric
	if x, err := encoding.DurationFromJSON(u.Duration); err != nil {
		return fmt.Errorf("error decoding Duration: %w", err)
	} else {
		v.Duration = x
	}
	return nil
}

func (v *MetricsResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Value interface{} `json:"value,omitempty"`
	}{}
	u.Value = encoding.AnyToJSON(v.Value)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.AnyFromJSON(u.Value); err != nil {
		return fmt.Errorf("error decoding Value: %w", err)
	} else {
		v.Value = x
	}
	return nil
}

func (v *MultiResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       string        `json:"type,omitempty"`
		Items      []interface{} `json:"items,omitempty"`
		Start      uint64        `json:"start"`
		Count      uint64        `json:"count"`
		Total      uint64        `json:"total"`
		OtherItems []interface{} `json:"otherItems,omitempty"`
	}{}
	u.Type = v.Type
	u.Items = make([]interface{}, len(v.Items))
	for i, x := range v.Items {
		u.Items[i] = encoding.AnyToJSON(x)
	}
	u.Start = v.Start
	u.Count = v.Count
	u.Total = v.Total
	u.OtherItems = make([]interface{}, len(v.OtherItems))
	for i, x := range v.OtherItems {
		u.OtherItems[i] = encoding.AnyToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.Items = make([]interface{}, len(u.Items))
	for i, x := range u.Items {
		if x, err := encoding.AnyFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Items: %w", err)
		} else {
			v.Items[i] = x
		}
	}
	v.Start = u.Start
	v.Count = u.Count
	v.Total = u.Total
	v.OtherItems = make([]interface{}, len(u.OtherItems))
	for i, x := range u.OtherItems {
		if x, err := encoding.AnyFromJSON(x); err != nil {
			return fmt.Errorf("error decoding OtherItems: %w", err)
		} else {
			v.OtherItems[i] = x
		}
	}
	return nil
}

func (v *QueryOptions) UnmarshalJSON(data []byte) error {
	u := struct {
		Expand       bool   `json:"expand,omitempty"`
		ExpandChains bool   `json:"expandChains,omitempty"`
		Height       uint64 `json:"height,omitempty"`
		Prove        bool   `json:"prove,omitempty"`
	}{}
	u.Expand = v.Expand
	u.ExpandChains = v.Expand
	u.Height = v.Height
	u.Prove = v.Prove
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Expand != false {
		v.Expand = u.Expand
	} else {
		v.Expand = u.ExpandChains
	}
	v.Height = u.Height
	v.Prove = u.Prove
	return nil
}

func (v *Signer) UnmarshalJSON(data []byte) error {
	u := struct {
		PublicKey     *string                `json:"publicKey,omitempty"`
		Timestamp     uint64                 `json:"timestamp,omitempty"`
		Nonce         uint64                 `json:"nonce,omitempty"`
		Url           *url.URL               `json:"url,omitempty"`
		SignatureType protocol.SignatureType `json:"signatureType,omitempty"`
	}{}
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Timestamp = v.Timestamp
	u.Nonce = v.Timestamp
	u.Url = v.Url
	u.SignatureType = v.SignatureType
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	if u.Timestamp != 0 {
		v.Timestamp = u.Timestamp
	} else {
		v.Timestamp = u.Nonce
	}
	v.Url = u.Url
	v.SignatureType = u.SignatureType
	return nil
}

func (v *TokenDeposit) UnmarshalJSON(data []byte) error {
	u := struct {
		Url    *url.URL `json:"url,omitempty"`
		Amount *string  `json:"amount,omitempty"`
		Txid   *string  `json:"txid,omitempty"`
	}{}
	u.Url = v.Url
	u.Amount = encoding.BigintToJSON(&v.Amount)
	u.Txid = encoding.BytesToJSON(v.Txid)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Url = u.Url
	if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	if x, err := encoding.BytesFromJSON(u.Txid); err != nil {
		return fmt.Errorf("error decoding Txid: %w", err)
	} else {
		v.Txid = x
	}
	return nil
}

func (v *TransactionQueryResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type               string                      `json:"type,omitempty"`
		MainChain          *MerkleState                `json:"mainChain,omitempty"`
		MerkleState        *MerkleState                `json:"merkleState,omitempty"`
		Data               interface{}                 `json:"data,omitempty"`
		Origin             *url.URL                    `json:"origin,omitempty"`
		Sponsor            *url.URL                    `json:"sponsor,omitempty"`
		TransactionHash    *string                     `json:"transactionHash,omitempty"`
		Txid               *string                     `json:"txid,omitempty"`
		Transaction        *protocol.Transaction       `json:"transaction,omitempty"`
		Signatures         []json.RawMessage           `json:"signatures,omitempty"`
		Status             *protocol.TransactionStatus `json:"status,omitempty"`
		SyntheticTxids     []string                    `json:"syntheticTxids,omitempty"`
		Receipts           []*query.TxReceipt          `json:"receipts,omitempty"`
		SignatureThreshold uint64                      `json:"signatureThreshold,omitempty"`
		Invalidated        bool                        `json:"invalidated,omitempty"`
	}{}
	u.Type = v.Type
	u.MainChain = v.MainChain
	u.MerkleState = v.MainChain
	u.Data = encoding.AnyToJSON(v.Data)
	u.Origin = v.Origin
	u.Sponsor = v.Origin
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	u.Txid = encoding.BytesToJSON(v.TransactionHash)
	u.Transaction = v.Transaction
	u.Signatures = make([]json.RawMessage, len(v.Signatures))
	for i, x := range v.Signatures {
		if y, err := json.Marshal(x); err != nil {
			return fmt.Errorf("error encoding Signatures: %w", err)
		} else {
			u.Signatures[i] = y
		}
	}
	u.Status = v.Status
	u.SyntheticTxids = make([]string, len(v.SyntheticTxids))
	for i, x := range v.SyntheticTxids {
		u.SyntheticTxids[i] = encoding.ChainToJSON(x)
	}
	u.Receipts = v.Receipts
	u.SignatureThreshold = v.SignatureThreshold
	u.Invalidated = v.Invalidated
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	if u.MainChain != nil {
		v.MainChain = u.MainChain
	} else {
		v.MainChain = u.MerkleState
	}
	if x, err := encoding.AnyFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
	if u.Origin != nil {
		v.Origin = u.Origin
	} else {
		v.Origin = u.Sponsor
	}
	if u.TransactionHash != nil {
		if x, err := encoding.BytesFromJSON(u.TransactionHash); err != nil {
			return fmt.Errorf("error decoding TransactionHash: %w", err)
		} else {
			v.TransactionHash = x
		}
	} else {
		if x, err := encoding.BytesFromJSON(u.Txid); err != nil {
			return fmt.Errorf("error decoding TransactionHash: %w", err)
		} else {
			v.TransactionHash = x
		}
	}
	v.Transaction = u.Transaction
	v.Signatures = make([]protocol.Signature, len(u.Signatures))
	for i, x := range u.Signatures {
		if y, err := protocol.UnmarshalSignatureJSON(x); err != nil {
			return fmt.Errorf("error decoding Signatures: %w", err)
		} else {
			v.Signatures[i] = y
		}
	}
	v.Status = u.Status
	v.SyntheticTxids = make([][32]byte, len(u.SyntheticTxids))
	for i, x := range u.SyntheticTxids {
		if x, err := encoding.ChainFromJSON(x); err != nil {
			return fmt.Errorf("error decoding SyntheticTxids: %w", err)
		} else {
			v.SyntheticTxids[i] = x
		}
	}
	v.Receipts = u.Receipts
	v.SignatureThreshold = u.SignatureThreshold
	v.Invalidated = u.Invalidated
	return nil
}

func (v *TxHistoryQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Url   *url.URL `json:"url,omitempty"`
		Start uint64   `json:"start,omitempty"`
		Count uint64   `json:"count,omitempty"`
	}{}
	u.Url = v.UrlQuery.Url
	u.Start = v.QueryPagination.Start
	u.Count = v.QueryPagination.Count
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.UrlQuery.Url = u.Url
	v.QueryPagination.Start = u.Start
	v.QueryPagination.Count = u.Count
	return nil
}

func (v *TxRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		CheckOnly  bool        `json:"checkOnly,omitempty"`
		IsEnvelope bool        `json:"isEnvelope,omitempty"`
		Origin     *url.URL    `json:"origin,omitempty"`
		Sponsor    *url.URL    `json:"sponsor,omitempty"`
		Signer     Signer      `json:"signer,omitempty"`
		Signature  *string     `json:"signature,omitempty"`
		KeyPage    KeyPage     `json:"keyPage,omitempty"`
		TxHash     *string     `json:"txHash,omitempty"`
		Payload    interface{} `json:"payload,omitempty"`
		Memo       string      `json:"memo,omitempty"`
		Metadata   *string     `json:"metadata,omitempty"`
	}{}
	u.CheckOnly = v.CheckOnly
	u.IsEnvelope = v.IsEnvelope
	u.Origin = v.Origin
	u.Sponsor = v.Origin
	u.Signer = v.Signer
	u.Signature = encoding.BytesToJSON(v.Signature)
	u.KeyPage = v.KeyPage
	u.TxHash = encoding.BytesToJSON(v.TxHash)
	u.Payload = encoding.AnyToJSON(v.Payload)
	u.Memo = v.Memo
	u.Metadata = encoding.BytesToJSON(v.Metadata)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.CheckOnly = u.CheckOnly
	v.IsEnvelope = u.IsEnvelope
	if u.Origin != nil {
		v.Origin = u.Origin
	} else {
		v.Origin = u.Sponsor
	}
	v.Signer = u.Signer
	if x, err := encoding.BytesFromJSON(u.Signature); err != nil {
		return fmt.Errorf("error decoding Signature: %w", err)
	} else {
		v.Signature = x
	}
	v.KeyPage = u.KeyPage
	if x, err := encoding.BytesFromJSON(u.TxHash); err != nil {
		return fmt.Errorf("error decoding TxHash: %w", err)
	} else {
		v.TxHash = x
	}
	if x, err := encoding.AnyFromJSON(u.Payload); err != nil {
		return fmt.Errorf("error decoding Payload: %w", err)
	} else {
		v.Payload = x
	}
	v.Memo = u.Memo
	if x, err := encoding.BytesFromJSON(u.Metadata); err != nil {
		return fmt.Errorf("error decoding Metadata: %w", err)
	} else {
		v.Metadata = x
	}
	return nil
}

func (v *TxResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		TransactionHash *string     `json:"transactionHash,omitempty"`
		Txid            *string     `json:"txid,omitempty"`
		EnvelopeHash    *string     `json:"envelopeHash,omitempty"`
		SimpleHash      *string     `json:"simpleHash,omitempty"`
		Hash            *string     `json:"hash,omitempty"`
		Code            uint64      `json:"code,omitempty"`
		Message         string      `json:"message,omitempty"`
		Delivered       bool        `json:"delivered,omitempty"`
		Result          interface{} `json:"result,omitempty"`
	}{}
	u.TransactionHash = encoding.BytesToJSON(v.TransactionHash)
	u.Txid = encoding.BytesToJSON(v.TransactionHash)
	u.EnvelopeHash = encoding.BytesToJSON(v.EnvelopeHash)
	u.SimpleHash = encoding.BytesToJSON(v.SimpleHash)
	u.Hash = encoding.BytesToJSON(v.SimpleHash)
	u.Code = v.Code
	u.Message = v.Message
	u.Delivered = v.Delivered
	u.Result = encoding.AnyToJSON(v.Result)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.TransactionHash != nil {
		if x, err := encoding.BytesFromJSON(u.TransactionHash); err != nil {
			return fmt.Errorf("error decoding TransactionHash: %w", err)
		} else {
			v.TransactionHash = x
		}
	} else {
		if x, err := encoding.BytesFromJSON(u.Txid); err != nil {
			return fmt.Errorf("error decoding TransactionHash: %w", err)
		} else {
			v.TransactionHash = x
		}
	}
	if x, err := encoding.BytesFromJSON(u.EnvelopeHash); err != nil {
		return fmt.Errorf("error decoding EnvelopeHash: %w", err)
	} else {
		v.EnvelopeHash = x
	}
	if u.SimpleHash != nil {
		if x, err := encoding.BytesFromJSON(u.SimpleHash); err != nil {
			return fmt.Errorf("error decoding SimpleHash: %w", err)
		} else {
			v.SimpleHash = x
		}
	} else {
		if x, err := encoding.BytesFromJSON(u.Hash); err != nil {
			return fmt.Errorf("error decoding SimpleHash: %w", err)
		} else {
			v.SimpleHash = x
		}
	}
	v.Code = u.Code
	v.Message = u.Message
	v.Delivered = u.Delivered
	if x, err := encoding.AnyFromJSON(u.Result); err != nil {
		return fmt.Errorf("error decoding Result: %w", err)
	} else {
		v.Result = x
	}
	return nil
}

func (v *TxnQuery) UnmarshalJSON(data []byte) error {
	u := struct {
		Expand       bool        `json:"expand,omitempty"`
		ExpandChains bool        `json:"expandChains,omitempty"`
		Height       uint64      `json:"height,omitempty"`
		Prove        bool        `json:"prove,omitempty"`
		Txid         *string     `json:"txid,omitempty"`
		Wait         interface{} `json:"wait,omitempty"`
	}{}
	u.Expand = v.QueryOptions.Expand
	u.ExpandChains = v.QueryOptions.Expand
	u.Height = v.QueryOptions.Height
	u.Prove = v.QueryOptions.Prove
	u.Txid = encoding.BytesToJSON(v.Txid)
	u.Wait = encoding.DurationToJSON(v.Wait)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if u.Expand != false {
		v.QueryOptions.Expand = u.Expand
	} else {
		v.QueryOptions.Expand = u.ExpandChains
	}
	v.QueryOptions.Height = u.Height
	v.QueryOptions.Prove = u.Prove
	if x, err := encoding.BytesFromJSON(u.Txid); err != nil {
		return fmt.Errorf("error decoding Txid: %w", err)
	} else {
		v.Txid = x
	}
	if x, err := encoding.DurationFromJSON(u.Wait); err != nil {
		return fmt.Errorf("error decoding Wait: %w", err)
	} else {
		v.Wait = x
	}
	return nil
}
