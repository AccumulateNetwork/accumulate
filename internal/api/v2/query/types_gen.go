package query

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/smt/managed"
)

type ChainState struct {
	fieldsSet []bool
	Name      string             `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Height    uint64             `json:"height,omitempty" form:"height" query:"height" validate:"required"`
	Roots     [][]byte           `json:"roots,omitempty" form:"roots" query:"roots" validate:"required"`
	extraData []byte
}

type DirectoryQueryResult struct {
	fieldsSet       []bool
	Entries         []string           `json:"entries,omitempty" form:"entries" query:"entries"`
	ExpandedEntries []protocol.Account `json:"expandedEntries,omitempty" form:"expandedEntries" query:"expandedEntries"`
	Total           uint64             `json:"total" form:"total" query:"total" validate:"required"`
	extraData       []byte
}

type GeneralReceipt struct {
	fieldsSet      []bool
	LocalBlock     uint64          `json:"localBlock,omitempty" form:"localBlock" query:"localBlock" validate:"required"`
	DirectoryBlock uint64          `json:"directoryBlock,omitempty" form:"directoryBlock" query:"directoryBlock" validate:"required"`
	MajorBlock     uint64          `json:"majorBlock,omitempty" form:"majorBlock" query:"majorBlock" validate:"required"`
	Proof          managed.Receipt `json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	Error          string          `json:"error,omitempty" form:"error" query:"error" validate:"required"`
	extraData      []byte
}

type MultiResponse struct {
	fieldsSet []bool
	Type      string   `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Items     []string `json:"items,omitempty" form:"items" query:"items" validate:"required"`
	Start     uint64   `json:"start" form:"start" query:"start" validate:"required"`
	Count     uint64   `json:"count" form:"count" query:"count" validate:"required"`
	Total     uint64   `json:"total" form:"total" query:"total" validate:"required"`
	extraData []byte
}

type RequestByChainId struct {
	fieldsSet []bool
	ChainId   [32]byte `json:"chainId,omitempty" form:"chainId" query:"chainId" validate:"required"`
	extraData []byte
}

type RequestByTxId struct {
	fieldsSet []bool
	TxId      [32]byte `json:"txId,omitempty" form:"txId" query:"txId" validate:"required"`
	extraData []byte
}

type RequestByUrl struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Scratch   bool     `json:"scratch,omitempty" form:"scratch" query:"scratch"`
	extraData []byte
}

type RequestDataEntry struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	EntryHash [32]byte `json:"entryHash,omitempty" form:"entryHash" query:"entryHash"`
	extraData []byte
}

type RequestDataEntrySet struct {
	fieldsSet    []bool
	Url          *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Start        uint64   `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Count        uint64   `json:"count,omitempty" form:"count" query:"count" validate:"required"`
	ExpandChains bool     `json:"expandChains,omitempty" form:"expandChains" query:"expandChains"`
	extraData    []byte
}

type RequestDirectory struct {
	fieldsSet    []bool
	Url          *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Start        uint64   `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Limit        uint64   `json:"limit,omitempty" form:"limit" query:"limit" validate:"required"`
	ExpandChains bool     `json:"expandChains,omitempty" form:"expandChains" query:"expandChains" validate:"required"`
	extraData    []byte
}

type RequestKeyPageIndex struct {
	fieldsSet []bool
	Url       *url.URL `json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Key       []byte   `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	extraData []byte
}

type RequestMajorBlocks struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Start     uint64   `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Limit     uint64   `json:"limit,omitempty" form:"limit" query:"limit" validate:"required"`
	extraData []byte
}

type RequestMinorBlocks struct {
	fieldsSet       []bool
	Account         *url.URL        `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Start           uint64          `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Limit           uint64          `json:"limit,omitempty" form:"limit" query:"limit" validate:"required"`
	TxFetchMode     TxFetchMode     `json:"txFetchMode,omitempty" form:"txFetchMode" query:"txFetchMode" validate:"required"`
	BlockFilterMode BlockFilterMode `json:"blockFilterMode,omitempty" form:"blockFilterMode" query:"blockFilterMode" validate:"required"`
	extraData       []byte
}

type RequestSynth struct {
	fieldsSet      []bool
	Source         *url.URL `json:"source,omitempty" form:"source" query:"source" validate:"required"`
	Destination    *url.URL `json:"destination,omitempty" form:"destination" query:"destination" validate:"required"`
	SequenceNumber uint64   `json:"sequenceNumber,omitempty" form:"sequenceNumber" query:"sequenceNumber"`
	Anchor         bool     `json:"anchor,omitempty" form:"anchor" query:"anchor"`
	extraData      []byte
}

type RequestTxHistory struct {
	fieldsSet []bool
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Start     uint64   `json:"start,omitempty" form:"start" query:"start" validate:"required"`
	Limit     uint64   `json:"limit,omitempty" form:"limit" query:"limit" validate:"required"`
	Scratch   bool     `json:"scratch,omitempty" form:"scratch" query:"scratch" validate:"required"`
	extraData []byte
}

type ResponseAccount struct {
	fieldsSet  []bool
	Account    protocol.Account `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	ChainState []ChainState     `json:"chainState,omitempty" form:"chainState" query:"chainState" validate:"required"`
	Receipt    *GeneralReceipt  `json:"receipt,omitempty" form:"receipt" query:"receipt"`
	extraData  []byte
}

type ResponseByTxId struct {
	fieldsSet  []bool
	TxId       *url.TxID                   `json:"txId,omitempty" form:"txId" query:"txId" validate:"required"`
	Envelope   *protocol.Envelope          `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	Status     *protocol.TransactionStatus `json:"status,omitempty" form:"status" query:"status" validate:"required"`
	Produced   []*url.TxID                 `json:"produced,omitempty" form:"produced" query:"produced" validate:"required"`
	Height     uint64                      `json:"height" form:"height" query:"height" validate:"required"`
	ChainState [][]byte                    `json:"chainState,omitempty" form:"chainState" query:"chainState" validate:"required"`
	Receipts   []*TxReceipt                `json:"receipts,omitempty" form:"receipts" query:"receipts" validate:"required"`
	Signers    []SignatureSet              `json:"signers,omitempty" form:"signers" query:"signers" validate:"required"`
	extraData  []byte
}

type ResponseChainEntry struct {
	fieldsSet []bool
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Height    uint64             `json:"height" form:"height" query:"height" validate:"required"`
	Entry     []byte             `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	State     [][]byte           `json:"state,omitempty" form:"state" query:"state" validate:"required"`
	Receipt   *GeneralReceipt    `json:"receipt,omitempty" form:"receipt" query:"receipt"`
	extraData []byte
}

type ResponseChainRange struct {
	fieldsSet []bool
	Type      protocol.ChainType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	Start     int64              `json:"start" form:"start" query:"start" validate:"required"`
	End       int64              `json:"end" form:"end" query:"end" validate:"required"`
	Total     int64              `json:"total" form:"total" query:"total" validate:"required"`
	Entries   [][]byte           `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData []byte
}

type ResponseDataEntry struct {
	fieldsSet []bool
	EntryHash [32]byte           `json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
	Entry     protocol.DataEntry `json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	extraData []byte
}

type ResponseDataEntrySet struct {
	fieldsSet   []bool
	DataEntries []ResponseDataEntry `json:"dataEntries,omitempty" form:"dataEntries" query:"dataEntries" validate:"required"`
	Total       uint64              `json:"total,omitempty" form:"total" query:"total" validate:"required"`
	extraData   []byte
}

type ResponseKeyPageIndex struct {
	fieldsSet []bool
	Authority *url.URL `json:"authority,omitempty" form:"authority" query:"authority" validate:"required"`
	Signer    *url.URL `json:"signer,omitempty" form:"signer" query:"signer" validate:"required"`
	Index     uint64   `json:"index" form:"index" query:"index" validate:"required"`
	extraData []byte
}

type ResponseMajorBlocks struct {
	fieldsSet   []bool
	TotalBlocks uint64                `json:"totalBlocks" form:"totalBlocks" query:"totalBlocks" validate:"required"`
	Entries     []*ResponseMajorEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData   []byte
}

type ResponseMajorEntry struct {
	fieldsSet []bool
	// MajorBlockIndex is the index of the block. Only include when indexing the root anchor chain.
	MajorBlockIndex uint64 `json:"majorBlockIndex,omitempty" form:"majorBlockIndex" query:"majorBlockIndex" validate:"required"`
	// MajorBlockTime is the start time of the block..
	MajorBlockTime *time.Time `json:"majorBlockTime,omitempty" form:"majorBlockTime" query:"majorBlockTime" validate:"required"`
	// MinorBlocks the minor blocks within this block (excluding transactions).
	MinorBlocks []*ResponseMinorEntry `json:"minorBlocks,omitempty" form:"minorBlocks" query:"minorBlocks" validate:"required"`
	extraData   []byte
}

type ResponseMinorBlocks struct {
	fieldsSet   []bool
	TotalBlocks uint64                `json:"totalBlocks" form:"totalBlocks" query:"totalBlocks" validate:"required"`
	Entries     []*ResponseMinorEntry `json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	extraData   []byte
}

type ResponseMinorEntry struct {
	fieldsSet []bool
	// BlockIndex is the index of the block. Only include when indexing the root anchor chain.
	BlockIndex uint64 `json:"blockIndex,omitempty" form:"blockIndex" query:"blockIndex" validate:"required"`
	// BlockTime is the start time of the block..
	BlockTime *time.Time `json:"blockTime,omitempty" form:"blockTime" query:"blockTime" validate:"required"`
	// TxCount shows how many transactions this block contains.
	TxCount uint64   `json:"txCount,omitempty" form:"txCount" query:"txCount" validate:"required"`
	TxIds   [][]byte `json:"txIds,omitempty" form:"txIds" query:"txIds" validate:"required"`
	// Transactions the transactions within this block.
	Transactions []*ResponseByTxId `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	extraData    []byte
}

type ResponsePending struct {
	fieldsSet    []bool
	Transactions []*url.TxID `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	extraData    []byte
}

type ResponseTxHistory struct {
	fieldsSet    []bool
	Start        uint64           `json:"start" form:"start" query:"start" validate:"required"`
	End          uint64           `json:"end" form:"end" query:"end" validate:"required"`
	Total        uint64           `json:"total" form:"total" query:"total" validate:"required"`
	Transactions []ResponseByTxId `json:"transactions,omitempty" form:"transactions" query:"transactions" validate:"required"`
	extraData    []byte
}

type SignatureSet struct {
	fieldsSet  []bool
	Account    protocol.Account     `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Signatures []protocol.Signature `json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	extraData  []byte
}

type TxReceipt struct {
	fieldsSet []bool
	GeneralReceipt
	Account   *url.URL `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	Chain     string   `json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	extraData []byte
}

type UnknownRequest struct {
	fieldsSet []bool
	extraData []byte
}

func (*RequestByChainId) Type() QueryType { return QueryTypeChainId }

func (*RequestByTxId) Type() QueryType { return QueryTypeTxId }

func (*RequestByUrl) Type() QueryType { return QueryTypeUrl }

func (*RequestDataEntry) Type() QueryType { return QueryTypeData }

func (*RequestDataEntrySet) Type() QueryType { return QueryTypeDataSet }

func (*RequestDirectory) Type() QueryType { return QueryTypeDirectoryUrl }

func (*RequestKeyPageIndex) Type() QueryType { return QueryTypeKeyPageIndex }

func (*RequestMajorBlocks) Type() QueryType { return QueryTypeMajorBlocks }

func (*RequestMinorBlocks) Type() QueryType { return QueryTypeMinorBlocks }

func (*RequestSynth) Type() QueryType { return QueryTypeSynth }

func (*RequestTxHistory) Type() QueryType { return QueryTypeTxHistory }

func (*UnknownRequest) Type() QueryType { return QueryTypeUnknown }

func (v *ChainState) Copy() *ChainState {
	u := new(ChainState)

	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Roots = make([][]byte, len(v.Roots))
	for i, v := range v.Roots {
		u.Roots[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *ChainState) CopyAsInterface() interface{} { return v.Copy() }

func (v *DirectoryQueryResult) Copy() *DirectoryQueryResult {
	u := new(DirectoryQueryResult)

	u.Entries = make([]string, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = v
	}
	u.ExpandedEntries = make([]protocol.Account, len(v.ExpandedEntries))
	for i, v := range v.ExpandedEntries {
		if v != nil {
			u.ExpandedEntries[i] = (v).CopyAsInterface().(protocol.Account)
		}
	}
	u.Total = v.Total

	return u
}

func (v *DirectoryQueryResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *GeneralReceipt) Copy() *GeneralReceipt {
	u := new(GeneralReceipt)

	u.LocalBlock = v.LocalBlock
	u.DirectoryBlock = v.DirectoryBlock
	u.MajorBlock = v.MajorBlock
	u.Proof = *(&v.Proof).Copy()
	u.Error = v.Error

	return u
}

func (v *GeneralReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestByChainId) Copy() *RequestByChainId {
	u := new(RequestByChainId)

	u.ChainId = v.ChainId

	return u
}

func (v *RequestByChainId) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestByTxId) Copy() *RequestByTxId {
	u := new(RequestByTxId)

	u.TxId = v.TxId

	return u
}

func (v *RequestByTxId) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestByUrl) Copy() *RequestByUrl {
	u := new(RequestByUrl)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Scratch = v.Scratch

	return u
}

func (v *RequestByUrl) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestDataEntry) Copy() *RequestDataEntry {
	u := new(RequestDataEntry)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.EntryHash = v.EntryHash

	return u
}

func (v *RequestDataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestDataEntrySet) Copy() *RequestDataEntrySet {
	u := new(RequestDataEntrySet)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Start = v.Start
	u.Count = v.Count
	u.ExpandChains = v.ExpandChains

	return u
}

func (v *RequestDataEntrySet) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestDirectory) Copy() *RequestDirectory {
	u := new(RequestDirectory)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Start = v.Start
	u.Limit = v.Limit
	u.ExpandChains = v.ExpandChains

	return u
}

func (v *RequestDirectory) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestKeyPageIndex) Copy() *RequestKeyPageIndex {
	u := new(RequestKeyPageIndex)

	if v.Url != nil {
		u.Url = v.Url
	}
	u.Key = encoding.BytesCopy(v.Key)

	return u
}

func (v *RequestKeyPageIndex) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestMajorBlocks) Copy() *RequestMajorBlocks {
	u := new(RequestMajorBlocks)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Start = v.Start
	u.Limit = v.Limit

	return u
}

func (v *RequestMajorBlocks) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestMinorBlocks) Copy() *RequestMinorBlocks {
	u := new(RequestMinorBlocks)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Start = v.Start
	u.Limit = v.Limit
	u.TxFetchMode = v.TxFetchMode
	u.BlockFilterMode = v.BlockFilterMode

	return u
}

func (v *RequestMinorBlocks) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestSynth) Copy() *RequestSynth {
	u := new(RequestSynth)

	if v.Source != nil {
		u.Source = v.Source
	}
	if v.Destination != nil {
		u.Destination = v.Destination
	}
	u.SequenceNumber = v.SequenceNumber
	u.Anchor = v.Anchor

	return u
}

func (v *RequestSynth) CopyAsInterface() interface{} { return v.Copy() }

func (v *RequestTxHistory) Copy() *RequestTxHistory {
	u := new(RequestTxHistory)

	if v.Account != nil {
		u.Account = v.Account
	}
	u.Start = v.Start
	u.Limit = v.Limit
	u.Scratch = v.Scratch

	return u
}

func (v *RequestTxHistory) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseAccount) Copy() *ResponseAccount {
	u := new(ResponseAccount)

	if v.Account != nil {
		u.Account = (v.Account).CopyAsInterface().(protocol.Account)
	}
	u.ChainState = make([]ChainState, len(v.ChainState))
	for i, v := range v.ChainState {
		u.ChainState[i] = *(&v).Copy()
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *ResponseAccount) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseByTxId) Copy() *ResponseByTxId {
	u := new(ResponseByTxId)

	if v.TxId != nil {
		u.TxId = v.TxId
	}
	if v.Envelope != nil {
		u.Envelope = (v.Envelope).Copy()
	}
	if v.Status != nil {
		u.Status = (v.Status).Copy()
	}
	u.Produced = make([]*url.TxID, len(v.Produced))
	for i, v := range v.Produced {
		if v != nil {
			u.Produced[i] = v
		}
	}
	u.Height = v.Height
	u.ChainState = make([][]byte, len(v.ChainState))
	for i, v := range v.ChainState {
		u.ChainState[i] = encoding.BytesCopy(v)
	}
	u.Receipts = make([]*TxReceipt, len(v.Receipts))
	for i, v := range v.Receipts {
		if v != nil {
			u.Receipts[i] = (v).Copy()
		}
	}
	u.Signers = make([]SignatureSet, len(v.Signers))
	for i, v := range v.Signers {
		u.Signers[i] = *(&v).Copy()
	}

	return u
}

func (v *ResponseByTxId) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseChainEntry) Copy() *ResponseChainEntry {
	u := new(ResponseChainEntry)

	u.Type = v.Type
	u.Height = v.Height
	u.Entry = encoding.BytesCopy(v.Entry)
	u.State = make([][]byte, len(v.State))
	for i, v := range v.State {
		u.State[i] = encoding.BytesCopy(v)
	}
	if v.Receipt != nil {
		u.Receipt = (v.Receipt).Copy()
	}

	return u
}

func (v *ResponseChainEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseChainRange) Copy() *ResponseChainRange {
	u := new(ResponseChainRange)

	u.Type = v.Type
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make([][]byte, len(v.Entries))
	for i, v := range v.Entries {
		u.Entries[i] = encoding.BytesCopy(v)
	}

	return u
}

func (v *ResponseChainRange) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseDataEntry) Copy() *ResponseDataEntry {
	u := new(ResponseDataEntry)

	u.EntryHash = v.EntryHash
	if v.Entry != nil {
		u.Entry = (v.Entry).CopyAsInterface().(protocol.DataEntry)
	}

	return u
}

func (v *ResponseDataEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseDataEntrySet) Copy() *ResponseDataEntrySet {
	u := new(ResponseDataEntrySet)

	u.DataEntries = make([]ResponseDataEntry, len(v.DataEntries))
	for i, v := range v.DataEntries {
		u.DataEntries[i] = *(&v).Copy()
	}
	u.Total = v.Total

	return u
}

func (v *ResponseDataEntrySet) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseKeyPageIndex) Copy() *ResponseKeyPageIndex {
	u := new(ResponseKeyPageIndex)

	if v.Authority != nil {
		u.Authority = v.Authority
	}
	if v.Signer != nil {
		u.Signer = v.Signer
	}
	u.Index = v.Index

	return u
}

func (v *ResponseKeyPageIndex) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseMajorBlocks) Copy() *ResponseMajorBlocks {
	u := new(ResponseMajorBlocks)

	u.TotalBlocks = v.TotalBlocks
	u.Entries = make([]*ResponseMajorEntry, len(v.Entries))
	for i, v := range v.Entries {
		if v != nil {
			u.Entries[i] = (v).Copy()
		}
	}

	return u
}

func (v *ResponseMajorBlocks) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseMajorEntry) Copy() *ResponseMajorEntry {
	u := new(ResponseMajorEntry)

	u.MajorBlockIndex = v.MajorBlockIndex
	if v.MajorBlockTime != nil {
		u.MajorBlockTime = new(time.Time)
		*u.MajorBlockTime = *v.MajorBlockTime
	}
	u.MinorBlocks = make([]*ResponseMinorEntry, len(v.MinorBlocks))
	for i, v := range v.MinorBlocks {
		if v != nil {
			u.MinorBlocks[i] = (v).Copy()
		}
	}

	return u
}

func (v *ResponseMajorEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseMinorBlocks) Copy() *ResponseMinorBlocks {
	u := new(ResponseMinorBlocks)

	u.TotalBlocks = v.TotalBlocks
	u.Entries = make([]*ResponseMinorEntry, len(v.Entries))
	for i, v := range v.Entries {
		if v != nil {
			u.Entries[i] = (v).Copy()
		}
	}

	return u
}

func (v *ResponseMinorBlocks) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseMinorEntry) Copy() *ResponseMinorEntry {
	u := new(ResponseMinorEntry)

	u.BlockIndex = v.BlockIndex
	if v.BlockTime != nil {
		u.BlockTime = new(time.Time)
		*u.BlockTime = *v.BlockTime
	}
	u.TxCount = v.TxCount
	u.TxIds = make([][]byte, len(v.TxIds))
	for i, v := range v.TxIds {
		u.TxIds[i] = encoding.BytesCopy(v)
	}
	u.Transactions = make([]*ResponseByTxId, len(v.Transactions))
	for i, v := range v.Transactions {
		if v != nil {
			u.Transactions[i] = (v).Copy()
		}
	}

	return u
}

func (v *ResponseMinorEntry) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponsePending) Copy() *ResponsePending {
	u := new(ResponsePending)

	u.Transactions = make([]*url.TxID, len(v.Transactions))
	for i, v := range v.Transactions {
		if v != nil {
			u.Transactions[i] = v
		}
	}

	return u
}

func (v *ResponsePending) CopyAsInterface() interface{} { return v.Copy() }

func (v *ResponseTxHistory) Copy() *ResponseTxHistory {
	u := new(ResponseTxHistory)

	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Transactions = make([]ResponseByTxId, len(v.Transactions))
	for i, v := range v.Transactions {
		u.Transactions[i] = *(&v).Copy()
	}

	return u
}

func (v *ResponseTxHistory) CopyAsInterface() interface{} { return v.Copy() }

func (v *SignatureSet) Copy() *SignatureSet {
	u := new(SignatureSet)

	if v.Account != nil {
		u.Account = (v.Account).CopyAsInterface().(protocol.Account)
	}
	u.Signatures = make([]protocol.Signature, len(v.Signatures))
	for i, v := range v.Signatures {
		if v != nil {
			u.Signatures[i] = (v).CopyAsInterface().(protocol.Signature)
		}
	}

	return u
}

func (v *SignatureSet) CopyAsInterface() interface{} { return v.Copy() }

func (v *TxReceipt) Copy() *TxReceipt {
	u := new(TxReceipt)

	u.GeneralReceipt = *v.GeneralReceipt.Copy()
	if v.Account != nil {
		u.Account = v.Account
	}
	u.Chain = v.Chain

	return u
}

func (v *TxReceipt) CopyAsInterface() interface{} { return v.Copy() }

func (v *UnknownRequest) Copy() *UnknownRequest {
	u := new(UnknownRequest)

	return u
}

func (v *UnknownRequest) CopyAsInterface() interface{} { return v.Copy() }

func (v *ChainState) Equal(u *ChainState) bool {
	if !(v.Name == u.Name) {
		return false
	}
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.Roots) != len(u.Roots) {
		return false
	}
	for i := range v.Roots {
		if !(bytes.Equal(v.Roots[i], u.Roots[i])) {
			return false
		}
	}

	return true
}

func (v *DirectoryQueryResult) Equal(u *DirectoryQueryResult) bool {
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(v.Entries[i] == u.Entries[i]) {
			return false
		}
	}
	if len(v.ExpandedEntries) != len(u.ExpandedEntries) {
		return false
	}
	for i := range v.ExpandedEntries {
		if !(protocol.EqualAccount(v.ExpandedEntries[i], u.ExpandedEntries[i])) {
			return false
		}
	}
	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *GeneralReceipt) Equal(u *GeneralReceipt) bool {
	if !(v.LocalBlock == u.LocalBlock) {
		return false
	}
	if !(v.DirectoryBlock == u.DirectoryBlock) {
		return false
	}
	if !(v.MajorBlock == u.MajorBlock) {
		return false
	}
	if !((&v.Proof).Equal(&u.Proof)) {
		return false
	}
	if !(v.Error == u.Error) {
		return false
	}

	return true
}

func (v *RequestByChainId) Equal(u *RequestByChainId) bool {
	if !(v.ChainId == u.ChainId) {
		return false
	}

	return true
}

func (v *RequestByTxId) Equal(u *RequestByTxId) bool {
	if !(v.TxId == u.TxId) {
		return false
	}

	return true
}

func (v *RequestByUrl) Equal(u *RequestByUrl) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *RequestDataEntry) Equal(u *RequestDataEntry) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.EntryHash == u.EntryHash) {
		return false
	}

	return true
}

func (v *RequestDataEntrySet) Equal(u *RequestDataEntrySet) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Count == u.Count) {
		return false
	}
	if !(v.ExpandChains == u.ExpandChains) {
		return false
	}

	return true
}

func (v *RequestDirectory) Equal(u *RequestDirectory) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Limit == u.Limit) {
		return false
	}
	if !(v.ExpandChains == u.ExpandChains) {
		return false
	}

	return true
}

func (v *RequestKeyPageIndex) Equal(u *RequestKeyPageIndex) bool {
	switch {
	case v.Url == u.Url:
		// equal
	case v.Url == nil || u.Url == nil:
		return false
	case !((v.Url).Equal(u.Url)):
		return false
	}
	if !(bytes.Equal(v.Key, u.Key)) {
		return false
	}

	return true
}

func (v *RequestMajorBlocks) Equal(u *RequestMajorBlocks) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Limit == u.Limit) {
		return false
	}

	return true
}

func (v *RequestMinorBlocks) Equal(u *RequestMinorBlocks) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Limit == u.Limit) {
		return false
	}
	if !(v.TxFetchMode == u.TxFetchMode) {
		return false
	}
	if !(v.BlockFilterMode == u.BlockFilterMode) {
		return false
	}

	return true
}

func (v *RequestSynth) Equal(u *RequestSynth) bool {
	switch {
	case v.Source == u.Source:
		// equal
	case v.Source == nil || u.Source == nil:
		return false
	case !((v.Source).Equal(u.Source)):
		return false
	}
	switch {
	case v.Destination == u.Destination:
		// equal
	case v.Destination == nil || u.Destination == nil:
		return false
	case !((v.Destination).Equal(u.Destination)):
		return false
	}
	if !(v.SequenceNumber == u.SequenceNumber) {
		return false
	}
	if !(v.Anchor == u.Anchor) {
		return false
	}

	return true
}

func (v *RequestTxHistory) Equal(u *RequestTxHistory) bool {
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.Limit == u.Limit) {
		return false
	}
	if !(v.Scratch == u.Scratch) {
		return false
	}

	return true
}

func (v *ResponseAccount) Equal(u *ResponseAccount) bool {
	if !(protocol.EqualAccount(v.Account, u.Account)) {
		return false
	}
	if len(v.ChainState) != len(u.ChainState) {
		return false
	}
	for i := range v.ChainState {
		if !((&v.ChainState[i]).Equal(&u.ChainState[i])) {
			return false
		}
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

func (v *ResponseByTxId) Equal(u *ResponseByTxId) bool {
	switch {
	case v.TxId == u.TxId:
		// equal
	case v.TxId == nil || u.TxId == nil:
		return false
	case !((v.TxId).Equal(u.TxId)):
		return false
	}
	switch {
	case v.Envelope == u.Envelope:
		// equal
	case v.Envelope == nil || u.Envelope == nil:
		return false
	case !((v.Envelope).Equal(u.Envelope)):
		return false
	}
	switch {
	case v.Status == u.Status:
		// equal
	case v.Status == nil || u.Status == nil:
		return false
	case !((v.Status).Equal(u.Status)):
		return false
	}
	if len(v.Produced) != len(u.Produced) {
		return false
	}
	for i := range v.Produced {
		if !((v.Produced[i]).Equal(u.Produced[i])) {
			return false
		}
	}
	if !(v.Height == u.Height) {
		return false
	}
	if len(v.ChainState) != len(u.ChainState) {
		return false
	}
	for i := range v.ChainState {
		if !(bytes.Equal(v.ChainState[i], u.ChainState[i])) {
			return false
		}
	}
	if len(v.Receipts) != len(u.Receipts) {
		return false
	}
	for i := range v.Receipts {
		if !((v.Receipts[i]).Equal(u.Receipts[i])) {
			return false
		}
	}
	if len(v.Signers) != len(u.Signers) {
		return false
	}
	for i := range v.Signers {
		if !((&v.Signers[i]).Equal(&u.Signers[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseChainEntry) Equal(u *ResponseChainEntry) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Height == u.Height) {
		return false
	}
	if !(bytes.Equal(v.Entry, u.Entry)) {
		return false
	}
	if len(v.State) != len(u.State) {
		return false
	}
	for i := range v.State {
		if !(bytes.Equal(v.State[i], u.State[i])) {
			return false
		}
	}
	switch {
	case v.Receipt == u.Receipt:
		// equal
	case v.Receipt == nil || u.Receipt == nil:
		return false
	case !((v.Receipt).Equal(u.Receipt)):
		return false
	}

	return true
}

func (v *ResponseChainRange) Equal(u *ResponseChainRange) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.End == u.End) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !(bytes.Equal(v.Entries[i], u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseDataEntry) Equal(u *ResponseDataEntry) bool {
	if !(v.EntryHash == u.EntryHash) {
		return false
	}
	if !(protocol.EqualDataEntry(v.Entry, u.Entry)) {
		return false
	}

	return true
}

func (v *ResponseDataEntrySet) Equal(u *ResponseDataEntrySet) bool {
	if len(v.DataEntries) != len(u.DataEntries) {
		return false
	}
	for i := range v.DataEntries {
		if !((&v.DataEntries[i]).Equal(&u.DataEntries[i])) {
			return false
		}
	}
	if !(v.Total == u.Total) {
		return false
	}

	return true
}

func (v *ResponseKeyPageIndex) Equal(u *ResponseKeyPageIndex) bool {
	switch {
	case v.Authority == u.Authority:
		// equal
	case v.Authority == nil || u.Authority == nil:
		return false
	case !((v.Authority).Equal(u.Authority)):
		return false
	}
	switch {
	case v.Signer == u.Signer:
		// equal
	case v.Signer == nil || u.Signer == nil:
		return false
	case !((v.Signer).Equal(u.Signer)):
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}

	return true
}

func (v *ResponseMajorBlocks) Equal(u *ResponseMajorBlocks) bool {
	if !(v.TotalBlocks == u.TotalBlocks) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((v.Entries[i]).Equal(u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseMajorEntry) Equal(u *ResponseMajorEntry) bool {
	if !(v.MajorBlockIndex == u.MajorBlockIndex) {
		return false
	}
	switch {
	case v.MajorBlockTime == u.MajorBlockTime:
		// equal
	case v.MajorBlockTime == nil || u.MajorBlockTime == nil:
		return false
	case !((*v.MajorBlockTime).Equal(*u.MajorBlockTime)):
		return false
	}
	if len(v.MinorBlocks) != len(u.MinorBlocks) {
		return false
	}
	for i := range v.MinorBlocks {
		if !((v.MinorBlocks[i]).Equal(u.MinorBlocks[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseMinorBlocks) Equal(u *ResponseMinorBlocks) bool {
	if !(v.TotalBlocks == u.TotalBlocks) {
		return false
	}
	if len(v.Entries) != len(u.Entries) {
		return false
	}
	for i := range v.Entries {
		if !((v.Entries[i]).Equal(u.Entries[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseMinorEntry) Equal(u *ResponseMinorEntry) bool {
	if !(v.BlockIndex == u.BlockIndex) {
		return false
	}
	switch {
	case v.BlockTime == u.BlockTime:
		// equal
	case v.BlockTime == nil || u.BlockTime == nil:
		return false
	case !((*v.BlockTime).Equal(*u.BlockTime)):
		return false
	}
	if !(v.TxCount == u.TxCount) {
		return false
	}
	if len(v.TxIds) != len(u.TxIds) {
		return false
	}
	for i := range v.TxIds {
		if !(bytes.Equal(v.TxIds[i], u.TxIds[i])) {
			return false
		}
	}
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((v.Transactions[i]).Equal(u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *ResponsePending) Equal(u *ResponsePending) bool {
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((v.Transactions[i]).Equal(u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *ResponseTxHistory) Equal(u *ResponseTxHistory) bool {
	if !(v.Start == u.Start) {
		return false
	}
	if !(v.End == u.End) {
		return false
	}
	if !(v.Total == u.Total) {
		return false
	}
	if len(v.Transactions) != len(u.Transactions) {
		return false
	}
	for i := range v.Transactions {
		if !((&v.Transactions[i]).Equal(&u.Transactions[i])) {
			return false
		}
	}

	return true
}

func (v *SignatureSet) Equal(u *SignatureSet) bool {
	if !(protocol.EqualAccount(v.Account, u.Account)) {
		return false
	}
	if len(v.Signatures) != len(u.Signatures) {
		return false
	}
	for i := range v.Signatures {
		if !(protocol.EqualSignature(v.Signatures[i], u.Signatures[i])) {
			return false
		}
	}

	return true
}

func (v *TxReceipt) Equal(u *TxReceipt) bool {
	if !v.GeneralReceipt.Equal(&u.GeneralReceipt) {
		return false
	}
	switch {
	case v.Account == u.Account:
		// equal
	case v.Account == nil || u.Account == nil:
		return false
	case !((v.Account).Equal(u.Account)):
		return false
	}
	if !(v.Chain == u.Chain) {
		return false
	}

	return true
}

func (v *UnknownRequest) Equal(u *UnknownRequest) bool {

	return true
}

var fieldNames_ChainState = []string{
	1: "Name",
	2: "Type",
	3: "Height",
	4: "Roots",
}

func (v *ChainState) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Name) == 0) {
		writer.WriteString(1, v.Name)
	}
	if !(v.Type == 0) {
		writer.WriteEnum(2, v.Type)
	}
	if !(v.Height == 0) {
		writer.WriteUint(3, v.Height)
	}
	if !(len(v.Roots) == 0) {
		for _, v := range v.Roots {
			writer.WriteBytes(4, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ChainState)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ChainState) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Name is missing")
	} else if len(v.Name) == 0 {
		errs = append(errs, "field Name is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Height is missing")
	} else if v.Height == 0 {
		errs = append(errs, "field Height is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Roots is missing")
	} else if len(v.Roots) == 0 {
		errs = append(errs, "field Roots is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_DirectoryQueryResult = []string{
	1: "Entries",
	2: "ExpandedEntries",
	3: "Total",
}

func (v *DirectoryQueryResult) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteString(1, v)
		}
	}
	if !(len(v.ExpandedEntries) == 0) {
		for _, v := range v.ExpandedEntries {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	writer.WriteUint(3, v.Total)

	_, _, err := writer.Reset(fieldNames_DirectoryQueryResult)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *DirectoryQueryResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_GeneralReceipt = []string{
	1: "LocalBlock",
	2: "DirectoryBlock",
	3: "MajorBlock",
	4: "Proof",
	5: "Error",
}

func (v *GeneralReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.LocalBlock == 0) {
		writer.WriteUint(1, v.LocalBlock)
	}
	if !(v.DirectoryBlock == 0) {
		writer.WriteUint(2, v.DirectoryBlock)
	}
	if !(v.MajorBlock == 0) {
		writer.WriteUint(3, v.MajorBlock)
	}
	if !((v.Proof).Equal(new(managed.Receipt))) {
		writer.WriteValue(4, v.Proof.MarshalBinary)
	}
	if !(len(v.Error) == 0) {
		writer.WriteString(5, v.Error)
	}

	_, _, err := writer.Reset(fieldNames_GeneralReceipt)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *GeneralReceipt) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field LocalBlock is missing")
	} else if v.LocalBlock == 0 {
		errs = append(errs, "field LocalBlock is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field DirectoryBlock is missing")
	} else if v.DirectoryBlock == 0 {
		errs = append(errs, "field DirectoryBlock is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field MajorBlock is missing")
	} else if v.MajorBlock == 0 {
		errs = append(errs, "field MajorBlock is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Proof is missing")
	} else if (v.Proof).Equal(new(managed.Receipt)) {
		errs = append(errs, "field Proof is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Error is missing")
	} else if len(v.Error) == 0 {
		errs = append(errs, "field Error is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_MultiResponse = []string{
	1: "Type",
	2: "Items",
	3: "Start",
	4: "Count",
	5: "Total",
}

func (v *MultiResponse) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Type) == 0) {
		writer.WriteString(1, v.Type)
	}
	if !(len(v.Items) == 0) {
		for _, v := range v.Items {
			writer.WriteString(2, v)
		}
	}
	writer.WriteUint(3, v.Start)
	writer.WriteUint(4, v.Count)
	writer.WriteUint(5, v.Total)

	_, _, err := writer.Reset(fieldNames_MultiResponse)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *MultiResponse) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if len(v.Type) == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Items is missing")
	} else if len(v.Items) == 0 {
		errs = append(errs, "field Items is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Count is missing")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Total is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestByChainId = []string{
	1: "Type",
	2: "ChainId",
}

func (v *RequestByChainId) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.ChainId == ([32]byte{})) {
		writer.WriteHash(2, &v.ChainId)
	}

	_, _, err := writer.Reset(fieldNames_RequestByChainId)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestByChainId) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ChainId is missing")
	} else if v.ChainId == ([32]byte{}) {
		errs = append(errs, "field ChainId is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestByTxId = []string{
	1: "Type",
	2: "TxId",
}

func (v *RequestByTxId) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.TxId == ([32]byte{})) {
		writer.WriteHash(2, &v.TxId)
	}

	_, _, err := writer.Reset(fieldNames_RequestByTxId)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestByTxId) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field TxId is missing")
	} else if v.TxId == ([32]byte{}) {
		errs = append(errs, "field TxId is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestByUrl = []string{
	1: "Type",
	2: "Url",
	3: "Scratch",
}

func (v *RequestByUrl) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(!v.Scratch) {
		writer.WriteBool(3, v.Scratch)
	}

	_, _, err := writer.Reset(fieldNames_RequestByUrl)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestByUrl) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestDataEntry = []string{
	1: "Type",
	2: "Url",
	3: "EntryHash",
}

func (v *RequestDataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(3, &v.EntryHash)
	}

	_, _, err := writer.Reset(fieldNames_RequestDataEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestDataEntrySet = []string{
	1: "Type",
	2: "Url",
	3: "Start",
	4: "Count",
	5: "ExpandChains",
}

func (v *RequestDataEntrySet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.Start == 0) {
		writer.WriteUint(3, v.Start)
	}
	if !(v.Count == 0) {
		writer.WriteUint(4, v.Count)
	}
	if !(!v.ExpandChains) {
		writer.WriteBool(5, v.ExpandChains)
	}

	_, _, err := writer.Reset(fieldNames_RequestDataEntrySet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestDataEntrySet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Count is missing")
	} else if v.Count == 0 {
		errs = append(errs, "field Count is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestDirectory = []string{
	1: "Type",
	2: "Url",
	3: "Start",
	4: "Limit",
	5: "ExpandChains",
}

func (v *RequestDirectory) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(v.Start == 0) {
		writer.WriteUint(3, v.Start)
	}
	if !(v.Limit == 0) {
		writer.WriteUint(4, v.Limit)
	}
	if !(!v.ExpandChains) {
		writer.WriteBool(5, v.ExpandChains)
	}

	_, _, err := writer.Reset(fieldNames_RequestDirectory)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestDirectory) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Limit is missing")
	} else if v.Limit == 0 {
		errs = append(errs, "field Limit is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field ExpandChains is missing")
	} else if !v.ExpandChains {
		errs = append(errs, "field ExpandChains is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestKeyPageIndex = []string{
	1: "Type",
	2: "Url",
	3: "Key",
}

func (v *RequestKeyPageIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Url == nil) {
		writer.WriteUrl(2, v.Url)
	}
	if !(len(v.Key) == 0) {
		writer.WriteBytes(3, v.Key)
	}

	_, _, err := writer.Reset(fieldNames_RequestKeyPageIndex)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Url is missing")
	} else if v.Url == nil {
		errs = append(errs, "field Url is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Key is missing")
	} else if len(v.Key) == 0 {
		errs = append(errs, "field Key is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestMajorBlocks = []string{
	1: "Type",
	2: "Account",
	3: "Start",
	4: "Limit",
}

func (v *RequestMajorBlocks) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(v.Start == 0) {
		writer.WriteUint(3, v.Start)
	}
	if !(v.Limit == 0) {
		writer.WriteUint(4, v.Limit)
	}

	_, _, err := writer.Reset(fieldNames_RequestMajorBlocks)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestMajorBlocks) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Limit is missing")
	} else if v.Limit == 0 {
		errs = append(errs, "field Limit is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestMinorBlocks = []string{
	1: "Type",
	2: "Account",
	3: "Start",
	4: "Limit",
	5: "TxFetchMode",
	6: "BlockFilterMode",
}

func (v *RequestMinorBlocks) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(v.Start == 0) {
		writer.WriteUint(3, v.Start)
	}
	if !(v.Limit == 0) {
		writer.WriteUint(4, v.Limit)
	}
	if !(v.TxFetchMode == 0) {
		writer.WriteEnum(5, v.TxFetchMode)
	}
	if !(v.BlockFilterMode == 0) {
		writer.WriteEnum(6, v.BlockFilterMode)
	}

	_, _, err := writer.Reset(fieldNames_RequestMinorBlocks)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestMinorBlocks) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Limit is missing")
	} else if v.Limit == 0 {
		errs = append(errs, "field Limit is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field TxFetchMode is missing")
	} else if v.TxFetchMode == 0 {
		errs = append(errs, "field TxFetchMode is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field BlockFilterMode is missing")
	} else if v.BlockFilterMode == 0 {
		errs = append(errs, "field BlockFilterMode is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestSynth = []string{
	1: "Type",
	2: "Source",
	3: "Destination",
	4: "SequenceNumber",
	5: "Anchor",
}

func (v *RequestSynth) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Source == nil) {
		writer.WriteUrl(2, v.Source)
	}
	if !(v.Destination == nil) {
		writer.WriteUrl(3, v.Destination)
	}
	if !(v.SequenceNumber == 0) {
		writer.WriteUint(4, v.SequenceNumber)
	}
	if !(!v.Anchor) {
		writer.WriteBool(5, v.Anchor)
	}

	_, _, err := writer.Reset(fieldNames_RequestSynth)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestSynth) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Source is missing")
	} else if v.Source == nil {
		errs = append(errs, "field Source is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Destination is missing")
	} else if v.Destination == nil {
		errs = append(errs, "field Destination is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_RequestTxHistory = []string{
	1: "Type",
	2: "Account",
	3: "Start",
	4: "Limit",
	5: "Scratch",
}

func (v *RequestTxHistory) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(v.Start == 0) {
		writer.WriteUint(3, v.Start)
	}
	if !(v.Limit == 0) {
		writer.WriteUint(4, v.Limit)
	}
	if !(!v.Scratch) {
		writer.WriteBool(5, v.Scratch)
	}

	_, _, err := writer.Reset(fieldNames_RequestTxHistory)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *RequestTxHistory) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Start is missing")
	} else if v.Start == 0 {
		errs = append(errs, "field Start is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Limit is missing")
	} else if v.Limit == 0 {
		errs = append(errs, "field Limit is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Scratch is missing")
	} else if !v.Scratch {
		errs = append(errs, "field Scratch is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseAccount = []string{
	1: "Account",
	2: "ChainState",
	3: "Receipt",
}

func (v *ResponseAccount) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(protocol.EqualAccount(v.Account, nil)) {
		writer.WriteValue(1, v.Account.MarshalBinary)
	}
	if !(len(v.ChainState) == 0) {
		for _, v := range v.ChainState {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(3, v.Receipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ResponseAccount)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseAccount) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if protocol.EqualAccount(v.Account, nil) {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ChainState is missing")
	} else if len(v.ChainState) == 0 {
		errs = append(errs, "field ChainState is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseByTxId = []string{
	1: "TxId",
	2: "Envelope",
	3: "Status",
	4: "Produced",
	5: "Height",
	6: "ChainState",
	7: "Receipts",
	8: "Signers",
}

func (v *ResponseByTxId) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.TxId == nil) {
		writer.WriteTxid(1, v.TxId)
	}
	if !(v.Envelope == nil) {
		writer.WriteValue(2, v.Envelope.MarshalBinary)
	}
	if !(v.Status == nil) {
		writer.WriteValue(3, v.Status.MarshalBinary)
	}
	if !(len(v.Produced) == 0) {
		for _, v := range v.Produced {
			writer.WriteTxid(4, v)
		}
	}
	writer.WriteUint(5, v.Height)
	if !(len(v.ChainState) == 0) {
		for _, v := range v.ChainState {
			writer.WriteBytes(6, v)
		}
	}
	if !(len(v.Receipts) == 0) {
		for _, v := range v.Receipts {
			writer.WriteValue(7, v.MarshalBinary)
		}
	}
	if !(len(v.Signers) == 0) {
		for _, v := range v.Signers {
			writer.WriteValue(8, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseByTxId)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseByTxId) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TxId is missing")
	} else if v.TxId == nil {
		errs = append(errs, "field TxId is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Envelope is missing")
	} else if v.Envelope == nil {
		errs = append(errs, "field Envelope is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Status is missing")
	} else if v.Status == nil {
		errs = append(errs, "field Status is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Produced is missing")
	} else if len(v.Produced) == 0 {
		errs = append(errs, "field Produced is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Height is missing")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field ChainState is missing")
	} else if len(v.ChainState) == 0 {
		errs = append(errs, "field ChainState is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field Receipts is missing")
	} else if len(v.Receipts) == 0 {
		errs = append(errs, "field Receipts is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field Signers is missing")
	} else if len(v.Signers) == 0 {
		errs = append(errs, "field Signers is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseChainEntry = []string{
	1: "Type",
	2: "Height",
	3: "Entry",
	4: "State",
	5: "Receipt",
}

func (v *ResponseChainEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	writer.WriteUint(2, v.Height)
	if !(len(v.Entry) == 0) {
		writer.WriteBytes(3, v.Entry)
	}
	if !(len(v.State) == 0) {
		for _, v := range v.State {
			writer.WriteBytes(4, v)
		}
	}
	if !(v.Receipt == nil) {
		writer.WriteValue(5, v.Receipt.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ResponseChainEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseChainEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Height is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Entry is missing")
	} else if len(v.Entry) == 0 {
		errs = append(errs, "field Entry is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field State is missing")
	} else if len(v.State) == 0 {
		errs = append(errs, "field State is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseChainRange = []string{
	1: "Type",
	2: "Start",
	3: "End",
	4: "Total",
	5: "Entries",
}

func (v *ResponseChainRange) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	writer.WriteInt(2, v.Start)
	writer.WriteInt(3, v.End)
	writer.WriteInt(4, v.Total)
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteBytes(5, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseChainRange)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseChainRange) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Start is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field End is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Total is missing")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseDataEntry = []string{
	1: "EntryHash",
	2: "Entry",
}

func (v *ResponseDataEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.EntryHash == ([32]byte{})) {
		writer.WriteHash(1, &v.EntryHash)
	}
	if !(protocol.EqualDataEntry(v.Entry, nil)) {
		writer.WriteValue(2, v.Entry.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_ResponseDataEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseDataEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field EntryHash is missing")
	} else if v.EntryHash == ([32]byte{}) {
		errs = append(errs, "field EntryHash is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entry is missing")
	} else if protocol.EqualDataEntry(v.Entry, nil) {
		errs = append(errs, "field Entry is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseDataEntrySet = []string{
	1: "DataEntries",
	2: "Total",
}

func (v *ResponseDataEntrySet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.DataEntries) == 0) {
		for _, v := range v.DataEntries {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}
	if !(v.Total == 0) {
		writer.WriteUint(2, v.Total)
	}

	_, _, err := writer.Reset(fieldNames_ResponseDataEntrySet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseDataEntrySet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field DataEntries is missing")
	} else if len(v.DataEntries) == 0 {
		errs = append(errs, "field DataEntries is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Total is missing")
	} else if v.Total == 0 {
		errs = append(errs, "field Total is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseKeyPageIndex = []string{
	1: "Authority",
	2: "Signer",
	3: "Index",
}

func (v *ResponseKeyPageIndex) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Authority == nil) {
		writer.WriteUrl(1, v.Authority)
	}
	if !(v.Signer == nil) {
		writer.WriteUrl(2, v.Signer)
	}
	writer.WriteUint(3, v.Index)

	_, _, err := writer.Reset(fieldNames_ResponseKeyPageIndex)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseKeyPageIndex) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Authority is missing")
	} else if v.Authority == nil {
		errs = append(errs, "field Authority is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signer is missing")
	} else if v.Signer == nil {
		errs = append(errs, "field Signer is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Index is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseMajorBlocks = []string{
	1: "TotalBlocks",
	2: "Entries",
}

func (v *ResponseMajorBlocks) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteUint(1, v.TotalBlocks)
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseMajorBlocks)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseMajorBlocks) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TotalBlocks is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseMajorEntry = []string{
	1: "MajorBlockIndex",
	2: "MajorBlockTime",
	3: "MinorBlocks",
}

func (v *ResponseMajorEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.MajorBlockIndex == 0) {
		writer.WriteUint(1, v.MajorBlockIndex)
	}
	if !(v.MajorBlockTime == nil) {
		writer.WriteTime(2, *v.MajorBlockTime)
	}
	if !(len(v.MinorBlocks) == 0) {
		for _, v := range v.MinorBlocks {
			writer.WriteValue(3, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseMajorEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseMajorEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field MajorBlockIndex is missing")
	} else if v.MajorBlockIndex == 0 {
		errs = append(errs, "field MajorBlockIndex is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field MajorBlockTime is missing")
	} else if v.MajorBlockTime == nil {
		errs = append(errs, "field MajorBlockTime is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field MinorBlocks is missing")
	} else if len(v.MinorBlocks) == 0 {
		errs = append(errs, "field MinorBlocks is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseMinorBlocks = []string{
	1: "TotalBlocks",
	2: "Entries",
}

func (v *ResponseMinorBlocks) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteUint(1, v.TotalBlocks)
	if !(len(v.Entries) == 0) {
		for _, v := range v.Entries {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseMinorBlocks)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseMinorBlocks) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TotalBlocks is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Entries is missing")
	} else if len(v.Entries) == 0 {
		errs = append(errs, "field Entries is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseMinorEntry = []string{
	1: "BlockIndex",
	2: "BlockTime",
	3: "TxCount",
	4: "TxIds",
	5: "Transactions",
}

func (v *ResponseMinorEntry) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.BlockIndex == 0) {
		writer.WriteUint(1, v.BlockIndex)
	}
	if !(v.BlockTime == nil) {
		writer.WriteTime(2, *v.BlockTime)
	}
	if !(v.TxCount == 0) {
		writer.WriteUint(3, v.TxCount)
	}
	if !(len(v.TxIds) == 0) {
		for _, v := range v.TxIds {
			writer.WriteBytes(4, v)
		}
	}
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(5, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseMinorEntry)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseMinorEntry) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field BlockIndex is missing")
	} else if v.BlockIndex == 0 {
		errs = append(errs, "field BlockIndex is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field BlockTime is missing")
	} else if v.BlockTime == nil {
		errs = append(errs, "field BlockTime is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field TxCount is missing")
	} else if v.TxCount == 0 {
		errs = append(errs, "field TxCount is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field TxIds is missing")
	} else if len(v.TxIds) == 0 {
		errs = append(errs, "field TxIds is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponsePending = []string{
	1: "Transactions",
}

func (v *ResponsePending) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteTxid(1, v)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponsePending)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponsePending) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ResponseTxHistory = []string{
	1: "Start",
	2: "End",
	3: "Total",
	4: "Transactions",
}

func (v *ResponseTxHistory) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteUint(1, v.Start)
	writer.WriteUint(2, v.End)
	writer.WriteUint(3, v.Total)
	if !(len(v.Transactions) == 0) {
		for _, v := range v.Transactions {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_ResponseTxHistory)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ResponseTxHistory) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Start is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field End is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Total is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Transactions is missing")
	} else if len(v.Transactions) == 0 {
		errs = append(errs, "field Transactions is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SignatureSet = []string{
	1: "Account",
	2: "Signatures",
}

func (v *SignatureSet) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(protocol.EqualAccount(v.Account, nil)) {
		writer.WriteValue(1, v.Account.MarshalBinary)
	}
	if !(len(v.Signatures) == 0) {
		for _, v := range v.Signatures {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_SignatureSet)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SignatureSet) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Account is missing")
	} else if protocol.EqualAccount(v.Account, nil) {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Signatures is missing")
	} else if len(v.Signatures) == 0 {
		errs = append(errs, "field Signatures is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_TxReceipt = []string{
	1: "GeneralReceipt",
	2: "Account",
	3: "Chain",
}

func (v *TxReceipt) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, v.GeneralReceipt.MarshalBinary)
	if !(v.Account == nil) {
		writer.WriteUrl(2, v.Account)
	}
	if !(len(v.Chain) == 0) {
		writer.WriteString(3, v.Chain)
	}

	_, _, err := writer.Reset(fieldNames_TxReceipt)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *TxReceipt) IsValid() error {
	var errs []string

	if err := v.GeneralReceipt.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if v.Account == nil {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Chain is missing")
	} else if len(v.Chain) == 0 {
		errs = append(errs, "field Chain is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_UnknownRequest = []string{
	1: "Type",
}

func (v *UnknownRequest) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_UnknownRequest)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *UnknownRequest) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *ChainState) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ChainState) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Name = x
	}
	if x := new(protocol.ChainType); reader.ReadEnum(2, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Height = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.Roots = append(v.Roots, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ChainState)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *DirectoryQueryResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *DirectoryQueryResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadString(1); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}
	for {
		ok := reader.ReadValue(2, func(b []byte) error {
			x, err := protocol.UnmarshalAccount(b)
			if err == nil {
				v.ExpandedEntries = append(v.ExpandedEntries, x)
			}
			return err
		})
		if !ok {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_DirectoryQueryResult)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *GeneralReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *GeneralReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.LocalBlock = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.DirectoryBlock = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.MajorBlock = x
	}
	if x := new(managed.Receipt); reader.ReadValue(4, x.UnmarshalBinary) {
		v.Proof = *x
	}
	if x, ok := reader.ReadString(5); ok {
		v.Error = x
	}

	seen, err := reader.Reset(fieldNames_GeneralReceipt)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *MultiResponse) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *MultiResponse) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadString(1); ok {
		v.Type = x
	}
	for {
		if x, ok := reader.ReadString(2); ok {
			v.Items = append(v.Items, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Count = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_MultiResponse)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestByChainId) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestByChainId) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadHash(2); ok {
		v.ChainId = *x
	}

	seen, err := reader.Reset(fieldNames_RequestByChainId)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestByTxId) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestByTxId) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadHash(2); ok {
		v.TxId = *x
	}

	seen, err := reader.Reset(fieldNames_RequestByTxId)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestByUrl) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestByUrl) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBool(3); ok {
		v.Scratch = x
	}

	seen, err := reader.Reset(fieldNames_RequestByUrl)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.EntryHash = *x
	}

	seen, err := reader.Reset(fieldNames_RequestDataEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestDataEntrySet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestDataEntrySet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Count = x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.ExpandChains = x
	}

	seen, err := reader.Reset(fieldNames_RequestDataEntrySet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestDirectory) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestDirectory) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Limit = x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.ExpandChains = x
	}

	seen, err := reader.Reset(fieldNames_RequestDirectory)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Url = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Key = x
	}

	seen, err := reader.Reset(fieldNames_RequestKeyPageIndex)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestMajorBlocks) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestMajorBlocks) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Limit = x
	}

	seen, err := reader.Reset(fieldNames_RequestMajorBlocks)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestMinorBlocks) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestMinorBlocks) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Limit = x
	}
	if x := new(TxFetchMode); reader.ReadEnum(5, x) {
		v.TxFetchMode = *x
	}
	if x := new(BlockFilterMode); reader.ReadEnum(6, x) {
		v.BlockFilterMode = *x
	}

	seen, err := reader.Reset(fieldNames_RequestMinorBlocks)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestSynth) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestSynth) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Source = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.Destination = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.SequenceNumber = x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.Anchor = x
	}

	seen, err := reader.Reset(fieldNames_RequestSynth)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *RequestTxHistory) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *RequestTxHistory) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.Limit = x
	}
	if x, ok := reader.ReadBool(5); ok {
		v.Scratch = x
	}

	seen, err := reader.Reset(fieldNames_RequestTxHistory)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseAccount) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseAccount) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.Account = x
		}
		return err
	})
	for {
		if x := new(ChainState); reader.ReadValue(2, x.UnmarshalBinary) {
			v.ChainState = append(v.ChainState, *x)
		} else {
			break
		}
	}
	if x := new(GeneralReceipt); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_ResponseAccount)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseByTxId) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseByTxId) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadTxid(1); ok {
		v.TxId = x
	}
	if x := new(protocol.Envelope); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Envelope = x
	}
	if x := new(protocol.TransactionStatus); reader.ReadValue(3, x.UnmarshalBinary) {
		v.Status = x
	}
	for {
		if x, ok := reader.ReadTxid(4); ok {
			v.Produced = append(v.Produced, x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(5); ok {
		v.Height = x
	}
	for {
		if x, ok := reader.ReadBytes(6); ok {
			v.ChainState = append(v.ChainState, x)
		} else {
			break
		}
	}
	for {
		if x := new(TxReceipt); reader.ReadValue(7, x.UnmarshalBinary) {
			v.Receipts = append(v.Receipts, x)
		} else {
			break
		}
	}
	for {
		if x := new(SignatureSet); reader.ReadValue(8, x.UnmarshalBinary) {
			v.Signers = append(v.Signers, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseByTxId)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseChainEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseChainEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.ChainType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Height = x
	}
	if x, ok := reader.ReadBytes(3); ok {
		v.Entry = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.State = append(v.State, x)
		} else {
			break
		}
	}
	if x := new(GeneralReceipt); reader.ReadValue(5, x.UnmarshalBinary) {
		v.Receipt = x
	}

	seen, err := reader.Reset(fieldNames_ResponseChainEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseChainRange) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseChainRange) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.ChainType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadInt(2); ok {
		v.Start = x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.End = x
	}
	if x, ok := reader.ReadInt(4); ok {
		v.Total = x
	}
	for {
		if x, ok := reader.ReadBytes(5); ok {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseChainRange)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseDataEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseDataEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.EntryHash = *x
	}
	reader.ReadValue(2, func(b []byte) error {
		x, err := protocol.UnmarshalDataEntry(b)
		if err == nil {
			v.Entry = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_ResponseDataEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseDataEntrySet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseDataEntrySet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(ResponseDataEntry); reader.ReadValue(1, x.UnmarshalBinary) {
			v.DataEntries = append(v.DataEntries, *x)
		} else {
			break
		}
	}
	if x, ok := reader.ReadUint(2); ok {
		v.Total = x
	}

	seen, err := reader.Reset(fieldNames_ResponseDataEntrySet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseKeyPageIndex) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseKeyPageIndex) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.Authority = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.Signer = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Index = x
	}

	seen, err := reader.Reset(fieldNames_ResponseKeyPageIndex)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseMajorBlocks) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseMajorBlocks) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.TotalBlocks = x
	}
	for {
		if x := new(ResponseMajorEntry); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseMajorBlocks)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseMajorEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseMajorEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.MajorBlockIndex = x
	}
	if x, ok := reader.ReadTime(2); ok {
		v.MajorBlockTime = &x
	}
	for {
		if x := new(ResponseMinorEntry); reader.ReadValue(3, x.UnmarshalBinary) {
			v.MinorBlocks = append(v.MinorBlocks, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseMajorEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseMinorBlocks) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseMinorBlocks) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.TotalBlocks = x
	}
	for {
		if x := new(ResponseMinorEntry); reader.ReadValue(2, x.UnmarshalBinary) {
			v.Entries = append(v.Entries, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseMinorBlocks)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseMinorEntry) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseMinorEntry) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.BlockIndex = x
	}
	if x, ok := reader.ReadTime(2); ok {
		v.BlockTime = &x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.TxCount = x
	}
	for {
		if x, ok := reader.ReadBytes(4); ok {
			v.TxIds = append(v.TxIds, x)
		} else {
			break
		}
	}
	for {
		if x := new(ResponseByTxId); reader.ReadValue(5, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseMinorEntry)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponsePending) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponsePending) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x, ok := reader.ReadTxid(1); ok {
			v.Transactions = append(v.Transactions, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponsePending)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ResponseTxHistory) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ResponseTxHistory) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUint(1); ok {
		v.Start = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.End = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.Total = x
	}
	for {
		if x := new(ResponseByTxId); reader.ReadValue(4, x.UnmarshalBinary) {
			v.Transactions = append(v.Transactions, *x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_ResponseTxHistory)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SignatureSet) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SignatureSet) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(b []byte) error {
		x, err := protocol.UnmarshalAccount(b)
		if err == nil {
			v.Account = x
		}
		return err
	})
	for {
		ok := reader.ReadValue(2, func(b []byte) error {
			x, err := protocol.UnmarshalSignature(b)
			if err == nil {
				v.Signatures = append(v.Signatures, x)
			}
			return err
		})
		if !ok {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_SignatureSet)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *TxReceipt) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *TxReceipt) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.GeneralReceipt.UnmarshalBinary)
	if x, ok := reader.ReadUrl(2); ok {
		v.Account = x
	}
	if x, ok := reader.ReadString(3); ok {
		v.Chain = x
	}

	seen, err := reader.Reset(fieldNames_TxReceipt)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *UnknownRequest) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *UnknownRequest) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType QueryType
	if x := new(QueryType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	seen, err := reader.Reset(fieldNames_UnknownRequest)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ChainState) MarshalJSON() ([]byte, error) {
	u := struct {
		Name   string                     `json:"name,omitempty"`
		Type   protocol.ChainType         `json:"type,omitempty"`
		Height uint64                     `json:"height,omitempty"`
		Count  uint64                     `json:"count,omitempty"`
		Roots  encoding.JsonList[*string] `json:"roots,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make(encoding.JsonList[*string], len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *DirectoryQueryResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Entries         encoding.JsonList[string]                        `json:"entries,omitempty"`
		ExpandedEntries encoding.JsonUnmarshalListWith[protocol.Account] `json:"expandedEntries,omitempty"`
		Total           uint64                                           `json:"total"`
	}{}
	u.Entries = v.Entries
	u.ExpandedEntries = encoding.JsonUnmarshalListWith[protocol.Account]{Value: v.ExpandedEntries, Func: protocol.UnmarshalAccountJSON}
	u.Total = v.Total
	return json.Marshal(&u)
}

func (v *GeneralReceipt) MarshalJSON() ([]byte, error) {
	u := struct {
		LocalBlock     uint64          `json:"localBlock,omitempty"`
		DirectoryBlock uint64          `json:"directoryBlock,omitempty"`
		MajorBlock     uint64          `json:"majorBlock,omitempty"`
		Proof          managed.Receipt `json:"proof,omitempty"`
		Receipt        managed.Receipt `json:"receipt,omitempty"`
		Error          string          `json:"error,omitempty"`
	}{}
	u.LocalBlock = v.LocalBlock
	u.DirectoryBlock = v.DirectoryBlock
	u.MajorBlock = v.MajorBlock
	u.Proof = v.Proof
	u.Receipt = v.Proof
	u.Error = v.Error
	return json.Marshal(&u)
}

func (v *MultiResponse) MarshalJSON() ([]byte, error) {
	u := struct {
		Type  string                    `json:"type,omitempty"`
		Items encoding.JsonList[string] `json:"items,omitempty"`
		Start uint64                    `json:"start"`
		Count uint64                    `json:"count"`
		Total uint64                    `json:"total"`
	}{}
	u.Type = v.Type
	u.Items = v.Items
	u.Start = v.Start
	u.Count = v.Count
	u.Total = v.Total
	return json.Marshal(&u)
}

func (v *RequestByChainId) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    QueryType `json:"type"`
		ChainId string    `json:"chainId,omitempty"`
	}{}
	u.Type = v.Type()
	u.ChainId = encoding.ChainToJSON(v.ChainId)
	return json.Marshal(&u)
}

func (v *RequestByTxId) MarshalJSON() ([]byte, error) {
	u := struct {
		Type QueryType `json:"type"`
		TxId string    `json:"txId,omitempty"`
	}{}
	u.Type = v.Type()
	u.TxId = encoding.ChainToJSON(v.TxId)
	return json.Marshal(&u)
}

func (v *RequestByUrl) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    QueryType `json:"type"`
		Url     *url.URL  `json:"url,omitempty"`
		Scratch bool      `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Scratch = v.Scratch
	return json.Marshal(&u)
}

func (v *RequestDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      QueryType `json:"type"`
		Url       *url.URL  `json:"url,omitempty"`
		EntryHash string    `json:"entryHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}

func (v *RequestDataEntrySet) MarshalJSON() ([]byte, error) {
	u := struct {
		Type         QueryType `json:"type"`
		Url          *url.URL  `json:"url,omitempty"`
		Start        uint64    `json:"start,omitempty"`
		Count        uint64    `json:"count,omitempty"`
		ExpandChains bool      `json:"expandChains,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Start = v.Start
	u.Count = v.Count
	u.ExpandChains = v.ExpandChains
	return json.Marshal(&u)
}

func (v *RequestDirectory) MarshalJSON() ([]byte, error) {
	u := struct {
		Type         QueryType `json:"type"`
		Url          *url.URL  `json:"url,omitempty"`
		Start        uint64    `json:"start,omitempty"`
		Limit        uint64    `json:"limit,omitempty"`
		ExpandChains bool      `json:"expandChains,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Start = v.Start
	u.Limit = v.Limit
	u.ExpandChains = v.ExpandChains
	return json.Marshal(&u)
}

func (v *RequestKeyPageIndex) MarshalJSON() ([]byte, error) {
	u := struct {
		Type QueryType `json:"type"`
		Url  *url.URL  `json:"url,omitempty"`
		Key  *string   `json:"key,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Key = encoding.BytesToJSON(v.Key)
	return json.Marshal(&u)
}

func (v *RequestMajorBlocks) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    QueryType `json:"type"`
		Account *url.URL  `json:"account,omitempty"`
		Start   uint64    `json:"start,omitempty"`
		Limit   uint64    `json:"limit,omitempty"`
	}{}
	u.Type = v.Type()
	u.Account = v.Account
	u.Start = v.Start
	u.Limit = v.Limit
	return json.Marshal(&u)
}

func (v *RequestMinorBlocks) MarshalJSON() ([]byte, error) {
	u := struct {
		Type            QueryType       `json:"type"`
		Account         *url.URL        `json:"account,omitempty"`
		Start           uint64          `json:"start,omitempty"`
		Limit           uint64          `json:"limit,omitempty"`
		TxFetchMode     TxFetchMode     `json:"txFetchMode,omitempty"`
		BlockFilterMode BlockFilterMode `json:"blockFilterMode,omitempty"`
	}{}
	u.Type = v.Type()
	u.Account = v.Account
	u.Start = v.Start
	u.Limit = v.Limit
	u.TxFetchMode = v.TxFetchMode
	u.BlockFilterMode = v.BlockFilterMode
	return json.Marshal(&u)
}

func (v *RequestSynth) MarshalJSON() ([]byte, error) {
	u := struct {
		Type           QueryType `json:"type"`
		Source         *url.URL  `json:"source,omitempty"`
		Destination    *url.URL  `json:"destination,omitempty"`
		SequenceNumber uint64    `json:"sequenceNumber,omitempty"`
		Anchor         bool      `json:"anchor,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.Source
	u.Destination = v.Destination
	u.SequenceNumber = v.SequenceNumber
	u.Anchor = v.Anchor
	return json.Marshal(&u)
}

func (v *RequestTxHistory) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    QueryType `json:"type"`
		Account *url.URL  `json:"account,omitempty"`
		Start   uint64    `json:"start,omitempty"`
		Limit   uint64    `json:"limit,omitempty"`
		Scratch bool      `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.Account = v.Account
	u.Start = v.Start
	u.Limit = v.Limit
	u.Scratch = v.Scratch
	return json.Marshal(&u)
}

func (v *ResponseAccount) MarshalJSON() ([]byte, error) {
	u := struct {
		Account    encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		ChainState encoding.JsonList[ChainState]                `json:"chainState,omitempty"`
		Receipt    *GeneralReceipt                              `json:"receipt,omitempty"`
	}{}
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.ChainState = v.ChainState
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *ResponseByTxId) MarshalJSON() ([]byte, error) {
	u := struct {
		TxId       *url.TxID                       `json:"txId,omitempty"`
		Envelope   *protocol.Envelope              `json:"envelope,omitempty"`
		Status     *protocol.TransactionStatus     `json:"status,omitempty"`
		Produced   encoding.JsonList[*url.TxID]    `json:"produced,omitempty"`
		Height     uint64                          `json:"height"`
		ChainState encoding.JsonList[*string]      `json:"chainState,omitempty"`
		Receipts   encoding.JsonList[*TxReceipt]   `json:"receipts,omitempty"`
		Signers    encoding.JsonList[SignatureSet] `json:"signers,omitempty"`
	}{}
	u.TxId = v.TxId
	u.Envelope = v.Envelope
	u.Status = v.Status
	u.Produced = v.Produced
	u.Height = v.Height
	u.ChainState = make(encoding.JsonList[*string], len(v.ChainState))
	for i, x := range v.ChainState {
		u.ChainState[i] = encoding.BytesToJSON(x)
	}
	u.Receipts = v.Receipts
	u.Signers = v.Signers
	return json.Marshal(&u)
}

func (v *ResponseChainEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    protocol.ChainType         `json:"type,omitempty"`
		Height  uint64                     `json:"height"`
		Entry   *string                    `json:"entry,omitempty"`
		State   encoding.JsonList[*string] `json:"state,omitempty"`
		Receipt *GeneralReceipt            `json:"receipt,omitempty"`
	}{}
	u.Type = v.Type
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *ResponseChainRange) MarshalJSON() ([]byte, error) {
	u := struct {
		Type    protocol.ChainType         `json:"type,omitempty"`
		Start   int64                      `json:"start"`
		End     int64                      `json:"end"`
		Total   int64                      `json:"total"`
		Entries encoding.JsonList[*string] `json:"entries,omitempty"`
	}{}
	u.Type = v.Type
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make(encoding.JsonList[*string], len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	return json.Marshal(&u)
}

func (v *ResponseDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		EntryHash string                                         `json:"entryHash,omitempty"`
		Entry     encoding.JsonUnmarshalWith[protocol.DataEntry] `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = encoding.JsonUnmarshalWith[protocol.DataEntry]{Value: v.Entry, Func: protocol.UnmarshalDataEntryJSON}
	return json.Marshal(&u)
}

func (v *ResponseDataEntrySet) MarshalJSON() ([]byte, error) {
	u := struct {
		DataEntries encoding.JsonList[ResponseDataEntry] `json:"dataEntries,omitempty"`
		Total       uint64                               `json:"total,omitempty"`
	}{}
	u.DataEntries = v.DataEntries
	u.Total = v.Total
	return json.Marshal(&u)
}

func (v *ResponseKeyPageIndex) MarshalJSON() ([]byte, error) {
	u := struct {
		Authority *url.URL `json:"authority,omitempty"`
		KeyBook   *url.URL `json:"keyBook,omitempty"`
		Signer    *url.URL `json:"signer,omitempty"`
		KeyPage   *url.URL `json:"keyPage,omitempty"`
		Index     uint64   `json:"index"`
	}{}
	u.Authority = v.Authority
	u.KeyBook = v.Authority
	u.Signer = v.Signer
	u.KeyPage = v.Signer
	u.Index = v.Index
	return json.Marshal(&u)
}

func (v *ResponseMajorBlocks) MarshalJSON() ([]byte, error) {
	u := struct {
		TotalBlocks uint64                                 `json:"totalBlocks"`
		Entries     encoding.JsonList[*ResponseMajorEntry] `json:"entries,omitempty"`
	}{}
	u.TotalBlocks = v.TotalBlocks
	u.Entries = v.Entries
	return json.Marshal(&u)
}

func (v *ResponseMajorEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		MajorBlockIndex uint64                                 `json:"majorBlockIndex,omitempty"`
		MajorBlockTime  *time.Time                             `json:"majorBlockTime,omitempty"`
		MinorBlocks     encoding.JsonList[*ResponseMinorEntry] `json:"minorBlocks,omitempty"`
	}{}
	u.MajorBlockIndex = v.MajorBlockIndex
	u.MajorBlockTime = v.MajorBlockTime
	u.MinorBlocks = v.MinorBlocks
	return json.Marshal(&u)
}

func (v *ResponseMinorBlocks) MarshalJSON() ([]byte, error) {
	u := struct {
		TotalBlocks uint64                                 `json:"totalBlocks"`
		Entries     encoding.JsonList[*ResponseMinorEntry] `json:"entries,omitempty"`
	}{}
	u.TotalBlocks = v.TotalBlocks
	u.Entries = v.Entries
	return json.Marshal(&u)
}

func (v *ResponseMinorEntry) MarshalJSON() ([]byte, error) {
	u := struct {
		BlockIndex   uint64                             `json:"blockIndex,omitempty"`
		BlockTime    *time.Time                         `json:"blockTime,omitempty"`
		TxCount      uint64                             `json:"txCount,omitempty"`
		TxIds        encoding.JsonList[*string]         `json:"txIds,omitempty"`
		Transactions encoding.JsonList[*ResponseByTxId] `json:"transactions,omitempty"`
	}{}
	u.BlockIndex = v.BlockIndex
	u.BlockTime = v.BlockTime
	u.TxCount = v.TxCount
	u.TxIds = make(encoding.JsonList[*string], len(v.TxIds))
	for i, x := range v.TxIds {
		u.TxIds[i] = encoding.BytesToJSON(x)
	}
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *ResponsePending) MarshalJSON() ([]byte, error) {
	u := struct {
		Transactions encoding.JsonList[*url.TxID] `json:"transactions,omitempty"`
	}{}
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *ResponseTxHistory) MarshalJSON() ([]byte, error) {
	u := struct {
		Start        uint64                            `json:"start"`
		End          uint64                            `json:"end"`
		Total        uint64                            `json:"total"`
		Transactions encoding.JsonList[ResponseByTxId] `json:"transactions,omitempty"`
	}{}
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Transactions = v.Transactions
	return json.Marshal(&u)
}

func (v *SignatureSet) MarshalJSON() ([]byte, error) {
	u := struct {
		Account    encoding.JsonUnmarshalWith[protocol.Account]       `json:"account,omitempty"`
		Signatures encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
	}{}
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Signatures = encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	return json.Marshal(&u)
}

func (v *TxReceipt) MarshalJSON() ([]byte, error) {
	u := struct {
		LocalBlock     uint64          `json:"localBlock,omitempty"`
		DirectoryBlock uint64          `json:"directoryBlock,omitempty"`
		MajorBlock     uint64          `json:"majorBlock,omitempty"`
		Proof          managed.Receipt `json:"proof,omitempty"`
		Receipt        managed.Receipt `json:"receipt,omitempty"`
		Error          string          `json:"error,omitempty"`
		Account        *url.URL        `json:"account,omitempty"`
		Chain          string          `json:"chain,omitempty"`
	}{}
	u.LocalBlock = v.GeneralReceipt.LocalBlock
	u.DirectoryBlock = v.GeneralReceipt.DirectoryBlock
	u.MajorBlock = v.GeneralReceipt.MajorBlock
	u.Proof = v.GeneralReceipt.Proof
	u.Receipt = v.GeneralReceipt.Proof
	u.Error = v.GeneralReceipt.Error
	u.Account = v.Account
	u.Chain = v.Chain
	return json.Marshal(&u)
}

func (v *UnknownRequest) MarshalJSON() ([]byte, error) {
	u := struct {
		Type QueryType `json:"type"`
	}{}
	u.Type = v.Type()
	return json.Marshal(&u)
}

func (v *ChainState) UnmarshalJSON(data []byte) error {
	u := struct {
		Name   string                     `json:"name,omitempty"`
		Type   protocol.ChainType         `json:"type,omitempty"`
		Height uint64                     `json:"height,omitempty"`
		Count  uint64                     `json:"count,omitempty"`
		Roots  encoding.JsonList[*string] `json:"roots,omitempty"`
	}{}
	u.Name = v.Name
	u.Type = v.Type
	u.Height = v.Height
	u.Count = v.Height
	u.Roots = make(encoding.JsonList[*string], len(v.Roots))
	for i, x := range v.Roots {
		u.Roots[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Name = u.Name
	v.Type = u.Type
	if !(u.Height == 0) {
		v.Height = u.Height
	} else {
		v.Height = u.Count
	}
	v.Roots = make([][]byte, len(u.Roots))
	for i, x := range u.Roots {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Roots: %w", err)
		} else {
			v.Roots[i] = x
		}
	}
	return nil
}

func (v *DirectoryQueryResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Entries         encoding.JsonList[string]                        `json:"entries,omitempty"`
		ExpandedEntries encoding.JsonUnmarshalListWith[protocol.Account] `json:"expandedEntries,omitempty"`
		Total           uint64                                           `json:"total"`
	}{}
	u.Entries = v.Entries
	u.ExpandedEntries = encoding.JsonUnmarshalListWith[protocol.Account]{Value: v.ExpandedEntries, Func: protocol.UnmarshalAccountJSON}
	u.Total = v.Total
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Entries = u.Entries
	v.ExpandedEntries = make([]protocol.Account, len(u.ExpandedEntries.Value))
	for i, x := range u.ExpandedEntries.Value {
		v.ExpandedEntries[i] = x
	}
	v.Total = u.Total
	return nil
}

func (v *GeneralReceipt) UnmarshalJSON(data []byte) error {
	u := struct {
		LocalBlock     uint64          `json:"localBlock,omitempty"`
		DirectoryBlock uint64          `json:"directoryBlock,omitempty"`
		MajorBlock     uint64          `json:"majorBlock,omitempty"`
		Proof          managed.Receipt `json:"proof,omitempty"`
		Receipt        managed.Receipt `json:"receipt,omitempty"`
		Error          string          `json:"error,omitempty"`
	}{}
	u.LocalBlock = v.LocalBlock
	u.DirectoryBlock = v.DirectoryBlock
	u.MajorBlock = v.MajorBlock
	u.Proof = v.Proof
	u.Receipt = v.Proof
	u.Error = v.Error
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.LocalBlock = u.LocalBlock
	v.DirectoryBlock = u.DirectoryBlock
	v.MajorBlock = u.MajorBlock
	if !(u.Proof.Equal(&managed.Receipt{})) {
		v.Proof = u.Proof
	} else {
		v.Proof = u.Receipt
	}
	v.Error = u.Error
	return nil
}

func (v *MultiResponse) UnmarshalJSON(data []byte) error {
	u := struct {
		Type  string                    `json:"type,omitempty"`
		Items encoding.JsonList[string] `json:"items,omitempty"`
		Start uint64                    `json:"start"`
		Count uint64                    `json:"count"`
		Total uint64                    `json:"total"`
	}{}
	u.Type = v.Type
	u.Items = v.Items
	u.Start = v.Start
	u.Count = v.Count
	u.Total = v.Total
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.Items = u.Items
	v.Start = u.Start
	v.Count = u.Count
	v.Total = u.Total
	return nil
}

func (v *RequestByChainId) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    QueryType `json:"type"`
		ChainId string    `json:"chainId,omitempty"`
	}{}
	u.Type = v.Type()
	u.ChainId = encoding.ChainToJSON(v.ChainId)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.ChainId); err != nil {
		return fmt.Errorf("error decoding ChainId: %w", err)
	} else {
		v.ChainId = x
	}
	return nil
}

func (v *RequestByTxId) UnmarshalJSON(data []byte) error {
	u := struct {
		Type QueryType `json:"type"`
		TxId string    `json:"txId,omitempty"`
	}{}
	u.Type = v.Type()
	u.TxId = encoding.ChainToJSON(v.TxId)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.TxId); err != nil {
		return fmt.Errorf("error decoding TxId: %w", err)
	} else {
		v.TxId = x
	}
	return nil
}

func (v *RequestByUrl) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    QueryType `json:"type"`
		Url     *url.URL  `json:"url,omitempty"`
		Scratch bool      `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Scratch = v.Scratch
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Scratch = u.Scratch
	return nil
}

func (v *RequestDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      QueryType `json:"type"`
		Url       *url.URL  `json:"url,omitempty"`
		EntryHash string    `json:"entryHash,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}

func (v *RequestDataEntrySet) UnmarshalJSON(data []byte) error {
	u := struct {
		Type         QueryType `json:"type"`
		Url          *url.URL  `json:"url,omitempty"`
		Start        uint64    `json:"start,omitempty"`
		Count        uint64    `json:"count,omitempty"`
		ExpandChains bool      `json:"expandChains,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Start = v.Start
	u.Count = v.Count
	u.ExpandChains = v.ExpandChains
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Start = u.Start
	v.Count = u.Count
	v.ExpandChains = u.ExpandChains
	return nil
}

func (v *RequestDirectory) UnmarshalJSON(data []byte) error {
	u := struct {
		Type         QueryType `json:"type"`
		Url          *url.URL  `json:"url,omitempty"`
		Start        uint64    `json:"start,omitempty"`
		Limit        uint64    `json:"limit,omitempty"`
		ExpandChains bool      `json:"expandChains,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Start = v.Start
	u.Limit = v.Limit
	u.ExpandChains = v.ExpandChains
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	v.Start = u.Start
	v.Limit = u.Limit
	v.ExpandChains = u.ExpandChains
	return nil
}

func (v *RequestKeyPageIndex) UnmarshalJSON(data []byte) error {
	u := struct {
		Type QueryType `json:"type"`
		Url  *url.URL  `json:"url,omitempty"`
		Key  *string   `json:"key,omitempty"`
	}{}
	u.Type = v.Type()
	u.Url = v.Url
	u.Key = encoding.BytesToJSON(v.Key)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Url = u.Url
	if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
	return nil
}

func (v *RequestMajorBlocks) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    QueryType `json:"type"`
		Account *url.URL  `json:"account,omitempty"`
		Start   uint64    `json:"start,omitempty"`
		Limit   uint64    `json:"limit,omitempty"`
	}{}
	u.Type = v.Type()
	u.Account = v.Account
	u.Start = v.Start
	u.Limit = v.Limit
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Account = u.Account
	v.Start = u.Start
	v.Limit = u.Limit
	return nil
}

func (v *RequestMinorBlocks) UnmarshalJSON(data []byte) error {
	u := struct {
		Type            QueryType       `json:"type"`
		Account         *url.URL        `json:"account,omitempty"`
		Start           uint64          `json:"start,omitempty"`
		Limit           uint64          `json:"limit,omitempty"`
		TxFetchMode     TxFetchMode     `json:"txFetchMode,omitempty"`
		BlockFilterMode BlockFilterMode `json:"blockFilterMode,omitempty"`
	}{}
	u.Type = v.Type()
	u.Account = v.Account
	u.Start = v.Start
	u.Limit = v.Limit
	u.TxFetchMode = v.TxFetchMode
	u.BlockFilterMode = v.BlockFilterMode
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Account = u.Account
	v.Start = u.Start
	v.Limit = u.Limit
	v.TxFetchMode = u.TxFetchMode
	v.BlockFilterMode = u.BlockFilterMode
	return nil
}

func (v *RequestSynth) UnmarshalJSON(data []byte) error {
	u := struct {
		Type           QueryType `json:"type"`
		Source         *url.URL  `json:"source,omitempty"`
		Destination    *url.URL  `json:"destination,omitempty"`
		SequenceNumber uint64    `json:"sequenceNumber,omitempty"`
		Anchor         bool      `json:"anchor,omitempty"`
	}{}
	u.Type = v.Type()
	u.Source = v.Source
	u.Destination = v.Destination
	u.SequenceNumber = v.SequenceNumber
	u.Anchor = v.Anchor
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Source = u.Source
	v.Destination = u.Destination
	v.SequenceNumber = u.SequenceNumber
	v.Anchor = u.Anchor
	return nil
}

func (v *RequestTxHistory) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    QueryType `json:"type"`
		Account *url.URL  `json:"account,omitempty"`
		Start   uint64    `json:"start,omitempty"`
		Limit   uint64    `json:"limit,omitempty"`
		Scratch bool      `json:"scratch,omitempty"`
	}{}
	u.Type = v.Type()
	u.Account = v.Account
	u.Start = v.Start
	u.Limit = v.Limit
	u.Scratch = v.Scratch
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Account = u.Account
	v.Start = u.Start
	v.Limit = u.Limit
	v.Scratch = u.Scratch
	return nil
}

func (v *ResponseAccount) UnmarshalJSON(data []byte) error {
	u := struct {
		Account    encoding.JsonUnmarshalWith[protocol.Account] `json:"account,omitempty"`
		ChainState encoding.JsonList[ChainState]                `json:"chainState,omitempty"`
		Receipt    *GeneralReceipt                              `json:"receipt,omitempty"`
	}{}
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.ChainState = v.ChainState
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account.Value

	v.ChainState = u.ChainState
	v.Receipt = u.Receipt
	return nil
}

func (v *ResponseByTxId) UnmarshalJSON(data []byte) error {
	u := struct {
		TxId       *url.TxID                       `json:"txId,omitempty"`
		Envelope   *protocol.Envelope              `json:"envelope,omitempty"`
		Status     *protocol.TransactionStatus     `json:"status,omitempty"`
		Produced   encoding.JsonList[*url.TxID]    `json:"produced,omitempty"`
		Height     uint64                          `json:"height"`
		ChainState encoding.JsonList[*string]      `json:"chainState,omitempty"`
		Receipts   encoding.JsonList[*TxReceipt]   `json:"receipts,omitempty"`
		Signers    encoding.JsonList[SignatureSet] `json:"signers,omitempty"`
	}{}
	u.TxId = v.TxId
	u.Envelope = v.Envelope
	u.Status = v.Status
	u.Produced = v.Produced
	u.Height = v.Height
	u.ChainState = make(encoding.JsonList[*string], len(v.ChainState))
	for i, x := range v.ChainState {
		u.ChainState[i] = encoding.BytesToJSON(x)
	}
	u.Receipts = v.Receipts
	u.Signers = v.Signers
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.TxId = u.TxId
	v.Envelope = u.Envelope
	v.Status = u.Status
	v.Produced = u.Produced
	v.Height = u.Height
	v.ChainState = make([][]byte, len(u.ChainState))
	for i, x := range u.ChainState {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding ChainState: %w", err)
		} else {
			v.ChainState[i] = x
		}
	}
	v.Receipts = u.Receipts
	v.Signers = u.Signers
	return nil
}

func (v *ResponseChainEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    protocol.ChainType         `json:"type,omitempty"`
		Height  uint64                     `json:"height"`
		Entry   *string                    `json:"entry,omitempty"`
		State   encoding.JsonList[*string] `json:"state,omitempty"`
		Receipt *GeneralReceipt            `json:"receipt,omitempty"`
	}{}
	u.Type = v.Type
	u.Height = v.Height
	u.Entry = encoding.BytesToJSON(v.Entry)
	u.State = make(encoding.JsonList[*string], len(v.State))
	for i, x := range v.State {
		u.State[i] = encoding.BytesToJSON(x)
	}
	u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.Height = u.Height
	if x, err := encoding.BytesFromJSON(u.Entry); err != nil {
		return fmt.Errorf("error decoding Entry: %w", err)
	} else {
		v.Entry = x
	}
	v.State = make([][]byte, len(u.State))
	for i, x := range u.State {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding State: %w", err)
		} else {
			v.State[i] = x
		}
	}
	v.Receipt = u.Receipt
	return nil
}

func (v *ResponseChainRange) UnmarshalJSON(data []byte) error {
	u := struct {
		Type    protocol.ChainType         `json:"type,omitempty"`
		Start   int64                      `json:"start"`
		End     int64                      `json:"end"`
		Total   int64                      `json:"total"`
		Entries encoding.JsonList[*string] `json:"entries,omitempty"`
	}{}
	u.Type = v.Type
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Entries = make(encoding.JsonList[*string], len(v.Entries))
	for i, x := range v.Entries {
		u.Entries[i] = encoding.BytesToJSON(x)
	}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Type = u.Type
	v.Start = u.Start
	v.End = u.End
	v.Total = u.Total
	v.Entries = make([][]byte, len(u.Entries))
	for i, x := range u.Entries {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding Entries: %w", err)
		} else {
			v.Entries[i] = x
		}
	}
	return nil
}

func (v *ResponseDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		EntryHash string                                         `json:"entryHash,omitempty"`
		Entry     encoding.JsonUnmarshalWith[protocol.DataEntry] `json:"entry,omitempty"`
	}{}
	u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	u.Entry = encoding.JsonUnmarshalWith[protocol.DataEntry]{Value: v.Entry, Func: protocol.UnmarshalDataEntryJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	v.Entry = u.Entry.Value

	return nil
}

func (v *ResponseDataEntrySet) UnmarshalJSON(data []byte) error {
	u := struct {
		DataEntries encoding.JsonList[ResponseDataEntry] `json:"dataEntries,omitempty"`
		Total       uint64                               `json:"total,omitempty"`
	}{}
	u.DataEntries = v.DataEntries
	u.Total = v.Total
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.DataEntries = u.DataEntries
	v.Total = u.Total
	return nil
}

func (v *ResponseKeyPageIndex) UnmarshalJSON(data []byte) error {
	u := struct {
		Authority *url.URL `json:"authority,omitempty"`
		KeyBook   *url.URL `json:"keyBook,omitempty"`
		Signer    *url.URL `json:"signer,omitempty"`
		KeyPage   *url.URL `json:"keyPage,omitempty"`
		Index     uint64   `json:"index"`
	}{}
	u.Authority = v.Authority
	u.KeyBook = v.Authority
	u.Signer = v.Signer
	u.KeyPage = v.Signer
	u.Index = v.Index
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(u.Authority == nil) {
		v.Authority = u.Authority
	} else {
		v.Authority = u.KeyBook
	}
	if !(u.Signer == nil) {
		v.Signer = u.Signer
	} else {
		v.Signer = u.KeyPage
	}
	v.Index = u.Index
	return nil
}

func (v *ResponseMajorBlocks) UnmarshalJSON(data []byte) error {
	u := struct {
		TotalBlocks uint64                                 `json:"totalBlocks"`
		Entries     encoding.JsonList[*ResponseMajorEntry] `json:"entries,omitempty"`
	}{}
	u.TotalBlocks = v.TotalBlocks
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.TotalBlocks = u.TotalBlocks
	v.Entries = u.Entries
	return nil
}

func (v *ResponseMajorEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		MajorBlockIndex uint64                                 `json:"majorBlockIndex,omitempty"`
		MajorBlockTime  *time.Time                             `json:"majorBlockTime,omitempty"`
		MinorBlocks     encoding.JsonList[*ResponseMinorEntry] `json:"minorBlocks,omitempty"`
	}{}
	u.MajorBlockIndex = v.MajorBlockIndex
	u.MajorBlockTime = v.MajorBlockTime
	u.MinorBlocks = v.MinorBlocks
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.MajorBlockIndex = u.MajorBlockIndex
	v.MajorBlockTime = u.MajorBlockTime
	v.MinorBlocks = u.MinorBlocks
	return nil
}

func (v *ResponseMinorBlocks) UnmarshalJSON(data []byte) error {
	u := struct {
		TotalBlocks uint64                                 `json:"totalBlocks"`
		Entries     encoding.JsonList[*ResponseMinorEntry] `json:"entries,omitempty"`
	}{}
	u.TotalBlocks = v.TotalBlocks
	u.Entries = v.Entries
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.TotalBlocks = u.TotalBlocks
	v.Entries = u.Entries
	return nil
}

func (v *ResponseMinorEntry) UnmarshalJSON(data []byte) error {
	u := struct {
		BlockIndex   uint64                             `json:"blockIndex,omitempty"`
		BlockTime    *time.Time                         `json:"blockTime,omitempty"`
		TxCount      uint64                             `json:"txCount,omitempty"`
		TxIds        encoding.JsonList[*string]         `json:"txIds,omitempty"`
		Transactions encoding.JsonList[*ResponseByTxId] `json:"transactions,omitempty"`
	}{}
	u.BlockIndex = v.BlockIndex
	u.BlockTime = v.BlockTime
	u.TxCount = v.TxCount
	u.TxIds = make(encoding.JsonList[*string], len(v.TxIds))
	for i, x := range v.TxIds {
		u.TxIds[i] = encoding.BytesToJSON(x)
	}
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.BlockIndex = u.BlockIndex
	v.BlockTime = u.BlockTime
	v.TxCount = u.TxCount
	v.TxIds = make([][]byte, len(u.TxIds))
	for i, x := range u.TxIds {
		if x, err := encoding.BytesFromJSON(x); err != nil {
			return fmt.Errorf("error decoding TxIds: %w", err)
		} else {
			v.TxIds[i] = x
		}
	}
	v.Transactions = u.Transactions
	return nil
}

func (v *ResponsePending) UnmarshalJSON(data []byte) error {
	u := struct {
		Transactions encoding.JsonList[*url.TxID] `json:"transactions,omitempty"`
	}{}
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Transactions = u.Transactions
	return nil
}

func (v *ResponseTxHistory) UnmarshalJSON(data []byte) error {
	u := struct {
		Start        uint64                            `json:"start"`
		End          uint64                            `json:"end"`
		Total        uint64                            `json:"total"`
		Transactions encoding.JsonList[ResponseByTxId] `json:"transactions,omitempty"`
	}{}
	u.Start = v.Start
	u.End = v.End
	u.Total = v.Total
	u.Transactions = v.Transactions
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Start = u.Start
	v.End = u.End
	v.Total = u.Total
	v.Transactions = u.Transactions
	return nil
}

func (v *SignatureSet) UnmarshalJSON(data []byte) error {
	u := struct {
		Account    encoding.JsonUnmarshalWith[protocol.Account]       `json:"account,omitempty"`
		Signatures encoding.JsonUnmarshalListWith[protocol.Signature] `json:"signatures,omitempty"`
	}{}
	u.Account = encoding.JsonUnmarshalWith[protocol.Account]{Value: v.Account, Func: protocol.UnmarshalAccountJSON}
	u.Signatures = encoding.JsonUnmarshalListWith[protocol.Signature]{Value: v.Signatures, Func: protocol.UnmarshalSignatureJSON}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.Account = u.Account.Value

	v.Signatures = make([]protocol.Signature, len(u.Signatures.Value))
	for i, x := range u.Signatures.Value {
		v.Signatures[i] = x
	}
	return nil
}

func (v *TxReceipt) UnmarshalJSON(data []byte) error {
	u := struct {
		LocalBlock     uint64          `json:"localBlock,omitempty"`
		DirectoryBlock uint64          `json:"directoryBlock,omitempty"`
		MajorBlock     uint64          `json:"majorBlock,omitempty"`
		Proof          managed.Receipt `json:"proof,omitempty"`
		Receipt        managed.Receipt `json:"receipt,omitempty"`
		Error          string          `json:"error,omitempty"`
		Account        *url.URL        `json:"account,omitempty"`
		Chain          string          `json:"chain,omitempty"`
	}{}
	u.LocalBlock = v.GeneralReceipt.LocalBlock
	u.DirectoryBlock = v.GeneralReceipt.DirectoryBlock
	u.MajorBlock = v.GeneralReceipt.MajorBlock
	u.Proof = v.GeneralReceipt.Proof
	u.Receipt = v.GeneralReceipt.Proof
	u.Error = v.GeneralReceipt.Error
	u.Account = v.Account
	u.Chain = v.Chain
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.GeneralReceipt.LocalBlock = u.LocalBlock
	v.GeneralReceipt.DirectoryBlock = u.DirectoryBlock
	v.GeneralReceipt.MajorBlock = u.MajorBlock
	if !(u.Proof.Equal(&managed.Receipt{})) {
		v.GeneralReceipt.Proof = u.Proof
	} else {
		v.GeneralReceipt.Proof = u.Receipt
	}
	v.GeneralReceipt.Error = u.Error
	v.Account = u.Account
	v.Chain = u.Chain
	return nil
}

func (v *UnknownRequest) UnmarshalJSON(data []byte) error {
	u := struct {
		Type QueryType `json:"type"`
	}{}
	u.Type = v.Type()
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	return nil
}
