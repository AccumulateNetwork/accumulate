// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package api

// GENERATED BY go run ./tools/cmd/gen-api. DO NOT EDIT.

import (
	"context"
	"encoding/json"

	"github.com/AccumulateNetwork/jsonrpc2/v15"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

func (m *JrpcMethods) populateMethodTable() jsonrpc2.MethodMap {
	if m.methods == nil {
		m.methods = make(jsonrpc2.MethodMap, 35)
	}

	m.methods["describe"] = m.Describe
	m.methods["execute"] = m.Execute
	m.methods["add-credits"] = m.ExecuteAddCredits
	m.methods["burn-tokens"] = m.ExecuteBurnTokens
	m.methods["create-adi"] = m.ExecuteCreateAdi
	m.methods["create-data-account"] = m.ExecuteCreateDataAccount
	m.methods["create-identity"] = m.ExecuteCreateIdentity
	m.methods["create-key-book"] = m.ExecuteCreateKeyBook
	m.methods["create-key-page"] = m.ExecuteCreateKeyPage
	m.methods["create-token"] = m.ExecuteCreateToken
	m.methods["create-token-account"] = m.ExecuteCreateTokenAccount
	m.methods["execute-direct"] = m.ExecuteDirect
	m.methods["issue-tokens"] = m.ExecuteIssueTokens
	m.methods["execute-local"] = m.ExecuteLocal
	m.methods["send-tokens"] = m.ExecuteSendTokens
	m.methods["update-account-auth"] = m.ExecuteUpdateAccountAuth
	m.methods["update-key"] = m.ExecuteUpdateKey
	m.methods["update-key-page"] = m.ExecuteUpdateKeyPage
	m.methods["write-data"] = m.ExecuteWriteData
	m.methods["write-data-to"] = m.ExecuteWriteDataTo
	m.methods["faucet"] = m.Faucet
	m.methods["metrics"] = m.Metrics
	m.methods["query"] = m.Query
	m.methods["query-data"] = m.QueryData
	m.methods["query-data-set"] = m.QueryDataSet
	m.methods["query-directory"] = m.QueryDirectory
	m.methods["query-key-index"] = m.QueryKeyPageIndex
	m.methods["query-major-blocks"] = m.QueryMajorBlocks
	m.methods["query-minor-blocks"] = m.QueryMinorBlocks
	m.methods["query-synth"] = m.QuerySynth
	m.methods["query-tx"] = m.QueryTx
	m.methods["query-tx-history"] = m.QueryTxHistory
	m.methods["query-tx-local"] = m.QueryTxLocal
	m.methods["status"] = m.Status
	m.methods["version"] = m.Version

	return m.methods
}

func (m *JrpcMethods) parse(params json.RawMessage, target interface{}, validateFields ...string) error {
	err := json.Unmarshal(params, target)
	if err != nil {
		return validatorError(err)
	}

	// validate fields
	if len(validateFields) == 0 {
		if err = m.validate.Struct(target); err != nil {
			return validatorError(err)
		}
	} else {
		if err = m.validate.StructPartial(target, validateFields...); err != nil {
			return validatorError(err)
		}
	}

	return nil
}

func jrpcFormatResponse(res interface{}, err error) interface{} {
	if err != nil {
		return accumulateError(err)
	}

	return res
}

// ExecuteAddCredits submits an AddCredits transaction.
func (m *JrpcMethods) ExecuteAddCredits(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.AddCredits))
}

// ExecuteBurnTokens submits a BurnTokens transaction.
func (m *JrpcMethods) ExecuteBurnTokens(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.BurnTokens))
}

// ExecuteCreateAdi submits a CreateIdentity transaction.
func (m *JrpcMethods) ExecuteCreateAdi(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.CreateIdentity))
}

// ExecuteCreateDataAccount submits a CreateDataAccount transaction.
func (m *JrpcMethods) ExecuteCreateDataAccount(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.CreateDataAccount))
}

// ExecuteCreateIdentity submits a CreateIdentity transaction.
func (m *JrpcMethods) ExecuteCreateIdentity(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.CreateIdentity))
}

// ExecuteCreateKeyBook submits a CreateKeyBook transaction.
func (m *JrpcMethods) ExecuteCreateKeyBook(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.CreateKeyBook))
}

// ExecuteCreateKeyPage submits a CreateKeyPage transaction.
func (m *JrpcMethods) ExecuteCreateKeyPage(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.CreateKeyPage))
}

// ExecuteCreateToken submits a CreateToken transaction.
func (m *JrpcMethods) ExecuteCreateToken(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.CreateToken))
}

// ExecuteCreateTokenAccount submits a CreateTokenAccount transaction.
func (m *JrpcMethods) ExecuteCreateTokenAccount(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.CreateTokenAccount))
}

// ExecuteIssueTokens submits an IssueTokens transaction.
func (m *JrpcMethods) ExecuteIssueTokens(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.IssueTokens))
}

// ExecuteSendTokens submits a SendTokens transaction.
func (m *JrpcMethods) ExecuteSendTokens(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.SendTokens), "From", "To")
}

// ExecuteUpdateAccountAuth submits an UpdateAccountAuth transaction.
func (m *JrpcMethods) ExecuteUpdateAccountAuth(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.UpdateAccountAuth))
}

// ExecuteUpdateKey submits an UpdateKey transaction.
func (m *JrpcMethods) ExecuteUpdateKey(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.UpdateKey))
}

// ExecuteUpdateKeyPage submits an UpdateKeyPage transaction.
func (m *JrpcMethods) ExecuteUpdateKeyPage(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.UpdateKeyPage))
}

// ExecuteWriteData submits a WriteData transaction.
func (m *JrpcMethods) ExecuteWriteData(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.WriteData))
}

// ExecuteWriteDataTo submits a WriteDataTo transaction.
func (m *JrpcMethods) ExecuteWriteDataTo(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.WriteDataTo))
}

// Query queries an account or account chain by URL.
func (m *JrpcMethods) Query(ctx context.Context, params json.RawMessage) interface{} {
	req := new(GeneralQuery)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Url)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QueryUrl(req.Url, req.QueryOptions))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}

// QueryData queries an entry on an account's data chain.
func (m *JrpcMethods) QueryData(ctx context.Context, params json.RawMessage) interface{} {
	req := new(DataEntryQuery)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Url)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QueryData(req.Url, req.EntryHash))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query-data", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}

// QueryDataSet queries a range of entries on an account's data chain.
func (m *JrpcMethods) QueryDataSet(ctx context.Context, params json.RawMessage) interface{} {
	req := new(DataEntrySetQuery)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Url)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QueryDataSet(req.Url, req.QueryPagination, req.QueryOptions))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query-data-set", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}

// QueryDirectory queries the directory entries of an account.
func (m *JrpcMethods) QueryDirectory(ctx context.Context, params json.RawMessage) interface{} {
	req := new(DirectoryQuery)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Url)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QueryDirectory(req.Url, req.QueryPagination, req.QueryOptions))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query-directory", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}

// QueryKeyPageIndex queries the location of a key within an account's key book(s).
func (m *JrpcMethods) QueryKeyPageIndex(ctx context.Context, params json.RawMessage) interface{} {
	req := new(KeyPageIndexQuery)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Url)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QueryKeyPageIndex(req.Url, req.Key))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query-key-index", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}

// QueryMajorBlocks queries an account's major blocks.
//
// WARNING: EXPERIMENTAL!
func (m *JrpcMethods) QueryMajorBlocks(ctx context.Context, params json.RawMessage) interface{} {
	req := new(MajorBlocksQuery)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Url)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QueryMajorBlocks(req.Url, req.QueryPagination))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query-major-blocks", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}

// QueryMinorBlocks queries an account's minor blocks.
//
// WARNING: EXPERIMENTAL!
func (m *JrpcMethods) QueryMinorBlocks(ctx context.Context, params json.RawMessage) interface{} {
	req := new(MinorBlocksQuery)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Url)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QueryMinorBlocks(req.Url, req.QueryPagination, req.TxFetchMode, req.BlockFilterMode))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query-minor-blocks", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}

// WARNING: EXPERIMENTAL!
func (m *JrpcMethods) QuerySynth(ctx context.Context, params json.RawMessage) interface{} {
	req := new(SyntheticTransactionRequest)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Source)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QuerySynth(req.Source, req.Destination, req.SequenceNumber, req.Anchor))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query-synth", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}

// QueryTxHistory queries an account's transaction history.
func (m *JrpcMethods) QueryTxHistory(ctx context.Context, params json.RawMessage) interface{} {
	req := new(TxHistoryQuery)
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.Url)
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.QueryTxHistory(req.Url, req.QueryPagination, req.Scratch))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "query-tx-history", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}
