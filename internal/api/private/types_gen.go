// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package private

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
)

type SequenceOptions struct {
	fieldsSet []bool
	NodeID    p2p.PeerID `json:"nodeID,omitempty" form:"nodeID" query:"nodeID" validate:"required"`
	extraData []byte
}

func (v *SequenceOptions) Copy() *SequenceOptions {
	u := new(SequenceOptions)

	if v.NodeID != "" {
		u.NodeID = p2p.CopyPeerID(v.NodeID)
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SequenceOptions) CopyAsInterface() interface{} { return v.Copy() }

func (v *SequenceOptions) Equal(u *SequenceOptions) bool {
	if !(p2p.EqualPeerID(v.NodeID, u.NodeID)) {
		return false
	}

	return true
}

var fieldNames_SequenceOptions = []string{
	1: "NodeID",
}

func (v *SequenceOptions) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.NodeID == ("")) {
		writer.WriteValue(1, v.NodeID.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_SequenceOptions)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SequenceOptions) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field NodeID is missing")
	} else if v.NodeID == ("") {
		errs = append(errs, "field NodeID is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *SequenceOptions) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SequenceOptions) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, func(r io.Reader) error {
		x, err := p2p.UnmarshalPeerIDFrom(r)
		if err == nil {
			v.NodeID = x
		}
		return err
	})

	seen, err := reader.Reset(fieldNames_SequenceOptions)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func init() {

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("nodeID", "p2p.PeerID"),
	}, "SequenceOptions", "sequenceOptions")

}

func (v *SequenceOptions) MarshalJSON() ([]byte, error) {
	u := struct {
		NodeID    *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"nodeID,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	if !(v.NodeID == ("")) {
		u.NodeID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.NodeID, Func: p2p.UnmarshalPeerIDJSON}
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SequenceOptions) UnmarshalJSON(data []byte) error {
	u := struct {
		NodeID    *encoding.JsonUnmarshalWith[p2p.PeerID] `json:"nodeID,omitempty"`
		ExtraData *string                                 `json:"$epilogue,omitempty"`
	}{}
	u.NodeID = &encoding.JsonUnmarshalWith[p2p.PeerID]{Value: v.NodeID, Func: p2p.UnmarshalPeerIDJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if u.NodeID != nil {
		v.NodeID = u.NodeID.Value
	}

	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}
