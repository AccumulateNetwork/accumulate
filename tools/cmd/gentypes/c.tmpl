/// GENERATED BY go run ./tools/cmd/gentypes. DO NOT EDIT.
#include <jsmn.h>
#include <encoding.h>
#include <transactions.h>
#include <types.h>
#include <url.h>
#include <state.h>
#include <big.h>
{{- if not (isPkg "types/state")}}
#include "types/state.h"
{{- end}}
{{- if not (isPkg "types/api/transactions")}}
#include "types/api/transactions"
{{- end}}

{{range .Types}}
struct {{.Name}} {
    //pseudo helper functions
    int (*GetType)();
    rbytes (*MarshalBinary)(v *{{.Name}});
    error (*UnmarshalBinary)(v *{{.Name}});
    rbytes (*MarshalJSON)(v *{{.Name}});
    error (*UnmarshalJSON)(v *{{.Name}});
    bool (*Equal)(v *{{.Name}},u *{{.Name}});
    int (*BinarySize)(v *{{.Name}});


	{{if .IsChain}}{{if isPkg "types/state"}}ChainHeader{{else}}state.ChainHeader{{end}}
	{{- end}}
	{{- range .Embeddings}}
	{{.}}
	{{- end}}
	{{- range .Fields}}
	{{resolveType . false}} {{.Name}} {{if .IsMarshalled}}; //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
	{{- end}}

};
{{end}}

{{range .Types}}
{{- if and .IsChain .MakeConstructor}}
func New{{.Name}}() *{{.Name}} {
	v := new({{.Name}})
	v.Type = types.AccountType{{.ChainType}}

    .GetType = GetType##Struct,\
    .MarshalBinary = MarshalBinary##Struct,\
    .UnmarshalBinary = UnmarshalBinary##Struct, \
    .MarshalJSON = MarshalJSON##Struct,\
    .UnmarshalJSON = UnmarshalJSON##Struct,\
    .Equal = Equal##Struct,\
	return v
}
{{- end}}
{{end}}

{{range .Types}}{{if .IsTransaction}}
TxType GetType{{.Name}}()  { return TxType{{.TransactionType}}; }
{{end}}{{end}}

{{range .Types}}{{if .IsComparable}}
bool Equal{{.Name}}({{.Name}} *v, {{.Name}} *u) {
	{{- if .IsChain}}
	if !v.ChainHeader.Equal(&u.ChainHeader) {
		return false
	}
	{{end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{areEqual . (print "v->" .Name) (print "u->" .Name)}}
	{{- end}}
	{{- end}}

	return true
}
{{end}}{{end}}

{{range .Types}}{{if .IsBinary}}
int BinarySize{{.Name}}({{.Name}} *v) {
	var n int

	{{if .IsTransaction}}
	n += encoding.UvarintBinarySize(types.TxType{{.TransactionType}}.ID())
	{{end}}

	{{if .IsChain}}
	// Enforce sanity
	v.Type = types.AccountType{{.ChainType}}

	n += v.ChainHeader.GetHeaderSize()
	{{end}}

	{{- range .Embeddings}}
	n += v.{{.}}.BinarySize()
	{{end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{binarySize . (print "v." .Name)}}
	{{- end}}
	{{- end}}

	return n
}
{{end}}{{end}}

{{range .Types}}{{if .IsBinary}}
rbytes MarshalBinary{{.Name}}({{.Name}} *v)  {
	var buffer bytes.Buffer

	{{if .IsTransaction}}
	buffer.Write(encoding.UvarintMarshalBinary(types.TxType{{.TransactionType}}.ID()))
	{{end}}

	{{if .IsChain}}
	// Enforce sanity
	v.Type = types.AccountType{{.ChainType}}

	if b, err := v.ChainHeader.MarshalBinary(); err != nil {
		return nil, fmt.Errorf("error encoding header: %w", err)
	} else {
		buffer.Write(b)
	}
	{{- end}}

	{{- range .Embeddings}}
	if b, err := v.{{.}}.MarshalBinary(); err != nil {
		return nil, err
	} else {
		buffer.Write(b)
	}
	{{end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{binaryMarshalValue . (print "v." .Name) .Name}}
	{{- end}}
	{{- end}}

	return buffer.Bytes(), nil
}
{{end}}{{end}}

{{range .Types}}{{if .IsBinary}}
error UnmarshalBinary{{.Name}}({{.Name}}*v, data []byte) {
	{{- if .IsTransaction}}
	typ := types.TxType{{.TransactionType}}
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	{{end}}

	{{- if .IsChain}}
	typ := types.AccountType{{.ChainType}}
	if err := v.ChainHeader.UnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding header: %w", err)
	} else if v.Type != typ {
		return fmt.Errorf("invalid account type: want %v, got %v", typ, v.Type)
	}
	data = data[v.GetHeaderSize():]
	{{end}}

	{{- range .Embeddings}}
	if err := v.{{.}}.UnmarshalBinary(data); err != nil {
		return err
	}
	data = data[v.{{.}}.BinarySize():]
	{{end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{binaryUnmarshalValue . (print "v." .Name) .Name}}
	{{- end}}
	{{- end}}

	return nil
}
{{end}}{{end}}

{{define "jsonType"}}struct {
	{{- if .IsChain}}{{if isPkg "types/state"}}ChainHeader{{else}}state.ChainHeader{{end}}
	{{- end}}
	{{- range .Embeddings}}{{.}}
	{{- end}}
	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{.Name}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
	{{- if .AlternativeName}}
	{{.AlternativeName}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .AlternativeName}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
	{{- end}}
	{{- end}}
	{{- end}}
}{{end}}

{{range .Types}}{{if needsCustomJSON .}}
rbytes MarshalJSON{{.Name}}({{.Name}} *v) {
	u := {{template "jsonType" .}}{}

	{{- if .IsChain}}
	u.ChainHeader = v.ChainHeader
	{{- end}}

	{{- range .Embeddings}}
	u.{{.}} = v.{{.}}
	{{- end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{valueToJson . (print "u." .Name) (print "v." .Name)}}
	{{- if .AlternativeName}}
	{{valueToJson . (print "u." .AlternativeName) (print "v." .Name)}}
	{{- end}}
	{{- end}}
	{{- end}}
	return json.Marshal(&u)
}
{{end}}{{end}}

{{range .Types}}{{if needsCustomJSON .}}
error UnmarshalJSON{{.Name}}({{.Name}} *v,data []byte) {
	u := {{template "jsonType" .}}{}

	{{- if .IsChain}}
	u.ChainHeader = v.ChainHeader
	{{- end}}

	{{- range .Embeddings}}
	u.{{.}} = v.{{.}}
	{{- end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{valueToJson . (print "u." .Name) (print "v." .Name)}}
	{{- if .AlternativeName}}
	{{valueToJson . (print "u." .AlternativeName) (print "v." .Name)}}
	{{- end}}
	{{- end}}
	{{- end}}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}

	{{- if .IsChain}}
	v.ChainHeader = u.ChainHeader
	{{- end}}

	{{- range .Embeddings}}
	v.{{.}} = u.{{.}}
	{{- end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{- if .AlternativeName}}
	var zero{{.Name}} {{resolveType . false}}
	if u.{{.Name}} != zero{{.Name}} {
		{{valueFromJson . (print "v." .Name) (print "u." .Name) .Name}}
	} else {
		{{valueFromJson . (print "v." .Name) (print "u." .AlternativeName) .Name}}
	}
	{{- else}}
	{{valueFromJson . (print "v." .Name) (print "u." .Name) .Name}}
	{{- end}}
	{{- end}}
	{{- end}}
	return nil
}
{{end}}{{end}}