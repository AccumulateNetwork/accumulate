#ifndef protocol_H
#define protocol_H
// go run ./tools/cmd/gentypes ../../../protocol/basic.yml --language c --out _test.h
// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.


#include <jsmn.h>
#include <encoding.h>
#include <transactions.h>
#include <types.h>
#include <url.h>
#include <state.h>
#include <big.h>
#include "types/state.h"
#include "types/api/transactions"


struct Basic {
	string Recipient ; //`json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required,acc-url"`
	uint64 Precision ; //`json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	string Properties ; //`json:"properties,omitempty" form:"properties" query:"properties" validate:"acc-url"`
	big.Int InitialSupply ; //`json:"initialSupply,omitempty" form:"initialSupply" query:"initialSupply"`
	bool HasSupplyLimit ; //`json:"hasSupplyLimit,omitempty" form:"hasSupplyLimit" query:"hasSupplyLimit"`
	[32]byte Cause ; //`json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`

    int (*GetType)();
    rbytes (*MarshalBinary)(*Basic);
    error (*UnmarshalBinary)(*Basic);
    rbytes (*MarshalJSON)(*Basic);
    error (*UnmarshalJSON)(*Basic);
    bool (*Equal)(*Basic, *Basic);
    int (*BinarySize)(*Basic);
};

Basic b = NewBasic(Basic);

#define NewBasic(Struct, ...) \
    ((Struct) { \
        .GetType = GetType##Struct,\
        .MarshalBinary = MarshalBinary##Struct,\
        .UnmarshalBinary = UnmarshalBinary##Struct, \
        .MarshalJSON = MarshalJSON##Struct,\
        .UnmarshalJSON = UnmarshalJSON##Struct,\
        .Equal = Equal##Struct,\
    ##__VA_ARGS__ })

struct error {
   int code;
   char[64] err;
};

struct bytes {
   uint8_t *data;
   size_t len;
};

struct rbytes {
   bytes *byte;
   char[64] err;
};

//employee john = TRANSACTION(.name="John");
TransactionType GetTypeBasic() {
   return TxTypeBasic;
}

bool Equal(v *Basic, u *Basic) bool {
		if !(v.Recipient == u.Recipient) { return false }



		if !(v.Precision == u.Precision) { return false }



		if !(v.Properties == u.Properties) { return false }



		if !(v.InitialSupply.Cmp(&u.InitialSupply) == 0) { return false }



		if !(v.HasSupplyLimit == u.HasSupplyLimit) { return false }



		if !(v.Cause == u.Cause) { return false }




	return true
}



int BinarySizeBasic(v *Basic) {
	var n int

	n += encoding.UvarintBinarySize(types.TxTypeBasic.ID())
	n += encoding.StringBinarySize(v.Recipient)
	n += encoding.UvarintBinarySize(v.Precision)
	n += encoding.StringBinarySize(v.Properties)
	n += encoding.BigintBinarySize(&v.InitialSupply)
	n += encoding.BoolBinarySize(v.HasSupplyLimit)
	n += encoding.ChainBinarySize(&v.Cause)
	return n
}

bytes, error MarshalBinaryBasic(v *Basic) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeBasic.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Recipient))


		buffer.Write(encoding.UvarintMarshalBinary(v.Precision))


		buffer.Write(encoding.StringMarshalBinary(v.Properties))


		buffer.Write(encoding.BigintMarshalBinary(&v.InitialSupply))


		buffer.Write(encoding.BoolMarshalBinary(v.HasSupplyLimit))


		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))



	return buffer.Bytes(), nil
}

error UnmarshalBinary(v *Basic, bytes *data) {
	typ := types.TxTypeBasic
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Recipient: %w", err) } else { v.Recipient = x }
	data = data[encoding.StringBinarySize(v.Recipient):]


		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Precision: %w", err) } else { v.Precision = x }
	data = data[encoding.UvarintBinarySize(v.Precision):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Properties: %w", err) } else { v.Properties = x }
	data = data[encoding.StringBinarySize(v.Properties):]


		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding InitialSupply: %w", err) } else { v.InitialSupply.Set(x) }
	data = data[encoding.BigintBinarySize(&v.InitialSupply):]


		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding HasSupplyLimit: %w", err) } else { v.HasSupplyLimit = x }
	data = data[encoding.BoolBinarySize(v.HasSupplyLimit):]


		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]



	return nil
}

rbytes MarshalJSON(Basic *v) {
	u := struct {
	Recipient string `json:"recipient,omitempty"`
	Precision uint64 `json:"precision,omitempty"`
	Properties string `json:"properties,omitempty"`
	InitialSupply *string `json:"initialSupply,omitempty"`
	HasSupplyLimit bool `json:"hasSupplyLimit,omitempty"`
	Cause string `json:"cause,omitempty"`
}{}
		u.Recipient = v.Recipient
		u.Precision = v.Precision
		u.Properties = v.Properties
		u.InitialSupply = encoding.BigintToJSON(&v.InitialSupply)
		u.HasSupplyLimit = v.HasSupplyLimit
		u.Cause = encoding.ChainToJSON(v.Cause)
	return json.Marshal(&u)
}



error UnmarshalJSON(Basic *v, data []byte) {
	u := struct {
	Recipient string `json:"recipient,omitempty"`
	Precision uint64 `json:"precision,omitempty"`
	Properties string `json:"properties,omitempty"`
	InitialSupply *string `json:"initialSupply,omitempty"`
	HasSupplyLimit bool `json:"hasSupplyLimit,omitempty"`
	Cause string `json:"cause,omitempty"`
}{}
		u.Recipient = v.Recipient
		u.Precision = v.Precision
		u.Properties = v.Properties
		u.InitialSupply = encoding.BigintToJSON(&v.InitialSupply)
		u.HasSupplyLimit = v.HasSupplyLimit
		u.Cause = encoding.ChainToJSON(v.Cause)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Recipient = u.Recipient
		v.Precision = u.Precision
		v.Properties = u.Properties
		if x, err := encoding.BigintFromJSON(u.InitialSupply); err != nil {
		return fmt.Errorf("error decoding InitialSupply: %w", err)
	} else {
		v.InitialSupply = *x
	}
		v.HasSupplyLimit = u.HasSupplyLimit
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
	return nil
}

#endif