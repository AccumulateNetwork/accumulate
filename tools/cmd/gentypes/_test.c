#include "_test.h"

/// GENERATED BY go run ./tools/cmd/gentypes. DO NOT EDIT.
#include <jsmn.h>
#include <encoding.h>
#include <transactions.h>
#include <types.h>
#include <url.h>
#include <state.h>
#include <big.h>
#include "types/state.h"
#include "types/api/transactions"
func NewAcmeFaucet() AcmeFaucet {
	AcmeFaucet v;
    v.GetType = GetTypeAcmeFaucet;
    v.MarshalBinary = MarshalBinaryAcmeFaucet;
    v.UnmarshalBinary = UnmarshalBinaryAcmeFaucet;
    v.MarshalJSON = MarshalJSONAcmeFaucet;
    v.UnmarshalJSON = UnmarshalJSONAcmeFaucet;
    v.Equal = EqualAcmeFaucet;
    return v;
}
func NewAddCredits() AddCredits {
	AddCredits v;
    v.GetType = GetTypeAddCredits;
    v.MarshalBinary = MarshalBinaryAddCredits;
    v.UnmarshalBinary = UnmarshalBinaryAddCredits;
    v.MarshalJSON = MarshalJSONAddCredits;
    v.UnmarshalJSON = UnmarshalJSONAddCredits;
    v.Equal = EqualAddCredits;
    return v;
}
func NewAnchoredRecord() AnchoredRecord {
	AnchoredRecord v;
    v.GetType = GetTypeAnchoredRecord;
    v.MarshalBinary = MarshalBinaryAnchoredRecord;
    v.UnmarshalBinary = UnmarshalBinaryAnchoredRecord;
    v.MarshalJSON = MarshalJSONAnchoredRecord;
    v.UnmarshalJSON = UnmarshalJSONAnchoredRecord;
    v.Equal = EqualAnchoredRecord;
    return v;
}
func NewBurnTokens() BurnTokens {
	BurnTokens v;
    v.GetType = GetTypeBurnTokens;
    v.MarshalBinary = MarshalBinaryBurnTokens;
    v.UnmarshalBinary = UnmarshalBinaryBurnTokens;
    v.MarshalJSON = MarshalJSONBurnTokens;
    v.UnmarshalJSON = UnmarshalJSONBurnTokens;
    v.Equal = EqualBurnTokens;
    return v;
}
func NewChainParams() ChainParams {
	ChainParams v;
    v.GetType = GetTypeChainParams;
    v.MarshalBinary = MarshalBinaryChainParams;
    v.UnmarshalBinary = UnmarshalBinaryChainParams;
    v.MarshalJSON = MarshalJSONChainParams;
    v.UnmarshalJSON = UnmarshalJSONChainParams;
    v.Equal = EqualChainParams;
    return v;
}
func NewCreateDataAccount() CreateDataAccount {
	CreateDataAccount v;
    v.GetType = GetTypeCreateDataAccount;
    v.MarshalBinary = MarshalBinaryCreateDataAccount;
    v.UnmarshalBinary = UnmarshalBinaryCreateDataAccount;
    v.MarshalJSON = MarshalJSONCreateDataAccount;
    v.UnmarshalJSON = UnmarshalJSONCreateDataAccount;
    v.Equal = EqualCreateDataAccount;
    return v;
}
func NewCreateIdentity() CreateIdentity {
	CreateIdentity v;
    v.GetType = GetTypeCreateIdentity;
    v.MarshalBinary = MarshalBinaryCreateIdentity;
    v.UnmarshalBinary = UnmarshalBinaryCreateIdentity;
    v.MarshalJSON = MarshalJSONCreateIdentity;
    v.UnmarshalJSON = UnmarshalJSONCreateIdentity;
    v.Equal = EqualCreateIdentity;
    return v;
}
func NewCreateKeyBook() CreateKeyBook {
	CreateKeyBook v;
    v.GetType = GetTypeCreateKeyBook;
    v.MarshalBinary = MarshalBinaryCreateKeyBook;
    v.UnmarshalBinary = UnmarshalBinaryCreateKeyBook;
    v.MarshalJSON = MarshalJSONCreateKeyBook;
    v.UnmarshalJSON = UnmarshalJSONCreateKeyBook;
    v.Equal = EqualCreateKeyBook;
    return v;
}
func NewCreateKeyPage() CreateKeyPage {
	CreateKeyPage v;
    v.GetType = GetTypeCreateKeyPage;
    v.MarshalBinary = MarshalBinaryCreateKeyPage;
    v.UnmarshalBinary = UnmarshalBinaryCreateKeyPage;
    v.MarshalJSON = MarshalJSONCreateKeyPage;
    v.UnmarshalJSON = UnmarshalJSONCreateKeyPage;
    v.Equal = EqualCreateKeyPage;
    return v;
}
func NewCreateToken() CreateToken {
	CreateToken v;
    v.GetType = GetTypeCreateToken;
    v.MarshalBinary = MarshalBinaryCreateToken;
    v.UnmarshalBinary = UnmarshalBinaryCreateToken;
    v.MarshalJSON = MarshalJSONCreateToken;
    v.UnmarshalJSON = UnmarshalJSONCreateToken;
    v.Equal = EqualCreateToken;
    return v;
}
func NewCreateTokenAccount() CreateTokenAccount {
	CreateTokenAccount v;
    v.GetType = GetTypeCreateTokenAccount;
    v.MarshalBinary = MarshalBinaryCreateTokenAccount;
    v.UnmarshalBinary = UnmarshalBinaryCreateTokenAccount;
    v.MarshalJSON = MarshalJSONCreateTokenAccount;
    v.UnmarshalJSON = UnmarshalJSONCreateTokenAccount;
    v.Equal = EqualCreateTokenAccount;
    return v;
}
func NewIssueTokens() IssueTokens {
	IssueTokens v;
    v.GetType = GetTypeIssueTokens;
    v.MarshalBinary = MarshalBinaryIssueTokens;
    v.UnmarshalBinary = UnmarshalBinaryIssueTokens;
    v.MarshalJSON = MarshalJSONIssueTokens;
    v.UnmarshalJSON = UnmarshalJSONIssueTokens;
    v.Equal = EqualIssueTokens;
    return v;
}
func NewKeySpecParams() KeySpecParams {
	KeySpecParams v;
    v.GetType = GetTypeKeySpecParams;
    v.MarshalBinary = MarshalBinaryKeySpecParams;
    v.UnmarshalBinary = UnmarshalBinaryKeySpecParams;
    v.MarshalJSON = MarshalJSONKeySpecParams;
    v.UnmarshalJSON = UnmarshalJSONKeySpecParams;
    v.Equal = EqualKeySpecParams;
    return v;
}
func NewSegWitDataEntry() SegWitDataEntry {
	SegWitDataEntry v;
    v.GetType = GetTypeSegWitDataEntry;
    v.MarshalBinary = MarshalBinarySegWitDataEntry;
    v.UnmarshalBinary = UnmarshalBinarySegWitDataEntry;
    v.MarshalJSON = MarshalJSONSegWitDataEntry;
    v.UnmarshalJSON = UnmarshalJSONSegWitDataEntry;
    v.Equal = EqualSegWitDataEntry;
    return v;
}
func NewSendTokens() SendTokens {
	SendTokens v;
    v.GetType = GetTypeSendTokens;
    v.MarshalBinary = MarshalBinarySendTokens;
    v.UnmarshalBinary = UnmarshalBinarySendTokens;
    v.MarshalJSON = MarshalJSONSendTokens;
    v.UnmarshalJSON = UnmarshalJSONSendTokens;
    v.Equal = EqualSendTokens;
    return v;
}
func NewSignPending() SignPending {
	SignPending v;
    v.GetType = GetTypeSignPending;
    v.MarshalBinary = MarshalBinarySignPending;
    v.UnmarshalBinary = UnmarshalBinarySignPending;
    v.MarshalJSON = MarshalJSONSignPending;
    v.UnmarshalJSON = UnmarshalJSONSignPending;
    v.Equal = EqualSignPending;
    return v;
}
func NewSyntheticAnchor() SyntheticAnchor {
	SyntheticAnchor v;
    v.GetType = GetTypeSyntheticAnchor;
    v.MarshalBinary = MarshalBinarySyntheticAnchor;
    v.UnmarshalBinary = UnmarshalBinarySyntheticAnchor;
    v.MarshalJSON = MarshalJSONSyntheticAnchor;
    v.UnmarshalJSON = UnmarshalJSONSyntheticAnchor;
    v.Equal = EqualSyntheticAnchor;
    return v;
}
func NewSyntheticBurnTokens() SyntheticBurnTokens {
	SyntheticBurnTokens v;
    v.GetType = GetTypeSyntheticBurnTokens;
    v.MarshalBinary = MarshalBinarySyntheticBurnTokens;
    v.UnmarshalBinary = UnmarshalBinarySyntheticBurnTokens;
    v.MarshalJSON = MarshalJSONSyntheticBurnTokens;
    v.UnmarshalJSON = UnmarshalJSONSyntheticBurnTokens;
    v.Equal = EqualSyntheticBurnTokens;
    return v;
}
func NewSyntheticCreateChain() SyntheticCreateChain {
	SyntheticCreateChain v;
    v.GetType = GetTypeSyntheticCreateChain;
    v.MarshalBinary = MarshalBinarySyntheticCreateChain;
    v.UnmarshalBinary = UnmarshalBinarySyntheticCreateChain;
    v.MarshalJSON = MarshalJSONSyntheticCreateChain;
    v.UnmarshalJSON = UnmarshalJSONSyntheticCreateChain;
    v.Equal = EqualSyntheticCreateChain;
    return v;
}
func NewSyntheticDepositCredits() SyntheticDepositCredits {
	SyntheticDepositCredits v;
    v.GetType = GetTypeSyntheticDepositCredits;
    v.MarshalBinary = MarshalBinarySyntheticDepositCredits;
    v.UnmarshalBinary = UnmarshalBinarySyntheticDepositCredits;
    v.MarshalJSON = MarshalJSONSyntheticDepositCredits;
    v.UnmarshalJSON = UnmarshalJSONSyntheticDepositCredits;
    v.Equal = EqualSyntheticDepositCredits;
    return v;
}
func NewSyntheticDepositTokens() SyntheticDepositTokens {
	SyntheticDepositTokens v;
    v.GetType = GetTypeSyntheticDepositTokens;
    v.MarshalBinary = MarshalBinarySyntheticDepositTokens;
    v.UnmarshalBinary = UnmarshalBinarySyntheticDepositTokens;
    v.MarshalJSON = MarshalJSONSyntheticDepositTokens;
    v.UnmarshalJSON = UnmarshalJSONSyntheticDepositTokens;
    v.Equal = EqualSyntheticDepositTokens;
    return v;
}
func NewSyntheticMirror() SyntheticMirror {
	SyntheticMirror v;
    v.GetType = GetTypeSyntheticMirror;
    v.MarshalBinary = MarshalBinarySyntheticMirror;
    v.UnmarshalBinary = UnmarshalBinarySyntheticMirror;
    v.MarshalJSON = MarshalJSONSyntheticMirror;
    v.UnmarshalJSON = UnmarshalJSONSyntheticMirror;
    v.Equal = EqualSyntheticMirror;
    return v;
}
func NewSyntheticWriteData() SyntheticWriteData {
	SyntheticWriteData v;
    v.GetType = GetTypeSyntheticWriteData;
    v.MarshalBinary = MarshalBinarySyntheticWriteData;
    v.UnmarshalBinary = UnmarshalBinarySyntheticWriteData;
    v.MarshalJSON = MarshalJSONSyntheticWriteData;
    v.UnmarshalJSON = UnmarshalJSONSyntheticWriteData;
    v.Equal = EqualSyntheticWriteData;
    return v;
}
func NewTokenRecipient() TokenRecipient {
	TokenRecipient v;
    v.GetType = GetTypeTokenRecipient;
    v.MarshalBinary = MarshalBinaryTokenRecipient;
    v.UnmarshalBinary = UnmarshalBinaryTokenRecipient;
    v.MarshalJSON = MarshalJSONTokenRecipient;
    v.UnmarshalJSON = UnmarshalJSONTokenRecipient;
    v.Equal = EqualTokenRecipient;
    return v;
}
func NewUpdateKeyPage() UpdateKeyPage {
	UpdateKeyPage v;
    v.GetType = GetTypeUpdateKeyPage;
    v.MarshalBinary = MarshalBinaryUpdateKeyPage;
    v.UnmarshalBinary = UnmarshalBinaryUpdateKeyPage;
    v.MarshalJSON = MarshalJSONUpdateKeyPage;
    v.UnmarshalJSON = UnmarshalJSONUpdateKeyPage;
    v.Equal = EqualUpdateKeyPage;
    return v;
}
func NewWriteData() WriteData {
	WriteData v;
    v.GetType = GetTypeWriteData;
    v.MarshalBinary = MarshalBinaryWriteData;
    v.UnmarshalBinary = UnmarshalBinaryWriteData;
    v.MarshalJSON = MarshalJSONWriteData;
    v.UnmarshalJSON = UnmarshalJSONWriteData;
    v.Equal = EqualWriteData;
    return v;
}
func NewWriteDataResult() WriteDataResult {
	WriteDataResult v;
    v.GetType = GetTypeWriteDataResult;
    v.MarshalBinary = MarshalBinaryWriteDataResult;
    v.UnmarshalBinary = UnmarshalBinaryWriteDataResult;
    v.MarshalJSON = MarshalJSONWriteDataResult;
    v.UnmarshalJSON = UnmarshalJSONWriteDataResult;
    v.Equal = EqualWriteDataResult;
    return v;
}
func NewWriteDataTo() WriteDataTo {
	WriteDataTo v;
    v.GetType = GetTypeWriteDataTo;
    v.MarshalBinary = MarshalBinaryWriteDataTo;
    v.UnmarshalBinary = UnmarshalBinaryWriteDataTo;
    v.MarshalJSON = MarshalJSONWriteDataTo;
    v.UnmarshalJSON = UnmarshalJSONWriteDataTo;
    v.Equal = EqualWriteDataTo;
    return v;
}
TxType GetTypeAcmeFaucet()  { return TxTypeAcmeFaucet; }
TxType GetTypeAddCredits()  { return TxTypeAddCredits; }
TxType GetTypeBurnTokens()  { return TxTypeBurnTokens; }
TxType GetTypeCreateDataAccount()  { return TxTypeCreateDataAccount; }
TxType GetTypeCreateIdentity()  { return TxTypeCreateIdentity; }
TxType GetTypeCreateKeyBook()  { return TxTypeCreateKeyBook; }
TxType GetTypeCreateKeyPage()  { return TxTypeCreateKeyPage; }
TxType GetTypeCreateToken()  { return TxTypeCreateToken; }
TxType GetTypeCreateTokenAccount()  { return TxTypeCreateTokenAccount; }
TxType GetTypeIssueTokens()  { return TxTypeIssueTokens; }
TxType GetTypeSegWitDataEntry()  { return TxTypeSegWitDataEntry; }
TxType GetTypeSendTokens()  { return TxTypeSendTokens; }
TxType GetTypeSignPending()  { return TxTypeSignPending; }
TxType GetTypeSyntheticAnchor()  { return TxTypeSyntheticAnchor; }
TxType GetTypeSyntheticBurnTokens()  { return TxTypeSyntheticBurnTokens; }
TxType GetTypeSyntheticCreateChain()  { return TxTypeSyntheticCreateChain; }
TxType GetTypeSyntheticDepositCredits()  { return TxTypeSyntheticDepositCredits; }
TxType GetTypeSyntheticDepositTokens()  { return TxTypeSyntheticDepositTokens; }
TxType GetTypeSyntheticMirror()  { return TxTypeSyntheticMirror; }
TxType GetTypeSyntheticWriteData()  { return TxTypeSyntheticWriteData; }
TxType GetTypeUpdateKeyPage()  { return TxTypeUpdateKeyPage; }
TxType GetTypeWriteData()  { return TxTypeWriteData; }
TxType GetTypeWriteDataTo()  { return TxTypeWriteDataTo; }
bool EqualAcmeFaucet(AcmeFaucet *v, AcmeFaucet *u) {
		if !(strcmp(v->Url.string.Data, u->Url.string.Data)==0) { return false }
	return true
}
bool EqualAddCredits(AddCredits *v, AddCredits *u) {
		if !(strcmp(v->Recipient.string.Data, u->Recipient.string.Data)==0) { return false }
		if !(memcmp(v->Amount, u->Amount) == 0) { return false }
	return true
}
bool EqualAnchoredRecord(AnchoredRecord *v, AnchoredRecord *u) {
		if !(memcmp(v->Record, u->Record)==0) { return false }
		if !(v->Anchor == u->Anchor) { return false }
	return true
}
bool EqualBurnTokens(BurnTokens *v, BurnTokens *u) {
		if !(v->Amount.Cmp(&u->Amount) == 0) { return false }
	return true
}
bool EqualChainParams(ChainParams *v, ChainParams *u) {
		if !(memcmp(v->Data, u->Data)==0) { return false }
		if !(v->IsUpdate == u->IsUpdate) { return false }
	return true
}
bool EqualCreateDataAccount(CreateDataAccount *v, CreateDataAccount *u) {
		if !(strcmp(v->Url.string.Data, u->Url.string.Data)==0) { return false }
		if !(strcmp(v->KeyBookUrl.string.Data, u->KeyBookUrl.string.Data)==0) { return false }
		if !(strcmp(v->ManagerKeyBookUrl.string.Data, u->ManagerKeyBookUrl.string.Data)==0) { return false }
		if !(v->Scratch == u->Scratch) { return false }
	return true
}
bool EqualCreateIdentity(CreateIdentity *v, CreateIdentity *u) {
		if !(strcmp(v->Url.string.Data, u->Url.string.Data)==0) { return false }
		if !(memcmp(v->PublicKey, u->PublicKey)==0) { return false }
		if !(strcmp(v->KeyBookName.string.Data, u->KeyBookName.string.Data)==0) { return false }
		if !(strcmp(v->KeyPageName.string.Data, u->KeyPageName.string.Data)==0) { return false }
	return true
}
bool EqualCreateKeyBook(CreateKeyBook *v, CreateKeyBook *u) {
		if !(strcmp(v->Url.string.Data, u->Url.string.Data)==0) { return false }
		if !(v->Pages.data.len == u->Pages.data.len) { return false }
	for i := range v->Pages {
		v, u := v->Pages[i], u->Pages[i]
	if !(strcmp(v.string.Data, u.string.Data)==0) { return false }
	}
	return true
}
bool EqualCreateKeyPage(CreateKeyPage *v, CreateKeyPage *u) {
		if !(strcmp(v->Url.string.Data, u->Url.string.Data)==0) { return false }
		if !(v->Keys.data.len == u->Keys.data.len) { return false }
	for i := range v->Keys {
		v, u := v->Keys[i], u->Keys[i]
	if !(v.Equal(u)) { return false }
	}
	return true
}
bool EqualCreateToken(CreateToken *v, CreateToken *u) {
		if !(strcmp(v->Url.string.Data, u->Url.string.Data)==0) { return false }
		if !(strcmp(v->KeyBookUrl.string.Data, u->KeyBookUrl.string.Data)==0) { return false }
		if !(strcmp(v->Symbol.string.Data, u->Symbol.string.Data)==0) { return false }
		if !(memcmp(v->Precision, u->Precision) == 0) { return false }
		if !(strcmp(v->Properties.string.Data, u->Properties.string.Data)==0) { return false }
		if !(v->InitialSupply.Cmp(&u->InitialSupply) == 0) { return false }
		if !(v->HasSupplyLimit == u->HasSupplyLimit) { return false }
	return true
}
bool EqualCreateTokenAccount(CreateTokenAccount *v, CreateTokenAccount *u) {
		if !(strcmp(v->Url.string.Data, u->Url.string.Data)==0) { return false }
		if !(strcmp(v->TokenUrl.string.Data, u->TokenUrl.string.Data)==0) { return false }
		if !(strcmp(v->KeyBookUrl.string.Data, u->KeyBookUrl.string.Data)==0) { return false }
		if !(v->Scratch == u->Scratch) { return false }
	return true
}
bool EqualIssueTokens(IssueTokens *v, IssueTokens *u) {
		if !(strcmp(v->Recipient.string.Data, u->Recipient.string.Data)==0) { return false }
		if !(v->Amount.Cmp(&u->Amount) == 0) { return false }
	return true
}
bool EqualKeySpecParams(KeySpecParams *v, KeySpecParams *u) {
		if !(memcmp(v->PublicKey, u->PublicKey)==0) { return false }
	return true
}
bool EqualSegWitDataEntry(SegWitDataEntry *v, SegWitDataEntry *u) {
		if !(v->Cause == u->Cause) { return false }
		if !(strcmp(v->EntryUrl.string.Data, u->EntryUrl.string.Data)==0) { return false }
		if !(v->EntryHash == u->EntryHash) { return false }
	return true
}
bool EqualSendTokens(SendTokens *v, SendTokens *u) {
		if !(v->Hash == u->Hash) { return false }
		if !(memcmp(v->Meta, u->Meta)==0) { return false }
		if !(v->To.data.len == u->To.data.len) { return false }
	for i := range v->To {
		v, u := v->To[i], u->To[i]
	if !(v.Equal(u)) { return false }
	}
	return true
}
bool EqualSignPending(SignPending *v, SignPending *u) {
	return true
}
bool EqualSyntheticAnchor(SyntheticAnchor *v, SyntheticAnchor *u) {
		if !(strcmp(v->Source.string.Data, u->Source.string.Data)==0) { return false }
		if !(v->Major == u->Major) { return false }
		if !(v->RootAnchor == u->RootAnchor) { return false }
		if !(memcmp(v->RootIndex, u->RootIndex) == 0) { return false }
		if !(memcmp(v->Block, u->Block) == 0) { return false }
		if !(memcmp(v->SourceIndex, u->SourceIndex) == 0) { return false }
		if !(memcmp(v->SourceBlock, u->SourceBlock) == 0) { return false }
		if !(v->Receipt.Equal(&u->Receipt)) { return false }
	return true
}
bool EqualSyntheticBurnTokens(SyntheticBurnTokens *v, SyntheticBurnTokens *u) {
		if !(v->Cause == u->Cause) { return false }
		if !(v->Amount.Cmp(&u->Amount) == 0) { return false }
	return true
}
bool EqualSyntheticCreateChain(SyntheticCreateChain *v, SyntheticCreateChain *u) {
		if !(v->Cause == u->Cause) { return false }
		if !(v->Chains.data.len == u->Chains.data.len) { return false }
	for i := range v->Chains {
		v, u := v->Chains[i], u->Chains[i]
	if !(v.Equal(&u)) { return false }
	}
	return true
}
bool EqualSyntheticDepositCredits(SyntheticDepositCredits *v, SyntheticDepositCredits *u) {
		if !(v->Cause == u->Cause) { return false }
		if !(memcmp(v->Amount, u->Amount) == 0) { return false }
	return true
}
bool EqualSyntheticDepositTokens(SyntheticDepositTokens *v, SyntheticDepositTokens *u) {
		if !(v->Cause == u->Cause) { return false }
		if !(strcmp(v->Token.string.Data, u->Token.string.Data)==0) { return false }
		if !(v->Amount.Cmp(&u->Amount) == 0) { return false }
	return true
}
bool EqualSyntheticMirror(SyntheticMirror *v, SyntheticMirror *u) {
		if !(v->Objects.data.len == u->Objects.data.len) { return false }
	for i := range v->Objects {
		v, u := v->Objects[i], u->Objects[i]
	if !(v.Equal(&u)) { return false }
	}
	return true
}
bool EqualSyntheticWriteData(SyntheticWriteData *v, SyntheticWriteData *u) {
		if !(v->Cause == u->Cause) { return false }
		if !(v->Entry.Equal(&u->Entry)) { return false }
	return true
}
bool EqualTokenRecipient(TokenRecipient *v, TokenRecipient *u) {
		if !(strcmp(v->Url.string.Data, u->Url.string.Data)==0) { return false }
		if !(v->Amount.Cmp(&u->Amount) == 0) { return false }
	return true
}
bool EqualUpdateKeyPage(UpdateKeyPage *v, UpdateKeyPage *u) {
		if !(v->Operation == u->Operation) { return false }
		if !(memcmp(v->Key, u->Key)==0) { return false }
		if !(memcmp(v->NewKey, u->NewKey)==0) { return false }
		if !(strcmp(v->Owner.string.Data, u->Owner.string.Data)==0) { return false }
		if !(memcmp(v->Threshold, u->Threshold) == 0) { return false }
	return true
}
bool EqualWriteData(WriteData *v, WriteData *u) {
		if !(v->Entry.Equal(&u->Entry)) { return false }
	return true
}
bool EqualWriteDataResult(WriteDataResult *v, WriteDataResult *u) {
		if !(v->EntryHash == u->EntryHash) { return false }
		if !(v->AccountUrl.Equal(u->AccountUrl)) { return false }
		if !(memcmp(v->AccountID, u->AccountID)==0) { return false }
	return true
}
bool EqualWriteDataTo(WriteDataTo *v, WriteDataTo *u) {
		if !(strcmp(v->Recipient.string.Data, u->Recipient.string.Data)==0) { return false }
		if !(v->Entry.Equal(&u->Entry)) { return false }
	return true
}
int BinarySizeAcmeFaucet(AcmeFaucet *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeAcmeFaucet.ID())
		n += encoding.StringBinarySize(v.Url)
	return n
}
int BinarySizeAddCredits(AddCredits *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeAddCredits.ID())
		n += encoding.StringBinarySize(v.Recipient)
		n += encoding.UvarintBinarySize(v.Amount)
	return n
}
int BinarySizeAnchoredRecord(AnchoredRecord *v) {
	var n int
		n += encoding.BytesBinarySize(v.Record)
		n += encoding.ChainBinarySize(&v.Anchor)
	return n
}
int BinarySizeBurnTokens(BurnTokens *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeBurnTokens.ID())
		n += encoding.BigintBinarySize(&v.Amount)
	return n
}
int BinarySizeChainParams(ChainParams *v) {
	var n int
		n += encoding.BytesBinarySize(v.Data)
		n += encoding.BoolBinarySize(v.IsUpdate)
	return n
}
int BinarySizeCreateDataAccount(CreateDataAccount *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeCreateDataAccount.ID())
		n += encoding.StringBinarySize(v.Url)
		n += encoding.StringBinarySize(v.KeyBookUrl)
		n += encoding.StringBinarySize(v.ManagerKeyBookUrl)
		n += encoding.BoolBinarySize(v.Scratch)
	return n
}
int BinarySizeCreateIdentity(CreateIdentity *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeCreateIdentity.ID())
		n += encoding.StringBinarySize(v.Url)
		n += encoding.BytesBinarySize(v.PublicKey)
		n += encoding.StringBinarySize(v.KeyBookName)
		n += encoding.StringBinarySize(v.KeyPageName)
	return n
}
int BinarySizeCreateKeyBook(CreateKeyBook *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeCreateKeyBook.ID())
		n += encoding.StringBinarySize(v.Url)
		n += encoding.UvarintBinarySize(uint64(len(v.Pages)))
	for _, v := range v.Pages {
	n += encoding.StringBinarySize(v)
	}
	return n
}
int BinarySizeCreateKeyPage(CreateKeyPage *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeCreateKeyPage.ID())
		n += encoding.StringBinarySize(v.Url)
		n += encoding.UvarintBinarySize(uint64(len(v.Keys)))
	for _, v := range v.Keys {
	n += v.BinarySize()
	}
	return n
}
int BinarySizeCreateToken(CreateToken *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeCreateToken.ID())
		n += encoding.StringBinarySize(v.Url)
		n += encoding.StringBinarySize(v.KeyBookUrl)
		n += encoding.StringBinarySize(v.Symbol)
		n += encoding.UvarintBinarySize(v.Precision)
		n += encoding.StringBinarySize(v.Properties)
		n += encoding.BigintBinarySize(&v.InitialSupply)
		n += encoding.BoolBinarySize(v.HasSupplyLimit)
	return n
}
int BinarySizeCreateTokenAccount(CreateTokenAccount *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeCreateTokenAccount.ID())
		n += encoding.StringBinarySize(v.Url)
		n += encoding.StringBinarySize(v.TokenUrl)
		n += encoding.StringBinarySize(v.KeyBookUrl)
		n += encoding.BoolBinarySize(v.Scratch)
	return n
}
int BinarySizeIssueTokens(IssueTokens *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeIssueTokens.ID())
		n += encoding.StringBinarySize(v.Recipient)
		n += encoding.BigintBinarySize(&v.Amount)
	return n
}
int BinarySizeKeySpecParams(KeySpecParams *v) {
	var n int
		n += encoding.BytesBinarySize(v.PublicKey)
	return n
}
int BinarySizeSegWitDataEntry(SegWitDataEntry *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSegWitDataEntry.ID())
		n += encoding.ChainBinarySize(&v.Cause)
		n += encoding.StringBinarySize(v.EntryUrl)
		n += encoding.ChainBinarySize(&v.EntryHash)
	return n
}
int BinarySizeSendTokens(SendTokens *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSendTokens.ID())
		n += encoding.ChainBinarySize(&v.Hash)
		n += encoding.BytesBinarySize(v.Meta)
		n += encoding.UvarintBinarySize(uint64(len(v.To)))
	for _, v := range v.To {
	n += v.BinarySize()
	}
	return n
}
int BinarySizeSignPending(SignPending *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSignPending.ID())
	return n
}
int BinarySizeSyntheticAnchor(SyntheticAnchor *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticAnchor.ID())
		n += encoding.StringBinarySize(v.Source)
		n += encoding.BoolBinarySize(v.Major)
		n += encoding.ChainBinarySize(&v.RootAnchor)
		n += encoding.UvarintBinarySize(v.RootIndex)
		n += encoding.UvarintBinarySize(v.Block)
		n += encoding.UvarintBinarySize(v.SourceIndex)
		n += encoding.UvarintBinarySize(v.SourceBlock)
		n += v.Receipt.BinarySize()
	return n
}
int BinarySizeSyntheticBurnTokens(SyntheticBurnTokens *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticBurnTokens.ID())
		n += encoding.ChainBinarySize(&v.Cause)
		n += encoding.BigintBinarySize(&v.Amount)
	return n
}
int BinarySizeSyntheticCreateChain(SyntheticCreateChain *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticCreateChain.ID())
		n += encoding.ChainBinarySize(&v.Cause)
		n += encoding.UvarintBinarySize(uint64(len(v.Chains)))
	for _, v := range v.Chains {
	n += v.BinarySize()
	}
	return n
}
int BinarySizeSyntheticDepositCredits(SyntheticDepositCredits *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticDepositCredits.ID())
		n += encoding.ChainBinarySize(&v.Cause)
		n += encoding.UvarintBinarySize(v.Amount)
	return n
}
int BinarySizeSyntheticDepositTokens(SyntheticDepositTokens *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticDepositTokens.ID())
		n += encoding.ChainBinarySize(&v.Cause)
		n += encoding.StringBinarySize(v.Token)
		n += encoding.BigintBinarySize(&v.Amount)
	return n
}
int BinarySizeSyntheticMirror(SyntheticMirror *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticMirror.ID())
		n += encoding.UvarintBinarySize(uint64(len(v.Objects)))
	for _, v := range v.Objects {
	n += v.BinarySize()
	}
	return n
}
int BinarySizeSyntheticWriteData(SyntheticWriteData *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticWriteData.ID())
		n += encoding.ChainBinarySize(&v.Cause)
		n += v.Entry.BinarySize()
	return n
}
int BinarySizeTokenRecipient(TokenRecipient *v) {
	var n int
		n += encoding.StringBinarySize(v.Url)
		n += encoding.BigintBinarySize(&v.Amount)
	return n
}
int BinarySizeUpdateKeyPage(UpdateKeyPage *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeUpdateKeyPage.ID())
		n += v.Operation.BinarySize()
		n += encoding.BytesBinarySize(v.Key)
		n += encoding.BytesBinarySize(v.NewKey)
		n += encoding.StringBinarySize(v.Owner)
		n += encoding.UvarintBinarySize(v.Threshold)
	return n
}
int BinarySizeWriteData(WriteData *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeWriteData.ID())
		n += v.Entry.BinarySize()
	return n
}
int BinarySizeWriteDataResult(WriteDataResult *v) {
	var n int
		n += encoding.ChainBinarySize(&v.EntryHash)
		n += v.AccountUrl.BinarySize()
		n += encoding.BytesBinarySize(v.AccountID)
	return n
}
int BinarySizeWriteDataTo(WriteDataTo *v) {
	var n int
	n += encoding.UvarintBinarySize(types.TxTypeWriteDataTo.ID())
		n += encoding.StringBinarySize(v.Recipient)
		n += v.Entry.BinarySize()
	return n
}
rbytes MarshalBinaryAcmeFaucet(AcmeFaucet *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeAcmeFaucet.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Url))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryAddCredits(AddCredits *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeAddCredits.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Recipient))
		buffer.Write(encoding.UvarintMarshalBinary(v.Amount))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryAnchoredRecord(AnchoredRecord *v)  {
	var buffer bytes.Buffer
		buffer.Write(encoding.BytesMarshalBinary(v.Record))
		buffer.Write(encoding.ChainMarshalBinary(&v.Anchor))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryBurnTokens(BurnTokens *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeBurnTokens.ID()))
		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryChainParams(ChainParams *v)  {
	var buffer bytes.Buffer
		buffer.Write(encoding.BytesMarshalBinary(v.Data))
		buffer.Write(encoding.BoolMarshalBinary(v.IsUpdate))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryCreateDataAccount(CreateDataAccount *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateDataAccount.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Url))
		buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))
		buffer.Write(encoding.StringMarshalBinary(v.ManagerKeyBookUrl))
		buffer.Write(encoding.BoolMarshalBinary(v.Scratch))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryCreateIdentity(CreateIdentity *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateIdentity.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Url))
		buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))
		buffer.Write(encoding.StringMarshalBinary(v.KeyBookName))
		buffer.Write(encoding.StringMarshalBinary(v.KeyPageName))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryCreateKeyBook(CreateKeyBook *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateKeyBook.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Url))
		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Pages))))
	for i, v := range v.Pages {
		_ = i
	buffer.Write(encoding.StringMarshalBinary(v))
	}
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryCreateKeyPage(CreateKeyPage *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateKeyPage.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Url))
		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Keys))))
	for i, v := range v.Keys {
		_ = i
	if b, err := v.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Keys[%d]: %w", i,err) } else { buffer.Write(b) }
	}
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryCreateToken(CreateToken *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateToken.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Url))
		buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))
		buffer.Write(encoding.StringMarshalBinary(v.Symbol))
		buffer.Write(encoding.UvarintMarshalBinary(v.Precision))
		buffer.Write(encoding.StringMarshalBinary(v.Properties))
		buffer.Write(encoding.BigintMarshalBinary(&v.InitialSupply))
		buffer.Write(encoding.BoolMarshalBinary(v.HasSupplyLimit))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryCreateTokenAccount(CreateTokenAccount *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateTokenAccount.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Url))
		buffer.Write(encoding.StringMarshalBinary(v.TokenUrl))
		buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))
		buffer.Write(encoding.BoolMarshalBinary(v.Scratch))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryIssueTokens(IssueTokens *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeIssueTokens.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Recipient))
		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryKeySpecParams(KeySpecParams *v)  {
	var buffer bytes.Buffer
		buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySegWitDataEntry(SegWitDataEntry *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSegWitDataEntry.ID()))
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))
		buffer.Write(encoding.StringMarshalBinary(v.EntryUrl))
		buffer.Write(encoding.ChainMarshalBinary(&v.EntryHash))
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySendTokens(SendTokens *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSendTokens.ID()))
		buffer.Write(encoding.ChainMarshalBinary(&v.Hash))
		buffer.Write(encoding.BytesMarshalBinary(v.Meta))
		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.To))))
	for i, v := range v.To {
		_ = i
	if b, err := v.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding To[%d]: %w", i,err) } else { buffer.Write(b) }
	}
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySignPending(SignPending *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSignPending.ID()))
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySyntheticAnchor(SyntheticAnchor *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticAnchor.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Source))
		buffer.Write(encoding.BoolMarshalBinary(v.Major))
		buffer.Write(encoding.ChainMarshalBinary(&v.RootAnchor))
		buffer.Write(encoding.UvarintMarshalBinary(v.RootIndex))
		buffer.Write(encoding.UvarintMarshalBinary(v.Block))
		buffer.Write(encoding.UvarintMarshalBinary(v.SourceIndex))
		buffer.Write(encoding.UvarintMarshalBinary(v.SourceBlock))
		if b, err := v.Receipt.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Receipt: %w", err) } else { buffer.Write(b) }
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySyntheticBurnTokens(SyntheticBurnTokens *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticBurnTokens.ID()))
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))
		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySyntheticCreateChain(SyntheticCreateChain *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticCreateChain.ID()))
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))
		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Chains))))
	for i, v := range v.Chains {
		_ = i
	if b, err := v.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Chains[%d]: %w", i,err) } else { buffer.Write(b) }
	}
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySyntheticDepositCredits(SyntheticDepositCredits *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticDepositCredits.ID()))
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))
		buffer.Write(encoding.UvarintMarshalBinary(v.Amount))
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySyntheticDepositTokens(SyntheticDepositTokens *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticDepositTokens.ID()))
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))
		buffer.Write(encoding.StringMarshalBinary(v.Token))
		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySyntheticMirror(SyntheticMirror *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticMirror.ID()))
		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Objects))))
	for i, v := range v.Objects {
		_ = i
	if b, err := v.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Objects[%d]: %w", i,err) } else { buffer.Write(b) }
	}
	return buffer.Bytes(), nil
}
rbytes MarshalBinarySyntheticWriteData(SyntheticWriteData *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticWriteData.ID()))
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))
		if b, err := v.Entry.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Entry: %w", err) } else { buffer.Write(b) }
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryTokenRecipient(TokenRecipient *v)  {
	var buffer bytes.Buffer
		buffer.Write(encoding.StringMarshalBinary(v.Url))
		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryUpdateKeyPage(UpdateKeyPage *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeUpdateKeyPage.ID()))
		if b, err := v.Operation.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Operation: %w", err) } else { buffer.Write(b) }
		buffer.Write(encoding.BytesMarshalBinary(v.Key))
		buffer.Write(encoding.BytesMarshalBinary(v.NewKey))
		buffer.Write(encoding.StringMarshalBinary(v.Owner))
		buffer.Write(encoding.UvarintMarshalBinary(v.Threshold))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryWriteData(WriteData *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeWriteData.ID()))
		if b, err := v.Entry.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Entry: %w", err) } else { buffer.Write(b) }
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryWriteDataResult(WriteDataResult *v)  {
	var buffer bytes.Buffer
		buffer.Write(encoding.ChainMarshalBinary(&v.EntryHash))
		if b, err := v.AccountUrl.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding AccountUrl: %w", err) } else { buffer.Write(b) }
		buffer.Write(encoding.BytesMarshalBinary(v.AccountID))
	return buffer.Bytes(), nil
}
rbytes MarshalBinaryWriteDataTo(WriteDataTo *v)  {
	var buffer bytes.Buffer
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeWriteDataTo.ID()))
		buffer.Write(encoding.StringMarshalBinary(v.Recipient))
		if b, err := v.Entry.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Entry: %w", err) } else { buffer.Write(b) }
	return buffer.Bytes(), nil
}
error UnmarshalBinaryAcmeFaucet(AcmeFaucet*v, data []byte) {
	typ := types.TxTypeAcmeFaucet
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]
	return nil
}
error UnmarshalBinaryAddCredits(AddCredits*v, data []byte) {
	typ := types.TxTypeAddCredits
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Recipient: %w", err) } else { v.Recipient = x }
	data = data[encoding.StringBinarySize(v.Recipient):]
		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount = x }
	data = data[encoding.UvarintBinarySize(v.Amount):]
	return nil
}
error UnmarshalBinaryAnchoredRecord(AnchoredRecord*v, data []byte) {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Record: %w", err) } else { v.Record = x }
	data = data[encoding.BytesBinarySize(v.Record):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Anchor: %w", err) } else { v.Anchor = x }
	data = data[encoding.ChainBinarySize(&v.Anchor):]
	return nil
}
error UnmarshalBinaryBurnTokens(BurnTokens*v, data []byte) {
	typ := types.TxTypeBurnTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]
	return nil
}
error UnmarshalBinaryChainParams(ChainParams*v, data []byte) {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Data: %w", err) } else { v.Data = x }
	data = data[encoding.BytesBinarySize(v.Data):]
		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding IsUpdate: %w", err) } else { v.IsUpdate = x }
	data = data[encoding.BoolBinarySize(v.IsUpdate):]
	return nil
}
error UnmarshalBinaryCreateDataAccount(CreateDataAccount*v, data []byte) {
	typ := types.TxTypeCreateDataAccount
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyBookUrl: %w", err) } else { v.KeyBookUrl = x }
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding ManagerKeyBookUrl: %w", err) } else { v.ManagerKeyBookUrl = x }
	data = data[encoding.StringBinarySize(v.ManagerKeyBookUrl):]
		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Scratch: %w", err) } else { v.Scratch = x }
	data = data[encoding.BoolBinarySize(v.Scratch):]
	return nil
}
error UnmarshalBinaryCreateIdentity(CreateIdentity*v, data []byte) {
	typ := types.TxTypeCreateIdentity
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding PublicKey: %w", err) } else { v.PublicKey = x }
	data = data[encoding.BytesBinarySize(v.PublicKey):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyBookName: %w", err) } else { v.KeyBookName = x }
	data = data[encoding.StringBinarySize(v.KeyBookName):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyPageName: %w", err) } else { v.KeyPageName = x }
	data = data[encoding.StringBinarySize(v.KeyPageName):]
	return nil
}
error UnmarshalBinaryCreateKeyBook(CreateKeyBook*v, data []byte) {
	typ := types.TxTypeCreateKeyBook
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]
	var lenPages uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Pages: %w", err) } else { lenPages = x }
	data = data[encoding.UvarintBinarySize(lenPages):]
	v.Pages = make(string[], lenPages)
	for i := range v.Pages {
	if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Pages[%d]: %w", i,err) } else { v.Pages[i] = x }
	data = data[encoding.StringBinarySize(v.Pages[i]):]
	}
	return nil
}
error UnmarshalBinaryCreateKeyPage(CreateKeyPage*v, data []byte) {
	typ := types.TxTypeCreateKeyPage
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]
	var lenKeys uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Keys: %w", err) } else { lenKeys = x }
	data = data[encoding.UvarintBinarySize(lenKeys):]
	v.Keys = make(*KeySpecParams[], lenKeys)
	for i := range v.Keys {
		var x *KeySpecParams
	x = new(KeySpecParams)
	if err := x.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Keys[%d]: %w", i,err) }
	data = data[x.BinarySize():]
		v.Keys[i] = x	}
	return nil
}
error UnmarshalBinaryCreateToken(CreateToken*v, data []byte) {
	typ := types.TxTypeCreateToken
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyBookUrl: %w", err) } else { v.KeyBookUrl = x }
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Symbol: %w", err) } else { v.Symbol = x }
	data = data[encoding.StringBinarySize(v.Symbol):]
		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Precision: %w", err) } else { v.Precision = x }
	data = data[encoding.UvarintBinarySize(v.Precision):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Properties: %w", err) } else { v.Properties = x }
	data = data[encoding.StringBinarySize(v.Properties):]
		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding InitialSupply: %w", err) } else { v.InitialSupply.Set(x) }
	data = data[encoding.BigintBinarySize(&v.InitialSupply):]
		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding HasSupplyLimit: %w", err) } else { v.HasSupplyLimit = x }
	data = data[encoding.BoolBinarySize(v.HasSupplyLimit):]
	return nil
}
error UnmarshalBinaryCreateTokenAccount(CreateTokenAccount*v, data []byte) {
	typ := types.TxTypeCreateTokenAccount
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding TokenUrl: %w", err) } else { v.TokenUrl = x }
	data = data[encoding.StringBinarySize(v.TokenUrl):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyBookUrl: %w", err) } else { v.KeyBookUrl = x }
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]
		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Scratch: %w", err) } else { v.Scratch = x }
	data = data[encoding.BoolBinarySize(v.Scratch):]
	return nil
}
error UnmarshalBinaryIssueTokens(IssueTokens*v, data []byte) {
	typ := types.TxTypeIssueTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Recipient: %w", err) } else { v.Recipient = x }
	data = data[encoding.StringBinarySize(v.Recipient):]
		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]
	return nil
}
error UnmarshalBinaryKeySpecParams(KeySpecParams*v, data []byte) {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding PublicKey: %w", err) } else { v.PublicKey = x }
	data = data[encoding.BytesBinarySize(v.PublicKey):]
	return nil
}
error UnmarshalBinarySegWitDataEntry(SegWitDataEntry*v, data []byte) {
	typ := types.TxTypeSegWitDataEntry
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding EntryUrl: %w", err) } else { v.EntryUrl = x }
	data = data[encoding.StringBinarySize(v.EntryUrl):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding EntryHash: %w", err) } else { v.EntryHash = x }
	data = data[encoding.ChainBinarySize(&v.EntryHash):]
	return nil
}
error UnmarshalBinarySendTokens(SendTokens*v, data []byte) {
	typ := types.TxTypeSendTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Hash: %w", err) } else { v.Hash = x }
	data = data[encoding.ChainBinarySize(&v.Hash):]
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Meta: %w", err) } else { v.Meta = x }
	data = data[encoding.BytesBinarySize(v.Meta):]
	var lenTo uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding To: %w", err) } else { lenTo = x }
	data = data[encoding.UvarintBinarySize(lenTo):]
	v.To = make(*TokenRecipient[], lenTo)
	for i := range v.To {
		var x *TokenRecipient
	x = new(TokenRecipient)
	if err := x.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding To[%d]: %w", i,err) }
	data = data[x.BinarySize():]
		v.To[i] = x	}
	return nil
}
error UnmarshalBinarySignPending(SignPending*v, data []byte) {
	typ := types.TxTypeSignPending
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	return nil
}
error UnmarshalBinarySyntheticAnchor(SyntheticAnchor*v, data []byte) {
	typ := types.TxTypeSyntheticAnchor
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Source: %w", err) } else { v.Source = x }
	data = data[encoding.StringBinarySize(v.Source):]
		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Major: %w", err) } else { v.Major = x }
	data = data[encoding.BoolBinarySize(v.Major):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding RootAnchor: %w", err) } else { v.RootAnchor = x }
	data = data[encoding.ChainBinarySize(&v.RootAnchor):]
		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding RootIndex: %w", err) } else { v.RootIndex = x }
	data = data[encoding.UvarintBinarySize(v.RootIndex):]
		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Block: %w", err) } else { v.Block = x }
	data = data[encoding.UvarintBinarySize(v.Block):]
		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding SourceIndex: %w", err) } else { v.SourceIndex = x }
	data = data[encoding.UvarintBinarySize(v.SourceIndex):]
		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding SourceBlock: %w", err) } else { v.SourceBlock = x }
	data = data[encoding.UvarintBinarySize(v.SourceBlock):]
		if err := v.Receipt.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Receipt: %w", err) }
	data = data[v.Receipt.BinarySize():]
	return nil
}
error UnmarshalBinarySyntheticBurnTokens(SyntheticBurnTokens*v, data []byte) {
	typ := types.TxTypeSyntheticBurnTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]
		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]
	return nil
}
error UnmarshalBinarySyntheticCreateChain(SyntheticCreateChain*v, data []byte) {
	typ := types.TxTypeSyntheticCreateChain
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]
	var lenChains uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Chains: %w", err) } else { lenChains = x }
	data = data[encoding.UvarintBinarySize(lenChains):]
	v.Chains = make(ChainParams[], lenChains)
	for i := range v.Chains {
	if err := v.Chains[i].UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Chains[%d]: %w", i,err) }
	data = data[v.Chains[i].BinarySize():]
	}
	return nil
}
error UnmarshalBinarySyntheticDepositCredits(SyntheticDepositCredits*v, data []byte) {
	typ := types.TxTypeSyntheticDepositCredits
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]
		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount = x }
	data = data[encoding.UvarintBinarySize(v.Amount):]
	return nil
}
error UnmarshalBinarySyntheticDepositTokens(SyntheticDepositTokens*v, data []byte) {
	typ := types.TxTypeSyntheticDepositTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Token: %w", err) } else { v.Token = x }
	data = data[encoding.StringBinarySize(v.Token):]
		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]
	return nil
}
error UnmarshalBinarySyntheticMirror(SyntheticMirror*v, data []byte) {
	typ := types.TxTypeSyntheticMirror
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	var lenObjects uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Objects: %w", err) } else { lenObjects = x }
	data = data[encoding.UvarintBinarySize(lenObjects):]
	v.Objects = make(AnchoredRecord[], lenObjects)
	for i := range v.Objects {
	if err := v.Objects[i].UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Objects[%d]: %w", i,err) }
	data = data[v.Objects[i].BinarySize():]
	}
	return nil
}
error UnmarshalBinarySyntheticWriteData(SyntheticWriteData*v, data []byte) {
	typ := types.TxTypeSyntheticWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]
		if err := v.Entry.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Entry: %w", err) }
	data = data[v.Entry.BinarySize():]
	return nil
}
error UnmarshalBinaryTokenRecipient(TokenRecipient*v, data []byte) {
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]
		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]
	return nil
}
error UnmarshalBinaryUpdateKeyPage(UpdateKeyPage*v, data []byte) {
	typ := types.TxTypeUpdateKeyPage
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if err := v.Operation.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Operation: %w", err) }
	data = data[v.Operation.BinarySize():]
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Key: %w", err) } else { v.Key = x }
	data = data[encoding.BytesBinarySize(v.Key):]
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding NewKey: %w", err) } else { v.NewKey = x }
	data = data[encoding.BytesBinarySize(v.NewKey):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Owner: %w", err) } else { v.Owner = x }
	data = data[encoding.StringBinarySize(v.Owner):]
		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Threshold: %w", err) } else { v.Threshold = x }
	data = data[encoding.UvarintBinarySize(v.Threshold):]
	return nil
}
error UnmarshalBinaryWriteData(WriteData*v, data []byte) {
	typ := types.TxTypeWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if err := v.Entry.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Entry: %w", err) }
	data = data[v.Entry.BinarySize():]
	return nil
}
error UnmarshalBinaryWriteDataResult(WriteDataResult*v, data []byte) {
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding EntryHash: %w", err) } else { v.EntryHash = x }
	data = data[encoding.ChainBinarySize(&v.EntryHash):]
		v.AccountUrl = new(url.URL)
	if err := v.AccountUrl.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding AccountUrl: %w", err) }
	data = data[v.AccountUrl.BinarySize():]
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding AccountID: %w", err) } else { v.AccountID = x }
	data = data[encoding.BytesBinarySize(v.AccountID):]
	return nil
}
error UnmarshalBinaryWriteDataTo(WriteDataTo*v, data []byte) {
	typ := types.TxTypeWriteDataTo
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Recipient: %w", err) } else { v.Recipient = x }
	data = data[encoding.StringBinarySize(v.Recipient):]
		if err := v.Entry.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Entry: %w", err) }
	data = data[v.Entry.BinarySize():]
	return nil
}
rbytes MarshalJSONAnchoredRecord(AnchoredRecord *v) {
	u := struct {
	Record String* `json:"record,omitempty"`
	Anchor String `json:"anchor,omitempty"`
}{}
		u.Record = encoding.BytesToJSON(v.Record)
		u.Anchor = encoding.ChainToJSON(v.Anchor)
	return json.Marshal(&u)
}
rbytes MarshalJSONBurnTokens(BurnTokens *v) {
	u := struct {
	Amount String* `json:"amount,omitempty"`
}{}
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}
rbytes MarshalJSONChainParams(ChainParams *v) {
	u := struct {
	Data String* `json:"data,omitempty"`
	IsUpdate bool `json:"isUpdate,omitempty"`
}{}
		u.Data = encoding.BytesToJSON(v.Data)
		u.IsUpdate = v.IsUpdate
	return json.Marshal(&u)
}
rbytes MarshalJSONCreateIdentity(CreateIdentity *v) {
	u := struct {
	Url string `json:"url,omitempty"`
	PublicKey String* `json:"publicKey,omitempty"`
	KeyBookName string `json:"keyBookName,omitempty"`
	KeyPageName string `json:"keyPageName,omitempty"`
}{}
		u.Url = v.Url
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
		u.KeyBookName = v.KeyBookName
		u.KeyPageName = v.KeyPageName
	return json.Marshal(&u)
}
rbytes MarshalJSONCreateToken(CreateToken *v) {
	u := struct {
	Url string `json:"url,omitempty"`
	KeyBookUrl string `json:"keyBookUrl,omitempty"`
	Symbol string `json:"symbol,omitempty"`
	Precision uint64_t `json:"precision,omitempty"`
	Properties string `json:"properties,omitempty"`
	InitialSupply String* `json:"initialSupply,omitempty"`
	HasSupplyLimit bool `json:"hasSupplyLimit,omitempty"`
}{}
		u.Url = v.Url
		u.KeyBookUrl = v.KeyBookUrl
		u.Symbol = v.Symbol
		u.Precision = v.Precision
		u.Properties = v.Properties
		u.InitialSupply = encoding.BigintToJSON(&v.InitialSupply)
		u.HasSupplyLimit = v.HasSupplyLimit
	return json.Marshal(&u)
}
rbytes MarshalJSONIssueTokens(IssueTokens *v) {
	u := struct {
	Recipient string `json:"recipient,omitempty"`
	Amount String* `json:"amount,omitempty"`
}{}
		u.Recipient = v.Recipient
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}
rbytes MarshalJSONKeySpecParams(KeySpecParams *v) {
	u := struct {
	PublicKey String* `json:"publicKey,omitempty"`
}{}
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	return json.Marshal(&u)
}
rbytes MarshalJSONSegWitDataEntry(SegWitDataEntry *v) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	EntryUrl string `json:"entryUrl,omitempty"`
	EntryHash String `json:"entryHash,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.EntryUrl = v.EntryUrl
		u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}
rbytes MarshalJSONSendTokens(SendTokens *v) {
	u := struct {
	Hash String `json:"hash,omitempty"`
	Meta json.RawMessage `json:"meta,omitempty"`
	To *TokenRecipient[] `json:"to,omitempty"`
}{}
		u.Hash = encoding.ChainToJSON(v.Hash)
		u.Meta = v.Meta
		u.To = v.To
	return json.Marshal(&u)
}
rbytes MarshalJSONSyntheticAnchor(SyntheticAnchor *v) {
	u := struct {
	Source string `json:"source,omitempty"`
	Major bool `json:"major,omitempty"`
	RootAnchor String `json:"rootAnchor,omitempty"`
	RootIndex uint64_t `json:"rootIndex,omitempty"`
	Block uint64_t `json:"block,omitempty"`
	SourceIndex uint64_t `json:"sourceIndex,omitempty"`
	SourceBlock uint64_t `json:"sourceBlock,omitempty"`
	Receipt Receipt `json:"receipt,omitempty"`
}{}
		u.Source = v.Source
		u.Major = v.Major
		u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
		u.RootIndex = v.RootIndex
		u.Block = v.Block
		u.SourceIndex = v.SourceIndex
		u.SourceBlock = v.SourceBlock
		u.Receipt = v.Receipt
	return json.Marshal(&u)
}
rbytes MarshalJSONSyntheticBurnTokens(SyntheticBurnTokens *v) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Amount String* `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}
rbytes MarshalJSONSyntheticCreateChain(SyntheticCreateChain *v) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Chains ChainParams[] `json:"chains,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Chains = v.Chains
	return json.Marshal(&u)
}
rbytes MarshalJSONSyntheticDepositCredits(SyntheticDepositCredits *v) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Amount uint64_t `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Amount = v.Amount
	return json.Marshal(&u)
}
rbytes MarshalJSONSyntheticDepositTokens(SyntheticDepositTokens *v) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Token string `json:"token,omitempty"`
	Amount String* `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Token = v.Token
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}
rbytes MarshalJSONSyntheticWriteData(SyntheticWriteData *v) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Entry DataEntry `json:"entry,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Entry = v.Entry
	return json.Marshal(&u)
}
rbytes MarshalJSONTokenRecipient(TokenRecipient *v) {
	u := struct {
	Url string `json:"url,omitempty"`
	Amount String* `json:"amount,omitempty"`
}{}
		u.Url = v.Url
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}
rbytes MarshalJSONUpdateKeyPage(UpdateKeyPage *v) {
	u := struct {
	Operation KeyPageOperation `json:"operation,omitempty"`
	Key String* `json:"key,omitempty"`
	NewKey String* `json:"newKey,omitempty"`
	Owner string `json:"owner,omitempty"`
	Threshold uint64_t `json:"threshold,omitempty"`
}{}
		u.Operation = v.Operation
		u.Key = encoding.BytesToJSON(v.Key)
		u.NewKey = encoding.BytesToJSON(v.NewKey)
		u.Owner = v.Owner
		u.Threshold = v.Threshold
	return json.Marshal(&u)
}
rbytes MarshalJSONWriteDataResult(WriteDataResult *v) {
	u := struct {
	EntryHash String `json:"entryHash,omitempty"`
	AccountUrl *url.URL `json:"accountUrl,omitempty"`
	AccountID String* `json:"accountID,omitempty"`
}{}
		u.EntryHash = encoding.ChainToJSON(v.EntryHash)
		u.AccountUrl = v.AccountUrl
		u.AccountID = encoding.BytesToJSON(v.AccountID)
	return json.Marshal(&u)
}
error UnmarshalJSONAnchoredRecord(AnchoredRecord *v,data []byte) {
	u := struct {
	Record String* `json:"record,omitempty"`
	Anchor String `json:"anchor,omitempty"`
}{}
		u.Record = encoding.BytesToJSON(v.Record)
		u.Anchor = encoding.ChainToJSON(v.Anchor)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.BytesFromJSON(u.Record); err != nil {
		return fmt.Errorf("error decoding Record: %w", err)
	} else {
		v.Record = x
	}
		if x, err := encoding.ChainFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Anchor = x
	}
	return nil
}
error UnmarshalJSONBurnTokens(BurnTokens *v,data []byte) {
	u := struct {
	Amount String* `json:"amount,omitempty"`
}{}
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}
error UnmarshalJSONChainParams(ChainParams *v,data []byte) {
	u := struct {
	Data String* `json:"data,omitempty"`
	IsUpdate bool `json:"isUpdate,omitempty"`
}{}
		u.Data = encoding.BytesToJSON(v.Data)
		u.IsUpdate = v.IsUpdate
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
		v.IsUpdate = u.IsUpdate
	return nil
}
error UnmarshalJSONCreateIdentity(CreateIdentity *v,data []byte) {
	u := struct {
	Url string `json:"url,omitempty"`
	PublicKey String* `json:"publicKey,omitempty"`
	KeyBookName string `json:"keyBookName,omitempty"`
	KeyPageName string `json:"keyPageName,omitempty"`
}{}
		u.Url = v.Url
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
		u.KeyBookName = v.KeyBookName
		u.KeyPageName = v.KeyPageName
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Url = u.Url
		if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
		v.KeyBookName = u.KeyBookName
		v.KeyPageName = u.KeyPageName
	return nil
}
error UnmarshalJSONCreateToken(CreateToken *v,data []byte) {
	u := struct {
	Url string `json:"url,omitempty"`
	KeyBookUrl string `json:"keyBookUrl,omitempty"`
	Symbol string `json:"symbol,omitempty"`
	Precision uint64_t `json:"precision,omitempty"`
	Properties string `json:"properties,omitempty"`
	InitialSupply String* `json:"initialSupply,omitempty"`
	HasSupplyLimit bool `json:"hasSupplyLimit,omitempty"`
}{}
		u.Url = v.Url
		u.KeyBookUrl = v.KeyBookUrl
		u.Symbol = v.Symbol
		u.Precision = v.Precision
		u.Properties = v.Properties
		u.InitialSupply = encoding.BigintToJSON(&v.InitialSupply)
		u.HasSupplyLimit = v.HasSupplyLimit
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Url = u.Url
		v.KeyBookUrl = u.KeyBookUrl
		v.Symbol = u.Symbol
		v.Precision = u.Precision
		v.Properties = u.Properties
		if x, err := encoding.BigintFromJSON(u.InitialSupply); err != nil {
		return fmt.Errorf("error decoding InitialSupply: %w", err)
	} else {
		v.InitialSupply = *x
	}
		v.HasSupplyLimit = u.HasSupplyLimit
	return nil
}
error UnmarshalJSONIssueTokens(IssueTokens *v,data []byte) {
	u := struct {
	Recipient string `json:"recipient,omitempty"`
	Amount String* `json:"amount,omitempty"`
}{}
		u.Recipient = v.Recipient
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Recipient = u.Recipient
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}
error UnmarshalJSONKeySpecParams(KeySpecParams *v,data []byte) {
	u := struct {
	PublicKey String* `json:"publicKey,omitempty"`
}{}
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	return nil
}
error UnmarshalJSONSegWitDataEntry(SegWitDataEntry *v,data []byte) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	EntryUrl string `json:"entryUrl,omitempty"`
	EntryHash String `json:"entryHash,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.EntryUrl = v.EntryUrl
		u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.EntryUrl = u.EntryUrl
		if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}
error UnmarshalJSONSendTokens(SendTokens *v,data []byte) {
	u := struct {
	Hash String `json:"hash,omitempty"`
	Meta json.RawMessage `json:"meta,omitempty"`
	To *TokenRecipient[] `json:"to,omitempty"`
}{}
		u.Hash = encoding.ChainToJSON(v.Hash)
		u.Meta = v.Meta
		u.To = v.To
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
		v.Meta = u.Meta
		v.To = u.To
	return nil
}
error UnmarshalJSONSyntheticAnchor(SyntheticAnchor *v,data []byte) {
	u := struct {
	Source string `json:"source,omitempty"`
	Major bool `json:"major,omitempty"`
	RootAnchor String `json:"rootAnchor,omitempty"`
	RootIndex uint64_t `json:"rootIndex,omitempty"`
	Block uint64_t `json:"block,omitempty"`
	SourceIndex uint64_t `json:"sourceIndex,omitempty"`
	SourceBlock uint64_t `json:"sourceBlock,omitempty"`
	Receipt Receipt `json:"receipt,omitempty"`
}{}
		u.Source = v.Source
		u.Major = v.Major
		u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
		u.RootIndex = v.RootIndex
		u.Block = v.Block
		u.SourceIndex = v.SourceIndex
		u.SourceBlock = v.SourceBlock
		u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Source = u.Source
		v.Major = u.Major
		if x, err := encoding.ChainFromJSON(u.RootAnchor); err != nil {
		return fmt.Errorf("error decoding RootAnchor: %w", err)
	} else {
		v.RootAnchor = x
	}
		v.RootIndex = u.RootIndex
		v.Block = u.Block
		v.SourceIndex = u.SourceIndex
		v.SourceBlock = u.SourceBlock
		v.Receipt = u.Receipt
	return nil
}
error UnmarshalJSONSyntheticBurnTokens(SyntheticBurnTokens *v,data []byte) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Amount String* `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}
error UnmarshalJSONSyntheticCreateChain(SyntheticCreateChain *v,data []byte) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Chains ChainParams[] `json:"chains,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Chains = v.Chains
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.Chains = u.Chains
	return nil
}
error UnmarshalJSONSyntheticDepositCredits(SyntheticDepositCredits *v,data []byte) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Amount uint64_t `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Amount = v.Amount
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.Amount = u.Amount
	return nil
}
error UnmarshalJSONSyntheticDepositTokens(SyntheticDepositTokens *v,data []byte) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Token string `json:"token,omitempty"`
	Amount String* `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Token = v.Token
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.Token = u.Token
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}
error UnmarshalJSONSyntheticWriteData(SyntheticWriteData *v,data []byte) {
	u := struct {
	Cause String `json:"cause,omitempty"`
	Entry DataEntry `json:"entry,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.Entry = u.Entry
	return nil
}
error UnmarshalJSONTokenRecipient(TokenRecipient *v,data []byte) {
	u := struct {
	Url string `json:"url,omitempty"`
	Amount String* `json:"amount,omitempty"`
}{}
		u.Url = v.Url
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Url = u.Url
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}
error UnmarshalJSONUpdateKeyPage(UpdateKeyPage *v,data []byte) {
	u := struct {
	Operation KeyPageOperation `json:"operation,omitempty"`
	Key String* `json:"key,omitempty"`
	NewKey String* `json:"newKey,omitempty"`
	Owner string `json:"owner,omitempty"`
	Threshold uint64_t `json:"threshold,omitempty"`
}{}
		u.Operation = v.Operation
		u.Key = encoding.BytesToJSON(v.Key)
		u.NewKey = encoding.BytesToJSON(v.NewKey)
		u.Owner = v.Owner
		u.Threshold = v.Threshold
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Operation = u.Operation
		if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
		if x, err := encoding.BytesFromJSON(u.NewKey); err != nil {
		return fmt.Errorf("error decoding NewKey: %w", err)
	} else {
		v.NewKey = x
	}
		v.Owner = u.Owner
		v.Threshold = u.Threshold
	return nil
}
error UnmarshalJSONWriteDataResult(WriteDataResult *v,data []byte) {
	u := struct {
	EntryHash String `json:"entryHash,omitempty"`
	AccountUrl *url.URL `json:"accountUrl,omitempty"`
	AccountID String* `json:"accountID,omitempty"`
}{}
		u.EntryHash = encoding.ChainToJSON(v.EntryHash)
		u.AccountUrl = v.AccountUrl
		u.AccountID = encoding.BytesToJSON(v.AccountID)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
		v.AccountUrl = u.AccountUrl
		if x, err := encoding.BytesFromJSON(u.AccountID); err != nil {
		return fmt.Errorf("error decoding AccountID: %w", err)
	} else {
		v.AccountID = x
	}
	return nil
}
