#ifndef protocol_H
#define protocol_H

// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.


#include <jsmn.h>
#include <encoding.h>
#include <transactions.h>
#include <types.h>
#include <url.h>
#include <state.h>
#include <big.h>
#include "types/state.h"
#include "types/api/transactions"


struct AcmeFaucet {
	
	string Url ; //`json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
};

struct AddCredits {
	
	string Recipient ; //`json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	uint64 Amount ; //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
};

struct AnchoredRecord {
	
	[]byte Record ; //`json:"record,omitempty" form:"record" query:"record" validate:"required"`
	[32]byte Anchor ; //`json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
};

struct BurnTokens {
	
	big.Int Amount ; //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
};

struct ChainParams {
	
	[]byte Data ; //`json:"data,omitempty" form:"data" query:"data" validate:"required"`
	bool IsUpdate ; //`json:"isUpdate,omitempty" form:"isUpdate" query:"isUpdate" validate:"required"`
};

struct CreateDataAccount {
	
	string Url ; //`json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	string KeyBookUrl ; //`json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl" validate:"acc-url"`
	string ManagerKeyBookUrl ; //`json:"managerKeyBookUrl,omitempty" form:"managerKeyBookUrl" query:"managerKeyBookUrl" validate:"acc-url"`
};

struct CreateIdentity {
	
	string Url ; //`json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	[]byte PublicKey ; //`json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	string KeyBookName ; //`json:"keyBookName,omitempty" form:"keyBookName" query:"keyBookName"`
	string KeyPageName ; //`json:"keyPageName,omitempty" form:"keyPageName" query:"keyPageName"`
};

struct CreateKeyBook {
	
	string Url ; //`json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	[]string Pages ; //`json:"pages,omitempty" form:"pages" query:"pages" validate:"required"`
};

struct CreateKeyPage {
	
	string Url ; //`json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	[]*KeySpecParams Keys ; //`json:"keys,omitempty" form:"keys" query:"keys" validate:"required"`
};

struct CreateToken {
	
	string Url ; //`json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	string KeyBookUrl ; //`json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl" validate:"acc-url"`
	string Symbol ; //`json:"symbol,omitempty" form:"symbol" query:"symbol" validate:"required"`
	uint64 Precision ; //`json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	string Properties ; //`json:"properties,omitempty" form:"properties" query:"properties" validate:"acc-url"`
	big.Int InitialSupply ; //`json:"initialSupply,omitempty" form:"initialSupply" query:"initialSupply"`
	bool HasSupplyLimit ; //`json:"hasSupplyLimit,omitempty" form:"hasSupplyLimit" query:"hasSupplyLimit"`
};

struct CreateTokenAccount {
	
	string Url ; //`json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	string TokenUrl ; //`json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required,acc-url"`
	string KeyBookUrl ; //`json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl" validate:"acc-url"`
};

struct IssueTokens {
	
	string Recipient ; //`json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required,acc-url"`
	big.Int Amount ; //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
};

struct KeySpecParams {
	
	[]byte PublicKey ; //`json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
};

struct SegWitDataEntry {
	
	[32]byte Cause ; //`json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	string EntryUrl ; //`json:"entryUrl,omitempty" form:"entryUrl" query:"entryUrl" validate:"required,acc-url"`
	[32]byte EntryHash ; //`json:"entryHash,omitempty" form:"entryHash" query:"entryHash" validate:"required"`
};

struct SendTokens {
	
	[32]byte Hash ; //`json:"hash,omitempty" form:"hash" query:"hash"`
	json.RawMessage Meta ; //`json:"meta,omitempty" form:"meta" query:"meta"`
	[]*TokenRecipient To ; //`json:"to,omitempty" form:"to" query:"to" validate:"required"`
};

struct SyntheticAnchor {
	
	string Source ; //`json:"source,omitempty" form:"source" query:"source" validate:"required,acc-url"`
	bool Major ; //`json:"major,omitempty" form:"major" query:"major" validate:"required"`
	[32]byte RootAnchor ; //`json:"rootAnchor,omitempty" form:"rootAnchor" query:"rootAnchor" validate:"required"`
	uint64 RootIndex ; //`json:"rootIndex,omitempty" form:"rootIndex" query:"rootIndex" validate:"required"`
	uint64 SourceIndex ; //`json:"sourceIndex,omitempty" form:"sourceIndex" query:"sourceIndex" validate:"required"`
	Receipt Receipt ; //`json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
};

struct SyntheticBurnTokens {
	
	[32]byte Cause ; //`json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	big.Int Amount ; //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
};

struct SyntheticCreateChain {
	
	[32]byte Cause ; //`json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	[]ChainParams Chains ; //`json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
};

struct SyntheticDepositCredits {
	
	[32]byte Cause ; //`json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	uint64 Amount ; //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
};

struct SyntheticDepositTokens {
	
	[32]byte Cause ; //`json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	string Token ; //`json:"token,omitempty" form:"token" query:"token" validate:"required,acc-url"`
	big.Int Amount ; //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
};

struct SyntheticMirror {
	
	[]AnchoredRecord Objects ; //`json:"objects,omitempty" form:"objects" query:"objects" validate:"required"`
};

struct SyntheticWriteData {
	
	[32]byte Cause ; //`json:"cause,omitempty" form:"cause" query:"cause" validate:"required"`
	DataEntry Entry ; //`json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
};

struct TokenRecipient {
	
	string Url ; //`json:"url,omitempty" form:"url" query:"url" validate:"required,acc-url"`
	big.Int Amount ; //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
};

struct UpdateKeyPage {
	
	KeyPageOperation Operation ; //`json:"operation,omitempty" form:"operation" query:"operation" validate:"required"`
	[]byte Key ; //`json:"key,omitempty" form:"key" query:"key"`
	[]byte NewKey ; //`json:"newKey,omitempty" form:"newKey" query:"newKey"`
	string Owner ; //`json:"owner,omitempty" form:"owner" query:"owner"`
	uint64 Threshold ; //`json:"threshold,omitempty" form:"threshold" query:"threshold"`
};

struct WriteData {
	
	DataEntry Entry ; //`json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
};

struct WriteDataTo {
	
	string Recipient ; //`json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required,acc-url"`
	DataEntry Entry ; //`json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
};































func (*AcmeFaucet) GetType() types.TransactionType { return types.TxTypeAcmeFaucet }

func (*AddCredits) GetType() types.TransactionType { return types.TxTypeAddCredits }

func (*BurnTokens) GetType() types.TransactionType { return types.TxTypeBurnTokens }

func (*CreateDataAccount) GetType() types.TransactionType { return types.TxTypeCreateDataAccount }

func (*CreateIdentity) GetType() types.TransactionType { return types.TxTypeCreateIdentity }

func (*CreateKeyBook) GetType() types.TransactionType { return types.TxTypeCreateKeyBook }

func (*CreateKeyPage) GetType() types.TransactionType { return types.TxTypeCreateKeyPage }

func (*CreateToken) GetType() types.TransactionType { return types.TxTypeCreateToken }

func (*CreateTokenAccount) GetType() types.TransactionType { return types.TxTypeCreateTokenAccount }

func (*IssueTokens) GetType() types.TransactionType { return types.TxTypeIssueTokens }

func (*SegWitDataEntry) GetType() types.TransactionType { return types.TxTypeSegWitDataEntry }

func (*SendTokens) GetType() types.TransactionType { return types.TxTypeSendTokens }

func (*SyntheticAnchor) GetType() types.TransactionType { return types.TxTypeSyntheticAnchor }

func (*SyntheticBurnTokens) GetType() types.TransactionType { return types.TxTypeSyntheticBurnTokens }

func (*SyntheticCreateChain) GetType() types.TransactionType { return types.TxTypeSyntheticCreateChain }

func (*SyntheticDepositCredits) GetType() types.TransactionType { return types.TxTypeSyntheticDepositCredits }

func (*SyntheticDepositTokens) GetType() types.TransactionType { return types.TxTypeSyntheticDepositTokens }

func (*SyntheticMirror) GetType() types.TransactionType { return types.TxTypeSyntheticMirror }

func (*SyntheticWriteData) GetType() types.TransactionType { return types.TxTypeSyntheticWriteData }

func (*UpdateKeyPage) GetType() types.TransactionType { return types.TxTypeUpdateKeyPage }

func (*WriteData) GetType() types.TransactionType { return types.TxTypeWriteData }

func (*WriteDataTo) GetType() types.TransactionType { return types.TxTypeWriteDataTo }



func (v *AcmeFaucet) Equal(u *AcmeFaucet) bool {
		if !(v.Url == u.Url) { return false }




	return true
}

func (v *AddCredits) Equal(u *AddCredits) bool {
		if !(v.Recipient == u.Recipient) { return false }



		if !(v.Amount == u.Amount) { return false }




	return true
}

func (v *AnchoredRecord) Equal(u *AnchoredRecord) bool {
		if !(bytes.Equal(v.Record, u.Record)) { return false }



		if !(v.Anchor == u.Anchor) { return false }




	return true
}

func (v *BurnTokens) Equal(u *BurnTokens) bool {
		if !(v.Amount.Cmp(&u.Amount) == 0) { return false }




	return true
}

func (v *ChainParams) Equal(u *ChainParams) bool {
		if !(bytes.Equal(v.Data, u.Data)) { return false }



		if !(v.IsUpdate == u.IsUpdate) { return false }




	return true
}

func (v *CreateDataAccount) Equal(u *CreateDataAccount) bool {
		if !(v.Url == u.Url) { return false }



		if !(v.KeyBookUrl == u.KeyBookUrl) { return false }



		if !(v.ManagerKeyBookUrl == u.ManagerKeyBookUrl) { return false }




	return true
}

func (v *CreateIdentity) Equal(u *CreateIdentity) bool {
		if !(v.Url == u.Url) { return false }



		if !(bytes.Equal(v.PublicKey, u.PublicKey)) { return false }



		if !(v.KeyBookName == u.KeyBookName) { return false }



		if !(v.KeyPageName == u.KeyPageName) { return false }




	return true
}

func (v *CreateKeyBook) Equal(u *CreateKeyBook) bool {
		if !(v.Url == u.Url) { return false }



		if !(len(v.Pages) == len(u.Pages)) { return false }

	for i := range v.Pages {
		v, u := v.Pages[i], u.Pages[i]
	if !(v == u) { return false }


	}



	return true
}

func (v *CreateKeyPage) Equal(u *CreateKeyPage) bool {
		if !(v.Url == u.Url) { return false }



		if !(len(v.Keys) == len(u.Keys)) { return false }

	for i := range v.Keys {
		v, u := v.Keys[i], u.Keys[i]
	if !(v.Equal(u)) { return false }


	}



	return true
}

func (v *CreateToken) Equal(u *CreateToken) bool {
		if !(v.Url == u.Url) { return false }



		if !(v.KeyBookUrl == u.KeyBookUrl) { return false }



		if !(v.Symbol == u.Symbol) { return false }



		if !(v.Precision == u.Precision) { return false }



		if !(v.Properties == u.Properties) { return false }



		if !(v.InitialSupply.Cmp(&u.InitialSupply) == 0) { return false }



		if !(v.HasSupplyLimit == u.HasSupplyLimit) { return false }




	return true
}

func (v *CreateTokenAccount) Equal(u *CreateTokenAccount) bool {
		if !(v.Url == u.Url) { return false }



		if !(v.TokenUrl == u.TokenUrl) { return false }



		if !(v.KeyBookUrl == u.KeyBookUrl) { return false }




	return true
}

func (v *IssueTokens) Equal(u *IssueTokens) bool {
		if !(v.Recipient == u.Recipient) { return false }



		if !(v.Amount.Cmp(&u.Amount) == 0) { return false }




	return true
}

func (v *KeySpecParams) Equal(u *KeySpecParams) bool {
		if !(bytes.Equal(v.PublicKey, u.PublicKey)) { return false }




	return true
}

func (v *SegWitDataEntry) Equal(u *SegWitDataEntry) bool {
		if !(v.Cause == u.Cause) { return false }



		if !(v.EntryUrl == u.EntryUrl) { return false }



		if !(v.EntryHash == u.EntryHash) { return false }




	return true
}

func (v *SendTokens) Equal(u *SendTokens) bool {
		if !(v.Hash == u.Hash) { return false }



		if !(bytes.Equal(v.Meta, u.Meta)) { return false }



		if !(len(v.To) == len(u.To)) { return false }

	for i := range v.To {
		v, u := v.To[i], u.To[i]
	if !(v.Equal(u)) { return false }


	}



	return true
}

func (v *SyntheticAnchor) Equal(u *SyntheticAnchor) bool {
		if !(v.Source == u.Source) { return false }



		if !(v.Major == u.Major) { return false }



		if !(v.RootAnchor == u.RootAnchor) { return false }



		if !(v.RootIndex == u.RootIndex) { return false }



		if !(v.SourceIndex == u.SourceIndex) { return false }



		if !(v.Receipt.Equal(&u.Receipt)) { return false }




	return true
}

func (v *SyntheticBurnTokens) Equal(u *SyntheticBurnTokens) bool {
		if !(v.Cause == u.Cause) { return false }



		if !(v.Amount.Cmp(&u.Amount) == 0) { return false }




	return true
}

func (v *SyntheticCreateChain) Equal(u *SyntheticCreateChain) bool {
		if !(v.Cause == u.Cause) { return false }



		if !(len(v.Chains) == len(u.Chains)) { return false }

	for i := range v.Chains {
		v, u := v.Chains[i], u.Chains[i]
	if !(v.Equal(&u)) { return false }


	}



	return true
}

func (v *SyntheticDepositCredits) Equal(u *SyntheticDepositCredits) bool {
		if !(v.Cause == u.Cause) { return false }



		if !(v.Amount == u.Amount) { return false }




	return true
}

func (v *SyntheticDepositTokens) Equal(u *SyntheticDepositTokens) bool {
		if !(v.Cause == u.Cause) { return false }



		if !(v.Token == u.Token) { return false }



		if !(v.Amount.Cmp(&u.Amount) == 0) { return false }




	return true
}

func (v *SyntheticMirror) Equal(u *SyntheticMirror) bool {
		if !(len(v.Objects) == len(u.Objects)) { return false }

	for i := range v.Objects {
		v, u := v.Objects[i], u.Objects[i]
	if !(v.Equal(&u)) { return false }


	}



	return true
}

func (v *SyntheticWriteData) Equal(u *SyntheticWriteData) bool {
		if !(v.Cause == u.Cause) { return false }



		if !(v.Entry.Equal(&u.Entry)) { return false }




	return true
}

func (v *TokenRecipient) Equal(u *TokenRecipient) bool {
		if !(v.Url == u.Url) { return false }



		if !(v.Amount.Cmp(&u.Amount) == 0) { return false }




	return true
}

func (v *UpdateKeyPage) Equal(u *UpdateKeyPage) bool {
		if !(v.Operation == u.Operation) { return false }



		if !(bytes.Equal(v.Key, u.Key)) { return false }



		if !(bytes.Equal(v.NewKey, u.NewKey)) { return false }



		if !(v.Owner == u.Owner) { return false }



		if !(v.Threshold == u.Threshold) { return false }




	return true
}

func (v *WriteData) Equal(u *WriteData) bool {
		if !(v.Entry.Equal(&u.Entry)) { return false }




	return true
}

func (v *WriteDataTo) Equal(u *WriteDataTo) bool {
		if !(v.Recipient == u.Recipient) { return false }



		if !(v.Entry.Equal(&u.Entry)) { return false }




	return true
}



func (v *AcmeFaucet) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeAcmeFaucet.ID())
	

	
		n += encoding.StringBinarySize(v.Url)




	return n
}

func (v *AddCredits) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeAddCredits.ID())
	

	
		n += encoding.StringBinarySize(v.Recipient)



		n += encoding.UvarintBinarySize(v.Amount)




	return n
}

func (v *AnchoredRecord) BinarySize() int {
	var n int

	

	
		n += encoding.BytesBinarySize(v.Record)



		n += encoding.ChainBinarySize(&v.Anchor)




	return n
}

func (v *BurnTokens) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeBurnTokens.ID())
	

	
		n += encoding.BigintBinarySize(&v.Amount)




	return n
}

func (v *ChainParams) BinarySize() int {
	var n int

	

	
		n += encoding.BytesBinarySize(v.Data)



		n += encoding.BoolBinarySize(v.IsUpdate)




	return n
}

func (v *CreateDataAccount) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeCreateDataAccount.ID())
	

	
		n += encoding.StringBinarySize(v.Url)



		n += encoding.StringBinarySize(v.KeyBookUrl)



		n += encoding.StringBinarySize(v.ManagerKeyBookUrl)




	return n
}

func (v *CreateIdentity) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeCreateIdentity.ID())
	

	
		n += encoding.StringBinarySize(v.Url)



		n += encoding.BytesBinarySize(v.PublicKey)



		n += encoding.StringBinarySize(v.KeyBookName)



		n += encoding.StringBinarySize(v.KeyPageName)




	return n
}

func (v *CreateKeyBook) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeCreateKeyBook.ID())
	

	
		n += encoding.StringBinarySize(v.Url)



		n += encoding.UvarintBinarySize(uint64(len(v.Pages)))

	for _, v := range v.Pages {
	n += encoding.StringBinarySize(v)


	}



	return n
}

func (v *CreateKeyPage) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeCreateKeyPage.ID())
	

	
		n += encoding.StringBinarySize(v.Url)



		n += encoding.UvarintBinarySize(uint64(len(v.Keys)))

	for _, v := range v.Keys {
	n += v.BinarySize()


	}



	return n
}

func (v *CreateToken) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeCreateToken.ID())
	

	
		n += encoding.StringBinarySize(v.Url)



		n += encoding.StringBinarySize(v.KeyBookUrl)



		n += encoding.StringBinarySize(v.Symbol)



		n += encoding.UvarintBinarySize(v.Precision)



		n += encoding.StringBinarySize(v.Properties)



		n += encoding.BigintBinarySize(&v.InitialSupply)



		n += encoding.BoolBinarySize(v.HasSupplyLimit)




	return n
}

func (v *CreateTokenAccount) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeCreateTokenAccount.ID())
	

	
		n += encoding.StringBinarySize(v.Url)



		n += encoding.StringBinarySize(v.TokenUrl)



		n += encoding.StringBinarySize(v.KeyBookUrl)




	return n
}

func (v *IssueTokens) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeIssueTokens.ID())
	

	
		n += encoding.StringBinarySize(v.Recipient)



		n += encoding.BigintBinarySize(&v.Amount)




	return n
}

func (v *KeySpecParams) BinarySize() int {
	var n int

	

	
		n += encoding.BytesBinarySize(v.PublicKey)




	return n
}

func (v *SegWitDataEntry) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSegWitDataEntry.ID())
	

	
		n += encoding.ChainBinarySize(&v.Cause)



		n += encoding.StringBinarySize(v.EntryUrl)



		n += encoding.ChainBinarySize(&v.EntryHash)




	return n
}

func (v *SendTokens) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSendTokens.ID())
	

	
		n += encoding.ChainBinarySize(&v.Hash)



		n += encoding.BytesBinarySize(v.Meta)



		n += encoding.UvarintBinarySize(uint64(len(v.To)))

	for _, v := range v.To {
	n += v.BinarySize()


	}



	return n
}

func (v *SyntheticAnchor) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticAnchor.ID())
	

	
		n += encoding.StringBinarySize(v.Source)



		n += encoding.BoolBinarySize(v.Major)



		n += encoding.ChainBinarySize(&v.RootAnchor)



		n += encoding.UvarintBinarySize(v.RootIndex)



		n += encoding.UvarintBinarySize(v.SourceIndex)



		n += v.Receipt.BinarySize()




	return n
}

func (v *SyntheticBurnTokens) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticBurnTokens.ID())
	

	
		n += encoding.ChainBinarySize(&v.Cause)



		n += encoding.BigintBinarySize(&v.Amount)




	return n
}

func (v *SyntheticCreateChain) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticCreateChain.ID())
	

	
		n += encoding.ChainBinarySize(&v.Cause)



		n += encoding.UvarintBinarySize(uint64(len(v.Chains)))

	for _, v := range v.Chains {
	n += v.BinarySize()


	}



	return n
}

func (v *SyntheticDepositCredits) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticDepositCredits.ID())
	

	
		n += encoding.ChainBinarySize(&v.Cause)



		n += encoding.UvarintBinarySize(v.Amount)




	return n
}

func (v *SyntheticDepositTokens) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticDepositTokens.ID())
	

	
		n += encoding.ChainBinarySize(&v.Cause)



		n += encoding.StringBinarySize(v.Token)



		n += encoding.BigintBinarySize(&v.Amount)




	return n
}

func (v *SyntheticMirror) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticMirror.ID())
	

	
		n += encoding.UvarintBinarySize(uint64(len(v.Objects)))

	for _, v := range v.Objects {
	n += v.BinarySize()


	}



	return n
}

func (v *SyntheticWriteData) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeSyntheticWriteData.ID())
	

	
		n += encoding.ChainBinarySize(&v.Cause)



		n += v.Entry.BinarySize()




	return n
}

func (v *TokenRecipient) BinarySize() int {
	var n int

	

	
		n += encoding.StringBinarySize(v.Url)



		n += encoding.BigintBinarySize(&v.Amount)




	return n
}

func (v *UpdateKeyPage) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeUpdateKeyPage.ID())
	

	
		n += v.Operation.BinarySize()



		n += encoding.BytesBinarySize(v.Key)



		n += encoding.BytesBinarySize(v.NewKey)



		n += encoding.StringBinarySize(v.Owner)



		n += encoding.UvarintBinarySize(v.Threshold)




	return n
}

func (v *WriteData) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeWriteData.ID())
	

	
		n += v.Entry.BinarySize()




	return n
}

func (v *WriteDataTo) BinarySize() int {
	var n int

	
	n += encoding.UvarintBinarySize(types.TxTypeWriteDataTo.ID())
	

	
		n += encoding.StringBinarySize(v.Recipient)



		n += v.Entry.BinarySize()




	return n
}



func (v *AcmeFaucet) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeAcmeFaucet.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Url))



	return buffer.Bytes(), nil
}

func (v *AddCredits) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeAddCredits.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Recipient))


		buffer.Write(encoding.UvarintMarshalBinary(v.Amount))



	return buffer.Bytes(), nil
}

func (v *AnchoredRecord) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	

	
		buffer.Write(encoding.BytesMarshalBinary(v.Record))


		buffer.Write(encoding.ChainMarshalBinary(&v.Anchor))



	return buffer.Bytes(), nil
}

func (v *BurnTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeBurnTokens.ID()))
	

	
		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))



	return buffer.Bytes(), nil
}

func (v *ChainParams) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	

	
		buffer.Write(encoding.BytesMarshalBinary(v.Data))


		buffer.Write(encoding.BoolMarshalBinary(v.IsUpdate))



	return buffer.Bytes(), nil
}

func (v *CreateDataAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateDataAccount.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Url))


		buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))


		buffer.Write(encoding.StringMarshalBinary(v.ManagerKeyBookUrl))



	return buffer.Bytes(), nil
}

func (v *CreateIdentity) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateIdentity.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Url))


		buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))


		buffer.Write(encoding.StringMarshalBinary(v.KeyBookName))


		buffer.Write(encoding.StringMarshalBinary(v.KeyPageName))



	return buffer.Bytes(), nil
}

func (v *CreateKeyBook) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateKeyBook.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Url))


		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Pages))))
	for i, v := range v.Pages {
		_ = i
	buffer.Write(encoding.StringMarshalBinary(v))

	}



	return buffer.Bytes(), nil
}

func (v *CreateKeyPage) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateKeyPage.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Url))


		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Keys))))
	for i, v := range v.Keys {
		_ = i
	if b, err := v.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Keys[%d]: %w", i,err) } else { buffer.Write(b) }

	}



	return buffer.Bytes(), nil
}

func (v *CreateToken) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateToken.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Url))


		buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))


		buffer.Write(encoding.StringMarshalBinary(v.Symbol))


		buffer.Write(encoding.UvarintMarshalBinary(v.Precision))


		buffer.Write(encoding.StringMarshalBinary(v.Properties))


		buffer.Write(encoding.BigintMarshalBinary(&v.InitialSupply))


		buffer.Write(encoding.BoolMarshalBinary(v.HasSupplyLimit))



	return buffer.Bytes(), nil
}

func (v *CreateTokenAccount) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeCreateTokenAccount.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Url))


		buffer.Write(encoding.StringMarshalBinary(v.TokenUrl))


		buffer.Write(encoding.StringMarshalBinary(v.KeyBookUrl))



	return buffer.Bytes(), nil
}

func (v *IssueTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeIssueTokens.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Recipient))


		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))



	return buffer.Bytes(), nil
}

func (v *KeySpecParams) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	

	
		buffer.Write(encoding.BytesMarshalBinary(v.PublicKey))



	return buffer.Bytes(), nil
}

func (v *SegWitDataEntry) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSegWitDataEntry.ID()))
	

	
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))


		buffer.Write(encoding.StringMarshalBinary(v.EntryUrl))


		buffer.Write(encoding.ChainMarshalBinary(&v.EntryHash))



	return buffer.Bytes(), nil
}

func (v *SendTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSendTokens.ID()))
	

	
		buffer.Write(encoding.ChainMarshalBinary(&v.Hash))


		buffer.Write(encoding.BytesMarshalBinary(v.Meta))


		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.To))))
	for i, v := range v.To {
		_ = i
	if b, err := v.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding To[%d]: %w", i,err) } else { buffer.Write(b) }

	}



	return buffer.Bytes(), nil
}

func (v *SyntheticAnchor) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticAnchor.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Source))


		buffer.Write(encoding.BoolMarshalBinary(v.Major))


		buffer.Write(encoding.ChainMarshalBinary(&v.RootAnchor))


		buffer.Write(encoding.UvarintMarshalBinary(v.RootIndex))


		buffer.Write(encoding.UvarintMarshalBinary(v.SourceIndex))


		if b, err := v.Receipt.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Receipt: %w", err) } else { buffer.Write(b) }



	return buffer.Bytes(), nil
}

func (v *SyntheticBurnTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticBurnTokens.ID()))
	

	
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))


		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))



	return buffer.Bytes(), nil
}

func (v *SyntheticCreateChain) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticCreateChain.ID()))
	

	
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))


		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Chains))))
	for i, v := range v.Chains {
		_ = i
	if b, err := v.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Chains[%d]: %w", i,err) } else { buffer.Write(b) }

	}



	return buffer.Bytes(), nil
}

func (v *SyntheticDepositCredits) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticDepositCredits.ID()))
	

	
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))


		buffer.Write(encoding.UvarintMarshalBinary(v.Amount))



	return buffer.Bytes(), nil
}

func (v *SyntheticDepositTokens) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticDepositTokens.ID()))
	

	
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))


		buffer.Write(encoding.StringMarshalBinary(v.Token))


		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))



	return buffer.Bytes(), nil
}

func (v *SyntheticMirror) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticMirror.ID()))
	

	
		buffer.Write(encoding.UvarintMarshalBinary(uint64(len(v.Objects))))
	for i, v := range v.Objects {
		_ = i
	if b, err := v.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Objects[%d]: %w", i,err) } else { buffer.Write(b) }

	}



	return buffer.Bytes(), nil
}

func (v *SyntheticWriteData) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeSyntheticWriteData.ID()))
	

	
		buffer.Write(encoding.ChainMarshalBinary(&v.Cause))


		if b, err := v.Entry.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Entry: %w", err) } else { buffer.Write(b) }



	return buffer.Bytes(), nil
}

func (v *TokenRecipient) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	

	
		buffer.Write(encoding.StringMarshalBinary(v.Url))


		buffer.Write(encoding.BigintMarshalBinary(&v.Amount))



	return buffer.Bytes(), nil
}

func (v *UpdateKeyPage) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeUpdateKeyPage.ID()))
	

	
		if b, err := v.Operation.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Operation: %w", err) } else { buffer.Write(b) }


		buffer.Write(encoding.BytesMarshalBinary(v.Key))


		buffer.Write(encoding.BytesMarshalBinary(v.NewKey))


		buffer.Write(encoding.StringMarshalBinary(v.Owner))


		buffer.Write(encoding.UvarintMarshalBinary(v.Threshold))



	return buffer.Bytes(), nil
}

func (v *WriteData) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeWriteData.ID()))
	

	
		if b, err := v.Entry.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Entry: %w", err) } else { buffer.Write(b) }



	return buffer.Bytes(), nil
}

func (v *WriteDataTo) MarshalBinary() ([]byte, error) {
	var buffer bytes.Buffer

	
	buffer.Write(encoding.UvarintMarshalBinary(types.TxTypeWriteDataTo.ID()))
	

	
		buffer.Write(encoding.StringMarshalBinary(v.Recipient))


		if b, err := v.Entry.MarshalBinary(); err != nil { return nil, fmt.Errorf("error encoding Entry: %w", err) } else { buffer.Write(b) }



	return buffer.Bytes(), nil
}



func (v *AcmeFaucet) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeAcmeFaucet
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]



	return nil
}

func (v *AddCredits) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeAddCredits
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Recipient: %w", err) } else { v.Recipient = x }
	data = data[encoding.StringBinarySize(v.Recipient):]


		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount = x }
	data = data[encoding.UvarintBinarySize(v.Amount):]



	return nil
}

func (v *AnchoredRecord) UnmarshalBinary(data []byte) error {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Record: %w", err) } else { v.Record = x }
	data = data[encoding.BytesBinarySize(v.Record):]


		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Anchor: %w", err) } else { v.Anchor = x }
	data = data[encoding.ChainBinarySize(&v.Anchor):]



	return nil
}

func (v *BurnTokens) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeBurnTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]



	return nil
}

func (v *ChainParams) UnmarshalBinary(data []byte) error {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Data: %w", err) } else { v.Data = x }
	data = data[encoding.BytesBinarySize(v.Data):]


		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding IsUpdate: %w", err) } else { v.IsUpdate = x }
	data = data[encoding.BoolBinarySize(v.IsUpdate):]



	return nil
}

func (v *CreateDataAccount) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateDataAccount
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyBookUrl: %w", err) } else { v.KeyBookUrl = x }
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding ManagerKeyBookUrl: %w", err) } else { v.ManagerKeyBookUrl = x }
	data = data[encoding.StringBinarySize(v.ManagerKeyBookUrl):]



	return nil
}

func (v *CreateIdentity) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateIdentity
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]


		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding PublicKey: %w", err) } else { v.PublicKey = x }
	data = data[encoding.BytesBinarySize(v.PublicKey):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyBookName: %w", err) } else { v.KeyBookName = x }
	data = data[encoding.StringBinarySize(v.KeyBookName):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyPageName: %w", err) } else { v.KeyPageName = x }
	data = data[encoding.StringBinarySize(v.KeyPageName):]



	return nil
}

func (v *CreateKeyBook) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateKeyBook
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]


	var lenPages uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Pages: %w", err) } else { lenPages = x }
	data = data[encoding.UvarintBinarySize(lenPages):]

	v.Pages = make([]string, lenPages)
	for i := range v.Pages {
	if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Pages[%d]: %w", i,err) } else { v.Pages[i] = x }
	data = data[encoding.StringBinarySize(v.Pages[i]):]

	}



	return nil
}

func (v *CreateKeyPage) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateKeyPage
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]


	var lenKeys uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Keys: %w", err) } else { lenKeys = x }
	data = data[encoding.UvarintBinarySize(lenKeys):]

	v.Keys = make([]*KeySpecParams, lenKeys)
	for i := range v.Keys {
		var x *KeySpecParams
	x = new(KeySpecParams)
	if err := x.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Keys[%d]: %w", i,err) }
	data = data[x.BinarySize():]

		v.Keys[i] = x	}



	return nil
}

func (v *CreateToken) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateToken
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyBookUrl: %w", err) } else { v.KeyBookUrl = x }
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Symbol: %w", err) } else { v.Symbol = x }
	data = data[encoding.StringBinarySize(v.Symbol):]


		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Precision: %w", err) } else { v.Precision = x }
	data = data[encoding.UvarintBinarySize(v.Precision):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Properties: %w", err) } else { v.Properties = x }
	data = data[encoding.StringBinarySize(v.Properties):]


		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding InitialSupply: %w", err) } else { v.InitialSupply.Set(x) }
	data = data[encoding.BigintBinarySize(&v.InitialSupply):]


		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding HasSupplyLimit: %w", err) } else { v.HasSupplyLimit = x }
	data = data[encoding.BoolBinarySize(v.HasSupplyLimit):]



	return nil
}

func (v *CreateTokenAccount) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeCreateTokenAccount
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding TokenUrl: %w", err) } else { v.TokenUrl = x }
	data = data[encoding.StringBinarySize(v.TokenUrl):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding KeyBookUrl: %w", err) } else { v.KeyBookUrl = x }
	data = data[encoding.StringBinarySize(v.KeyBookUrl):]



	return nil
}

func (v *IssueTokens) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeIssueTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Recipient: %w", err) } else { v.Recipient = x }
	data = data[encoding.StringBinarySize(v.Recipient):]


		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]



	return nil
}

func (v *KeySpecParams) UnmarshalBinary(data []byte) error {
		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding PublicKey: %w", err) } else { v.PublicKey = x }
	data = data[encoding.BytesBinarySize(v.PublicKey):]



	return nil
}

func (v *SegWitDataEntry) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSegWitDataEntry
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding EntryUrl: %w", err) } else { v.EntryUrl = x }
	data = data[encoding.StringBinarySize(v.EntryUrl):]


		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding EntryHash: %w", err) } else { v.EntryHash = x }
	data = data[encoding.ChainBinarySize(&v.EntryHash):]



	return nil
}

func (v *SendTokens) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSendTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Hash: %w", err) } else { v.Hash = x }
	data = data[encoding.ChainBinarySize(&v.Hash):]


		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Meta: %w", err) } else { v.Meta = x }
	data = data[encoding.BytesBinarySize(v.Meta):]


	var lenTo uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding To: %w", err) } else { lenTo = x }
	data = data[encoding.UvarintBinarySize(lenTo):]

	v.To = make([]*TokenRecipient, lenTo)
	for i := range v.To {
		var x *TokenRecipient
	x = new(TokenRecipient)
	if err := x.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding To[%d]: %w", i,err) }
	data = data[x.BinarySize():]

		v.To[i] = x	}



	return nil
}

func (v *SyntheticAnchor) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticAnchor
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Source: %w", err) } else { v.Source = x }
	data = data[encoding.StringBinarySize(v.Source):]


		if x, err := encoding.BoolUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Major: %w", err) } else { v.Major = x }
	data = data[encoding.BoolBinarySize(v.Major):]


		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding RootAnchor: %w", err) } else { v.RootAnchor = x }
	data = data[encoding.ChainBinarySize(&v.RootAnchor):]


		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding RootIndex: %w", err) } else { v.RootIndex = x }
	data = data[encoding.UvarintBinarySize(v.RootIndex):]


		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding SourceIndex: %w", err) } else { v.SourceIndex = x }
	data = data[encoding.UvarintBinarySize(v.SourceIndex):]


		if err := v.Receipt.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Receipt: %w", err) }
	data = data[v.Receipt.BinarySize():]



	return nil
}

func (v *SyntheticBurnTokens) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticBurnTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]


		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]



	return nil
}

func (v *SyntheticCreateChain) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticCreateChain
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]


	var lenChains uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Chains: %w", err) } else { lenChains = x }
	data = data[encoding.UvarintBinarySize(lenChains):]

	v.Chains = make([]ChainParams, lenChains)
	for i := range v.Chains {
	if err := v.Chains[i].UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Chains[%d]: %w", i,err) }
	data = data[v.Chains[i].BinarySize():]

	}



	return nil
}

func (v *SyntheticDepositCredits) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticDepositCredits
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]


		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount = x }
	data = data[encoding.UvarintBinarySize(v.Amount):]



	return nil
}

func (v *SyntheticDepositTokens) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticDepositTokens
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Token: %w", err) } else { v.Token = x }
	data = data[encoding.StringBinarySize(v.Token):]


		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]



	return nil
}

func (v *SyntheticMirror) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticMirror
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
	var lenObjects uint64
	if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Objects: %w", err) } else { lenObjects = x }
	data = data[encoding.UvarintBinarySize(lenObjects):]

	v.Objects = make([]AnchoredRecord, lenObjects)
	for i := range v.Objects {
	if err := v.Objects[i].UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Objects[%d]: %w", i,err) }
	data = data[v.Objects[i].BinarySize():]

	}



	return nil
}

func (v *SyntheticWriteData) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeSyntheticWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.ChainUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Cause: %w", err) } else { v.Cause = x }
	data = data[encoding.ChainBinarySize(&v.Cause):]


		if err := v.Entry.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Entry: %w", err) }
	data = data[v.Entry.BinarySize():]



	return nil
}

func (v *TokenRecipient) UnmarshalBinary(data []byte) error {
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Url: %w", err) } else { v.Url = x }
	data = data[encoding.StringBinarySize(v.Url):]


		if x, err := encoding.BigintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Amount: %w", err) } else { v.Amount.Set(x) }
	data = data[encoding.BigintBinarySize(&v.Amount):]



	return nil
}

func (v *UpdateKeyPage) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeUpdateKeyPage
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if err := v.Operation.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Operation: %w", err) }
	data = data[v.Operation.BinarySize():]


		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Key: %w", err) } else { v.Key = x }
	data = data[encoding.BytesBinarySize(v.Key):]


		if x, err := encoding.BytesUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding NewKey: %w", err) } else { v.NewKey = x }
	data = data[encoding.BytesBinarySize(v.NewKey):]


		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Owner: %w", err) } else { v.Owner = x }
	data = data[encoding.StringBinarySize(v.Owner):]


		if x, err := encoding.UvarintUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Threshold: %w", err) } else { v.Threshold = x }
	data = data[encoding.UvarintBinarySize(v.Threshold):]



	return nil
}

func (v *WriteData) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeWriteData
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if err := v.Entry.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Entry: %w", err) }
	data = data[v.Entry.BinarySize():]



	return nil
}

func (v *WriteDataTo) UnmarshalBinary(data []byte) error {
	typ := types.TxTypeWriteDataTo
	if v, err := encoding.UvarintUnmarshalBinary(data); err != nil {
		return fmt.Errorf("error decoding TX type: %w", err)
	} else if v != uint64(typ) {
		return fmt.Errorf("invalid TX type: want %v, got %v", typ, types.TransactionType(v))
	}
	data = data[encoding.UvarintBinarySize(uint64(typ)):]
	
		if x, err := encoding.StringUnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Recipient: %w", err) } else { v.Recipient = x }
	data = data[encoding.StringBinarySize(v.Recipient):]


		if err := v.Entry.UnmarshalBinary(data); err != nil { return fmt.Errorf("error decoding Entry: %w", err) }
	data = data[v.Entry.BinarySize():]



	return nil
}





func (v *AnchoredRecord) MarshalJSON() ([]byte, error) {
	u := struct {
	Record *string `json:"record,omitempty"`
	Anchor string `json:"anchor,omitempty"`
}{}
		u.Record = encoding.BytesToJSON(v.Record)
		u.Anchor = encoding.ChainToJSON(v.Anchor)
	return json.Marshal(&u)
}

func (v *BurnTokens) MarshalJSON() ([]byte, error) {
	u := struct {
	Amount *string `json:"amount,omitempty"`
}{}
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *ChainParams) MarshalJSON() ([]byte, error) {
	u := struct {
	Data *string `json:"data,omitempty"`
	IsUpdate bool `json:"isUpdate,omitempty"`
}{}
		u.Data = encoding.BytesToJSON(v.Data)
		u.IsUpdate = v.IsUpdate
	return json.Marshal(&u)
}

func (v *CreateIdentity) MarshalJSON() ([]byte, error) {
	u := struct {
	Url string `json:"url,omitempty"`
	PublicKey *string `json:"publicKey,omitempty"`
	KeyBookName string `json:"keyBookName,omitempty"`
	KeyPageName string `json:"keyPageName,omitempty"`
}{}
		u.Url = v.Url
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
		u.KeyBookName = v.KeyBookName
		u.KeyPageName = v.KeyPageName
	return json.Marshal(&u)
}

func (v *CreateToken) MarshalJSON() ([]byte, error) {
	u := struct {
	Url string `json:"url,omitempty"`
	KeyBookUrl string `json:"keyBookUrl,omitempty"`
	Symbol string `json:"symbol,omitempty"`
	Precision uint64 `json:"precision,omitempty"`
	Properties string `json:"properties,omitempty"`
	InitialSupply *string `json:"initialSupply,omitempty"`
	HasSupplyLimit bool `json:"hasSupplyLimit,omitempty"`
}{}
		u.Url = v.Url
		u.KeyBookUrl = v.KeyBookUrl
		u.Symbol = v.Symbol
		u.Precision = v.Precision
		u.Properties = v.Properties
		u.InitialSupply = encoding.BigintToJSON(&v.InitialSupply)
		u.HasSupplyLimit = v.HasSupplyLimit
	return json.Marshal(&u)
}

func (v *IssueTokens) MarshalJSON() ([]byte, error) {
	u := struct {
	Recipient string `json:"recipient,omitempty"`
	Amount *string `json:"amount,omitempty"`
}{}
		u.Recipient = v.Recipient
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *KeySpecParams) MarshalJSON() ([]byte, error) {
	u := struct {
	PublicKey *string `json:"publicKey,omitempty"`
}{}
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	return json.Marshal(&u)
}

func (v *SegWitDataEntry) MarshalJSON() ([]byte, error) {
	u := struct {
	Cause string `json:"cause,omitempty"`
	EntryUrl string `json:"entryUrl,omitempty"`
	EntryHash string `json:"entryHash,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.EntryUrl = v.EntryUrl
		u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	return json.Marshal(&u)
}

func (v *SendTokens) MarshalJSON() ([]byte, error) {
	u := struct {
	Hash string `json:"hash,omitempty"`
	Meta json.RawMessage `json:"meta,omitempty"`
	To []*TokenRecipient `json:"to,omitempty"`
}{}
		u.Hash = encoding.ChainToJSON(v.Hash)
		u.Meta = v.Meta
		u.To = v.To
	return json.Marshal(&u)
}

func (v *SyntheticAnchor) MarshalJSON() ([]byte, error) {
	u := struct {
	Source string `json:"source,omitempty"`
	Major bool `json:"major,omitempty"`
	RootAnchor string `json:"rootAnchor,omitempty"`
	RootIndex uint64 `json:"rootIndex,omitempty"`
	SourceIndex uint64 `json:"sourceIndex,omitempty"`
	Receipt Receipt `json:"receipt,omitempty"`
}{}
		u.Source = v.Source
		u.Major = v.Major
		u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
		u.RootIndex = v.RootIndex
		u.SourceIndex = v.SourceIndex
		u.Receipt = v.Receipt
	return json.Marshal(&u)
}

func (v *SyntheticBurnTokens) MarshalJSON() ([]byte, error) {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Amount *string `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *SyntheticCreateChain) MarshalJSON() ([]byte, error) {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Chains []ChainParams `json:"chains,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Chains = v.Chains
	return json.Marshal(&u)
}

func (v *SyntheticDepositCredits) MarshalJSON() ([]byte, error) {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Amount uint64 `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Amount = v.Amount
	return json.Marshal(&u)
}

func (v *SyntheticDepositTokens) MarshalJSON() ([]byte, error) {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Token string `json:"token,omitempty"`
	Amount *string `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Token = v.Token
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *SyntheticWriteData) MarshalJSON() ([]byte, error) {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Entry DataEntry `json:"entry,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Entry = v.Entry
	return json.Marshal(&u)
}

func (v *TokenRecipient) MarshalJSON() ([]byte, error) {
	u := struct {
	Url string `json:"url,omitempty"`
	Amount *string `json:"amount,omitempty"`
}{}
		u.Url = v.Url
		u.Amount = encoding.BigintToJSON(&v.Amount)
	return json.Marshal(&u)
}

func (v *UpdateKeyPage) MarshalJSON() ([]byte, error) {
	u := struct {
	Operation KeyPageOperation `json:"operation,omitempty"`
	Key *string `json:"key,omitempty"`
	NewKey *string `json:"newKey,omitempty"`
	Owner string `json:"owner,omitempty"`
	Threshold uint64 `json:"threshold,omitempty"`
}{}
		u.Operation = v.Operation
		u.Key = encoding.BytesToJSON(v.Key)
		u.NewKey = encoding.BytesToJSON(v.NewKey)
		u.Owner = v.Owner
		u.Threshold = v.Threshold
	return json.Marshal(&u)
}



func (v *AnchoredRecord) UnmarshalJSON(data []byte) error {
	u := struct {
	Record *string `json:"record,omitempty"`
	Anchor string `json:"anchor,omitempty"`
}{}
		u.Record = encoding.BytesToJSON(v.Record)
		u.Anchor = encoding.ChainToJSON(v.Anchor)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.BytesFromJSON(u.Record); err != nil {
		return fmt.Errorf("error decoding Record: %w", err)
	} else {
		v.Record = x
	}
		if x, err := encoding.ChainFromJSON(u.Anchor); err != nil {
		return fmt.Errorf("error decoding Anchor: %w", err)
	} else {
		v.Anchor = x
	}
	return nil
}

func (v *BurnTokens) UnmarshalJSON(data []byte) error {
	u := struct {
	Amount *string `json:"amount,omitempty"`
}{}
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *ChainParams) UnmarshalJSON(data []byte) error {
	u := struct {
	Data *string `json:"data,omitempty"`
	IsUpdate bool `json:"isUpdate,omitempty"`
}{}
		u.Data = encoding.BytesToJSON(v.Data)
		u.IsUpdate = v.IsUpdate
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.BytesFromJSON(u.Data); err != nil {
		return fmt.Errorf("error decoding Data: %w", err)
	} else {
		v.Data = x
	}
		v.IsUpdate = u.IsUpdate
	return nil
}

func (v *CreateIdentity) UnmarshalJSON(data []byte) error {
	u := struct {
	Url string `json:"url,omitempty"`
	PublicKey *string `json:"publicKey,omitempty"`
	KeyBookName string `json:"keyBookName,omitempty"`
	KeyPageName string `json:"keyPageName,omitempty"`
}{}
		u.Url = v.Url
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
		u.KeyBookName = v.KeyBookName
		u.KeyPageName = v.KeyPageName
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Url = u.Url
		if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
		v.KeyBookName = u.KeyBookName
		v.KeyPageName = u.KeyPageName
	return nil
}

func (v *CreateToken) UnmarshalJSON(data []byte) error {
	u := struct {
	Url string `json:"url,omitempty"`
	KeyBookUrl string `json:"keyBookUrl,omitempty"`
	Symbol string `json:"symbol,omitempty"`
	Precision uint64 `json:"precision,omitempty"`
	Properties string `json:"properties,omitempty"`
	InitialSupply *string `json:"initialSupply,omitempty"`
	HasSupplyLimit bool `json:"hasSupplyLimit,omitempty"`
}{}
		u.Url = v.Url
		u.KeyBookUrl = v.KeyBookUrl
		u.Symbol = v.Symbol
		u.Precision = v.Precision
		u.Properties = v.Properties
		u.InitialSupply = encoding.BigintToJSON(&v.InitialSupply)
		u.HasSupplyLimit = v.HasSupplyLimit
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Url = u.Url
		v.KeyBookUrl = u.KeyBookUrl
		v.Symbol = u.Symbol
		v.Precision = u.Precision
		v.Properties = u.Properties
		if x, err := encoding.BigintFromJSON(u.InitialSupply); err != nil {
		return fmt.Errorf("error decoding InitialSupply: %w", err)
	} else {
		v.InitialSupply = *x
	}
		v.HasSupplyLimit = u.HasSupplyLimit
	return nil
}

func (v *IssueTokens) UnmarshalJSON(data []byte) error {
	u := struct {
	Recipient string `json:"recipient,omitempty"`
	Amount *string `json:"amount,omitempty"`
}{}
		u.Recipient = v.Recipient
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Recipient = u.Recipient
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *KeySpecParams) UnmarshalJSON(data []byte) error {
	u := struct {
	PublicKey *string `json:"publicKey,omitempty"`
}{}
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	return nil
}

func (v *SegWitDataEntry) UnmarshalJSON(data []byte) error {
	u := struct {
	Cause string `json:"cause,omitempty"`
	EntryUrl string `json:"entryUrl,omitempty"`
	EntryHash string `json:"entryHash,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.EntryUrl = v.EntryUrl
		u.EntryHash = encoding.ChainToJSON(v.EntryHash)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.EntryUrl = u.EntryUrl
		if x, err := encoding.ChainFromJSON(u.EntryHash); err != nil {
		return fmt.Errorf("error decoding EntryHash: %w", err)
	} else {
		v.EntryHash = x
	}
	return nil
}

func (v *SendTokens) UnmarshalJSON(data []byte) error {
	u := struct {
	Hash string `json:"hash,omitempty"`
	Meta json.RawMessage `json:"meta,omitempty"`
	To []*TokenRecipient `json:"to,omitempty"`
}{}
		u.Hash = encoding.ChainToJSON(v.Hash)
		u.Meta = v.Meta
		u.To = v.To
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = x
	}
		v.Meta = u.Meta
		v.To = u.To
	return nil
}

func (v *SyntheticAnchor) UnmarshalJSON(data []byte) error {
	u := struct {
	Source string `json:"source,omitempty"`
	Major bool `json:"major,omitempty"`
	RootAnchor string `json:"rootAnchor,omitempty"`
	RootIndex uint64 `json:"rootIndex,omitempty"`
	SourceIndex uint64 `json:"sourceIndex,omitempty"`
	Receipt Receipt `json:"receipt,omitempty"`
}{}
		u.Source = v.Source
		u.Major = v.Major
		u.RootAnchor = encoding.ChainToJSON(v.RootAnchor)
		u.RootIndex = v.RootIndex
		u.SourceIndex = v.SourceIndex
		u.Receipt = v.Receipt
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Source = u.Source
		v.Major = u.Major
		if x, err := encoding.ChainFromJSON(u.RootAnchor); err != nil {
		return fmt.Errorf("error decoding RootAnchor: %w", err)
	} else {
		v.RootAnchor = x
	}
		v.RootIndex = u.RootIndex
		v.SourceIndex = u.SourceIndex
		v.Receipt = u.Receipt
	return nil
}

func (v *SyntheticBurnTokens) UnmarshalJSON(data []byte) error {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Amount *string `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *SyntheticCreateChain) UnmarshalJSON(data []byte) error {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Chains []ChainParams `json:"chains,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Chains = v.Chains
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.Chains = u.Chains
	return nil
}

func (v *SyntheticDepositCredits) UnmarshalJSON(data []byte) error {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Amount uint64 `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Amount = v.Amount
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.Amount = u.Amount
	return nil
}

func (v *SyntheticDepositTokens) UnmarshalJSON(data []byte) error {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Token string `json:"token,omitempty"`
	Amount *string `json:"amount,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Token = v.Token
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.Token = u.Token
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *SyntheticWriteData) UnmarshalJSON(data []byte) error {
	u := struct {
	Cause string `json:"cause,omitempty"`
	Entry DataEntry `json:"entry,omitempty"`
}{}
		u.Cause = encoding.ChainToJSON(v.Cause)
		u.Entry = v.Entry
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		if x, err := encoding.ChainFromJSON(u.Cause); err != nil {
		return fmt.Errorf("error decoding Cause: %w", err)
	} else {
		v.Cause = x
	}
		v.Entry = u.Entry
	return nil
}

func (v *TokenRecipient) UnmarshalJSON(data []byte) error {
	u := struct {
	Url string `json:"url,omitempty"`
	Amount *string `json:"amount,omitempty"`
}{}
		u.Url = v.Url
		u.Amount = encoding.BigintToJSON(&v.Amount)
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Url = u.Url
		if x, err := encoding.BigintFromJSON(u.Amount); err != nil {
		return fmt.Errorf("error decoding Amount: %w", err)
	} else {
		v.Amount = *x
	}
	return nil
}

func (v *UpdateKeyPage) UnmarshalJSON(data []byte) error {
	u := struct {
	Operation KeyPageOperation `json:"operation,omitempty"`
	Key *string `json:"key,omitempty"`
	NewKey *string `json:"newKey,omitempty"`
	Owner string `json:"owner,omitempty"`
	Threshold uint64 `json:"threshold,omitempty"`
}{}
		u.Operation = v.Operation
		u.Key = encoding.BytesToJSON(v.Key)
		u.NewKey = encoding.BytesToJSON(v.NewKey)
		u.Owner = v.Owner
		u.Threshold = v.Threshold
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
		v.Operation = u.Operation
		if x, err := encoding.BytesFromJSON(u.Key); err != nil {
		return fmt.Errorf("error decoding Key: %w", err)
	} else {
		v.Key = x
	}
		if x, err := encoding.BytesFromJSON(u.NewKey); err != nil {
		return fmt.Errorf("error decoding NewKey: %w", err)
	} else {
		v.NewKey = x
	}
		v.Owner = u.Owner
		v.Threshold = u.Threshold
	return nil
}

#endif