package main

import (
	"encoding/binary"
	"fmt"
	"log"
	"time"

	badger "github.com/dgraph-io/badger/v3"
	"github.com/spf13/cobra"
	"gitlab.com/accumulatenetwork/accumulate/internal/database/smt/common"
)

var cmdBuildSummary = &cobra.Command{
	Use:   "summary [input directory]",
	Short: "Build a summary of the good database into a file Summary.dat",
	Args:  cobra.ExactArgs(1),
	Run:   buildSummary,
}

func buildSummary(_ *cobra.Command, args []string) {
	dbName := args[1]
	// Open the Badger database located in the /tmp/badger directory.
	// It will be created if it doesn't exist.
	db, err := badger.Open(badger.DefaultOptions(dbName))	
	if err != nil {
		fmt.Printf("error opening db %v\n",err)
		return
	}
	defer func() {
		if err := db.Close(); err != nil {
			fmt.Printf("error closing db %v\n",err)
		}
	}()

	var rh1 common.RandHash
	var rhk1 common.RandHash
	//var rh2 common.RandHash
	//var rhk2 common.RandHash

	start := time.Now()
	writeStuff := func(rh, rkh *common.RandHash, db *badger.DB) {
		for i := 0; i < numUpdates; i++ {
			if err := db.Update(func(txn *badger.Txn) error {
				for i := 0; i < 100; i++ {
					if err := txn.Set(rkh.Next(), rh.GetRandBuff(rh.GetIntN(128)+128)); err != nil {
						return err
					}
				}
				return nil
			}); err != nil {
				log.Fatal(err)
			}
			if i%10000==0 {
				fmt.Printf("\n%d %v\n",i,time.Since(start))
			}
		}
	}

	writeStuff(&rh1, &rhk1, db1)
	fmt.Printf("\nWriting db1 took %v\n", time.Since(start))
	start = time.Now()
	//writeStuff(&rh2, &rhk2, db2)
	//fmt.Printf("\nWriting db2 took %v\n", time.Since(start))
	//start = time.Now()

	keys := make(map[uint64]bool)

	if err := db1.View(func(txn *badger.Txn) error {
		opts := badger.DefaultIteratorOptions
		opts.PrefetchValues = false
		it := txn.NewIterator(opts)
		defer it.Close()
		for it.Rewind(); it.Valid(); it.Next() {
			item := it.Item()
			k := item.Key()
			keys[binary.BigEndian.Uint64(k)] = true
		}
		return nil
	}); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("\nCollecting %d keys took %v\n", len(keys), time.Since(start))

	var rh3 common.RandHash
	fmt.Println()
	for i := 0; i < len(keys); i++ {
		k := binary.BigEndian.Uint64(rh3.Next())
		if !keys[k] {
			fmt.Printf("Key not found %08x\n", k)
		}
	}

	fmt.Printf("\nValidating %d keys took %v\n", len(keys), time.Since(start))

}
