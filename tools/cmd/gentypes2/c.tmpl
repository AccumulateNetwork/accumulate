package {{.Package}}

// GENERATED BY go run ./tools/cmd/gentypes2. DO NOT EDIT.

#include <common/encoding.h>

{{range .Types}}
{{$typ := .Name}}
enum {{$typ}} {
{{range .Values}}
// {{$typ}}{{.Name}} {{.Description}}.
    const {{$typ}}{{.Name}} = {{.Value}},
{{end}}
};
{{end}}

{{range .Types}}
// ID returns the ID of the {{natural .Name}}
static uint64_t {{.Name}}_ID() { return (uint64_t)(v); }

struct list {
   const char *name;
   uint32 e;
};

// String returns the name of the {{natural .Name}}
static {{.Name}}_list {{.Name}}_l[] = {
	{{- $typ := .Name}}
	{{- range .Values}}
	{ "{{lower .Name}}", {{$typ}}{{.Name}} },
	{{- end}}
};

static Error {{.Name}}_string({{.Name}} *v, String *out) {
    Error e = Error_init(0);
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof({{.Name}}_l); ++i ) {
        if ( {{.Name}}_l[i].e == v ) {
            strncpy(out->data, {{.Name}}_l[i], out->len);
            return e;
        }
    }
    e.code = -1;
    return e;
}

// {{.Name}}ByName returns the named {{natural .Name}}.
static Error {{.Name}}_byName(const {{.Name}} *v, String *name) {
    Error e = Error_init(0);
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof({{.Name}}_l); ++i ) {
        if ( strcmp({{.Name}}_l[i].name, (const char*)name->data) == 0 ) {
            *v = {{.Name}}_l[i].e;
            return e;
        }
    }
    e.code = -1;
    return e;
}

// MarshalJSON marshals the {{natural .Name}} to JSON as a string.
static Error MarshalJSON({{.Name}} *v, String *out) {
    char buffer[32] = {0};
    String s;
    String_init(&s, buffer, sizeof(buffer));
    Error e = {{.Name}}_string(v, &s);
    if e.code != 0 {
        return e;
    }
	return out->MarshalJSON(out, &s);
}

// UnmarshalJSON unmarshals the {{natural .Name}} from JSON as a string.
static Error UnmarshalJSON({{.Name}} *v, Bytes *in) error {
	char buffer[32] = {0};
	String s = String_init(0, buffer, sizeof(buffer));
	Error e = s.UnmarshalJSON(&s, in)
	if e.code != 0 {
		return e;
	}

	e = {{.Name}}_byName(&v, &s);
	if e.code != 0 {
		strcat(e.err, "invalid {{natural .Name}} ");
		strcat(e.err, (const char*)s.data);
	}
	return e;
}

// {{.Name}}_binarySize returns the number of bytes required to binary marshal the {{natural .Name}}.
static func {{.Name}}_binarySize({{.Name}} *v) int {
	return varint_size({{.Name}}_ID(*v))
}

// MarshalBinary marshals the {{natural .Name}} to bytes as a unsigned varint.
static Error {{.Name}}_marshalBinary(const {{.Name}} *v, Bytes *out) {
    if ( out->len < {{.Name}}_binarySize(*v)
    int r = varint_write(out->data, 0, {{.Name}}_ID(*v));
    Error e = Error_init(0);
    if ( r < 0 ) {
        e.err = r;
    }
    return e;
}

// UnmarshalBinary unmarshals the {{natural .Name}} from bytes as a unsigned varint.
static Error {{.Name}}_unmarshalBinary( {{.Name}} *v, const Bytes *in) error {
    Error e = Error_init(0);
    int r = varint_read(in->data, in->len, v);
	if r < 0 {
		e.err = r;
	}
	return e;
}

{{end}}
