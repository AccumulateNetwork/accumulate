#pragma once

// GENERATED BY go run ./tools/cmd/gentypes2. DO NOT EDIT.

#include <common/encoding.h>


typedef struct {
   const char *name;
   uint32_t e;
} enum_t;

{{range .Types}}
{{$typ := .Name}}
typedef enum {
{{range .Values}}
    // {{$typ}}{{.Name}} {{.Description}}.
    {{$typ}}{{.Name}} = {{.Value}},
{{end}}
} {{$typ}};
{{end}}

{{range .Types}}
// ID returns the ID of the {{natural .Name}}
static uint64_t {{.Name}}_ID({{.Name}} v) { return (uint64_t)(v); }

// String returns the name of the {{natural .Name}}
static enum_t {{.Name}}_l[] = {
	{{- $typ := .Name}}
	{{- range .Values}}
	{ "{{lower .Name}}", {{$typ}}{{.Name}} },
	{{- end}}
};

static Error {{.Name}}_string({{.Name}} *v, String *out) {
    Error e = Error_init(0);
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof({{.Name}}_l); ++i ) {
        if ( {{.Name}}_l[i].e == *v ) {
            strncpy((char*)out->string.buffer.ptr+out->string.buffer.offset, {{.Name}}_l[i].name,
                out->string.buffer.size-out->string.buffer.offset);
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// {{.Name}}ByName returns the named {{natural .Name}}.
static Error {{.Name}}_byName({{.Name}} *v, String *name) {
    Error e = Error_init(0);
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof({{.Name}}_l); ++i ) {
        if ( strcmp({{.Name}}_l[i].name, (const char*)name->string.buffer.ptr-name->string.buffer.offset) == 0 ) {
            *v = {{.Name}}_l[i].e;
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// {{.Name}}_marshalJSON marshals the {{natural .Name}} to JSON as a string.
static Error {{.Name}}_marshalJSON({{.Name}} *v, String *out) {
    uint8_t buffer[32] = {0};
    String s;
    String_init(&s, buffer, sizeof(buffer));
    Error e = {{.Name}}_string(v, &s);
    if ( e.code != ErrorNone ) {
        return e;
    }
    return out->MarshalJSON(out, &s.string);
}

// {{.Name}}_unmarshalJSON unmarshals the {{natural .Name}} from JSON as a string.
static Error {{.Name}}_unmarshalJSON({{.Name}} *v, Bytes *in) {
	uint8_t buffer[32] = {0};
	String s = String_init(0, buffer, sizeof(buffer));
	Error e = s.UnmarshalJSON(&s, in);
	if ( e.code != 0 ) {
		return e;
	}

	e = {{.Name}}_byName(v, &s);
	if ( e.code != ErrorNone ) {
		strcat(e.err, "invalid {{natural .Name}} ");
		strcat(e.err, (const char*)in->buffer.ptr);
	}
	return e;
}

// {{.Name}}_binarySize returns the number of bytes required to binary marshal the {{natural .Name}}.
static int {{.Name}}_binarySize(const {{.Name}} *v) {
	return varint_size({{.Name}}_ID(*v));
}

// MarshalBinary marshals the {{natural .Name}} to bytes as a unsigned varint.
static Error {{.Name}}_marshalBinary(const {{.Name}} *v, Bytes *out) {
    if ( !buffer_can_read(&out->buffer, {{.Name}}_binarySize(v)) ) {
        return ErrorCode[ErrorParameterInsufficientData];
    }
    int r = varint_write((uint8_t*)out->buffer.ptr+out->buffer.offset, out->buffer.size, {{.Name}}_ID(*v));
    out->buffer.offset += r;
    if ( r < 0 ) {
        return ErrorCode[ErrorVarIntWrite];
    }
    return ErrorCode[ErrorNone];
}

// UnmarshalBinary unmarshals the {{natural .Name}} from bytes as a unsigned varint.
static Error {{.Name}}_unmarshalBinary( {{.Name}} *v, const Bytes *in) {
    uint64_t t = 0;
    int r = varint_read((uint8_t*)in->buffer.ptr, in->buffer.size - in->buffer.offset, (uint64_t*)&t);
	if ( r < 0 ) {
		return ErrorCode[ErrorVarIntRead];
	}
	*v = ({{.Name}})t;
	return ErrorCode[ErrorNone];
}

{{end}}
