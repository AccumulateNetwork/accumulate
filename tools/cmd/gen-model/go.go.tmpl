// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package {{.Package}}

// GENERATED BY go run ./tools/cmd/gen-model. DO NOT EDIT.

//lint:file-ignore S1008,U1000 generated code

import (
	"encoding/hex"
	"fmt"
	"strconv"

	"gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	record "gitlab.com/accumulatenetwork/accumulate/pkg/database"
	"gitlab.com/accumulatenetwork/accumulate/pkg/database/values"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	"gitlab.com/accumulatenetwork/accumulate/internal/database/smt/storage"
)

{{  define "accessor"}}
{{- if .Private}}get{{end}}{{.Name}}
{{- end}}

{{  define "valueLabel"}}
{{- if not (and .GetParent.Type.IsEntity .GetParent.Root) -}}
c.label + " " +
{{- end -}}
"{{natural .Name}}"
{{- if parameterized . -}}
{{range .GetParameters}} + " " + {{keyToString . (print "k." .Name)}}{{end}}
{{- end}}
{{- end}}

{{  define "key"}}
{{- if .GetParent.Root -}}
(*record.Key)(nil)
{{- else -}}
c.key
{{- end -}}
.Append({{template "keyArgs" .}})
{{- end}}

{{  define "keyArgs"}}
{{- if parameterized . -}}
"{{.Name}}", {{range .GetParameters}}k.{{.Name}}, {{end}}
{{- else -}}
"{{.Name}}"
{{- end}}
{{- end}}

{{  define "encoder" -}}
{{- if .Wrapped -}}
values.Wrapped(values.{{title .DataType.String}}Wrapper)
{{- else if .Union -}}
values.Union({{unionMethod . "Unmarshal"}})
{{- else -}}
values.Struct[{{stateType . true}}]()
{{- end}}
{{- end}}

{{  define "newValue"}}
{{- if .IsSet}}
return values.NewSet(c.logger.L, c.{{valueStore .}}, {{template "key" .}}, {{template "valueLabel" .}}, {{template "encoder" .}},
	{{- if wrapped . -}}
	values.Compare{{title .DataType.String}}
	{{- else if .Comparator -}}
	{{.Comparator}}
	{{- else -}}
	func(u, v {{stateType . false}}) int { return u.Compare(v) }
	{{- end -}}
)
{{- else if .IsList}}
return values.NewList(c.logger.L, c.{{valueStore .}}, {{template "key" .}}, {{template "valueLabel" .}}, {{template "encoder" .}})
{{- else}}
return values.NewValue(c.logger.L, c.{{valueStore .}}, {{template "key" .}}, {{template "valueLabel" .}}, {{.EmptyIfMissing}}, {{template "encoder" .}})
{{- end}}
{{- end}}

{{define "newCounted"}}
{{- if wrapped .}}
return values.NewCounted(c.logger.L, c.{{valueStore .}}, {{template "key" .}}, {{template "valueLabel" .}}, values.WrappedFactory(values.{{title .DataType.String}}Wrapper))
{{- else if .Union}}
return values.NewCounted(c.logger.L, c.{{valueStore .}}, {{template "key" .}}, {{template "valueLabel" .}}, values.UnionFactory({{unionMethod . "Unmarshal"}}))
{{- else}}
return values.NewCounted(c.logger.L, c.{{valueStore .}}, {{template "key" .}}, {{template "valueLabel" .}}, values.Struct[{{stateType . true}}])
{{- end}}
{{- end}}

{{define "entity"}}
{{$c := .}}

{{if .Interface}}
type {{.FullName}} interface {
	record.Record
	{{- range .Attributes}}
	{{template "accessor" .}}({{range .GetParameters}}{{lower .Name}} {{parameterType .}},{{end}}) {{recordType . false}}
	{{- end}}
}
{{end}}

type {{fullName .}} struct {
	logger logging.OptionalLogger
	store record.Store
	{{- if not .Root}}
	key *record.Key
	label string
	{{- if .GetParent}}
	parent *{{fullName .GetParent}}
	{{- end}}
	{{- end}}
	{{- range .Fields}}
	{{.Name}} {{parameterType .}}
	{{- end}}
	{{  range .Attributes}}
	{{lower .Name}} {{fieldType .}}
	{{- end}}
}

func (c *{{fullName $c}}) Key() *record.Key { return {{if .Root}}nil{{else}}c.key{{end}} }

{{range .Attributes}}
{{if parameterized .}}
type {{lower .FullName}}Key struct {
	{{- range .GetParameters}}
	{{.Name}} {{parameterType .}}
	{{- end}}
}

type {{lower .FullName}}MapKey struct {
	{{- range .GetParameters}}
	{{.Name}} {{keyType .}}
	{{- end}}
}

{{$a := .}}
func (k {{lower .FullName}}Key) ForMap() {{lower .FullName}}MapKey {
	return {{lower $a.FullName}}MapKey{ {{range .GetParameters}}{{asKey . (print "k." .Name)}}, {{end}} }
}
{{end}}
{{end}}

{{range .Attributes}}
{{if not .OmitAccessor}}
func (c *{{fullName $c}}) {{template "accessor" .}}({{range .GetParameters}}{{lower .Name}} {{parameterType .}},{{end}}) {{recordType . false}} {
	{{- if parameterized .}}
	return values.GetOrCreateMap(c, &c.{{lower .Name}}, {{lower .FullName}}Key{ {{range .GetParameters}}{{lower .Name}},{{end}} }, (*{{fullName $c}}).new{{.Name}})
	{{- else}}
	return values.GetOrCreate(c, &c.{{lower .Name}}, (*{{fullName $c}}).new{{.Name}})
	{{- end -}}
}
{{end}}

{{if not .OmitConstructor}}
func (c *{{fullName $c}}) new{{.Name}}({{if parameterized .}}k {{lower .FullName}}Key{{end}}) {{recordType . true}} {
	{{- if .Type.IsEntity}}
	v := new({{fullName .}})
	v.logger = c.logger
	v.store = c.{{valueStore .}}
	v.key = {{template "key" .}}
	v.parent = c
	v.label = {{template "valueLabel" .}}
	return v
	{{- else if .Type.IsChain}}
	return database.NewChain(c.logger.L, c.{{valueStore .}}, {{template "key" .}}, markPower, merkle.ChainType{{title .ChainType}}, "{{chainNameFormat .}}", {{template "valueLabel" .}})
	{{- else if .Type.IsOther}}
	return {{if .Constructor}}{{.Constructor}}{{else}}new{{.DataType}}{{end}}(c, c.logger.L, c.store, {{template "key" .}}, "{{chainNameFormat .}}", {{template "valueLabel" .}})
	{{- else if .IsCounted}}
	{{- template "newCounted" .}}
	{{- else}}
	{{- template "newValue" .}}
	{{- end}}
}
{{end}}
{{end}}

{{if not .OmitResolve}}
func (c *{{fullName .}}) {{if .CustomResolve}}base{{end}}Resolve(key *record.Key) (record.Record, *record.Key, error) {
	if key.Len() == 0 {
		return nil, nil, errors.InternalError.With("bad key for {{natural .Name}}")
	}

	switch key.Get(0) {
	{{- range .Attributes}}
	case "{{.Name}}":
		{{- if parameterized .}}
		if key.Len() < {{add 1 (parameterCount .)}} {
			return nil, nil, errors.InternalError.With("bad key for {{natural $c.Name}}")
		}
		{{- range $index, $param := .GetParameters}}
		{{lower .Name}}, ok{{.Name}} := key.Get({{add 1 $index}}).({{parameterType $param}})
		{{- end}}
		if {{range $index, $param := .GetParameters}}{{if gt $index 0}} || {{end}}!ok{{.Name}}{{end}} {
			return nil, nil, errors.InternalError.With("bad key for {{natural $c.Name}}")
		}
		v := c.{{template "accessor" .}}({{range .GetParameters}}{{lower .Name}},{{end}})
		return v, key.SliceI({{add 1 (parameterCount .)}}), nil
		{{- else}}
		return c.{{template "accessor" .}}(), key.SliceI(1), nil
		{{- end}}
	{{- end}}
	default:
		return nil, nil, errors.InternalError.With("bad key for {{natural .Name}}")
	}
}
{{end}}

func (c *{{fullName .}}) {{if .CustomIsDirty}}base{{end}}IsDirty() bool {
	if c == nil {
		return false
	}

	{{  range .Attributes}}
	{{- if parameterized .}}
	for _, v := range c.{{lower .Name}} {
		if v.IsDirty() {
			return true
		}
	}
	{{- else}}
	if values.IsDirty(c.{{lower .Name}}) {
		return true
	}
	{{- end}}
	{{- end}}

	return false
}

{{if hasChains .}}
func (c *{{fullName .}}) dirtyChains() []*MerkleManager {
	if c == nil {
		return nil
	}

	var chains []*MerkleManager
	{{  range .Attributes}}
	{{- if parameterized .}}
	{{- if .Type.IsChain}}
	for _, v := range c.{{lower .Name}} {
		if v.IsDirty() {
			chains = append(chains, v)
		}
	}
	{{- else if hasChains .}}
	for _, v := range c.{{lower .Name}} {
		chains = append(chains, v.dirtyChains()...)
	}
	{{- end}}
	{{- else if .Type.IsChain}}
	if fieldIsDirty(c.{{lower .Name}}) {
		chains = append(chains, c.{{lower .Name}})
	}
	{{- else if hasChains .}}
	chains = append(chains, c.{{lower .Name}}.dirtyChains()...)
	{{- end}}
	{{- end}}

	return chains
}
{{end}}

{{if not .OmitWalk}}
func (c *{{fullName .}}) {{if .CustomWalk}}base{{end}}Walk(opts record.WalkOptions, fn record.WalkFunc) error {
	if c == nil {
		return nil
	}

	skip, err := values.WalkComposite(c, opts, fn)
	if skip || err != nil {
		return errors.UnknownError.Wrap(err)
	}

	{{- range .Attributes}}
	{{- if .Type.IsIndex}}
	if (!opts.IgnoreIndices) {
	{{- end}}
	{{- if parameterized .}}
	for _, v := range c.{{lower .Name}} {
		values.Walk(&err, v, opts, fn)
	}
	{{- else}}
	values.WalkField(&err, c.{{lower .Name}}, c.new{{.Name}}, opts, fn)
	{{- end}}
	{{- if .Type.IsIndex}}
	}
	{{- end}}
	{{- end}}
	return err
}
{{end}}

func (c *{{fullName .}}) {{if .CustomCommit}}base{{end}}Commit() error {
	if c == nil {
		return nil
	}

	var err error
	{{- range .Attributes}}
	{{- if parameterized .}}
	for _, v := range c.{{lower .Name}} {
		values.Commit(&err, v)
	}
	{{- else}}
	values.Commit(&err, c.{{lower .Name}})
	{{- end}}
	{{- end}}

	return err
}

{{range .Attributes}}
{{if .Type.IsEntity}}
{{template "entity" .}}
{{end}}
{{end}}
{{end}}

{{range .Records}}
{{template "entity" .}}
{{end}}
