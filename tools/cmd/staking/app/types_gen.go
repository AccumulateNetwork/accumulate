package app

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
)

type AccountParameters struct {
	fieldsSet []bool
	// TokenIssuance Token Issuance account acc://acme.
	TokenIssuance *url.URL `json:"tokenIssuance,omitempty" form:"tokenIssuance" query:"tokenIssuance" validate:"required"`
	// RegisteredADIs RegisteredADIs staking acc://staking.acme/Registered.
	RegisteredADIs *url.URL `json:"registeredADIs,omitempty" form:"registeredADIs" query:"registeredADIs" validate:"required"`
	// ApprovedADIs ApprovedADIs staking acc://staking.acme/Approved.
	ApprovedADIs *url.URL `json:"approvedADIs,omitempty" form:"approvedADIs" query:"approvedADIs" validate:"required"`
	// Disputes Disputes of staking acc://staking.acme/Disputes.
	Disputes *url.URL `json:"disputes,omitempty" form:"disputes" query:"disputes" validate:"required"`
	// StakingConfig Holds Parameter objects defining the config of staking.
	StakingConfig *url.URL `json:"stakingConfig,omitempty" form:"stakingConfig" query:"stakingConfig" validate:"required"`
	extraData     []byte
}

type AdiParameters struct {
	fieldsSet []bool
	// StakingService Staking Service ADI acc://staking.acme.
	StakingService *url.URL `json:"stakingService,omitempty" form:"stakingService" query:"stakingService" validate:"required"`
	extraData      []byte
}

type Parameters struct {
	fieldsSet []bool
	ADI       AdiParameters     `json:"adi,omitempty" form:"adi" query:"adi" validate:"required"`
	Account   AccountParameters `json:"account,omitempty" form:"account" query:"account" validate:"required"`
	// StartTime This is time zero for the protocol.
	StartTime time.Time `json:"startTime,omitempty" form:"startTime" query:"startTime" validate:"required"`
	// MajorBlockTime Scale time... 13000 gives about a 4 second major block.
	MajorBlockTime time.Duration `json:"majorBlockTime,omitempty" form:"majorBlockTime" query:"majorBlockTime" validate:"required"`
	// PayOutFreq Frequency of Payouts in major blocks. Only used in simulation.
	PayOutFreq int64 `json:"payOutFreq,omitempty" form:"payOutFreq" query:"payOutFreq" validate:"required"`
	// TokenLimit Total Tokens to be issued.
	TokenLimit int64 `json:"tokenLimit,omitempty" form:"tokenLimit" query:"tokenLimit" validate:"required"`
	// TokenIssuanceRate APR of payout of unissued tokens.
	TokenIssuanceRate float64          `json:"tokenIssuanceRate,omitempty" form:"tokenIssuanceRate" query:"tokenIssuanceRate" validate:"required"`
	StakingWeight     WeightParameters `json:"stakingWeight,omitempty" form:"stakingWeight" query:"stakingWeight" validate:"required"`
	// DelegateShare The share a Delegate Staker Keeps.
	DelegateShare float64 `json:"delegateShare,omitempty" form:"delegateShare" query:"delegateShare" validate:"required"`
	// DelegateeShare The share the Staker gets from the Delegates.
	DelegateeShare float64 `json:"delegateeShare,omitempty" form:"delegateeShare" query:"delegateeShare" validate:"required"`
	extraData      []byte
}

type WeightParameters struct {
	fieldsSet []bool
	// PureStaking Added weight for Pure Staking.
	PureStaking float64 `json:"pureStaking,omitempty" form:"pureStaking" query:"pureStaking" validate:"required"`
	// ProtocolValidator for Protocol Validators.
	ProtocolValidator float64 `json:"protocolValidator,omitempty" form:"protocolValidator" query:"protocolValidator" validate:"required"`
	// ProtocolFollower for Protocol Followers.
	ProtocolFollower float64 `json:"protocolFollower,omitempty" form:"protocolFollower" query:"protocolFollower" validate:"required"`
	// StakingValidator for Staking Validators.
	StakingValidator float64 `json:"stakingValidator,omitempty" form:"stakingValidator" query:"stakingValidator" validate:"required"`
	extraData        []byte
}

func (v *AccountParameters) Copy() *AccountParameters {
	u := new(AccountParameters)

	if v.TokenIssuance != nil {
		u.TokenIssuance = v.TokenIssuance
	}
	if v.RegisteredADIs != nil {
		u.RegisteredADIs = v.RegisteredADIs
	}
	if v.ApprovedADIs != nil {
		u.ApprovedADIs = v.ApprovedADIs
	}
	if v.Disputes != nil {
		u.Disputes = v.Disputes
	}
	if v.StakingConfig != nil {
		u.StakingConfig = v.StakingConfig
	}

	return u
}

func (v *AccountParameters) CopyAsInterface() interface{} { return v.Copy() }

func (v *AdiParameters) Copy() *AdiParameters {
	u := new(AdiParameters)

	if v.StakingService != nil {
		u.StakingService = v.StakingService
	}

	return u
}

func (v *AdiParameters) CopyAsInterface() interface{} { return v.Copy() }

func (v *Parameters) Copy() *Parameters {
	u := new(Parameters)

	u.ADI = *(&v.ADI).Copy()
	u.Account = *(&v.Account).Copy()
	u.StartTime = v.StartTime
	u.MajorBlockTime = v.MajorBlockTime
	u.PayOutFreq = v.PayOutFreq
	u.TokenLimit = v.TokenLimit
	u.TokenIssuanceRate = v.TokenIssuanceRate
	u.StakingWeight = *(&v.StakingWeight).Copy()
	u.DelegateShare = v.DelegateShare
	u.DelegateeShare = v.DelegateeShare

	return u
}

func (v *Parameters) CopyAsInterface() interface{} { return v.Copy() }

func (v *WeightParameters) Copy() *WeightParameters {
	u := new(WeightParameters)

	u.PureStaking = v.PureStaking
	u.ProtocolValidator = v.ProtocolValidator
	u.ProtocolFollower = v.ProtocolFollower
	u.StakingValidator = v.StakingValidator

	return u
}

func (v *WeightParameters) CopyAsInterface() interface{} { return v.Copy() }

func (v *AccountParameters) Equal(u *AccountParameters) bool {
	switch {
	case v.TokenIssuance == u.TokenIssuance:
		// equal
	case v.TokenIssuance == nil || u.TokenIssuance == nil:
		return false
	case !((v.TokenIssuance).Equal(u.TokenIssuance)):
		return false
	}
	switch {
	case v.RegisteredADIs == u.RegisteredADIs:
		// equal
	case v.RegisteredADIs == nil || u.RegisteredADIs == nil:
		return false
	case !((v.RegisteredADIs).Equal(u.RegisteredADIs)):
		return false
	}
	switch {
	case v.ApprovedADIs == u.ApprovedADIs:
		// equal
	case v.ApprovedADIs == nil || u.ApprovedADIs == nil:
		return false
	case !((v.ApprovedADIs).Equal(u.ApprovedADIs)):
		return false
	}
	switch {
	case v.Disputes == u.Disputes:
		// equal
	case v.Disputes == nil || u.Disputes == nil:
		return false
	case !((v.Disputes).Equal(u.Disputes)):
		return false
	}
	switch {
	case v.StakingConfig == u.StakingConfig:
		// equal
	case v.StakingConfig == nil || u.StakingConfig == nil:
		return false
	case !((v.StakingConfig).Equal(u.StakingConfig)):
		return false
	}

	return true
}

func (v *AdiParameters) Equal(u *AdiParameters) bool {
	switch {
	case v.StakingService == u.StakingService:
		// equal
	case v.StakingService == nil || u.StakingService == nil:
		return false
	case !((v.StakingService).Equal(u.StakingService)):
		return false
	}

	return true
}

func (v *Parameters) Equal(u *Parameters) bool {
	if !((&v.ADI).Equal(&u.ADI)) {
		return false
	}
	if !((&v.Account).Equal(&u.Account)) {
		return false
	}
	if !((v.StartTime).Equal(u.StartTime)) {
		return false
	}
	if !(v.MajorBlockTime == u.MajorBlockTime) {
		return false
	}
	if !(v.PayOutFreq == u.PayOutFreq) {
		return false
	}
	if !(v.TokenLimit == u.TokenLimit) {
		return false
	}
	if !(v.TokenIssuanceRate == u.TokenIssuanceRate) {
		return false
	}
	if !((&v.StakingWeight).Equal(&u.StakingWeight)) {
		return false
	}
	if !(v.DelegateShare == u.DelegateShare) {
		return false
	}
	if !(v.DelegateeShare == u.DelegateeShare) {
		return false
	}

	return true
}

func (v *WeightParameters) Equal(u *WeightParameters) bool {
	if !(v.PureStaking == u.PureStaking) {
		return false
	}
	if !(v.ProtocolValidator == u.ProtocolValidator) {
		return false
	}
	if !(v.ProtocolFollower == u.ProtocolFollower) {
		return false
	}
	if !(v.StakingValidator == u.StakingValidator) {
		return false
	}

	return true
}

var fieldNames_AccountParameters = []string{
	1: "TokenIssuance",
	2: "RegisteredADIs",
	3: "ApprovedADIs",
	4: "Disputes",
	5: "StakingConfig",
}

func (v *AccountParameters) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.TokenIssuance == nil) {
		writer.WriteUrl(1, v.TokenIssuance)
	}
	if !(v.RegisteredADIs == nil) {
		writer.WriteUrl(2, v.RegisteredADIs)
	}
	if !(v.ApprovedADIs == nil) {
		writer.WriteUrl(3, v.ApprovedADIs)
	}
	if !(v.Disputes == nil) {
		writer.WriteUrl(4, v.Disputes)
	}
	if !(v.StakingConfig == nil) {
		writer.WriteUrl(5, v.StakingConfig)
	}

	_, _, err := writer.Reset(fieldNames_AccountParameters)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AccountParameters) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field TokenIssuance is missing")
	} else if v.TokenIssuance == nil {
		errs = append(errs, "field TokenIssuance is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field RegisteredADIs is missing")
	} else if v.RegisteredADIs == nil {
		errs = append(errs, "field RegisteredADIs is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ApprovedADIs is missing")
	} else if v.ApprovedADIs == nil {
		errs = append(errs, "field ApprovedADIs is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field Disputes is missing")
	} else if v.Disputes == nil {
		errs = append(errs, "field Disputes is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field StakingConfig is missing")
	} else if v.StakingConfig == nil {
		errs = append(errs, "field StakingConfig is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_AdiParameters = []string{
	1: "StakingService",
}

func (v *AdiParameters) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.StakingService == nil) {
		writer.WriteUrl(1, v.StakingService)
	}

	_, _, err := writer.Reset(fieldNames_AdiParameters)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *AdiParameters) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field StakingService is missing")
	} else if v.StakingService == nil {
		errs = append(errs, "field StakingService is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_Parameters = []string{
	1:  "ADI",
	2:  "Account",
	3:  "StartTime",
	4:  "MajorBlockTime",
	5:  "PayOutFreq",
	6:  "TokenLimit",
	7:  "TokenIssuanceRate",
	8:  "StakingWeight",
	9:  "DelegateShare",
	10: "DelegateeShare",
}

func (v *Parameters) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !((v.ADI).Equal(new(AdiParameters))) {
		writer.WriteValue(1, v.ADI.MarshalBinary)
	}
	if !((v.Account).Equal(new(AccountParameters))) {
		writer.WriteValue(2, v.Account.MarshalBinary)
	}
	if !(v.StartTime == (time.Time{})) {
		writer.WriteTime(3, v.StartTime)
	}
	if !(v.MajorBlockTime == 0) {
		writer.WriteDuration(4, v.MajorBlockTime)
	}
	if !(v.PayOutFreq == 0) {
		writer.WriteInt(5, v.PayOutFreq)
	}
	if !(v.TokenLimit == 0) {
		writer.WriteInt(6, v.TokenLimit)
	}
	if !(v.TokenIssuanceRate == 0) {
		writer.WriteFloat(7, v.TokenIssuanceRate)
	}
	if !((v.StakingWeight).Equal(new(WeightParameters))) {
		writer.WriteValue(8, v.StakingWeight.MarshalBinary)
	}
	if !(v.DelegateShare == 0) {
		writer.WriteFloat(9, v.DelegateShare)
	}
	if !(v.DelegateeShare == 0) {
		writer.WriteFloat(10, v.DelegateeShare)
	}

	_, _, err := writer.Reset(fieldNames_Parameters)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *Parameters) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field ADI is missing")
	} else if (v.ADI).Equal(new(AdiParameters)) {
		errs = append(errs, "field ADI is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Account is missing")
	} else if (v.Account).Equal(new(AccountParameters)) {
		errs = append(errs, "field Account is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field StartTime is missing")
	} else if v.StartTime == (time.Time{}) {
		errs = append(errs, "field StartTime is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field MajorBlockTime is missing")
	} else if v.MajorBlockTime == 0 {
		errs = append(errs, "field MajorBlockTime is not set")
	}
	if len(v.fieldsSet) > 5 && !v.fieldsSet[5] {
		errs = append(errs, "field PayOutFreq is missing")
	} else if v.PayOutFreq == 0 {
		errs = append(errs, "field PayOutFreq is not set")
	}
	if len(v.fieldsSet) > 6 && !v.fieldsSet[6] {
		errs = append(errs, "field TokenLimit is missing")
	} else if v.TokenLimit == 0 {
		errs = append(errs, "field TokenLimit is not set")
	}
	if len(v.fieldsSet) > 7 && !v.fieldsSet[7] {
		errs = append(errs, "field TokenIssuanceRate is missing")
	} else if v.TokenIssuanceRate == 0 {
		errs = append(errs, "field TokenIssuanceRate is not set")
	}
	if len(v.fieldsSet) > 8 && !v.fieldsSet[8] {
		errs = append(errs, "field StakingWeight is missing")
	} else if (v.StakingWeight).Equal(new(WeightParameters)) {
		errs = append(errs, "field StakingWeight is not set")
	}
	if len(v.fieldsSet) > 9 && !v.fieldsSet[9] {
		errs = append(errs, "field DelegateShare is missing")
	} else if v.DelegateShare == 0 {
		errs = append(errs, "field DelegateShare is not set")
	}
	if len(v.fieldsSet) > 10 && !v.fieldsSet[10] {
		errs = append(errs, "field DelegateeShare is missing")
	} else if v.DelegateeShare == 0 {
		errs = append(errs, "field DelegateeShare is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_WeightParameters = []string{
	1: "PureStaking",
	2: "ProtocolValidator",
	3: "ProtocolFollower",
	4: "StakingValidator",
}

func (v *WeightParameters) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.PureStaking == 0) {
		writer.WriteFloat(1, v.PureStaking)
	}
	if !(v.ProtocolValidator == 0) {
		writer.WriteFloat(2, v.ProtocolValidator)
	}
	if !(v.ProtocolFollower == 0) {
		writer.WriteFloat(3, v.ProtocolFollower)
	}
	if !(v.StakingValidator == 0) {
		writer.WriteFloat(4, v.StakingValidator)
	}

	_, _, err := writer.Reset(fieldNames_WeightParameters)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *WeightParameters) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PureStaking is missing")
	} else if v.PureStaking == 0 {
		errs = append(errs, "field PureStaking is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field ProtocolValidator is missing")
	} else if v.ProtocolValidator == 0 {
		errs = append(errs, "field ProtocolValidator is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field ProtocolFollower is missing")
	} else if v.ProtocolFollower == 0 {
		errs = append(errs, "field ProtocolFollower is not set")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field StakingValidator is missing")
	} else if v.StakingValidator == 0 {
		errs = append(errs, "field StakingValidator is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *AccountParameters) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AccountParameters) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.TokenIssuance = x
	}
	if x, ok := reader.ReadUrl(2); ok {
		v.RegisteredADIs = x
	}
	if x, ok := reader.ReadUrl(3); ok {
		v.ApprovedADIs = x
	}
	if x, ok := reader.ReadUrl(4); ok {
		v.Disputes = x
	}
	if x, ok := reader.ReadUrl(5); ok {
		v.StakingConfig = x
	}

	seen, err := reader.Reset(fieldNames_AccountParameters)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *AdiParameters) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *AdiParameters) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadUrl(1); ok {
		v.StakingService = x
	}

	seen, err := reader.Reset(fieldNames_AdiParameters)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Parameters) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *Parameters) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(AdiParameters); reader.ReadValue(1, x.UnmarshalBinary) {
		v.ADI = *x
	}
	if x := new(AccountParameters); reader.ReadValue(2, x.UnmarshalBinary) {
		v.Account = *x
	}
	if x, ok := reader.ReadTime(3); ok {
		v.StartTime = x
	}
	if x, ok := reader.ReadDuration(4); ok {
		v.MajorBlockTime = x
	}
	if x, ok := reader.ReadInt(5); ok {
		v.PayOutFreq = x
	}
	if x, ok := reader.ReadInt(6); ok {
		v.TokenLimit = x
	}
	if x, ok := reader.ReadFloat(7); ok {
		v.TokenIssuanceRate = x
	}
	if x := new(WeightParameters); reader.ReadValue(8, x.UnmarshalBinary) {
		v.StakingWeight = *x
	}
	if x, ok := reader.ReadFloat(9); ok {
		v.DelegateShare = x
	}
	if x, ok := reader.ReadFloat(10); ok {
		v.DelegateeShare = x
	}

	seen, err := reader.Reset(fieldNames_Parameters)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *WeightParameters) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *WeightParameters) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadFloat(1); ok {
		v.PureStaking = x
	}
	if x, ok := reader.ReadFloat(2); ok {
		v.ProtocolValidator = x
	}
	if x, ok := reader.ReadFloat(3); ok {
		v.ProtocolFollower = x
	}
	if x, ok := reader.ReadFloat(4); ok {
		v.StakingValidator = x
	}

	seen, err := reader.Reset(fieldNames_WeightParameters)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *Parameters) MarshalJSON() ([]byte, error) {
	u := struct {
		ADI               AdiParameters     `json:"adi,omitempty"`
		Account           AccountParameters `json:"account,omitempty"`
		StartTime         time.Time         `json:"startTime,omitempty"`
		MajorBlockTime    interface{}       `json:"majorBlockTime,omitempty"`
		PayOutFreq        int64             `json:"payOutFreq,omitempty"`
		TokenLimit        int64             `json:"tokenLimit,omitempty"`
		TokenIssuanceRate float64           `json:"tokenIssuanceRate,omitempty"`
		StakingWeight     WeightParameters  `json:"stakingWeight,omitempty"`
		DelegateShare     float64           `json:"delegateShare,omitempty"`
		DelegateeShare    float64           `json:"delegateeShare,omitempty"`
	}{}
	u.ADI = v.ADI
	u.Account = v.Account
	u.StartTime = v.StartTime
	u.MajorBlockTime = encoding.DurationToJSON(v.MajorBlockTime)
	u.PayOutFreq = v.PayOutFreq
	u.TokenLimit = v.TokenLimit
	u.TokenIssuanceRate = v.TokenIssuanceRate
	u.StakingWeight = v.StakingWeight
	u.DelegateShare = v.DelegateShare
	u.DelegateeShare = v.DelegateeShare
	return json.Marshal(&u)
}

func (v *Parameters) UnmarshalJSON(data []byte) error {
	u := struct {
		ADI               AdiParameters     `json:"adi,omitempty"`
		Account           AccountParameters `json:"account,omitempty"`
		StartTime         time.Time         `json:"startTime,omitempty"`
		MajorBlockTime    interface{}       `json:"majorBlockTime,omitempty"`
		PayOutFreq        int64             `json:"payOutFreq,omitempty"`
		TokenLimit        int64             `json:"tokenLimit,omitempty"`
		TokenIssuanceRate float64           `json:"tokenIssuanceRate,omitempty"`
		StakingWeight     WeightParameters  `json:"stakingWeight,omitempty"`
		DelegateShare     float64           `json:"delegateShare,omitempty"`
		DelegateeShare    float64           `json:"delegateeShare,omitempty"`
	}{}
	u.ADI = v.ADI
	u.Account = v.Account
	u.StartTime = v.StartTime
	u.MajorBlockTime = encoding.DurationToJSON(v.MajorBlockTime)
	u.PayOutFreq = v.PayOutFreq
	u.TokenLimit = v.TokenLimit
	u.TokenIssuanceRate = v.TokenIssuanceRate
	u.StakingWeight = v.StakingWeight
	u.DelegateShare = v.DelegateShare
	u.DelegateeShare = v.DelegateeShare
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	v.ADI = u.ADI
	v.Account = u.Account
	v.StartTime = u.StartTime
	if x, err := encoding.DurationFromJSON(u.MajorBlockTime); err != nil {
		return fmt.Errorf("error decoding MajorBlockTime: %w", err)
	} else {
		v.MajorBlockTime = x
	}
	v.PayOutFreq = u.PayOutFreq
	v.TokenLimit = u.TokenLimit
	v.TokenIssuanceRate = u.TokenIssuanceRate
	v.StakingWeight = u.StakingWeight
	v.DelegateShare = u.DelegateShare
	v.DelegateeShare = u.DelegateeShare
	return nil
}
