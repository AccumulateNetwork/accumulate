// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package {{.Package}}

// GENERATED BY go run ./tools/cmd/gen-api. DO NOT EDIT.

import (
	"context"
	"encoding/json"

	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/pkg/api/v3"
	"github.com/AccumulateNetwork/jsonrpc2/v15"
)

func (m *JrpcMethods) populateMethodTable() jsonrpc2.MethodMap {
	if m.methods == nil {
		m.methods = make(jsonrpc2.MethodMap, {{len .Methods}})
	}
	{{range .Methods}}
	m.methods["{{.RPC}}"] = jrpcBatchQuery(m.{{.Name}}){{end}}

	return m.methods
}

func (m *JrpcMethods) parse(params json.RawMessage, target interface{}, validateFields ...string) error {
	err := json.Unmarshal(params, target)
	if err != nil {
		return validatorError(err)
	}

	// validate fields
	if len(validateFields) == 0 {
		if err = m.validate.Struct(target); err != nil {
			return validatorError(err)
		}
	} else {
		if err = m.validate.StructPartial(target, validateFields...); err != nil {
			return validatorError(err)
		}
	}

	return nil
}

func jrpcBatchQuery(m jsonrpc2.MethodFunc) jsonrpc2.MethodFunc {
	return func(ctx context.Context, params json.RawMessage) interface{} {
		ctx, cancel, _ := api.ContextWithBatchData(ctx)
		defer cancel()
		return m(ctx, params)
	}
}

func jrpcFormatResponse(res interface{}, err error) interface{} {
	if err != nil {
		return accumulateError(err)
	}

	return res
}

{{range .Methods}}
{{if eq .Kind "query"}}
{{if .Description}}// {{.Name}} {{.Description}}.{{end}}
{{- if .Experimental}}
//
// WARNING: EXPERIMENTAL! {{end}}
func (m *JrpcMethods) {{.Name}}(ctx context.Context, params json.RawMessage) interface{} {
	req := new({{.Input}})
	err := m.parse(params, req)
	if err != nil {
		return err
	}

	subnet, err := m.Router.RouteAccount(req.{{.RouteParam}})
	if err != nil {
		return validatorError(err)
	}

	if subnet == m.Options.Describe.PartitionId {
		return jrpcFormatResponse(m.querier.{{.Call}}({{range $i, $v := .CallParams}}{{if gt $i 0}}, {{end}}req.{{$v}}{{end}}))
	}

	var result interface{}
	err = m.Router.RequestAPIv2(ctx, subnet, "{{.RPC}}", params, &result)
	if err != nil {
		return accumulateError(err)
	}
	return result
}
{{else if eq .Kind "execute"}}
{{if .Description}}// {{.Name}} {{.Description}}.{{end}}
{{- if .Experimental}}
//
// WARNING! EXPERIMENTAL! {{end}}
func (m *JrpcMethods) {{.Name}}(ctx context.Context, params json.RawMessage) interface{} {
	return m.executeWith(ctx, params, new(protocol.{{.Input}}){{range .Validate}}, "{{.}}"{{end}})
}
{{end}}
{{end}}