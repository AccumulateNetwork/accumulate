package {{.Package}}

// GENERATED BY go run ./tools/cmd/gen-record. DO NOT EDIT.

import (
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/internal/errors"
	"gitlab.com/accumulatenetwork/accumulate/internal/logging"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	"gitlab.com/accumulatenetwork/accumulate/smt/managed"
	"gitlab.com/accumulatenetwork/accumulate/smt/storage"
)

{{  define "valueLabelFormat"}}
{{- if isBaseType .GetContainer -}}
c.label + " {{natural .Name}}"
{{- else -}}
"{{valueNameFormat .}}"
{{- end}}
{{- end}}

{{  define "chainNameFormat"}}
{{- if isBaseType .GetContainer -}}
c.name + "-{{natural .Name}}"
{{- else -}}
"{{chainNameFormat .}}"
{{- end}}
{{- end}}

{{  define "key"}}
{{- if .GetContainer.Root -}}
recordKey{}
{{- else -}}
c.key
{{- end}}
{{- if parameterized . -}}
.Append("{{.Name}}", {{range .GetParameters}}{{lower .Name}}{{end}})
{{- else -}}
.Append("{{.Name}}")
{{- end}}
{{- end}}

{{  define "newValue"}}
{{- if and .Wrapped .Set}}
return newSet(c.store, {{template "key" .}}, {{template "valueLabelFormat" .}}, newWrapperSlice({{lower .DataType.String}}Wrapper), compare{{title .DataType.String}})
{{- else if .Wrapped}}
return newWrapped(c.store, {{template "key" .}}, {{template "valueLabelFormat" .}}, {{.EmptyIfMissing}}, newWrapper({{lower .DataType.String}}Wrapper))
{{- else if .Set}}
new := func() (v {{stateType . false}}) { return {{if .Pointer}}new({{stateType . true}}){{else}}v{{end}} }
cmp := func(u, v {{stateType . false}}) int { return u.Compare(v) }
return newSet(c.store, {{template "key" .}}, {{template "valueLabelFormat" .}}, newSlice(new), cmp)
{{- else if .Union}}
return newWrapped(c.store, {{template "key" .}}, {{template "valueLabelFormat" .}}, {{.EmptyIfMissing}}, newUnion({{unionMethod . "Unmarshal"}}))
{{- else}}
new := func() (v {{stateType . false}}) { return {{if .Pointer}}new({{stateType . true}}){{else}}v{{end}} }
return newValue(c.store, {{template "key" .}}, {{template "valueLabelFormat" .}}, {{.EmptyIfMissing}}, new)
{{- end}}
{{- end}}

{{define "newCounted"}}
{{- if .Wrapped}}
return newCounted(c.store, {{template "key" .}}, {{template "valueLabelFormat" .}}, newCountableWrapped({{lower .DataType.String}}Wrapper))
{{- else}}
new := func() (v {{stateType . false}}) { return {{if .Pointer}}new({{stateType . true}}){{else}}v{{end}} }
return newCounted(c.store, {{template "key" .}}, {{template "valueLabelFormat" .}}, newCountableValue(new))
{{- end}}
{{- end}}

{{define "container"}}
type {{.FullName}} struct {
	store recordStore
	{{- if not .OmitKey}}
	key recordKey
	{{- end}}
	{{- if not .Root}}
	container *{{.GetContainer.FullName}}
	{{- end}}
	{{- range .Fields}}
	{{.Name}} {{parameterType .}}
	{{- end}}
	{{  range .Parts}}
	{{lower .Name}} {{fieldType .}}
	{{- end}}
}

{{$c := .}}
{{range .Parts}}
{{if not .OmitAccessor}}
func (c *{{$c.FullName}}) {{.Name}}({{range .GetParameters}}{{lower .Name}} {{parameterType .}},{{end}}) *{{recordType .}} {
	{{- if parameterized .}}
	return getOrCreateMap(&c.{{lower .Name}}, {{template "key" .}},
	{{- else}}
	return getOrCreateField(&c.{{lower .Name}},
	{{- end -}}

	func() *{{recordType .}} {
		{{- if .Type.IsContainer}}
		v := new({{.FullName}})
		v.store = c.store
		v.key = {{template "key" .}}
		v.container = c
		return v
		{{- else if .Type.IsChain}}
		return newChain(c.store, {{template "key" .}}, protocol.ChainType{{title .ChainType}}, {{template "chainNameFormat" .}}, {{template "valueLabelFormat" .}})
		{{- else if .Type.IsOther}}
		return new{{.DataType}}(c.store, {{template "key" .}}, {{template "chainNameFormat" .}}, {{template "valueLabelFormat" .}})
		{{- else if .Counted}}
		{{template "newCounted" .}}
		{{- else}}
		{{- template "newValue" .}}
		{{- end}}
	})
}
{{end}}
{{end}}

func (c *{{.FullName}}) resolve(key recordKey) (record, recordKey, error) {
	switch key[0] {
	{{- range .Parts}}
	case "{{.Name}}":
		{{- if parameterized .}}
		if len(key) < {{add 1 (parameterCount .)}} {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for {{natural $c.Name}}")
		}
		{{- range $index, $param := .GetParameters}}
		{{lower .Name}}, ok{{.Name}} := key[{{add 1 $index}}].({{parameterType $param}})
		{{- end}}
		if {{range $index, $param := .GetParameters}}{{if gt $index 0}} || {{end}}ok{{.Name}}{{end}} {
			return nil, nil, errors.New(errors.StatusInternalError, "bad key for {{natural $c.Name}}")
		}
		v := c.{{.Name}}({{range .GetParameters}}{{lower .Name}},{{end}})
		return v, key[{{add 1 (parameterCount .)}}:], nil
		{{- else}}
		return c.{{lower .Name}}, key[1:], nil
		{{- end}}
	{{- end}}
	default:
		return nil, nil, errors.New(errors.StatusInternalError, "bad key for {{natural .Name}}")
	}
}

func (c *{{.FullName}}) isDirty() bool {
	if c == nil {
		return false
	}

	{{  range .Parts}}
	{{- if parameterized .}}
	for _, v := range c.{{lower .Name}} {
		if v.isDirty() {
			return true
		}
	}
	{{- else}}
	if c.{{lower .Name}}.isDirty() {
		return true
	}
	{{- end}}
	{{- end}}

	return false
}

{{if .HasChains}}
{{if not (and .Root (eq .FullName "ChangeSet"))}}
func (c *{{.FullName}}) resolveChain(name string) (*Chain, bool) {
	switch {
	{{- range .Parts}}
	{{- if and (parameterized .) (or .Type.IsChain (and .Type.IsContainer .HasChains))}}
	case strings.HasPrefix(name, "{{chainName .}}("):
		name = name[len("{{chainName .}}("):]
		i := strings.Index(name, ")")
		if i < 0 {
			return nil, false
		}

		params := strings.Split(name[:i], ",")
		name = name[i+1:]
		if len(params) != {{parameterCount .}} {
			return nil, false
		}

		{{- range $i, $p := .Parameters}}
		param{{$p.Name}}, err := parse{{title $p.Type.String}}(params[{{$i}}])
		if err != nil {
			return nil, false
		}
		{{- end}}

		return c.{{.Name}}({{range .Parameters}}param{{.Name}},{{end}}){{if .Type.IsChain}}, true{{else}}.resolveChain(name){{end}}

	{{  else if and .Type.IsContainer .HasChains}}
	case strings.HasPrefix(name, "{{chainName .}}-"):
		return c.{{.Name}}().resolveChain(name[len("{{chainName .}}-"):])

	{{  else if .Type.IsChain}}
	case name == "{{chainName .}}":
		return c.{{.Name}}(), true

	{{  end}}
	{{- end}}
	default:
		return nil, false
	}
}
{{end}}

func (c *{{.FullName}}) dirtyChains() []*Chain {
	if c == nil {
		return nil
	}

	var chains []*Chain
	{{  range .Parts}}
	{{- if parameterized .}}
	{{- if and .Type.IsContainer .HasChains}}
	for _, v := range c.{{lower .Name}} {
		chains = append(chains, v.dirtyChains()...)
	}
	{{- else if .Type.IsChain}}
	for _, v := range c.{{lower .Name}} {
		if v.isDirty() {
			chains = append(chains, v)
		}
	}
	{{- end}}
	{{- else if and .Type.IsContainer .HasChains}}
	chains = append(chains, c.{{lower .Name}}.dirtyChains()...)
	{{- else if .Type.IsChain}}
	if c.{{lower .Name}}.isDirty() {
		chains = append(chains, c.{{lower .Name}})
	}
	{{- end}}
	{{- end}}

	return chains
}
{{end}}

func (c *{{.FullName}}) {{if .CustomCommit}}baseCommit{{else}}commit{{end}}() error {
	if c == nil {
		return nil
	}

	{{  range .Parts}}
	{{- if parameterized .}}
	for _, v := range c.{{lower .Name}} {
		if err := v.commit(); err != nil {
			return errors.Wrap(errors.StatusUnknown, err)
		}
	}
	{{- else}}
	if err := c.{{lower .Name}}.commit(); err != nil {
		return errors.Wrap(errors.StatusUnknown, err)
	}
	{{- end}}
	{{- end}}

	return nil
}

{{range .Parts}}
{{if .Type.IsContainer}}
{{template "container" .}}
{{end}}
{{end}}
{{end}}

{{range .Records}}
{{template "container" .}}
{{end}}

func getOrCreateField[T any](ptr **T, create func() *T) *T {
	if *ptr != nil {
		return *ptr
	}

	*ptr = create()
	return *ptr
}

func getOrCreateMap[T any](ptr *map[storage.Key]*T, key recordKey, create func() *T) *T {
	if *ptr == nil {
		*ptr = map[storage.Key]*T{}
	}

	k := key.Hash()
	if v, ok := (*ptr)[k]; ok {
		return v
	}

	v := create()
	(*ptr)[k] = v
	return v
}
