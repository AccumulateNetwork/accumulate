package {{.Package}}

// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"math/big"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/config"
	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/types"
	{{- if not (isPkg "protocol")}}
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	{{- end}}
	{{- if not (isPkg "types/state")}}
	"gitlab.com/accumulatenetwork/accumulate/types/state"
	{{- end}}
	{{- if not (isPkg "types/api/transactions")}}
	"gitlab.com/accumulatenetwork/accumulate/types/api/transactions"
	{{- end}}
)

{{range .Types}}
type {{.Name}} struct {
	{{if .IsBinary}}fieldsSet []bool{{end}}
	{{- range .Embeddings}}
	{{.Name}}
	{{- end}}
	{{- range .Fields}}
	{{.Name}} {{resolveType . false}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
	{{- end}}
}
{{end}}

{{range .Types}}
{{- if and .IsChain .MakeConstructor}}
// Deprated: use new({{.Name}})
func New{{.Name}}() *{{.Name}} {
	return new({{.Name}})
}
{{- end}}
{{end}}

{{range .Types}}{{if or .IsTransaction .IsTxResult}}
func (*{{.Name}}) GetType() {{pkg "protocol"}}TransactionType { return {{pkg "protocol"}}TransactionType{{.TransactionType}} }
{{else if .IsChain}}
func (*{{.Name}}) GetType() {{pkg "protocol"}}AccountType { return {{pkg "protocol"}}AccountType{{.ChainType}} }
{{end}}{{end}}

{{range .Types}}{{if .IsComparable}}
func (v *{{.Name}}) Equal(u *{{.Name}}) bool {
	{{- range .Embeddings}}
	if !v.{{.Name}}.Equal(&u.{{.Name}}) {
		return false
	}
	{{- end}}


	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{areEqual . (print "v." .Name) (print "u." .Name)}}
	{{- end}}
	{{- end}}

	return true
}
{{end}}{{end}}

{{range .Types}}{{if .IsBinary}}
var fieldNames_{{.Name}} = []string{
	{{- if or .IsTransaction .IsTxResult .IsChain}}
	"Type",
	{{- end}}

	{{- range .Embeddings}}
	{{.Number}}: "{{.Name}}",
	{{- end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{.Number}}: "{{.Name}}",
	{{- end}}
	{{- end}}
}

func (v *{{.Name}}) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	{{if or .IsTransaction .IsTxResult}}
	writer.WriteUint(1, {{pkg "protocol"}}TransactionType{{.TransactionType}}.ID())
	{{- else if .IsChain}}
	writer.WriteUint(1, {{pkg "protocol"}}AccountType{{.ChainType}}.ID())
	{{- end}}

	{{- range .Embeddings}}
	writer.WriteValue({{.Number}}, &v.{{.Name}})
	{{- end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{- if .OmitEmpty}}
	if !({{isZero . (print "v." .Name)}}) {
		{{binaryMarshalValue . "writer" (print "v." .Name)}}
	}
	{{- else }}
	{{binaryMarshalValue . "writer" (print "v." .Name)}}
	{{- end}}
	{{- end}}
	{{- end}}

	_, _, err := writer.Reset(fieldNames_{{.Name}})
	return buffer.Bytes(), err
}

func (v *{{.Name}}) IsValid() error {
	var errs []string

	{{range .Embeddings}}
	if err := v.{{.Name}}.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	{{- end}}

	{{- range .Fields}}
	{{- if and .IsMarshalled .IsRequired}}
	if len(v.fieldsSet) > {{.Number}} && !v.fieldsSet[{{.Number}}] {
		errs = append(errs, "field {{.Name}} is missing")
	} else if {{isZero . (print "v." .Name)}} {
		errs = append(errs, "field {{.Name}} is not set")
	}
	{{- end}}
	{{- end}}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}
{{end}}{{end}}

{{range .Types}}{{if .IsBinary}}
func (v *{{.Name}}) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *{{.Name}}) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	{{if or .IsTransaction .IsTxResult}}
	if x, ok := reader.ReadUint(1); !ok {
		return fmt.Errorf("field Type: missing")
	} else if x != {{pkg "protocol"}}TransactionType{{.TransactionType}}.ID() {
		return fmt.Errorf("field Type: want %v, got %v", {{pkg "protocol"}}TransactionType{{.TransactionType}}, {{pkg "protocol"}}TransactionType(x))
	}
	{{- else if .IsChain}}
	if x, ok := reader.ReadUint(1); !ok {
		return fmt.Errorf("field Type: missing")
	} else if x != {{pkg "protocol"}}AccountType{{.ChainType}}.ID() {
		return fmt.Errorf("field Type: want %v, got %v", {{pkg "protocol"}}AccountType{{.ChainType}}, {{pkg "protocol"}}AccountType(x))
	}
	{{end}}

	{{- range .Embeddings}}
	reader.ReadValue({{.Number}}, v.{{.Name}}.UnmarshalBinary)
	{{end}}

	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{binaryUnmarshalValue . "reader" (print "v." .Name)}}
	{{- end}}
	{{- end}}

	seen, err := reader.Reset(fieldNames_{{.Name}})
	v.fieldsSet = seen
	return err
}
{{end}}{{end}}

{{define "jsonField"}}
{{- if .IsMarshalled}}
{{.Name}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
{{- if .AlternativeName}}
{{.AlternativeName}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .AlternativeName}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
{{- end}}
{{- end}}
{{- end}}

{{define "jsonType"}}struct {
	{{- if or .IsTxResult .IsTransaction}}
	Type {{pkg "protocol"}}TransactionType `json:"type"`{{else if .IsChain}}
	Type {{pkg "protocol"}}AccountType `json:"type"`{{end}}
	{{- range .Embeddings}}
	{{- range .Fields}}
	{{- template "jsonField" .}}
	{{- end}}
	{{- end}}
	{{- range .Fields}}
	{{- template "jsonField" .}}
	{{- end}}
}
{{- end}}

{{define "valueToJson"}}
{{- if .Field.IsMarshalled}}
{{valueToJson .Field (print .Dst "." .Field.Name) (print .Src "." .Field.Name) .ForUnmarshal .Field.Name}}
{{- if .Field.AlternativeName}}
{{valueToJson .Field (print .Dst "." .Field.AlternativeName) (print .Src "." .Field.Name) .ForUnmarshal .Field.Name}}
{{- end}}
{{- end}}
{{- end}}

{{define "valueFromJson"}}
{{- if .Field.IsMarshalled}}
{{- if .Field.AlternativeName}}
if u.{{.Field.Name}} != {{jsonZeroValue .Field}} {
	{{valueFromJson .Field (print .Dst "." .Field.Name) (print .Src "." .Field.Name) .Field.Name}}
} else {
	{{valueFromJson .Field (print .Dst "." .Field.Name) (print .Src "." .Field.AlternativeName) .Field.Name}}
}
{{- else}}
{{valueFromJson .Field (print .Dst "." .Field.Name) (print .Src "." .Field.Name) .Field.Name}}
{{- end}}
{{- end}}
{{- end}}

{{range .Types}}{{if needsCustomJSON .}}
func (v *{{.Name}}) MarshalJSON() ([]byte, error) {
	u := {{template "jsonType" .}}{}

	{{- if or .IsTransaction .IsTxResult .IsChain}}
	u.Type = v.GetType()
	{{- end}}

	{{- range .Embeddings}}
	{{- $name := .Name}}
	{{- range .Fields}}
	{{- template "valueToJson" map "Field" . "Src" (print "v." $name) "Dst" "u" "ForUnmarshal" false}}
	{{- end}}
	{{- end}}

	{{- range .Fields}}
	{{- template "valueToJson" map "Field" . "Src" "v" "Dst" "u" "ForUnmarshal" false}}
	{{- end}}
	return json.Marshal(&u)
}
{{end}}{{end}}

{{range .Types}}{{if needsCustomJSON .}}
func (v *{{.Name}}) UnmarshalJSON(data []byte) error {
	u := {{template "jsonType" .}}{}

	{{- if or .IsTransaction .IsTxResult .IsChain}}
	u.Type = v.GetType()
	{{- end}}

	{{- range .Embeddings}}
	{{- $name := .Name}}
	{{- range .Fields}}
	{{- template "valueToJson" map "Field" . "Src" (print "v." $name) "Dst" "u" "ForUnmarshal" true}}
	{{- end}}
	{{- end}}

	{{- range .Fields}}
	{{- template "valueToJson" map "Field" . "Src" "v" "Dst" "u" "ForUnmarshal" true}}
	{{- end}}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}

	{{- range .Embeddings}}
	{{- $name := .Name}}
	{{- range .Fields}}
	{{- template "valueFromJson" map "Field" . "Src" "u" "Dst" (print "v." $name)}}
	{{- end}}
	{{- end}}

	{{- range .Fields}}
	{{- template "valueFromJson" map "Field" . "Src" "u" "Dst" "v"}}
	{{- end}}
	return nil
}
{{end}}{{end}}