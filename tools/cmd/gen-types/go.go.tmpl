package {{.Package}}

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"math/big"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/config"
	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
	"gitlab.com/accumulatenetwork/accumulate/internal/url"
	"gitlab.com/accumulatenetwork/accumulate/types"
	{{- if not (isPkg "protocol")}}
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	{{- end}}
	{{- if not (isPkg "types/state")}}
	"gitlab.com/accumulatenetwork/accum1ulate/types/state"
	{{- end}}
	{{- if not (isPkg "types/api/transactions")}}
	"gitlab.com/accumulatenetwork/accumulate/types/api/transactions"
	{{- end}}
)

{{range .Types}}
{{-   if .Description}}
// {{.Name}} {{.Description}}.
{{-   end}}
type {{.Name}} struct {
	{{  if .IsBinary}}fieldsSet []bool{{end}}
	{{- range .Fields}}
	{{-   if not .Virtual}}
	{{-     if .Description}}
	// {{.Name}} {{.Description}}.
	{{-     end}}
	{{-     if .IsEmbedded}}
	{{.Type}}
	{{-     else}}
	{{.Name}} {{resolveType . false}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
	{{-     end}}
	{{-   end}}
	{{- end}}
}
{{end}}

{{range .Types}}{{if .IsUnion}}
func (*{{.Name}}) Type() {{.UnionType}} { return {{.UnionType}}{{.UnionValue}} }
{{end}}{{end}}

{{range .Types}}{{if .IsComparable}}
func (v *{{.Name}}) Copy() *{{.Name}} {
	u := new({{.Name}})

	{{  range .Fields}}
	{{- if and .IsMarshalled (not .Virtual)}}
	{{- if .IsEmbedded}}
	u.{{get .}} = *v.{{get .}}.Copy()
	{{- else}}
	{{copy . (print "u." (get .)) (print "v." (get .))}}
	{{- end}}
	{{- end}}
	{{- end}}

	return u
}

func (v *{{.Name}}) CopyAsInterface() interface{} { return v.Copy() }
{{end}}{{end}}

{{range .Types}}{{if .IsComparable}}
func (v *{{.Name}}) Equal(u *{{.Name}}) bool {
	{{- range .Fields}}
	{{- if and .IsMarshalled (not .Virtual)}}
	{{- if .IsEmbedded}}
	if !v.{{get .}}.Equal(&u.{{get .}}) {
		return false
	}
	{{- else}}
	{{areEqual . (print "v." (get .)) (print "u." (get .)) "return false"}}
	{{- end}}
	{{- end}}
	{{- end}}

	return true
}
{{end}}{{end}}

{{range .Types}}{{if .IsBinary}}
var fieldNames_{{.Name}} = []string{
	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{- if .IsEmbedded}}
	{{.Number}}: "{{.Type}}",
	{{- else}}
	{{.Number}}: "{{.Name}}",
	{{- end}}
	{{- end}}
	{{- end}}
}

func (v *{{.Name}}) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	{{  range .Fields}}
	{{- if .IsMarshalled}}
	{{- if .IsEmbedded}}
	writer.WriteValue({{.Number}}, &v.{{.Type}})
	{{- else if .OmitEmpty}}
	if !({{isZero . (print "v." (get .))}}) {
		{{binaryMarshalValue . "writer" (print "v." (get .))}}
	}
	{{- else }}
	{{binaryMarshalValue . "writer" (print "v." (get .))}}
	{{- end}}
	{{- end}}
	{{- end}}

	_, _, err := writer.Reset(fieldNames_{{.Name}})
	return buffer.Bytes(), err
}

func (v *{{.Name}}) IsValid() error {
	var errs []string

	{{  range .Fields}}
	{{- if and .IsMarshalled .IsRequired}}
	{{- if .IsEmbedded}}
	if err := v.{{.Type}}.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	{{- else}}
	if len(v.fieldsSet) > {{.Number}} && !v.fieldsSet[{{.Number}}] {
		errs = append(errs, "field {{.Name}} is missing")
	{{- if not .KeepEmpty}}
	} else if {{isZero . (print "v." (get .))}} {
		errs = append(errs, "field {{.Name}} is not set")
	{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- end}}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}
{{end}}{{end}}

{{range .Types}}{{if .IsBinary}}
func (v *{{.Name}}) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *{{.Name}}) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	{{  range .Fields}}
	{{- if .IsMarshalled}}
	{{- if .IsEmbedded}}
	reader.ReadValue({{.Number}}, v.{{.Type}}.UnmarshalBinary)
	{{- else if not .Virtual}}
	{{binaryUnmarshalValue . "reader" (print "v." (get .))}}
	{{- else}}
	var v{{.Name}} {{.Type}}
	{{binaryUnmarshalValue . "reader" (print "v" .Name)}}
	{{areEqual . (print "v." (get .)) (print "v" .Name) (errVirtualFieldNotEqual . (print "v." (get .)) (print "v" .Name))}}
	{{- end}}
	{{- end}}
	{{- end}}

	seen, err := reader.Reset(fieldNames_{{.Name}})
	v.fieldsSet = seen
	return err
}
{{end}}{{end}}

{{define "jsonField"}}
{{- if .IsMarshalled}}
{{.Name}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
{{- if .AlternativeName}}
{{.AlternativeName}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .AlternativeName}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
{{- end}}
{{- end}}
{{- end}}

{{define "jsonType"}}struct {
	{{- range .Fields}}
	{{- if .IsEmbedded}}
	{{- range .TypeRef.Fields}}
	{{- template "jsonField" .}}
	{{- end}}
	{{- else}}
	{{- template "jsonField" .}}
	{{- end}}
	{{- end}}
}
{{- end}}

{{define "valueToJson"}}
{{- if .Field.IsMarshalled}}
{{valueToJson .Field (print .Dst "." .Field.Name) (print .Src "." (get .Field)) .ForUnmarshal (get .Field)}}
{{- if .Field.AlternativeName}}
{{valueToJson .Field (print .Dst "." .Field.AlternativeName) (print .Src "." (get .Field)) .ForUnmarshal (get .Field)}}
{{- end}}
{{- end}}
{{- end}}

{{define "valueFromJson"}}
{{- if .Field.IsMarshalled}}
{{- if .Field.Virtual}}
{{areEqual .Field (print .Dst "." (get .Field)) (print .Src "." .Field.Name) (errVirtualFieldNotEqual .Field (print .Dst "." (get .Field)) (print .Src "." .Field.Name))}}
{{- else if .Field.AlternativeName}}
if u.{{get .Field}} != {{jsonZeroValue .Field}} {
	{{valueFromJson .Field (print .Dst "." (get .Field)) (print .Src "." .Field.Name) (get .Field)}}
} else {
	{{valueFromJson .Field (print .Dst "." (get .Field)) (print .Src "." .Field.AlternativeName) (get .Field)}}
}
{{- else}}
{{valueFromJson .Field (print .Dst "." (get .Field)) (print .Src "." .Field.Name) (get .Field)}}
{{- end}}
{{- end}}
{{- end}}

{{range .Types}}{{if needsCustomJSON .}}
func (v *{{.Name}}) MarshalJSON() ([]byte, error) {
	u := {{template "jsonType" .}}{}

	{{- range .Fields}}
	{{- if .IsEmbedded}}
	{{- $name := .Type}}
	{{- range .TypeRef.Fields}}
	{{- template "valueToJson" map "Field" . "Src" (print "v." $name) "Dst" "u" "ForUnmarshal" false}}
	{{- end}}
	{{- else}}
	{{- template "valueToJson" map "Field" . "Src" "v" "Dst" "u" "ForUnmarshal" false}}
	{{- end}}
	{{- end}}
	return json.Marshal(&u)
}
{{end}}{{end}}

{{range .Types}}{{if needsCustomJSON .}}
func (v *{{.Name}}) UnmarshalJSON(data []byte) error {
	u := {{template "jsonType" .}}{}

	{{- range .Fields}}
	{{- if .IsEmbedded}}
	{{- $name := .Type}}
	{{- range .TypeRef.Fields}}
	{{- template "valueToJson" map "Field" . "Src" (print "v." $name) "Dst" "u" "ForUnmarshal" true}}
	{{- end}}
	{{- else}}
	{{- template "valueToJson" map "Field" . "Src" "v" "Dst" "u" "ForUnmarshal" true}}
	{{- end}}
	{{- end}}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}

	{{- range .Fields}}
	{{- if .IsEmbedded}}
	{{- $name := .Type}}
	{{- range .TypeRef.Fields}}
	{{- template "valueFromJson" map "Field" . "Src" "u" "Dst" (print "v." $name)}}
	{{- end}}
	{{- else}}
	{{- template "valueFromJson" map "Field" . "Src" "u" "Dst" "v"}}
	{{- end}}
	{{- end}}
	return nil
}
{{end}}{{end}}