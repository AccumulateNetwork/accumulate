/// GENERATED BY go run ./tools/cmd/gen-types (c_source). DO NOT EDIT.
#include <accumulate/protocol/{{snake .Name}}.h>

{{if .IsBinary}}int read{{.Name}}(Unmarshaler *m, {{.Name}} *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    {{$isUnion := .IsUnion}}{{if .IsUnion}}v->Type = {{.UnionType}}{{.UnionValue}};{{end}}
    {{- range .Embeddings}}b = read{{.}}(m, &v->_{{.}});
    CHECK_ERROR_CODE(b){{end}}

    {{- range .Fields}}{{- if .IsMarshalled}}{{-   if not .Virtual}}
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = peekField(m, &field);
    CHECK_ERROR_CODE(b)
    if (field == {{.Number}}) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
    {{- if .Repeatable}}
        {{$resolved := resolveType . true true}}
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->{{.Name}}_length = 0;
        while (field == {{.Number}}) {
            b = readField(&m2, &field);
            CHECK_ERROR_CODE(b)
            {{-       if not .Type.IsKnown}}
            uint64_t size = 0;
            b = readUInt(&m2, &size);
            CHECK_ERROR_CODE(b)
            //skip the object
            buffer_seek_cur(&m2.buffer, size);
            {{- else}}
            //need to read the known type
            {
                {{$resolved}} a;
                b = read{{$resolved}}(&m2, &a);
                CHECK_ERROR_CODE(b)
            }
            {{- end}}

            v->{{.Name}}_length++;
            field = 0;
            peekField(&m2, &field);
        }

        //now unmarshal for real...
        v->{{.Name}} = ({{$resolved}} *) unmarshalerAlloc(m, v->{{.Name}}_length * sizeof({{$resolved}}));
        CHECK_ERROR_INT(v->{{.Name}});
        for (size_t i = 0; i < v->{{.Name}}_length; ++i) {
            b = readField(m, &field);
            CHECK_ERROR_CODE(b)
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != {{.Number}}) {
                return ErrorInvalidField;
            }
            {{-       if not .Type.IsKnown}}
            uint64_t size = 0;
            b = readUInt(m, &size);
            CHECK_ERROR_CODE(b)
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = read{{$resolved}}(&m3, &v->{{.Name}}[i]);
                CHECK_ERROR_CODE(b)
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder
            {{- else}}
            b = read{{$resolved}}(m, &v->{{.Name}}[i]);
            CHECK_ERROR_CODE(b)
            {{- end}}

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }
    {{- else}}
        b = readField(m, &field);
        CHECK_ERROR_CODE(b)
        n += b;
        v->extraData[field - 1].buffer.size += b;
        {{if and $isUnion (eq .Number 1)}}
        uint64_t type = 0;
        b = readUInt(m, &type);
        CHECK_ERROR_CODE(b)
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        {{else}}
        {{-       if not .Type.IsKnown}}
        uint64_t size = 0;
        b = readUInt(m,&size);
        CHECK_ERROR_CODE(b)
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = read{{resolveType . true false}}(&m2, &v->{{.Name}});
        CHECK_ERROR_CODE(b)
        buffer_seek_cur(&m->buffer, b);
        {{- else}}
        b = read{{resolveType . true false}}(m, &v->{{.Name}});
        CHECK_ERROR_CODE(b)
        {{- end}}
        {{end}}
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    {{- end}}{{- end}}{{- end}}{{- end}}

	return n;
}
{{end}}
