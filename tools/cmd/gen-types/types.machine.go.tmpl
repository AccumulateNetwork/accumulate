// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package {{.Package}}

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"strings"
	"time"

	"github.com/libp2p/go-libp2p/core/peer"
	"gitlab.com/accumulatenetwork/accumulate/internal/node/config"
	"gitlab.com/accumulatenetwork/accumulate/pkg/api/v3/message"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	{{- if not (isPkg "pkg/types/merkle")}}
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	{{- end}}
	{{- if not (isPkg "pkg/errors")}}
	errors2 "gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	{{- end}}
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	{{- if not (isPkg "protocol")}}
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	{{- end}}
)

{{range .Types}}
{{-   if .Description}}
// {{.Name}} {{.Description}}.
{{-   end}}
type {{.FullName true true}} struct {
	{{  if .IsBinary}}fieldsSet []bool{{end}}
	{{- range .Fields}}
	{{-   if not .Virtual}}
	{{-     if .Description}}
	// {{.Name}} {{.Description}}.
	{{-     end}}
	{{-     if .IsEmbedded}}
	{{.Type}}
	{{-     else}}
	{{.Name}} {{resolveType . false}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}{{if .Toml}} toml:"{{.Toml}}" mapstructure:"{{.Toml}}"{{end}}`{{end}}
	{{-     end}}
	{{-   end}}
	{{- end}}
	{{  if .IsBinary}}extraData []byte{{end}}
}

var machine_{{.Name}} = &encoding.Machine[*{{.Name}}]{
	ExtraData: func(v *{{.Name}}) *[]byte { return &v.extraData },
	Seen:      func(v *{{.Name}}) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*{{.Name}}]{
		{{- $typ := .}}
		{{- range .Fields}}
		{{-   if not .Virtual}}
		{Name: "{{.Name}}", OmitEmpty: {{.OmitEmpty}}, Required: {{not .IsOptional}}, Accessor:
		{{-     if .Repeatable -}}
		encoding.SliceField[*{{$typ.FullName true false}}, *{{resolveElemType . true}}, {{accessor .}}]
		{{-     else -}}
		{{accessor .}}
		{{-     end -}}
		(func(v *{{$typ.FullName true false}}) {{if and .Pointer (not .Repeatable)}}*{{end}}*{{resolveType . (not .Repeatable)}} { return &v.{{.Name}} }) },
		{{-   end}}
		{{- end}}
	},
}


func (v *{{.FullName true false}}) IsValid() error                         { return machine_{{.Name}}.IsValid(v) }
func (v *{{.FullName true false}}) Copy() *{{.FullName true false}}        { return encoding.Copy(machine_{{.Name}}, v) }
func (v *{{.FullName true false}}) CopyAsInterface() interface{}           { return v.Copy() }
func (v *{{.FullName true false}}) Equal(u *{{.FullName true false}}) bool { return machine_{{.Name}}.Equal(v, u) }
func (v *{{.FullName true false}}) MarshalBinary() ([]byte, error)         { return machine_{{.Name}}.MarshalBinary(v) }
func (v *{{.FullName true false}}) UnmarshalBinary(data []byte) error      { return machine_{{.Name}}.Unmarshal(data, v) }
func (v *{{.FullName true false}}) UnmarshalBinaryFrom(rd io.Reader) error { return machine_{{.Name}}.UnmarshalFrom(rd, v) }

{{end}}

{{ $lud := .LongUnionDiscriminator }}
{{range .Types}}{{if .IsUnion}}
func (*{{.FullName true false}}) {{if $lud}}{{.UnionType}}{{else}}Type{{end}}() {{.UnionType}} { return {{.UnionType}}{{.UnionValue}} }
{{end}}{{end}}

{{define "jsonField"}}
{{- if .IsMarshalled}}
{{.Name}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
{{- if .AlternativeName}}
{{.AlternativeName}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .AlternativeName}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
{{- end}}
{{- end}}
{{- end}}

{{define "jsonType"}}struct {
	{{- range .Fields}}
	{{- if .IsEmbedded}}
	{{- range .TypeRef.Fields}}
	{{- template "jsonField" .}}
	{{- end}}
	{{- else}}
	{{- template "jsonField" .}}
	{{- end}}
	{{- end}}
}
{{- end}}

{{define "valueToJson"}}
{{- if .Field.IsMarshalled}}
{{valueToJson .Field (print .Dst "." .Field.Name) (print .Src "." (get .Field))}}
{{- if .Field.AlternativeName}}
{{valueToJson .Field (print .Dst "." .Field.AlternativeName) (print .Src "." (get .Field))}}
{{- end}}
{{- end}}
{{- end}}

{{define "jsonAltIsZero"}}
{{- if .Field.Repeatable -}}
len({{.Src}}.{{get .Field}}) == 0
{{- else if and .Field.AsReference (not .Field.Pointer) -}}
{{.Src}}.{{get .Field}}.Equal(&{{resolveType .Field false}}{})
{{- else -}}
{{.Src}}.{{get .Field}} == {{jsonZeroValue .Field}}
{{- end}}
{{- end}}

{{define "valueFromJson"}}
{{- if and .Field.IsMarshalled (not (and .Field.NonBinary .Field.Virtual))}}
{{- if .Field.Virtual}}
{{areEqual .Field (print .Dst "." (get .Field)) (print .Src "." .Field.Name) (errVirtualFieldNotEqual .Field (print .Dst "." (get .Field)) (print .Src "." .Field.Name))}}
{{- else if .Field.AlternativeName}}
if !({{template "jsonAltIsZero" .}}) {
	{{valueFromJson .Field (print .Dst "." (get .Field)) (print .Src "." .Field.Name) (get .Field)}}
} else {
	{{valueFromJson .Field (print .Dst "." (get .Field)) (print .Src "." .Field.AlternativeName) (get .Field)}}
}
{{- else}}
{{valueFromJson .Field (print .Dst "." (get .Field)) (print .Src "." .Field.Name) (get .Field)}}
{{- end}}
{{- end}}
{{- end}}

{{range .Types}}{{if needsCustomJSON .}}
func (v *{{.FullName true false}}) MarshalJSON() ([]byte, error) {
	u := {{template "jsonType" .}}{}

	{{- range .Fields}}
	{{- if .IsEmbedded}}
	{{- $name := get .}}
	{{- range .TypeRef.Fields}}
	{{- template "valueToJson" map "Field" . "Src" (print "v." $name) "Dst" "u"}}
	{{- end}}
	{{- else}}
	{{- template "valueToJson" map "Field" . "Src" "v" "Dst" "u"}}
	{{- end}}
	{{- end}}
	return json.Marshal(&u)
}
{{end}}{{end}}

{{range .Types}}{{if needsCustomJSON .}}
func (v *{{.FullName true false}}) UnmarshalJSON(data []byte) error {
	u := {{template "jsonType" .}}{}

	{{- range .Fields}}
	{{- if .IsEmbedded}}
	{{- $name := get .}}
	{{- range .TypeRef.Fields}}
	{{- template "valueToJson" map "Field" . "Src" (print "v." $name) "Dst" "u"}}
	{{- end}}
	{{- else}}
	{{- template "valueToJson" map "Field" . "Src" "v" "Dst" "u"}}
	{{- end}}
	{{- end}}
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}

	{{- range .Fields}}
	{{- if .IsEmbedded}}
	{{- $name := get .}}
	{{- range .TypeRef.Fields}}
	{{- template "valueFromJson" map "Field" . "Src" "u" "Dst" (print "v." $name)}}
	{{- end}}
	{{- else}}
	{{- template "valueFromJson" map "Field" . "Src" "u" "Dst" "v"}}
	{{- end}}
	{{- end}}
	return nil
}
{{end}}{{end}}