// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package {{.Package}}

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"strings"
	"time"

	"github.com/libp2p/go-libp2p/core/peer"
	"gitlab.com/accumulatenetwork/accumulate/internal/node/config"
	"gitlab.com/accumulatenetwork/accumulate/pkg/api/v3/message"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/p2p"
	{{- if not (isPkg "pkg/types/merkle")}}
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/merkle"
	{{- end}}
	{{- if not (isPkg "pkg/errors")}}
	errors2 "gitlab.com/accumulatenetwork/accumulate/pkg/errors"
	{{- end}}
	"gitlab.com/accumulatenetwork/accumulate/pkg/url"
	{{- if not (isPkg "protocol")}}
	"gitlab.com/accumulatenetwork/accumulate/protocol"
	{{- end}}
)

{{range .Types}}
{{-   if .Description}}
// {{.Name}} {{.Description}}.
{{-   end}}
type {{.FullName true true}} struct {
	{{  if .IsBinary}}fieldsSet []bool{{end}}
	{{- range .Fields}}
	{{-   if not .Virtual}}
	{{-     if .Description}}
	// {{.Name}} {{.Description}}.
	{{-     end}}
	{{-     if .IsEmbedded}}
	{{.Type}}
	{{-     else}}
	{{.Name}} {{resolveType . false}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}{{if .Toml}} toml:"{{.Toml}}" mapstructure:"{{.Toml}}"{{end}}`{{end}}
	{{-     end}}
	{{-   end}}
	{{- end}}
	{{  if .IsBinary}}extraData []byte{{end}}
}

var machine_{{.Name}} = &encoding.Machine[*{{.Name}}]{
	ExtraData: func(v *{{.Name}}) *[]byte { return &v.extraData },
	Seen:      func(v *{{.Name}}) *[]bool { return &v.fieldsSet },
	Fields: []*encoding.Field[*{{.Name}}]{
		{{- $typ := .}}
		{{- range .Fields}}
		{{-   if not .Virtual}}
		{Name: "{{.Name}}", OmitEmpty: {{.OmitEmpty}}, Required: {{not .IsOptional}}, Accessor:
		{{-     if .Repeatable -}}
		encoding.SliceField[*{{$typ.FullName true false}}, *{{resolveElemType . true}}, {{accessor .}}]
		{{-     else -}}
		{{accessor .}}
		{{-     end -}}
		(func(v *{{$typ.FullName true false}}) {{if and .Pointer (not .Repeatable)}}*{{end}}*{{resolveType . (not .Repeatable)}} { return &v.{{.Name}} }) },
		{{-   end}}
		{{- end}}
	},
}

func (v *{{.FullName true false}}) IsValid() error                         { return machine_{{.Name}}.IsValid(v) }
func (v *{{.FullName true false}}) Copy() *{{.FullName true false}}        { return encoding.Copy(machine_{{.Name}}, v) }
func (v *{{.FullName true false}}) CopyAsInterface() interface{}           { return v.Copy() }
func (v *{{.FullName true false}}) Equal(u *{{.FullName true false}}) bool { return machine_{{.Name}}.Equal(v, u) }
func (v *{{.FullName true false}}) MarshalBinary() ([]byte, error)         { return machine_{{.Name}}.MarshalBinary(v) }
func (v *{{.FullName true false}}) UnmarshalBinary(data []byte) error      { return machine_{{.Name}}.Unmarshal(data, v) }
func (v *{{.FullName true false}}) UnmarshalBinaryFrom(rd io.Reader) error { return machine_{{.Name}}.UnmarshalFrom(rd, v) }
func (v *{{.FullName true false}}) MarshalJSON() ([]byte, error)           { return machine_{{.Name}}.JSONMarshal(v) }
func (v *{{.FullName true false}}) UnmarshalJSON(b []byte) error           { return machine_{{.Name}}.JSONUnmarshal(b, v) }

{{end}}

{{ $lud := .LongUnionDiscriminator }}
{{range .Types}}{{if .IsUnion}}
func (*{{.FullName true false}}) {{if $lud}}{{.UnionType}}{{else}}Type{{end}}() {{.UnionType}} { return {{.UnionType}}{{.UnionValue}} }
{{end}}{{end}}
