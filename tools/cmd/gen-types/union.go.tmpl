// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package {{.Package}}

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

{{ $lud := .LongUnionDiscriminator }}
{{- range .Unions}}{{if not (eq .Type "result")}}

{{- if .Registry}}
var {{lcName .Name}}Registry = new(encoding.UnionRegistry[{{.Enumeration}}, {{.Interface}}])
{{- end}}

// {{unionMethod . "New"}} creates a new {{.Interface}} for the specified {{.Enumeration}}.
func {{unionMethod . "New"}}(typ {{.Enumeration}}) ({{.Interface}}, error) {
	switch typ {
	{{- range .Members}}
	case {{.UnionType}}{{.UnionValue}}:
		return new({{.FullName false true}}), nil
	{{- end}}
	}
	{{- if .Registry}}
	if v, ok := {{lcName .Name}}Registry.New(typ); ok {
		return v, nil
	}
	{{- end}}
	return nil, fmt.Errorf("unknown {{natural .Type}} %v", typ)
}

{{if (index .Members 0).IsComparable}}
// {{unionMethod . "Equal"}} is used to compare the values of the union
func {{unionMethod . "Equal"}}(a, b {{.Interface}}) bool {
	if a == b {
		return true
	}
	switch a := a.(type){
	{{- range .Members}}
	case *{{.Type.FullName false true}}:
		if a == nil {
			return b == nil
		}
		b, ok := b.(*{{.Type.FullName false true}})
		return ok && a.Equal(b)
	{{- end}}
	}
	{{- if .Registry}}
	return {{lcName .Name}}Registry.Equal(a, b)
	{{- else}}
	return false
	{{- end}}
}

// {{unionMethod . "Copy"}} copies a {{.Interface}}.
func {{unionMethod . "Copy"}}(v {{.Interface}}) {{.Interface}} {
	switch v := v.(type){
	{{- range .Members}}
	{{- if not .Params}}
	case *{{.Type.Name}}:
		return v.Copy()
	{{- end}}
	{{- end}}
	default:
		return v.CopyAsInterface().({{.Interface}})
	}
}
{{end}}

{{if (index .Members 0).IsBinary}}
// {{unionMethod . "Unmarshal"}} unmarshals a {{.Interface}}.
func {{unionMethod . "Unmarshal"}}(data []byte) ({{.Interface}}, error) {
	return {{unionMethod . "Unmarshal"}}From(bytes.NewReader(data))
}

// {{unionMethod . "Unmarshal"}}From unmarshals a {{.Interface}}.
func {{unionMethod . "Unmarshal"}}From(rd io.Reader) ({{.Interface}}, error) {
	reader := encoding.NewReader(rd)

	// Read the type code
	var typ {{.Enumeration}}
	if !reader.ReadEnum(1, &typ) {
		if reader.IsEmpty() {
			return nil, nil
		}
		return nil, fmt.Errorf("field Type: missing")
	}

	// Create a new {{natural .Interface}}
	v, err := {{unionMethod . "New"}}({{.Enumeration}}(typ))
	if err != nil {
		return nil, err
	}

	// Unmarshal the rest of the {{natural .Interface}}
	err = v.UnmarshalFieldsFrom(reader)
	if err != nil {
		return nil, err
	}

	return v, nil
}
{{end}}

// {{unionMethod . "Unmarshal"}}Json unmarshals a {{.Interface}}.
func {{unionMethod . "Unmarshal"}}JSON(data []byte) ({{.Interface}}, error) {
	var typ *struct{ {{if $lud}}{{.Enumeration}}{{else}}Type{{end}} {{.Enumeration}} }
	err := json.Unmarshal(data, &typ)
	if err != nil {
		return nil, err
	}

	if typ == nil {
		return nil, nil
	}

	acnt, err := {{unionMethod . "New"}}(typ.{{if $lud}}{{.Enumeration}}{{else}}Type{{end}})
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(data, acnt)
	if err != nil {
		return nil, err
	}

	return acnt, nil
}

{{- end}}
{{end}}
