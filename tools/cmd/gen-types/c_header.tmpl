#pragma once


/// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.

#include <common/encoding/encoding.h>
#include <common/protocol/enum.h>
#include <common/protocol/unions.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif

{{range .Types}}#define _WANT_{{.Name}}_    1
{{end}}
/// Forward Declarations
{{range .Types}}
struct {{.Name}};
{{end}}

/// Data Structures
{{range .Types}}
#if _WANT_{{.Name}}_
typedef struct {{.Name}} {
    {{if .IsUnion}}
    {{.UnionType}} Type;
    {{end}}
    //
    {{- range .Embeddings}}
    {{.}} _{{.}}; //"Embedded" struct
    {{- end}}

	//{{  if .IsBinary}}uint8_t fieldsSet[{{len .Fields}}];{{end}}
	{{- range .Fields}}
	{{-   if not .Virtual}}
	{{-     if .Description}}
	/// {{.Name}} {{.Description}}.
	{{-     end}}
	{{-     if .IsEmbedded}}
	{{.Type}} _{{.Type}};
    {{- else if and .Pointer .Repeatable}}
    size_t {{.Name}}_length;
	{{resolveType . false true}} {{.Name}}; {{if .IsMarshalled}} //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
	{{- else if .Repeatable}}
    size_t {{.Name}}_length;
	{{resolveType . false false}} {{.Name}}; {{if .IsMarshalled}} //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
    {{-     else}}
	{{resolveType . true false}} {{.Name}}; {{if .IsMarshalled}} //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
    {{-     end}}
	{{-   end}}
	{{- end}}
	//{{  if .IsBinary}}Bytes extraData[{{len .Fields}}];{{end}}

} {{.Name}};
#endif /* _WANT_{{.Name}}_ */
{{end}}



{{range .Types}}
#if _WANT_{{.Name}}_
{{if .IsUnion}}ACME_API {{.UnionType}} {{.UnionValue}}_type(void);{{end}}
ACME_API bool {{.Name}}_equal(const {{.Name}} *v, const {{.Name}} *u);
{{if .IsBinary}}ACME_API int unmarshalerRead{{.Name}}(Unmarshaler *m, {{.Name}} *v);
ACME_API int marshalerWrite{{.Name}}(Marshaler *m, const {{.Name}}*v);
ACME_API int {{.Name}}_binarySize(const {{.Name}} *v);
{{end}}
#endif /* _WANT_{{.Name}}_ */
{{end}}


#ifdef _ACCUMULATE_TRANSACTION_SOURCE_

/// JSON Marshaling
{{define "jsonType"}}struct {
	{{- range .Embeddings}}{{.}} {{lcName .}};
	{{- end}}
	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{.Name}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
	{{- if .AlternativeName}}
	{{.AlternativeName}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .AlternativeName}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
	{{- end}}
	{{- end}}
	{{- end}}
}{{end}}

{{range .Types}}
#if _WANT_{{.Name}}_
{{if .IsUnion}}
{{.UnionType}} {{.UnionValue}}_type(void) { return {{.UnionType}}{{.UnionValue}}; }
{{end}}

/// Comparisons
{{if .IsComparable}}bool {{.Name}}_equal(const {{.Name}} *v, const {{.Name}} *u) {
    {{- range .Fields}}
    {{- if .IsMarshalled}}
        {{- if .Repeatable}}
        if ( v->{{.Name}}_length == u->{{.Name}}_length ) {
            for ( size_t i = 0; i < v->{{.Name}}_length; ++i ) {

            {{- if .IsPointer}}
                const {{resolveType . false true}} a = &v->{{.Name}}[i];
                const {{resolveType . false true}} b = &u->{{.Name}}[i];
                {{- else}}
                const {{resolveType . false false}} a = &v->{{.Name}}[i];
                const {{resolveType . false false}} b = &u->{{.Name}}[i];
                {{- end}}
                if ( !{{resolveType . true true}}_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }
        {{- else}}
        {
            {{- if .IsPointer}}
            const {{resolveType . false false}} a = &v->{{.Name}};
            const {{resolveType . false false}} b = &u->{{.Name}};
            {{- else}}
            const {{resolveType . false false}} *a = &v->{{.Name}};
            const {{resolveType . false false}} *b = &u->{{.Name}};
            {{- end}}
            if ( !{{resolveType . true false}}_equal(a,b) ) {
                return false;
            }
        }
    {{- end}}
    {{- end}}
    {{- end}}

    return true;
}
{{end}}


/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the {{natural .Name}} from bytes as a unsigned varint.
{{if .IsBinary}}ACME_API int unmarshalerRead{{.Name}}(Unmarshaler *m, {{.Name}} *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    {{$isUnion := .IsUnion}}{{if .IsUnion}}uint64_t unionType = {{.UnionType}}{{.UnionValue}};{{end}}
    {{- range .Embeddings}}e = unmarshalerRead{{.}}(m, &v->_{{.}});
    if ( IsError(e) ) {
        return e.code;
    }{{end}}

    {{- range .Fields}}{{- if .IsMarshalled}}
    if ( m->buffer.offset == m->buffer.size ) {
        return n;
    }
    b = unmarshalerPeekField(m,&field);
    if ( IsError(ErrorCode(b))) {
            return b;
    }
    if ( field == {{.Number}} )
    {{- if .Repeatable}}
    {
        {{$resolved := resolveType . true true}}
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->{{.Name}}_length = 0;
        while ( field == {{.Number}} ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            {{-       if not .Type.IsKnown}}
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2,&size);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            //skip the object
            buffer_seek_cur(&m2.buffer, size);
            {{- else}}
            //need to read the known type
            {{$resolved}} a;
            b = unmarshalerRead{{$resolved}}(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            {{- end}}

            v->{{.Name}}_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->{{.Name}} = ({{$resolved}}*)unmarshalerAlloc(m, v->{{.Name}}_length*sizeof({{$resolved}}));
        for ( size_t i = 0; i < v->{{.Name}}_length; ++i ) {
            {{$resolved}}* a = &v->{{.Name}}[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != {{.Number}} ) {
                return ErrorInvalidField;
            }
            n += b;

            {{-       if not .Type.IsKnown}}
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
            Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                              .mempool = m->mempool};
            b = unmarshalerRead{{$resolved}}(&m3, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            buffer_seek_cur(&m->buffer, b);
            {{- else}}
            b = unmarshalerRead{{$resolved}}(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            {{- end}}

            {{-       if not .Type.IsKnown}}
            if ( b > (int)size ) {
                return ErrorInvalidObject;
            }

            int skip = (int)size - b;
            if ( !buffer_seek_cur(&m->buffer, skip) ) {
                return ErrorInvalidObject;
            }
            b += (int)size-b;
            {{- end}}
            n += b;
        }
    }
    {{- else}}
    {
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        n += b;

        {{- if .IsPointer}}
        {{resolveType . false false}} a = &v->{{.Name}};
        {{- else if .AsEnum}}
        {{resolveType . false false}} *a = &v->{{.Name}};
        {{- else}}
        {{resolveType . false false}} *a = &v->{{.Name}};
        {{- end}}

        {{if and $isUnion (eq .Number 1)}}
        //ensure we are the correct union type
        uint64_t type = 0;
        b = unmarshalerReadUInt(m,&type);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( type != unionType ) {
            return ErrorInvalidObject;
        }
        {{else}}
        {{-       if not .Type.IsKnown}}
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }
        n += b;
        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerRead{{resolveType . true false}}(&m2, a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        buffer_seek_cur(&m->buffer, b);

        {{- else}}
        b = unmarshalerRead{{resolveType . true false}}(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        {{- end}}
        {{end}}
        n += b;
    }
    {{- end}}{{- end}}{{- end}}

	return n;
}
{{end}}

{{if .IsBinary}}ACME_API int marshalerWrite{{.Name}}(Marshaler *m,const {{.Name}}*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    {{if .IsUnion}}
    if ( v->Type != {{.UnionType}}{{.UnionValue}} ) {
        return ErrorInvalidObject;
    }
    {{end}}

    {{- range .Embeddings}}
    e = marshalerWrite{{.}}(m, &v->_{{.}});
    if ( IsError(e) ) {
        return e.code;
    }
    {{end}}

    {{- range .Fields}}
    {{- if .IsMarshalled}}
        {{- if .Repeatable}}
        for ( size_t i = 0; i < v->{{.Name}}_length; ++i ) {
            const {{resolveType . true true}} *a = &v->{{.Name}}[i];
            b = marshalerWriteField(m, {{.Number}});
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            buffer_t offsetBuffer = m->buffer;
            if ( !buffer_seek_cur(&offsetBuffer, sizeof(size_t))) {
                return ErrorBufferTooSmall;
            }
            Marshaler m2 = NewMarshaler(&offsetBuffer);//create a temporary marshaler that will compute size
            //need to identify what the size of the following will be and write those bytes.
            int size = marshalerWrite{{resolveType . true true}}(&m2, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //write size of what is to follow
            b = marshalerWriteUInt(m, (uint64_t)size);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //now copy the contents into the marshal buffer to prevent having to remarshal
            if (!buffer_move(&m->buffer, offsetBuffer.ptr + offsetBuffer.offset, size)) {
                return ErrorBadCopy;
            }

            n += b;
        }
        {{- else}}
        {
            {{- if .IsPointer }}
            const {{resolveType . false false}} a = &v->{{.Name}};
            {{- else}}
            const {{resolveType . false false}} *a = &v->{{.Name}};
            {{- end}}

            b = marshalerWriteField(m, {{.Number}});
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            {{- if .AsEnum}}
            b = marshalerWrite{{resolveType . true false}}(m,*a);
            {{- else}}

            buffer_t offsetBuffer = m->buffer;
            if ( !buffer_seek_cur(&offsetBuffer, sizeof(size_t))) {
                return ErrorBufferTooSmall;
            }
            Marshaler m2 = NewMarshaler(&offsetBuffer);//create a temporary marshaler that will compute size
            //need to identify what the size of the following will be and write those bytes.
            int size = marshalerWrite{{resolveType . true true}}(&m2, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //write size of what is to follow
            b = marshalerWriteUInt(m, (uint64_t)size);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //now copy the contents into the marshal buffer to prevent having to remarshal
            if (!buffer_move(&m->buffer, offsetBuffer.ptr + offsetBuffer.offset, size)) {
                return ErrorBadCopy;
            }
            {{- end}}
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
    {{- end}}
    {{- end}}
    {{- end}}


    return n;
}
{{end}}

/// JSON Marshaling
{{if needsCustomJSON .}}static Error {{.Name}}_marshalJSON(const {{.Name}} *v, const Bytes *inData) {
    return ErrorCode(ErrorNotImplemented);
}
{{end}}

/// JSON Unmarshaling
{{if needsCustomJSON .}}static Error {{.Name}}_unmarshalJSON({{.Name}} *v,Bytes *outData) {
    return ErrorCode(ErrorNotImplemented);
}
{{end}}

static {{.Name}} {{.Name}}_init({{.Name}} *v) {
    {{.Name}} init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = {{.Name}}_type;
//    init.BinarySize = {{.Name}}_binarySize;
//    init.Equal = {{.Name}}_equal;
    //init.Copy = {{.Name}}_copy;
//    init.MarshalBinary = {{.Name}}_marshalBinary;
//    init.UnmarshalBinary = {{.Name}}_unmarshalBinary;
//    {{if needsCustomJSON .}}
//    init.MarshalJSON = {{.Name}}_marshalJSON;
//    init.UnmarshalJSON = {{.Name}}_unmarshalJSON;
    {{end}}

    if ( v ) {
        *v = init;
    }
    return init;
}
#endif /* _WANT_{{.Name}}_ */
{{end}}
#endif /* _ACCUMULATE_TRANSACTION_SOURCE_ */

#ifdef __cplusplus
}
#endif


