#ifndef _ACCUMULATE_TRANSACTION_HEADER_
#define _ACCUMULATE_TRANSACTION_HEADER_


/// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.
#include <common/encoding/encoding.h>
#include <common/protocol/enum.h>
#include <common/protocol/unions.h>
#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif

/// Forward Declarations
{{range .Types}}
struct {{.Name}};
{{end}}

/// Data Structures
{{range .Types}}
typedef struct {{.Name}} {
    {{if .IsUnion}}
    {{.UnionType}} Type;
    {{end}}
    //
    {{- range .Embeddings}}
    {{.}} _{{.}}; //"Embedded" struct
    {{- end}}

	//{{  if .IsBinary}}uint8_t fieldsSet[{{len .Fields}}];{{end}}
	{{- range .Fields}}
	{{-   if not .Virtual}}
	{{-     if .Description}}
	/// {{.Name}} {{.Description}}.
	{{-     end}}
	{{-     if .IsEmbedded}}
	{{.Type}} _{{.Type}};
    {{- else if and .Pointer .Repeatable}}
    size_t {{.Name}}_length;
	{{resolveType . false true}} {{.Name}}; {{if .IsMarshalled}} //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
	{{- else if .Repeatable}}
    size_t {{.Name}}_length;
	{{resolveType . false false}} {{.Name}}; {{if .IsMarshalled}} //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
    {{-     else}}
	{{resolveType . true false}} {{.Name}}; {{if .IsMarshalled}} //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
    {{-     end}}
	{{-   end}}
	{{- end}}
	//{{  if .IsBinary}}Bytes extraData[{{len .Fields}}];{{end}}

} {{.Name}};
{{end}}

{{range .Types}}{{if .IsUnion}}ACME_API {{.UnionType}} {{.UnionValue}}_type(void);{{end}}
ACME_API bool {{.Name}}_equal(const {{.Name}} *v, const {{.Name}} *u);
{{if .IsBinary}}ACME_API int unmarshalerRead{{.Name}}(Unmarshaler *m, {{.Name}} *v);
ACME_API int marshalerWrite{{.Name}}(Marshaler *m, {{.Name}}*v);
ACME_API int {{.Name}}_binarySize(const {{.Name}} *v);
{{end}}
{{end}}

#endif

#ifdef _ACCUMULATE_TRANSACTION_SOURCE_

{{range .Types}}{{if .IsUnion}}
{{.UnionType}} {{.UnionValue}}_type(void) { return {{.UnionType}}{{.UnionValue}}; }
{{end}}{{end}}

/// Comparisons
{{range .Types}}
{{if .IsComparable}}bool {{.Name}}_equal(const {{.Name}} *v, const {{.Name}} *u) {
    {{- range .Fields}}
    {{- if .IsMarshalled}}
        {{- if .Repeatable}}
        if ( v->{{.Name}}_length == u->{{.Name}}_length ) {
            for ( int i = 0; i < v->{{.Name}}_length; ++i ) {

            {{- if .IsPointer}}
                const {{resolveType . false true}} a = &v->{{.Name}}[i];
                const {{resolveType . false true}} b = &u->{{.Name}}[i];
                {{- else}}
                const {{resolveType . false false}} a = &v->{{.Name}}[i];
                const {{resolveType . false false}} b = &u->{{.Name}}[i];
                {{- end}}
                if ( !{{resolveType . true true}}_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }
        {{- else}}
        {
            {{- if .IsPointer}}
            const {{resolveType . false false}} a = &v->{{.Name}};
            const {{resolveType . false false}} b = &u->{{.Name}};
            {{- else}}
            const {{resolveType . false false}} *a = &v->{{.Name}};
            const {{resolveType . false false}} *b = &u->{{.Name}};
            {{- end}}
            if ( !{{resolveType . true false}}_equal(a,b) ) {
                return false;
            }
        }
    {{- end}}
    {{- end}}
    {{- end}}

    return true;
}
{{end}}{{end}}


/// Binary Marshalers
{{range .Types}}
{{if .IsBinary}}ACME_API Error {{.Name}}_marshalBinary({{.Name}} *v, Bytes *outData) {
    return ErrorCode(ErrorNotImplemented);
}
{{end}}{{end}}

/// Binary Unmarshalers
{{range .Types}}
// UnmarshalBinary unmarshals the {{natural .Name}} from bytes as a unsigned varint.
{{if .IsBinary}}ACME_API int unmarshalerRead{{.Name}}(Unmarshaler *m, {{.Name}} *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    {{$isUnion := .IsUnion}}{{if .IsUnion}}uint64_t unionType = {{.UnionType}}{{.UnionValue}};
    {{end}}
    {{- range .Embeddings}}e = unmarshalerRead{{.}}(m, &v->_{{.}});
    if ( IsError(e) ) {
        return e.code;
    }{{end}}

    {{- range .Fields}}
    {{- if .IsMarshalled}}
    {{- if .Repeatable}}
    {
        {{$resolved := resolveType . true true}}
        uint64_t field = 0;
        unmarshalerPeekField(m, &field);
        v->{{.Name}}_length = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        while ( field == {{.Number}} ) {
            {{$resolved}} a;
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != {{.Number}} ) {
                return ErrorInvalidField;
            }

            b = unmarshalerRead{{$resolved}}(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->{{.Name}}_length++;
            unmarshalerPeekField(m, &field);
        }
        //now unmarshal for real...
        v->{{.Name}} = ({{$resolved}}*)unmarshalerAlloc(m, v->{{.Name}}_length*sizeof({{$resolved}}));
        for ( size_t i = 0; i < v->{{.Name}}_length; ++i ) {
            {{$resolved}}* a = &v->{{.Name}}[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != {{.Number}} ) {
                return ErrorInvalidField;
            }

            b = unmarshalerRead{{$resolved}}(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }

    }
    {{- else}}
    {
        {{- if .IsPointer}}
        {{resolveType . false false}} a = &v->{{.Name}};
        {{- else if .AsEnum}}
        {{resolveType . false false}} *a = &v->{{.Name}};
        {{- else}}
        {{resolveType . false false}} *a = &v->{{.Name}};
        {{- end}}

        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != {{.Number}} ) {
            return ErrorInvalidField;
        }

        b = unmarshalerRead{{resolveType . true false}}(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        {{if $isUnion}}{{if eq .Number 1}}
        //ensure we are the correct union type
        uint64_t type = 0;
        Error e = UVarInt_get(a, &type);
        if ( IsError(e) ) {
            return e.code;
        }
        if ( type != unionType ) {
            return ErrorInvalidObject;
        }
        {{end}}{{end}}
        n += b;
    }
    {{- end}}{{- end}}{{- end}}
	return n;
}
{{end}}{{end}}

{{range .Types}}
{{if .IsBinary}}ACME_API int marshalerWrite{{.Name}}(Marshaler *m, {{.Name}}*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    {{if .IsUnion}}
    v->Type = {{.UnionType}}{{.UnionValue}};
    {{end}}

    {{- range .Embeddings}}
    e = marshalerWrite{{.}}(m, &v->_{{.}});
    if ( IsError(e) ) {
        return e.code;
    }
    {{end}}

    {{- range .Fields}}
    {{- if .IsMarshalled}}
        {{- if .Repeatable}}
        for ( int i = 0; i < v->{{.Name}}_length; ++i ) {
            const {{resolveType . false false}} a = &v->{{.Name}}[i];
            b = marshalerWriteField(m, {{.Number}});
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWrite{{resolveType . true true}}(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }
        {{- else}}
        {
            {{- if .IsPointer }}
            const {{resolveType . false false}} a = &v->{{.Name}};
            {{- else}}
            const {{resolveType . false false}} *a = &v->{{.Name}};
            {{- end}}

            b = marshalerWriteField(m, {{.Number}});
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            {{- if .AsEnum}}
            b = marshalerWrite{{resolveType . true false}}(m,*a);
            {{- else}}
            b = marshalerWrite{{resolveType . true false}}(m,a);
            {{- end}}
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
    {{- end}}
    {{- end}}
    {{- end}}


    return n;
}
{{end}}{{end}}

/// JSON Marshaling
{{define "jsonType"}}struct {
	{{- range .Embeddings}}{{.}} {{lcName .}};
	{{- end}}
	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{.Name}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
	{{- if .AlternativeName}}
	{{.AlternativeName}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .AlternativeName}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
	{{- end}}
	{{- end}}
	{{- end}}
}{{end}}

/// JSON Marshaling
{{range .Types}}
{{if needsCustomJSON .}}static Error {{.Name}}_marshalJSON(const {{.Name}} *v, const Bytes *inData) {
    return ErrorCode(ErrorNotImplemented);
}
{{end}}{{end}}

/// JSON Unmarshaling
{{range .Types}}
{{if needsCustomJSON .}}static Error {{.Name}}_unmarshalJSON({{.Name}} *v,Bytes *outData) {
    return ErrorCode(ErrorNotImplemented);
}
{{end}}{{end}}

{{range .Types}}
static {{.Name}} {{.Name}}_init({{.Name}} *v) {
    {{.Name}} init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = {{.Name}}_type;
//    init.BinarySize = {{.Name}}_binarySize;
//    init.Equal = {{.Name}}_equal;
    //init.Copy = {{.Name}}_copy;
//    init.MarshalBinary = {{.Name}}_marshalBinary;
//    init.UnmarshalBinary = {{.Name}}_unmarshalBinary;
//    {{if needsCustomJSON .}}
//    init.MarshalJSON = {{.Name}}_marshalJSON;
//    init.UnmarshalJSON = {{.Name}}_unmarshalJSON;
    {{end}}

    if ( v ) {
        *v = init;
    }
    return init;
}
{{end}}
#endif

#ifdef __cplusplus
}
#endif


