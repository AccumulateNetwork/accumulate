#pragma once


/// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.
#include <common/encoding/encoding.h>
#include <common/protocol/enum.h>
#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif

/// Forward Declarations
{{range .Types}}
struct {{.Name}};
{{end}}

/// Data Structures
{{range .Types}}
typedef struct {{.Name}} {

    //
    {{- range .Embeddings}}
    {{.}} _{{.}}; //"Embedded" struct
    {{- end}}

	{{  if .IsBinary}}uint8_t fieldsSet[{{len .Fields}}];{{end}}
	{{- range .Fields}}
	{{-   if not .Virtual}}
	{{-     if .Description}}
	/// {{.Name}} {{.Description}}.
	{{-     end}}
	{{-     if .IsEmbedded}}
	{{.Type}} _{{.Type}};
    {{- else if and .Pointer .Repeatable}}
    size_t {{.Name}}_length;
	{{resolveType . false false}} {{.Name}}; {{if .IsMarshalled}} //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
    {{-     else}}
	{{resolveType . false false}} {{.Name}}; {{if .IsMarshalled}} //`json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}" form:"{{lcName .Name}}" query:"{{lcName .Name}}"{{validateTag .}}`{{end}}
    {{-     end}}
	{{-   end}}
	{{- end}}
	{{  if .IsBinary}}Bytes extraData[{{len .Fields}}];{{end}}

} {{.Name}};
{{end}}

/// Comparisons
{{range .Types}}
{{if .IsComparable}}static bool {{.Name}}_equal(const {{.Name}} *v, const {{.Name}} *u) {
    {{- range .Fields}}
    {{- if .IsMarshalled}}
        {{- if .Repeatable}}
        if ( v->{{.Name}}_length == u->{{.Name}}_length ) {
            for ( int i = 0; i < v->{{.Name}}_length; ++i ) {
                const {{resolveType . false true}} a = v->{{.Name}}[i];
                const {{resolveType . false true}} b = u->{{.Name}}[i];
                if ( !{{resolveType . true true}}_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }
        {{- else}}
        {
            {{- if .IsPointer}}
            const {{resolveType . false false}} a = v->{{.Name}};
            const {{resolveType . false false}} b = u->{{.Name}};
            {{- else}}
            const {{resolveType . false false}} *a = &v->{{.Name}};
            const {{resolveType . false false}} *b = &u->{{.Name}};
            {{- end}}
            if ( !{{resolveType . true false}}_equal(a,b) ) {
                return false;
            }
        }
    {{- end}}
    {{- end}}
    {{- end}}

    return true;
}
{{end}}{{end}}


/// Marshaled Binary Size Calculations
{{range .Types}}
{{if .IsBinary}}ACME_API int {{.Name}}_binarySize(const {{.Name}} *v) {
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    Error e = Error_init(0);
    {{- range .Embeddings}}
    b = {{.}}_binarySize(&v->_{{.}});
    if ( IsError(ErrorCode(b)) ) {
        return b;
    }
    n += b;
    {{end}}

    {{- range .Fields}}
    {{- if .IsMarshalled}}
        {{- if .Repeatable}}
        for ( int i = 0; i < v->{{.Name}}_length; ++i ) {
            const {{resolveType . false true}} a = v->{{.Name}}[i];

            b = {{resolveType . true true}}_binarySize(v->{{.Name}}[i]);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            b += n;
        }
        {{- else}}
        {
            {{- if .IsPointer}}
            const {{resolveType . false false}} a = v->{{.Name}};
            {{- else}}
            const {{resolveType . false false}} *a = &v->{{.Name}};
            {{- end}}
            b = {{resolveType . true false}}_binarySize(a);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
        }
    {{- end}}
    {{- end}}
    {{- end}}

    return n;
}
{{end}}{{end}}

/// Binary Marshalers
{{range .Types}}
{{if .IsBinary}}ACME_API Error {{.Name}}_marshalBinary({{.Name}} *v, Bytes *outData) {
    return ErrorCode(ErrorNotImplemented);
}
{{end}}{{end}}

/// Binary Unmarshalers
// UnmarshalBinary unmarshals the {{natural .Name}} from bytes as a unsigned varint.
{{range .Types}}
{{if .IsBinary}}ACME_API int unmarshalerRead{{.Name}}(Marshaler *m, {{.Name}} *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)

    {{- range .Embeddings}}
        e = unmarshalerRead{{.}}(m, &v->_{{.}});
        if ( IsError(e) ) {
            return e.code;
        }
    {{end}}

    {{- range .Fields}}
    {{- if .IsMarshalled}}
        {{- if .Repeatable}}
        for ( int i = 0; i < v->{{.Name}}_length; ++i ) {
            const {{resolveType . false true}} *a = &v->{{.Name}}[i];

            //{{.Number}}
            uint64_t field = 0;
            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != {{.Number}} ) {
                return ErrorInvalidField;
            }

            b = unmarshalerRead{{resolveType . true true}}(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }
        {{- else}}
        {
            {{- if .IsPointer}}
            const {{resolveType . false false}} a = v->{{.Name}};
            {{- else}}
            const {{resolveType . false false}} *a = &v->{{.Name}};
            {{- end}}

            uint64_t field = 0;
            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != {{.Number}} ) {
                return ErrorInvalidField;
            }

            b = unmarshalerRead{{resolveType . true false}}(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
    {{- end}}
    {{- end}}
    {{- end}}

	return unmarshalerReadField(m, v);
}
{{end}}{{end}}

{{range .Types}}
{{if .IsBinary}}ACME_API int marshalerWrite{{.Name}}(Marshaler *m, {{.Name}}*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    {{- range .Embeddings}}
    e = marshalerWrite{{.}}(m, &v->_{{.}});
    if ( IsError(e) ) {
        return e.code;
    }
    {{end}}

    {{- range .Fields}}
    {{- if .IsMarshalled}}
        {{- if .Repeatable}}
        for ( int i = 0; i < v->{{.Name}}_length; ++i ) {
            const {{resolveType . false true}} a = v->{{.Name}}[i];

            b = marshalerWriteField(m, {{.Number}});
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWrite{{resolveType . true true}}(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }
        {{- else}}
        {
            {{- if .IsPointer}}
            const {{resolveType . false false}} a = v->{{.Name}};
            {{- else}}
            const {{resolveType . false false}} *a = &v->{{.Name}};
            {{- end}}

            b = marshalerWriteField(m, {{.Number}});
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWrite{{resolveType . true false}}(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
    {{- end}}
    {{- end}}
    {{- end}}


    return n;
}
{{end}}{{end}}

/// JSON Marshaling
{{define "jsonType"}}struct {
	{{- range .Embeddings}}{{.}} {{lcName .}};
	{{- end}}
	{{- range .Fields}}
	{{- if .IsMarshalled}}
	{{.Name}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .Name}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
	{{- if .AlternativeName}}
	{{.AlternativeName}} {{jsonType .}}{{if .IsMarshalled}} `json:"{{lcName .AlternativeName}}{{if .OmitEmpty}},omitempty{{end}}"`{{end}}
	{{- end}}
	{{- end}}
	{{- end}}
}{{end}}

/// JSON Marshaling
{{range .Types}}
{{if needsCustomJSON .}}static Error {{.Name}}_marshalJSON(const {{.Name}} *v, const Bytes *inData) {
    return ErrorCode(ErrorNotImplemented);
}
{{end}}{{end}}

/// JSON Unmarshaling
{{range .Types}}
{{if needsCustomJSON .}}static Error {{.Name}}_unmarshalJSON({{.Name}} *v,Bytes *outData) {
    return ErrorCode(ErrorNotImplemented);
}
{{end}}{{end}}

{{range .Types}}
static {{.Name}} {{.Name}}_init({{.Name}} *v) {
    {{.Name}} init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = {{.Name}}_type;
//    init.BinarySize = {{.Name}}_binarySize;
//    init.Equal = {{.Name}}_equal;
    //init.Copy = {{.Name}}_copy;
//    init.MarshalBinary = {{.Name}}_marshalBinary;
//    init.UnmarshalBinary = {{.Name}}_unmarshalBinary;
//    {{if needsCustomJSON .}}
//    init.MarshalJSON = {{.Name}}_marshalJSON;
//    init.UnmarshalJSON = {{.Name}}_unmarshalJSON;
    {{end}}

    if ( v ) {
        *v = init;
    }
    return init;
}
{{end}}

#ifdef __cplusplus
}
#endif


