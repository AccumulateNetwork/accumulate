// Copyright {{.Year}} The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package {{.Package}}

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	"strings"
)

{{range .Types}}
{{$typ := .Name}}
{{range .Values}}
// {{valueName .}} {{.Description}}.
const {{valueName .}} {{$typ}} = {{.Value}}
{{end}}
{{end}}

{{range .Types}}
// GetEnumValue returns the value of the {{natural .Name}}
func (v {{.Name}}) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *{{.Name}}) SetEnumValue(id uint64) bool {
	u := {{.Name}}(id)
	switch u {
	{{- $typ := .Name}}
	case {{range $i, $v := .Values}}{{if gt $i 0}}, {{end}}{{valueName .}}{{end}}:
		*v = u
		return true
	default:
		return false
	}
}

// String returns the name of the {{natural .Name}}.
func (v {{.Name}}) String() string {
	switch v {
	{{- $typ := .Name}}
	{{- range .Values}}
	case {{valueName .}}:
		return "{{if .Label}}{{.Label}}{{else}}{{lowerCamel .Name}}{{end}}"
	{{- end}}
	default:
		return fmt.Sprintf("{{.Name}}:%d", v)
	}
}

{{/* // GoString returns the Go constant name.
func (v {{.Name}}) GoString() string {
	switch v {
	{{- $typ := .Name}}
	{{- range .Values}}
	case {{valueName .}}:
		return "{{valueName .}}"
	{{- end}}
	default:
		return fmt.Sprintf("{{.Name}}(%d)", v)
	}
} */}}

// {{.Name}}ByName returns the named {{natural .Name}}.
func {{.Name}}ByName(name string) ({{.Name}}, bool) {
	switch strings.ToLower(name) {
	{{- $typ := .Name}}
	{{- range .Values}}
	{{- $typ := (valueName .)}}
	case "{{lower .Name}}":
		return {{$typ}}, true
	{{- if .Label}}
	case "{{lower .Label}}":
		return {{$typ}}, true
	{{- end}}
	{{- range .Aliases}}
	case "{{.}}":
		return {{$typ}}, true
	{{- end}}
	{{- end}}
	default:
		return 0, false
	}
}

// MarshalJSON marshals the {{natural .Name}} to JSON as a string.
func (v {{.Name}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the {{natural .Name}} from JSON as a string.
func (v *{{.Name}}) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = {{.Name}}ByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid {{natural .Name}} %q", s)
	}
	return nil
}

{{end}}
