// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package io.accumulatenetwork.sdk.{{.SubPackage}}

/**
    GENERATED BY go run ./tools/cmd/gen-api. DO NOT EDIT.
**/

import io.accumulatenetwork.sdk.support.IntValueEnum
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.Json.Default.serializersModule
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.int
import kotlinx.serialization.json.jsonPrimitive
import kotlinx.serialization.serializer

@Serializable(with = {{.Name}}Serializer::class)
enum class {{.Name}}(override val value: Int, val apiName: String) : IntValueEnum {

    {{- range $i, $v := .Values}}{{if gt $i 0}},{{end}}
    {{underscoreUpperCase $v.Name}}({{$v.Value}}, "{{lowerCamel $v.Name}}")
    {{- end}};

    override fun toString(): String {
        return apiName
    }


    companion object {
        fun fromValue(value: Int): {{.Name}} {
            return values().firstOrNull { it.value == value }
                ?: throw RuntimeException("$value is not a valid TransactionType")
        }

        fun fromApiName(name: String?): {{.Name}} {
            return values().firstOrNull { it.apiName.equals(name, ignoreCase = true) }
                ?: throw RuntimeException("'$name' is not a valid TransactionType")
        }
    }
}

object {{.Name}}Serializer : KSerializer<{{.Name}}> {

    override val descriptor = serializersModule.serializer<{{.Name}}>().descriptor

    override fun serialize(encoder: Encoder, value: {{.Name}}) {
        encoder.encodeString(value.apiName)
    }

    override fun deserialize(decoder: Decoder): {{.Name}} {
        return when (val element = Json.parseToJsonElement(decoder.decodeString())) {
            is JsonPrimitive -> {{.Name}}.fromApiName(element.content)
            is JsonObject -> {{.Name}}.fromValue(element.jsonPrimitive.int)
            else -> throw RuntimeException("Invalid type. Expected String or Int.")
        }
    }
}
