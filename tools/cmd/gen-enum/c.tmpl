#pragma once

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif
#include <accumulate/common/encoding.h>

typedef struct {
   const char *name;
   uint32_t e;
} enum_t;

{{range .Types}}
{{$typ := .Name}}
typedef enum {
{{range .Values}}
    // {{$typ}}{{.Name}} {{.Description}}.
    {{$typ}}{{.Name}} = {{.Value}},
{{end}}
} {{$typ}};
{{end}}

{{range .Types}}

typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, {{.Name}} *out);
    Error (*set)(struct Bytes *, {{.Name}} in);
} {{.Name}}_t;

ACME_API Error {{.Name}}_valid(const Bytes *v);
ACME_API Error {{.Name}}_set(Bytes *v, {{.Name}} n);
ACME_API Error {{.Name}}_get(const Bytes *v, {{.Name}} *n);
ACME_API uint64_t {{.Name}}_ID({{.Name}} v);
ACME_API Error {{.Name}}_fromString(Bytes *v, String *name);
ACME_API Error {{.Name}}_asString(const Bytes *v, String *out);
ACME_API Error {{.Name}}_marshalJSON(const Bytes *v, Marshaler *out);
ACME_API Error {{.Name}}_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API Error {{.Name}}_marshalBinary(const Bytes *v, Marshaler *out);
ACME_API Error {{.Name}}_unmarshalBinary(Bytes *v, const Marshaler *in);
{{.Name}}_t {{.Name}}_init({{.Name}}_t *v, buffer_t *buffer);

#ifndef ACME_HEADER

ACME_API Error {{.Name}}_valid(const Bytes *v) {
    if (!v) {
        return ErrorCode[ErrorParameterNil];
    }
    if (v->buffer.size != sizeof({{.Name}})) {
        return ErrorCode[ErrorBufferTooSmall];
    }
    return ErrorCode[ErrorNone];
}

ACME_API Error {{.Name}}_set(Bytes *v, {{.Name}} n) {
    Error e = {{.Name}}_valid(v);
    if ( e.code != ErrorNone ) {
        return e;
    }

    *(uint64_t*)(v->buffer.ptr+v->buffer.offset) = n;
    return ErrorCode[ErrorNone];
}

ACME_API Error {{.Name}}_get(const Bytes *v, {{.Name}} *n) {
    Error e = {{.Name}}_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if (!n) {
        return ErrorCode[ErrorParameterNil];
    }

    *n = *({{.Name}}*)(v->buffer.ptr+v->buffer.offset);
    return ErrorCode[ErrorNone];
}


// ID returns the ID of the {{natural .Name}}
ACME_API uint64_t {{.Name}}_ID({{.Name}} v) { return (uint64_t)(v); }

// String returns the name of the {{natural .Name}}
static enum_t {{.Name}}_l[] = {
	{{- $typ := .Name}}
	{{- range .Values}}
	{ "{{lower .Name}}", {{$typ}}{{.Name}} },
	{{- end}}
};

ACME_API Error {{.Name}}_asString(const Bytes *v, String *out) {
    Error e = {{.Name}}_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    {{.Name}} val = *({{.Name}}*)(v->buffer.ptr + v->buffer.offset);
    for ( int i = 0; i < sizeof({{.Name}}_l); ++i ) {
        if ( {{.Name}}_l[i].e == val ) {
            out->set(&out->data, {{.Name}}_l[i].name);
            return ErrorCode[ErrorNone];
        }
    }
    return ErrorCode[ErrorTypeNotFound];
}

// {{.Name}}ByName returns the named {{natural .Name}}.
ACME_API Error {{.Name}}_fromString(Bytes *v, String *name) {
    Error e = {{.Name}}_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof({{.Name}}_l); ++i ) {
        if ( strncmp({{.Name}}_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *({{.Name}}*)(v->buffer.ptr + v->buffer.offset) = {{.Name}}_l[i].e;
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// {{.Name}}_marshalJSON marshals the {{natural .Name}} to JSON as a string.
ACME_API Error {{.Name}}_marshalJSON(const Bytes *v, Marshaler *out) {
    if (!v || !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = {{.Name}}_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    e = {{.Name}}_asString(v, &s);
    if ( e.code != ErrorNone ) {
        return e;
    }
    return s.data.MarshalJSON(&s.data, out);
}

// {{.Name}}_unmarshalJSON unmarshals the {{natural .Name}} from JSON as a string.
ACME_API Error {{.Name}}_unmarshalJSON(Bytes *v, const Marshaler *in) {
    if (!v || !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = {{.Name}}_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    //unmarshal the "in" buffer from the Marshaler into a String
    e = s.data.UnmarshalJSON(&s.data, in);
    if ( e.code != ErrorNone ) {
        return e;
    }
    //now convert the unmarshaled string into the enum
    return {{.Name}}_fromString(v, &s);
}

// MarshalBinary marshals the {{natural .Name}} to bytes as a unsigned varint.
ACME_API Error {{.Name}}_marshalBinary(const Bytes *v, Marshaler *out) {
    if ( !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = {{.Name}}_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if ( !buffer_can_read(&out->cache, VarInt_binarySize(v)) ) {
        return ErrorCode[ErrorParameterInsufficientData];
    }
    {{.Name}} n;
    e = {{.Name}}_get(v, &n);
    if ( e.code != ErrorNone ) {
        return e;
    }

    int r = varint_write((uint8_t*)out->cache.ptr,out->cache.offset, (uint64_t)n);
    out->cache.offset += r;
    out->data.buffer.size += r;
    if ( r < 0 ) {
        return ErrorCode[ErrorVarIntWrite];
    }
    return ErrorCode[ErrorNone];
}

// UnmarshalBinary unmarshals the {{natural .Name}} from bytes as a unsigned varint.
ACME_API Error {{.Name}}_unmarshalBinary(Bytes *v, const Marshaler *in) {
    if ( !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = {{.Name}}_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint64_t t = 0;
    int r = varint_read((uint8_t*)in->data.buffer.ptr+in->data.buffer.offset, in->data.buffer.size,&t);
	if ( r < 0 ) {
		return ErrorCode[ErrorVarIntRead];
	}
	{{.Name}}_set(v,({{.Name}})t);
	return ErrorCode[ErrorNone];
}

// {{.Name}}_binarySize returns the number of bytes required to binary marshal the {{natural .Name}}.
{{.Name}}_t {{.Name}}_init({{.Name}}_t *v, buffer_t *buffer) {
    {{.Name}}_t init = { { {0,0,0},
                    VarInt_binarySize,
                    Bytes_equal,
                    Bytes_copy,
                    {{.Name}}_marshalBinary,
                    {{.Name}}_unmarshalBinary,
                    {{.Name}}_marshalJSON,
                    {{.Name}}_unmarshalJSON},
                    {{.Name}}_get,
                    {{.Name}}_set,
                  };
    if (buffer) {
        int sizeNeeded = sizeof({{.Name}});
        if ( buffer->size - buffer->offset < sizeNeeded ) {
            return init;
        }
        init.data.buffer.ptr = buffer->ptr;
        init.data.buffer.offset = buffer->offset;
        init.data.buffer.size = sizeNeeded;
        buffer->offset += sizeNeeded;
    }

    if (v) {
        *v = init;
    }
    return init;
}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif

{{end}}
