#pragma once

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif
#include <common/encoding/encoding.h>
#include <common/encoding/marshaler.h>

#define WANT_ENUM_STRING_CONVERSION 0

typedef struct {
   const char *name;
   uint64_t e;
} enum_t;

{{range .Types}}
{{$typ := .Name}}
typedef enum {
{{range .Values}}
    // {{$typ}}{{.Name}} {{.Description}}.
    {{$typ}}{{.Name}} = {{.Value}},
{{end}}
} {{$typ}};
{{end}}

{{range .Types}}

typedef struct {
    Bytes data;
} {{.Name}}_t;

ACME_API uint64_t {{.Name}}_ID({{.Name}} v);
#if WANT_ENUM_STRING_CONVERSION
ACME_API Error {{.Name}}_fromString({{.Name}} *v, String *name);
ACME_API Error {{.Name}}_asString({{.Name}} v, String *out);
#endif
ACME_API {{.Name}}_t {{.Name}}_init({{.Name}}_t *v, buffer_t *buffer);
ACME_API int unmarshalerRead{{.Name}}(Unmarshaler *m, {{.Name}} *v);
ACME_API int marshalerWrite{{.Name}}(Marshaler *m, {{.Name}} v);
ACME_API bool {{.Name}}_equal(const {{.Name}} *a, const {{.Name}} *b);

{{end}}

#ifdef _ACME_ENUM_SOURCE_


{{range .Types}}

ACME_API Error {{.Name}}_set(VarInt *v, {{.Name}} n) {
    return VarInt_set(v,n);
}

ACME_API Error {{.Name}}_get(const VarInt *v, {{.Name}} *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the {{natural .Name}}
ACME_API uint64_t {{.Name}}_ID({{.Name}} v) { return (uint64_t)(v); }
#if WANT_ENUM_STRING_CONVERSION
// String returns the name of the {{natural .Name}}
static enum_t {{.Name}}_l[] = {
	{{- $typ := .Name}}
	{{- range .Values}}
	{ "{{lower .Name}}", {{$typ}}{{.Name}} },
	{{- end}}
	{ 0,0 },
};

ACME_API Error {{.Name}}_asString(const {{.Name}} v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( {{.Name}}_l[i].name == 0 ) {
            break;
        }
        if ( {{.Name}}_l[i].e == v ) {
            String_set(out, {{.Name}}_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// {{.Name}}ByName returns the named {{natural .Name}}.
ACME_API Error {{.Name}}_fromString({{.Name}} *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( {{.Name}}_l[i].name == 0 ) {
            break;
        }
        if ( strncmp({{.Name}}_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = {{.Name}}_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}
#endif

ACME_API bool {{.Name}}_equal(const {{.Name}} *a, const {{.Name}} *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the {{natural .Name}} to bytes as an unsigned varint.
ACME_API int marshalerWrite{{.Name}}(Marshaler *m, {{.Name}} v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the {{natural .Name}} from bytes as an unsigned varint.
ACME_API int unmarshalerRead{{.Name}}(Unmarshaler *m, {{.Name}} *v) {
	uint64_t n = 0;
	int b = unmarshalerReadUInt(m, &n);
    *v = ({{.Name}})n;
    return b;
}

{{end}}

#endif /* _ACME_ENUM_SOURCE_ */

#ifdef __cplusplus
}
#endif
