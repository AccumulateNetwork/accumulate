// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package factom

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

type EntryMetadata struct {
	fieldsSet            []bool
	DBlockKeyMR          [32]byte `json:"dblockKeyMR,omitempty" form:"dblockKeyMR" query:"dblockKeyMR" validate:"required"`
	DBlockHeight         uint64   `json:"dblockHeight" form:"dblockHeight" query:"dblockHeight" validate:"required"`
	EBlockKeyMR          [32]byte `json:"eblockKeyMR,omitempty" form:"eblockKeyMR" query:"eblockKeyMR" validate:"required"`
	EBlockSequenceNumber uint64   `json:"eblockSequenceNumber" form:"eblockSequenceNumber" query:"eblockSequenceNumber" validate:"required"`
	EntryIndex           uint64   `json:"entryIndex" form:"entryIndex" query:"entryIndex" validate:"required"`
	extraData            []byte
}

func (v *EntryMetadata) Copy() *EntryMetadata {
	u := new(EntryMetadata)

	u.DBlockKeyMR = v.DBlockKeyMR
	u.DBlockHeight = v.DBlockHeight
	u.EBlockKeyMR = v.EBlockKeyMR
	u.EBlockSequenceNumber = v.EBlockSequenceNumber
	u.EntryIndex = v.EntryIndex

	return u
}

func (v *EntryMetadata) CopyAsInterface() interface{} { return v.Copy() }

func (v *EntryMetadata) Equal(u *EntryMetadata) bool {
	if !(v.DBlockKeyMR == u.DBlockKeyMR) {
		return false
	}
	if !(v.DBlockHeight == u.DBlockHeight) {
		return false
	}
	if !(v.EBlockKeyMR == u.EBlockKeyMR) {
		return false
	}
	if !(v.EBlockSequenceNumber == u.EBlockSequenceNumber) {
		return false
	}
	if !(v.EntryIndex == u.EntryIndex) {
		return false
	}

	return true
}

var fieldNames_EntryMetadata = []string{
	1: "DBlockKeyMR",
	2: "DBlockHeight",
	3: "EBlockKeyMR",
	4: "EBlockSequenceNumber",
	5: "EntryIndex",
}

func (v *EntryMetadata) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.DBlockKeyMR == ([32]byte{})) {
		writer.WriteHash(1, &v.DBlockKeyMR)
	}
	writer.WriteUint(2, v.DBlockHeight)
	if !(v.EBlockKeyMR == ([32]byte{})) {
		writer.WriteHash(3, &v.EBlockKeyMR)
	}
	writer.WriteUint(4, v.EBlockSequenceNumber)
	writer.WriteUint(5, v.EntryIndex)

	_, _, err := writer.Reset(fieldNames_EntryMetadata)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *EntryMetadata) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field DBlockKeyMR is missing")
	} else if v.DBlockKeyMR == ([32]byte{}) {
		errs = append(errs, "field DBlockKeyMR is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field DBlockHeight is missing")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field EBlockKeyMR is missing")
	} else if v.EBlockKeyMR == ([32]byte{}) {
		errs = append(errs, "field EBlockKeyMR is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field EBlockSequenceNumber is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field EntryIndex is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *EntryMetadata) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *EntryMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.DBlockKeyMR = *x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.DBlockHeight = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.EBlockKeyMR = *x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.EBlockSequenceNumber = x
	}
	if x, ok := reader.ReadUint(5); ok {
		v.EntryIndex = x
	}

	seen, err := reader.Reset(fieldNames_EntryMetadata)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *EntryMetadata) MarshalJSON() ([]byte, error) {
	u := struct {
		DBlockKeyMR          string `json:"dblockKeyMR,omitempty"`
		DBlockHeight         uint64 `json:"dblockHeight"`
		EBlockKeyMR          string `json:"eblockKeyMR,omitempty"`
		EBlockSequenceNumber uint64 `json:"eblockSequenceNumber"`
		EntryIndex           uint64 `json:"entryIndex"`
	}{}
	if !(v.DBlockKeyMR == ([32]byte{})) {
		u.DBlockKeyMR = encoding.ChainToJSON(v.DBlockKeyMR)
	}
	u.DBlockHeight = v.DBlockHeight
	if !(v.EBlockKeyMR == ([32]byte{})) {
		u.EBlockKeyMR = encoding.ChainToJSON(v.EBlockKeyMR)
	}
	u.EBlockSequenceNumber = v.EBlockSequenceNumber
	u.EntryIndex = v.EntryIndex
	return json.Marshal(&u)
}

func (v *EntryMetadata) UnmarshalJSON(data []byte) error {
	u := struct {
		DBlockKeyMR          string `json:"dblockKeyMR,omitempty"`
		DBlockHeight         uint64 `json:"dblockHeight"`
		EBlockKeyMR          string `json:"eblockKeyMR,omitempty"`
		EBlockSequenceNumber uint64 `json:"eblockSequenceNumber"`
		EntryIndex           uint64 `json:"entryIndex"`
	}{}
	u.DBlockKeyMR = encoding.ChainToJSON(v.DBlockKeyMR)
	u.DBlockHeight = v.DBlockHeight
	u.EBlockKeyMR = encoding.ChainToJSON(v.EBlockKeyMR)
	u.EBlockSequenceNumber = v.EBlockSequenceNumber
	u.EntryIndex = v.EntryIndex
	if err := json.Unmarshal(data, &u); err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.DBlockKeyMR); err != nil {
		return fmt.Errorf("error decoding DBlockKeyMR: %w", err)
	} else {
		v.DBlockKeyMR = x
	}
	v.DBlockHeight = u.DBlockHeight
	if x, err := encoding.ChainFromJSON(u.EBlockKeyMR); err != nil {
		return fmt.Errorf("error decoding EBlockKeyMR: %w", err)
	} else {
		v.EBlockKeyMR = x
	}
	v.EBlockSequenceNumber = u.EBlockSequenceNumber
	v.EntryIndex = u.EntryIndex
	return nil
}
