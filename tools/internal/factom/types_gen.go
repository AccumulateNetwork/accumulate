package factom

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"errors"
	"io"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/internal/encoding"
)

type EntryMetadata struct {
	fieldsSet   []bool
	BlockTime   time.Time `json:"blockTime,omitempty" form:"blockTime" query:"blockTime" validate:"required"`
	BlockHeight uint64    `json:"blockHeight" form:"blockHeight" query:"blockHeight" validate:"required"`
	EntryIndex  uint64    `json:"entryIndex" form:"entryIndex" query:"entryIndex" validate:"required"`
	EntryNumber uint64    `json:"entryNumber" form:"entryNumber" query:"entryNumber" validate:"required"`
	extraData   []byte
}

func (v *EntryMetadata) Copy() *EntryMetadata {
	u := new(EntryMetadata)

	u.BlockTime = v.BlockTime
	u.BlockHeight = v.BlockHeight
	u.EntryIndex = v.EntryIndex
	u.EntryNumber = v.EntryNumber

	return u
}

func (v *EntryMetadata) CopyAsInterface() interface{} { return v.Copy() }

func (v *EntryMetadata) Equal(u *EntryMetadata) bool {
	if !(v.BlockTime == u.BlockTime) {
		return false
	}
	if !(v.BlockHeight == u.BlockHeight) {
		return false
	}
	if !(v.EntryIndex == u.EntryIndex) {
		return false
	}
	if !(v.EntryNumber == u.EntryNumber) {
		return false
	}

	return true
}

var fieldNames_EntryMetadata = []string{
	1: "BlockTime",
	2: "BlockHeight",
	3: "EntryIndex",
	4: "EntryNumber",
}

func (v *EntryMetadata) MarshalBinary() ([]byte, error) {
	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.BlockTime == (time.Time{})) {
		writer.WriteTime(1, v.BlockTime)
	}
	writer.WriteUint(2, v.BlockHeight)
	writer.WriteUint(3, v.EntryIndex)
	writer.WriteUint(4, v.EntryNumber)

	_, _, err := writer.Reset(fieldNames_EntryMetadata)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *EntryMetadata) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field BlockTime is missing")
	} else if v.BlockTime == (time.Time{}) {
		errs = append(errs, "field BlockTime is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field BlockHeight is missing")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field EntryIndex is missing")
	}
	if len(v.fieldsSet) > 4 && !v.fieldsSet[4] {
		errs = append(errs, "field EntryNumber is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *EntryMetadata) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *EntryMetadata) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadTime(1); ok {
		v.BlockTime = x
	}
	if x, ok := reader.ReadUint(2); ok {
		v.BlockHeight = x
	}
	if x, ok := reader.ReadUint(3); ok {
		v.EntryIndex = x
	}
	if x, ok := reader.ReadUint(4); ok {
		v.EntryNumber = x
	}

	seen, err := reader.Reset(fieldNames_EntryMetadata)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}
