// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package typegen

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"encoding/json"
	"fmt"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
)

type ChainRecord struct {
	RecordBase
	ChainType string `json:"chainType,omitempty" form:"chainType" query:"chainType" validate:"required"`
}

type EntityRecord struct {
	RecordBase
	Fields        []*Field `json:"fields,omitempty" form:"fields" query:"fields" validate:"required"`
	CustomCommit  bool     `json:"customCommit,omitempty" form:"customCommit" query:"customCommit" validate:"required"`
	CustomResolve bool     `json:"customResolve,omitempty" form:"customResolve" query:"customResolve" validate:"required"`
	CustomIsDirty bool     `json:"customIsDirty,omitempty" form:"customIsDirty" query:"customIsDirty" validate:"required"`
	CustomWalk    bool     `json:"customWalk,omitempty" form:"customWalk" query:"customWalk" validate:"required"`
	OmitCommit    bool     `json:"omitCommit,omitempty" form:"omitCommit" query:"omitCommit" validate:"required"`
	OmitResolve   bool     `json:"omitResolve,omitempty" form:"omitResolve" query:"omitResolve" validate:"required"`
	OmitIsDirty   bool     `json:"omitIsDirty,omitempty" form:"omitIsDirty" query:"omitIsDirty" validate:"required"`
	OmitWalk      bool     `json:"omitWalk,omitempty" form:"omitWalk" query:"omitWalk" validate:"required"`
	ValueStore    string   `json:"valueStore,omitempty" form:"valueStore" query:"valueStore" validate:"required"`
	Root          bool     `json:"root,omitempty" form:"root" query:"root" validate:"required"`
	Interface     bool     `json:"interface,omitempty" form:"interface" query:"interface" validate:"required"`
	Attributes    []Record `json:"attributes,omitempty" form:"attributes" query:"attributes" validate:"required"`
}

type IndexRecord struct {
	RecordBase
	DataType       FieldType      `json:"dataType,omitempty" form:"dataType" query:"dataType" validate:"required"`
	Pointer        bool           `json:"pointer,omitempty" form:"pointer" query:"pointer" validate:"required"`
	EmptyIfMissing bool           `json:"emptyIfMissing,omitempty" form:"emptyIfMissing" query:"emptyIfMissing" validate:"required"`
	Union          bool           `json:"union,omitempty" form:"union" query:"union" validate:"required"`
	Collection     CollectionType `json:"collection,omitempty" form:"collection" query:"collection" validate:"required"`
	Comparator     string         `json:"comparator,omitempty" form:"comparator" query:"comparator" validate:"required"`
}

type OtherRecord struct {
	RecordBase
	DataType    string `json:"dataType,omitempty" form:"dataType" query:"dataType" validate:"required"`
	Pointer     bool   `json:"pointer,omitempty" form:"pointer" query:"pointer" validate:"required"`
	HasChains   bool   `json:"hasChains,omitempty" form:"hasChains" query:"hasChains" validate:"required"`
	Constructor string `json:"constructor,omitempty" form:"constructor" query:"constructor" validate:"required"`
}

type RecordBase struct {
	Name                   string        `json:"name,omitempty" form:"name" query:"name" validate:"required"`
	Key                    string        `json:"key,omitempty" form:"key" query:"key" validate:"required"`
	Description            string        `json:"description,omitempty" form:"description" query:"description" validate:"required"`
	Parent                 *EntityRecord `json:"parent,omitempty" form:"parent" query:"parent" validate:"required"`
	Private                bool          `json:"private,omitempty" form:"private" query:"private" validate:"required"`
	OmitAccessor           bool          `json:"omitAccessor,omitempty" form:"omitAccessor" query:"omitAccessor" validate:"required"`
	OmitConstructor        bool          `json:"omitConstructor,omitempty" form:"omitConstructor" query:"omitConstructor" validate:"required"`
	CustomValueConstructor bool          `json:"customValueConstructor,omitempty" form:"customValueConstructor" query:"customValueConstructor" validate:"required"`
	Parameters             []*Field      `json:"parameters,omitempty" form:"parameters" query:"parameters" validate:"required"`
	Index                  string        `json:"index,omitempty" form:"index" query:"index" validate:"required"`
}

type StateRecord struct {
	RecordBase
	DataType       FieldType      `json:"dataType,omitempty" form:"dataType" query:"dataType" validate:"required"`
	Pointer        bool           `json:"pointer,omitempty" form:"pointer" query:"pointer" validate:"required"`
	EmptyIfMissing bool           `json:"emptyIfMissing,omitempty" form:"emptyIfMissing" query:"emptyIfMissing" validate:"required"`
	Union          bool           `json:"union,omitempty" form:"union" query:"union" validate:"required"`
	Collection     CollectionType `json:"collection,omitempty" form:"collection" query:"collection" validate:"required"`
	Comparator     string         `json:"comparator,omitempty" form:"comparator" query:"comparator" validate:"required"`
}

func (*ChainRecord) Type() RecordType { return RecordTypeChain }

func (*EntityRecord) Type() RecordType { return RecordTypeEntity }

func (*IndexRecord) Type() RecordType { return RecordTypeIndex }

func (*OtherRecord) Type() RecordType { return RecordTypeOther }

func (*StateRecord) Type() RecordType { return RecordTypeState }

func (v *ChainRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		Type                   RecordType                `json:"type"`
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
		ChainType              string                    `json:"chainType,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.RecordBase.Name) == 0) {
		u.Name = v.RecordBase.Name
	}
	if !(len(v.RecordBase.Key) == 0) {
		u.Key = v.RecordBase.Key
	}
	if !(len(v.RecordBase.Description) == 0) {
		u.Description = v.RecordBase.Description
	}
	if !(v.RecordBase.Parent == nil) {
		u.Parent = v.RecordBase.Parent
	}
	if !(!v.RecordBase.Private) {
		u.Private = v.RecordBase.Private
	}
	if !(!v.RecordBase.OmitAccessor) {
		u.OmitAccessor = v.RecordBase.OmitAccessor
	}
	if !(!v.RecordBase.OmitConstructor) {
		u.OmitConstructor = v.RecordBase.OmitConstructor
	}
	if !(!v.RecordBase.CustomValueConstructor) {
		u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	}
	if !(len(v.RecordBase.Parameters) == 0) {
		u.Parameters = v.RecordBase.Parameters
	}
	if !(len(v.RecordBase.Index) == 0) {
		u.Index = v.RecordBase.Index
	}
	if !(len(v.ChainType) == 0) {
		u.ChainType = v.ChainType
	}
	return json.Marshal(&u)
}

func (v *EntityRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		Type                   RecordType                              `json:"type"`
		Name                   string                                  `json:"name,omitempty"`
		Key                    string                                  `json:"key,omitempty"`
		Description            string                                  `json:"description,omitempty"`
		Parent                 *EntityRecord                           `json:"parent,omitempty"`
		Private                bool                                    `json:"private,omitempty"`
		OmitAccessor           bool                                    `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                                    `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                                    `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field]               `json:"parameters,omitempty"`
		Index                  string                                  `json:"index,omitempty"`
		Fields                 encoding.JsonList[*Field]               `json:"fields,omitempty"`
		CustomCommit           bool                                    `json:"customCommit,omitempty"`
		CustomResolve          bool                                    `json:"customResolve,omitempty"`
		CustomIsDirty          bool                                    `json:"customIsDirty,omitempty"`
		CustomWalk             bool                                    `json:"customWalk,omitempty"`
		OmitCommit             bool                                    `json:"omitCommit,omitempty"`
		OmitResolve            bool                                    `json:"omitResolve,omitempty"`
		OmitIsDirty            bool                                    `json:"omitIsDirty,omitempty"`
		OmitWalk               bool                                    `json:"omitWalk,omitempty"`
		ValueStore             string                                  `json:"valueStore,omitempty"`
		Root                   bool                                    `json:"root,omitempty"`
		Interface              bool                                    `json:"interface,omitempty"`
		Attributes             *encoding.JsonUnmarshalListWith[Record] `json:"attributes,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.RecordBase.Name) == 0) {
		u.Name = v.RecordBase.Name
	}
	if !(len(v.RecordBase.Key) == 0) {
		u.Key = v.RecordBase.Key
	}
	if !(len(v.RecordBase.Description) == 0) {
		u.Description = v.RecordBase.Description
	}
	if !(v.RecordBase.Parent == nil) {
		u.Parent = v.RecordBase.Parent
	}
	if !(!v.RecordBase.Private) {
		u.Private = v.RecordBase.Private
	}
	if !(!v.RecordBase.OmitAccessor) {
		u.OmitAccessor = v.RecordBase.OmitAccessor
	}
	if !(!v.RecordBase.OmitConstructor) {
		u.OmitConstructor = v.RecordBase.OmitConstructor
	}
	if !(!v.RecordBase.CustomValueConstructor) {
		u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	}
	if !(len(v.RecordBase.Parameters) == 0) {
		u.Parameters = v.RecordBase.Parameters
	}
	if !(len(v.RecordBase.Index) == 0) {
		u.Index = v.RecordBase.Index
	}
	if !(len(v.Fields) == 0) {
		u.Fields = v.Fields
	}
	if !(!v.CustomCommit) {
		u.CustomCommit = v.CustomCommit
	}
	if !(!v.CustomResolve) {
		u.CustomResolve = v.CustomResolve
	}
	if !(!v.CustomIsDirty) {
		u.CustomIsDirty = v.CustomIsDirty
	}
	if !(!v.CustomWalk) {
		u.CustomWalk = v.CustomWalk
	}
	if !(!v.OmitCommit) {
		u.OmitCommit = v.OmitCommit
	}
	if !(!v.OmitResolve) {
		u.OmitResolve = v.OmitResolve
	}
	if !(!v.OmitIsDirty) {
		u.OmitIsDirty = v.OmitIsDirty
	}
	if !(!v.OmitWalk) {
		u.OmitWalk = v.OmitWalk
	}
	if !(len(v.ValueStore) == 0) {
		u.ValueStore = v.ValueStore
	}
	if !(!v.Root) {
		u.Root = v.Root
	}
	if !(!v.Interface) {
		u.Interface = v.Interface
	}
	if !(len(v.Attributes) == 0) {
		u.Attributes = &encoding.JsonUnmarshalListWith[Record]{Value: v.Attributes, Func: UnmarshalRecordJSON}
	}
	return json.Marshal(&u)
}

func (v *IndexRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		Type                   RecordType                `json:"type"`
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
		DataType               FieldType                 `json:"dataType,omitempty"`
		Pointer                bool                      `json:"pointer,omitempty"`
		EmptyIfMissing         bool                      `json:"emptyIfMissing,omitempty"`
		Union                  bool                      `json:"union,omitempty"`
		Collection             CollectionType            `json:"collection,omitempty"`
		Comparator             string                    `json:"comparator,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.RecordBase.Name) == 0) {
		u.Name = v.RecordBase.Name
	}
	if !(len(v.RecordBase.Key) == 0) {
		u.Key = v.RecordBase.Key
	}
	if !(len(v.RecordBase.Description) == 0) {
		u.Description = v.RecordBase.Description
	}
	if !(v.RecordBase.Parent == nil) {
		u.Parent = v.RecordBase.Parent
	}
	if !(!v.RecordBase.Private) {
		u.Private = v.RecordBase.Private
	}
	if !(!v.RecordBase.OmitAccessor) {
		u.OmitAccessor = v.RecordBase.OmitAccessor
	}
	if !(!v.RecordBase.OmitConstructor) {
		u.OmitConstructor = v.RecordBase.OmitConstructor
	}
	if !(!v.RecordBase.CustomValueConstructor) {
		u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	}
	if !(len(v.RecordBase.Parameters) == 0) {
		u.Parameters = v.RecordBase.Parameters
	}
	if !(len(v.RecordBase.Index) == 0) {
		u.Index = v.RecordBase.Index
	}
	if !((v.DataType).Equal(new(FieldType))) {
		u.DataType = v.DataType
	}
	if !(!v.Pointer) {
		u.Pointer = v.Pointer
	}
	if !(!v.EmptyIfMissing) {
		u.EmptyIfMissing = v.EmptyIfMissing
	}
	if !(!v.Union) {
		u.Union = v.Union
	}
	if !(v.Collection == 0) {
		u.Collection = v.Collection
	}
	if !(len(v.Comparator) == 0) {
		u.Comparator = v.Comparator
	}
	return json.Marshal(&u)
}

func (v *OtherRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		Type                   RecordType                `json:"type"`
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
		DataType               string                    `json:"dataType,omitempty"`
		Pointer                bool                      `json:"pointer,omitempty"`
		HasChains              bool                      `json:"hasChains,omitempty"`
		Constructor            string                    `json:"constructor,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.RecordBase.Name) == 0) {
		u.Name = v.RecordBase.Name
	}
	if !(len(v.RecordBase.Key) == 0) {
		u.Key = v.RecordBase.Key
	}
	if !(len(v.RecordBase.Description) == 0) {
		u.Description = v.RecordBase.Description
	}
	if !(v.RecordBase.Parent == nil) {
		u.Parent = v.RecordBase.Parent
	}
	if !(!v.RecordBase.Private) {
		u.Private = v.RecordBase.Private
	}
	if !(!v.RecordBase.OmitAccessor) {
		u.OmitAccessor = v.RecordBase.OmitAccessor
	}
	if !(!v.RecordBase.OmitConstructor) {
		u.OmitConstructor = v.RecordBase.OmitConstructor
	}
	if !(!v.RecordBase.CustomValueConstructor) {
		u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	}
	if !(len(v.RecordBase.Parameters) == 0) {
		u.Parameters = v.RecordBase.Parameters
	}
	if !(len(v.RecordBase.Index) == 0) {
		u.Index = v.RecordBase.Index
	}
	if !(len(v.DataType) == 0) {
		u.DataType = v.DataType
	}
	if !(!v.Pointer) {
		u.Pointer = v.Pointer
	}
	if !(!v.HasChains) {
		u.HasChains = v.HasChains
	}
	if !(len(v.Constructor) == 0) {
		u.Constructor = v.Constructor
	}
	return json.Marshal(&u)
}

func (v *RecordBase) MarshalJSON() ([]byte, error) {
	u := struct {
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
	}{}
	if !(len(v.Name) == 0) {
		u.Name = v.Name
	}
	if !(len(v.Key) == 0) {
		u.Key = v.Key
	}
	if !(len(v.Description) == 0) {
		u.Description = v.Description
	}
	if !(v.Parent == nil) {
		u.Parent = v.Parent
	}
	if !(!v.Private) {
		u.Private = v.Private
	}
	if !(!v.OmitAccessor) {
		u.OmitAccessor = v.OmitAccessor
	}
	if !(!v.OmitConstructor) {
		u.OmitConstructor = v.OmitConstructor
	}
	if !(!v.CustomValueConstructor) {
		u.CustomValueConstructor = v.CustomValueConstructor
	}
	if !(len(v.Parameters) == 0) {
		u.Parameters = v.Parameters
	}
	if !(len(v.Index) == 0) {
		u.Index = v.Index
	}
	return json.Marshal(&u)
}

func (v *StateRecord) MarshalJSON() ([]byte, error) {
	u := struct {
		Type                   RecordType                `json:"type"`
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
		DataType               FieldType                 `json:"dataType,omitempty"`
		Pointer                bool                      `json:"pointer,omitempty"`
		EmptyIfMissing         bool                      `json:"emptyIfMissing,omitempty"`
		Union                  bool                      `json:"union,omitempty"`
		Collection             CollectionType            `json:"collection,omitempty"`
		Comparator             string                    `json:"comparator,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.RecordBase.Name) == 0) {
		u.Name = v.RecordBase.Name
	}
	if !(len(v.RecordBase.Key) == 0) {
		u.Key = v.RecordBase.Key
	}
	if !(len(v.RecordBase.Description) == 0) {
		u.Description = v.RecordBase.Description
	}
	if !(v.RecordBase.Parent == nil) {
		u.Parent = v.RecordBase.Parent
	}
	if !(!v.RecordBase.Private) {
		u.Private = v.RecordBase.Private
	}
	if !(!v.RecordBase.OmitAccessor) {
		u.OmitAccessor = v.RecordBase.OmitAccessor
	}
	if !(!v.RecordBase.OmitConstructor) {
		u.OmitConstructor = v.RecordBase.OmitConstructor
	}
	if !(!v.RecordBase.CustomValueConstructor) {
		u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	}
	if !(len(v.RecordBase.Parameters) == 0) {
		u.Parameters = v.RecordBase.Parameters
	}
	if !(len(v.RecordBase.Index) == 0) {
		u.Index = v.RecordBase.Index
	}
	if !((v.DataType).Equal(new(FieldType))) {
		u.DataType = v.DataType
	}
	if !(!v.Pointer) {
		u.Pointer = v.Pointer
	}
	if !(!v.EmptyIfMissing) {
		u.EmptyIfMissing = v.EmptyIfMissing
	}
	if !(!v.Union) {
		u.Union = v.Union
	}
	if !(v.Collection == 0) {
		u.Collection = v.Collection
	}
	if !(len(v.Comparator) == 0) {
		u.Comparator = v.Comparator
	}
	return json.Marshal(&u)
}

func (v *ChainRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		Type                   RecordType                `json:"type"`
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
		ChainType              string                    `json:"chainType,omitempty"`
	}{}
	u.Type = v.Type()
	u.Name = v.RecordBase.Name
	u.Key = v.RecordBase.Key
	u.Description = v.RecordBase.Description
	u.Parent = v.RecordBase.Parent
	u.Private = v.RecordBase.Private
	u.OmitAccessor = v.RecordBase.OmitAccessor
	u.OmitConstructor = v.RecordBase.OmitConstructor
	u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	u.Parameters = v.RecordBase.Parameters
	u.Index = v.RecordBase.Index
	u.ChainType = v.ChainType
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.RecordBase.Name = u.Name
	v.RecordBase.Key = u.Key
	v.RecordBase.Description = u.Description
	v.RecordBase.Parent = u.Parent
	v.RecordBase.Private = u.Private
	v.RecordBase.OmitAccessor = u.OmitAccessor
	v.RecordBase.OmitConstructor = u.OmitConstructor
	v.RecordBase.CustomValueConstructor = u.CustomValueConstructor
	v.RecordBase.Parameters = u.Parameters
	v.RecordBase.Index = u.Index
	v.ChainType = u.ChainType
	return nil
}

func (v *EntityRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		Type                   RecordType                              `json:"type"`
		Name                   string                                  `json:"name,omitempty"`
		Key                    string                                  `json:"key,omitempty"`
		Description            string                                  `json:"description,omitempty"`
		Parent                 *EntityRecord                           `json:"parent,omitempty"`
		Private                bool                                    `json:"private,omitempty"`
		OmitAccessor           bool                                    `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                                    `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                                    `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field]               `json:"parameters,omitempty"`
		Index                  string                                  `json:"index,omitempty"`
		Fields                 encoding.JsonList[*Field]               `json:"fields,omitempty"`
		CustomCommit           bool                                    `json:"customCommit,omitempty"`
		CustomResolve          bool                                    `json:"customResolve,omitempty"`
		CustomIsDirty          bool                                    `json:"customIsDirty,omitempty"`
		CustomWalk             bool                                    `json:"customWalk,omitempty"`
		OmitCommit             bool                                    `json:"omitCommit,omitempty"`
		OmitResolve            bool                                    `json:"omitResolve,omitempty"`
		OmitIsDirty            bool                                    `json:"omitIsDirty,omitempty"`
		OmitWalk               bool                                    `json:"omitWalk,omitempty"`
		ValueStore             string                                  `json:"valueStore,omitempty"`
		Root                   bool                                    `json:"root,omitempty"`
		Interface              bool                                    `json:"interface,omitempty"`
		Attributes             *encoding.JsonUnmarshalListWith[Record] `json:"attributes,omitempty"`
	}{}
	u.Type = v.Type()
	u.Name = v.RecordBase.Name
	u.Key = v.RecordBase.Key
	u.Description = v.RecordBase.Description
	u.Parent = v.RecordBase.Parent
	u.Private = v.RecordBase.Private
	u.OmitAccessor = v.RecordBase.OmitAccessor
	u.OmitConstructor = v.RecordBase.OmitConstructor
	u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	u.Parameters = v.RecordBase.Parameters
	u.Index = v.RecordBase.Index
	u.Fields = v.Fields
	u.CustomCommit = v.CustomCommit
	u.CustomResolve = v.CustomResolve
	u.CustomIsDirty = v.CustomIsDirty
	u.CustomWalk = v.CustomWalk
	u.OmitCommit = v.OmitCommit
	u.OmitResolve = v.OmitResolve
	u.OmitIsDirty = v.OmitIsDirty
	u.OmitWalk = v.OmitWalk
	u.ValueStore = v.ValueStore
	u.Root = v.Root
	u.Interface = v.Interface
	u.Attributes = &encoding.JsonUnmarshalListWith[Record]{Value: v.Attributes, Func: UnmarshalRecordJSON}
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.RecordBase.Name = u.Name
	v.RecordBase.Key = u.Key
	v.RecordBase.Description = u.Description
	v.RecordBase.Parent = u.Parent
	v.RecordBase.Private = u.Private
	v.RecordBase.OmitAccessor = u.OmitAccessor
	v.RecordBase.OmitConstructor = u.OmitConstructor
	v.RecordBase.CustomValueConstructor = u.CustomValueConstructor
	v.RecordBase.Parameters = u.Parameters
	v.RecordBase.Index = u.Index
	v.Fields = u.Fields
	v.CustomCommit = u.CustomCommit
	v.CustomResolve = u.CustomResolve
	v.CustomIsDirty = u.CustomIsDirty
	v.CustomWalk = u.CustomWalk
	v.OmitCommit = u.OmitCommit
	v.OmitResolve = u.OmitResolve
	v.OmitIsDirty = u.OmitIsDirty
	v.OmitWalk = u.OmitWalk
	v.ValueStore = u.ValueStore
	v.Root = u.Root
	v.Interface = u.Interface
	if u.Attributes.Value != nil {
		v.Attributes = make([]Record, len(u.Attributes.Value))
		for i, x := range u.Attributes.Value {
			v.Attributes[i] = x
		}
	}
	return nil
}

func (v *IndexRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		Type                   RecordType                `json:"type"`
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
		DataType               FieldType                 `json:"dataType,omitempty"`
		Pointer                bool                      `json:"pointer,omitempty"`
		EmptyIfMissing         bool                      `json:"emptyIfMissing,omitempty"`
		Union                  bool                      `json:"union,omitempty"`
		Collection             CollectionType            `json:"collection,omitempty"`
		Comparator             string                    `json:"comparator,omitempty"`
	}{}
	u.Type = v.Type()
	u.Name = v.RecordBase.Name
	u.Key = v.RecordBase.Key
	u.Description = v.RecordBase.Description
	u.Parent = v.RecordBase.Parent
	u.Private = v.RecordBase.Private
	u.OmitAccessor = v.RecordBase.OmitAccessor
	u.OmitConstructor = v.RecordBase.OmitConstructor
	u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	u.Parameters = v.RecordBase.Parameters
	u.Index = v.RecordBase.Index
	u.DataType = v.DataType
	u.Pointer = v.Pointer
	u.EmptyIfMissing = v.EmptyIfMissing
	u.Union = v.Union
	u.Collection = v.Collection
	u.Comparator = v.Comparator
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.RecordBase.Name = u.Name
	v.RecordBase.Key = u.Key
	v.RecordBase.Description = u.Description
	v.RecordBase.Parent = u.Parent
	v.RecordBase.Private = u.Private
	v.RecordBase.OmitAccessor = u.OmitAccessor
	v.RecordBase.OmitConstructor = u.OmitConstructor
	v.RecordBase.CustomValueConstructor = u.CustomValueConstructor
	v.RecordBase.Parameters = u.Parameters
	v.RecordBase.Index = u.Index
	v.DataType = u.DataType
	v.Pointer = u.Pointer
	v.EmptyIfMissing = u.EmptyIfMissing
	v.Union = u.Union
	v.Collection = u.Collection
	v.Comparator = u.Comparator
	return nil
}

func (v *OtherRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		Type                   RecordType                `json:"type"`
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
		DataType               string                    `json:"dataType,omitempty"`
		Pointer                bool                      `json:"pointer,omitempty"`
		HasChains              bool                      `json:"hasChains,omitempty"`
		Constructor            string                    `json:"constructor,omitempty"`
	}{}
	u.Type = v.Type()
	u.Name = v.RecordBase.Name
	u.Key = v.RecordBase.Key
	u.Description = v.RecordBase.Description
	u.Parent = v.RecordBase.Parent
	u.Private = v.RecordBase.Private
	u.OmitAccessor = v.RecordBase.OmitAccessor
	u.OmitConstructor = v.RecordBase.OmitConstructor
	u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	u.Parameters = v.RecordBase.Parameters
	u.Index = v.RecordBase.Index
	u.DataType = v.DataType
	u.Pointer = v.Pointer
	u.HasChains = v.HasChains
	u.Constructor = v.Constructor
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.RecordBase.Name = u.Name
	v.RecordBase.Key = u.Key
	v.RecordBase.Description = u.Description
	v.RecordBase.Parent = u.Parent
	v.RecordBase.Private = u.Private
	v.RecordBase.OmitAccessor = u.OmitAccessor
	v.RecordBase.OmitConstructor = u.OmitConstructor
	v.RecordBase.CustomValueConstructor = u.CustomValueConstructor
	v.RecordBase.Parameters = u.Parameters
	v.RecordBase.Index = u.Index
	v.DataType = u.DataType
	v.Pointer = u.Pointer
	v.HasChains = u.HasChains
	v.Constructor = u.Constructor
	return nil
}

func (v *RecordBase) UnmarshalJSON(data []byte) error {
	u := struct {
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
	}{}
	u.Name = v.Name
	u.Key = v.Key
	u.Description = v.Description
	u.Parent = v.Parent
	u.Private = v.Private
	u.OmitAccessor = v.OmitAccessor
	u.OmitConstructor = v.OmitConstructor
	u.CustomValueConstructor = v.CustomValueConstructor
	u.Parameters = v.Parameters
	u.Index = v.Index
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Name = u.Name
	v.Key = u.Key
	v.Description = u.Description
	v.Parent = u.Parent
	v.Private = u.Private
	v.OmitAccessor = u.OmitAccessor
	v.OmitConstructor = u.OmitConstructor
	v.CustomValueConstructor = u.CustomValueConstructor
	v.Parameters = u.Parameters
	v.Index = u.Index
	return nil
}

func (v *StateRecord) UnmarshalJSON(data []byte) error {
	u := struct {
		Type                   RecordType                `json:"type"`
		Name                   string                    `json:"name,omitempty"`
		Key                    string                    `json:"key,omitempty"`
		Description            string                    `json:"description,omitempty"`
		Parent                 *EntityRecord             `json:"parent,omitempty"`
		Private                bool                      `json:"private,omitempty"`
		OmitAccessor           bool                      `json:"omitAccessor,omitempty"`
		OmitConstructor        bool                      `json:"omitConstructor,omitempty"`
		CustomValueConstructor bool                      `json:"customValueConstructor,omitempty"`
		Parameters             encoding.JsonList[*Field] `json:"parameters,omitempty"`
		Index                  string                    `json:"index,omitempty"`
		DataType               FieldType                 `json:"dataType,omitempty"`
		Pointer                bool                      `json:"pointer,omitempty"`
		EmptyIfMissing         bool                      `json:"emptyIfMissing,omitempty"`
		Union                  bool                      `json:"union,omitempty"`
		Collection             CollectionType            `json:"collection,omitempty"`
		Comparator             string                    `json:"comparator,omitempty"`
	}{}
	u.Type = v.Type()
	u.Name = v.RecordBase.Name
	u.Key = v.RecordBase.Key
	u.Description = v.RecordBase.Description
	u.Parent = v.RecordBase.Parent
	u.Private = v.RecordBase.Private
	u.OmitAccessor = v.RecordBase.OmitAccessor
	u.OmitConstructor = v.RecordBase.OmitConstructor
	u.CustomValueConstructor = v.RecordBase.CustomValueConstructor
	u.Parameters = v.RecordBase.Parameters
	u.Index = v.RecordBase.Index
	u.DataType = v.DataType
	u.Pointer = v.Pointer
	u.EmptyIfMissing = v.EmptyIfMissing
	u.Union = v.Union
	u.Collection = v.Collection
	u.Comparator = v.Comparator
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.RecordBase.Name = u.Name
	v.RecordBase.Key = u.Key
	v.RecordBase.Description = u.Description
	v.RecordBase.Parent = u.Parent
	v.RecordBase.Private = u.Private
	v.RecordBase.OmitAccessor = u.OmitAccessor
	v.RecordBase.OmitConstructor = u.OmitConstructor
	v.RecordBase.CustomValueConstructor = u.CustomValueConstructor
	v.RecordBase.Parameters = u.Parameters
	v.RecordBase.Index = u.Index
	v.DataType = u.DataType
	v.Pointer = u.Pointer
	v.EmptyIfMissing = u.EmptyIfMissing
	v.Union = u.Union
	v.Collection = u.Collection
	v.Comparator = u.Comparator
	return nil
}
