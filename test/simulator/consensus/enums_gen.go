// Copyright 2024 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package consensus

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	"strings"
)

// messageTypeStartBlock .
const messageTypeStartBlock messageType = 16

// messageTypeProposeLeader .
const messageTypeProposeLeader messageType = 17

// messageTypeProposeBlock .
const messageTypeProposeBlock messageType = 18

// messageTypeAcceptBlockProposal .
const messageTypeAcceptBlockProposal messageType = 19

// messageTypeFinalizedBlock .
const messageTypeFinalizedBlock messageType = 20

// messageTypeCommittedBlock .
const messageTypeCommittedBlock messageType = 21

// messageTypeExecutedBlock .
const messageTypeExecutedBlock messageType = 22

// messageTypeSubmitEnvelope .
const messageTypeSubmitEnvelope messageType = 32

// messageTypeAcceptedSubmission .
const messageTypeAcceptedSubmission messageType = 33

// messageTypeEnvelopeSubmitted .
const messageTypeEnvelopeSubmitted messageType = 34

// GetEnumValue returns the value of the message Type
func (v messageType) GetEnumValue() uint64 { return uint64(v) }

// SetEnumValue sets the value. SetEnumValue returns false if the value is invalid.
func (v *messageType) SetEnumValue(id uint64) bool {
	u := messageType(id)
	switch u {
	case messageTypeStartBlock, messageTypeProposeLeader, messageTypeProposeBlock, messageTypeAcceptBlockProposal, messageTypeFinalizedBlock, messageTypeCommittedBlock, messageTypeExecutedBlock, messageTypeSubmitEnvelope, messageTypeAcceptedSubmission, messageTypeEnvelopeSubmitted:
		*v = u
		return true
	}
	return false
}

// String returns the name of the message Type.
func (v messageType) String() string {
	switch v {
	case messageTypeStartBlock:
		return "startBlock"
	case messageTypeProposeLeader:
		return "proposeLeader"
	case messageTypeProposeBlock:
		return "proposeBlock"
	case messageTypeAcceptBlockProposal:
		return "acceptBlockProposal"
	case messageTypeFinalizedBlock:
		return "finalizedBlock"
	case messageTypeCommittedBlock:
		return "committedBlock"
	case messageTypeExecutedBlock:
		return "executedBlock"
	case messageTypeSubmitEnvelope:
		return "submitEnvelope"
	case messageTypeAcceptedSubmission:
		return "acceptedSubmission"
	case messageTypeEnvelopeSubmitted:
		return "envelopeSubmitted"
	}
	return fmt.Sprintf("messageType:%d", v)
}

// messageTypeByName returns the named message Type.
func messageTypeByName(name string) (messageType, bool) {
	switch strings.ToLower(name) {
	case "startblock":
		return messageTypeStartBlock, true
	case "proposeleader":
		return messageTypeProposeLeader, true
	case "proposeblock":
		return messageTypeProposeBlock, true
	case "acceptblockproposal":
		return messageTypeAcceptBlockProposal, true
	case "finalizedblock":
		return messageTypeFinalizedBlock, true
	case "committedblock":
		return messageTypeCommittedBlock, true
	case "executedblock":
		return messageTypeExecutedBlock, true
	case "submitenvelope":
		return messageTypeSubmitEnvelope, true
	case "acceptedsubmission":
		return messageTypeAcceptedSubmission, true
	case "envelopesubmitted":
		return messageTypeEnvelopeSubmitted, true
	}
	return 0, false
}

// MarshalJSON marshals the message Type to JSON as a string.
func (v messageType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.String())
}

// UnmarshalJSON unmarshals the message Type from JSON as a string.
func (v *messageType) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ok bool
	*v, ok = messageTypeByName(s)
	if !ok || strings.ContainsRune(v.String(), ':') {
		return fmt.Errorf("invalid message Type %q", s)
	}
	return nil
}
