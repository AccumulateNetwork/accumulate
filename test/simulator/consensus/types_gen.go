// Copyright 2022 The Accumulate Authors
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package consensus

// GENERATED BY go run ./tools/cmd/gen-types. DO NOT EDIT.

//lint:file-ignore S1001,S1002,S1008,SA4013 generated code

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"time"

	"gitlab.com/accumulatenetwork/accumulate/pkg/types/encoding"
	"gitlab.com/accumulatenetwork/accumulate/pkg/types/messaging"
	"gitlab.com/accumulatenetwork/accumulate/protocol"
)

type BlockProposal struct {
	fieldsSet []bool
	LeaderProposal
	Index     uint64                `json:"index,omitempty" form:"index" query:"index" validate:"required"`
	Time      time.Time             `json:"time,omitempty" form:"time" query:"time" validate:"required"`
	Envelopes []*messaging.Envelope `json:"envelopes,omitempty" form:"envelopes" query:"envelopes" validate:"required"`
	extraData []byte
}

type BlockResults struct {
	fieldsSet        []bool
	MessageResults   []*protocol.TransactionStatus `json:"messageResults,omitempty" form:"messageResults" query:"messageResults" validate:"required"`
	ValidatorUpdates []*ValidatorUpdate            `json:"validatorUpdates,omitempty" form:"validatorUpdates" query:"validatorUpdates" validate:"required"`
	extraData        []byte
}

type CommitResult struct {
	fieldsSet []bool
	Hash      [32]byte `json:"hash,omitempty" form:"hash" query:"hash" validate:"required"`
	extraData []byte
}

type EnvelopeSubmitted struct {
	fieldsSet []bool
	Results   []*protocol.TransactionStatus `json:"results,omitempty" form:"results" query:"results" validate:"required"`
	extraData []byte
}

type ExecutedBlock struct {
	fieldsSet []bool
	Network   string   `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Node      [32]byte `json:"node,omitempty" form:"node" query:"node" validate:"required"`
	extraData []byte
}

type LeaderProposal struct {
	fieldsSet []bool
	Leader    [32]byte `json:"leader,omitempty" form:"leader" query:"leader" validate:"required"`
	extraData []byte
}

type StartBlock struct {
	fieldsSet []bool
	extraData []byte
}

type SubmitEnvelope struct {
	fieldsSet []bool
	Network   string              `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	Envelope  *messaging.Envelope `json:"envelope,omitempty" form:"envelope" query:"envelope" validate:"required"`
	Pretend   bool                `json:"pretend,omitempty" form:"pretend" query:"pretend" validate:"required"`
	extraData []byte
}

type ValidatorUpdate struct {
	fieldsSet []bool
	Type      protocol.SignatureType `json:"type,omitempty" form:"type" query:"type" validate:"required"`
	PublicKey []byte                 `json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Power     int64                  `json:"power,omitempty" form:"power" query:"power" validate:"required"`
	extraData []byte
}

type acceptBlockProposal struct {
	fieldsSet []bool
	baseNodeMessage
	p         proposeBlock `json:"p,omitempty" form:"p" query:"p" validate:"required"`
	extraData []byte
}

type acceptedSubmission struct {
	fieldsSet []bool
	baseNodeMessage
	result    EnvelopeSubmitted   `json:"result,omitempty" form:"result" query:"result" validate:"required"`
	env       *messaging.Envelope `json:"env,omitempty" form:"env" query:"env" validate:"required"`
	extraData []byte
}

type baseNodeMessage struct {
	fieldsSet  []bool
	PubKeyHash [32]byte `json:"pubKeyHash,omitempty" form:"pubKeyHash" query:"pubKeyHash" validate:"required"`
	Network    string   `json:"network,omitempty" form:"network" query:"network" validate:"required"`
	extraData  []byte
}

type committedBlock struct {
	fieldsSet []bool
	baseNodeMessage
	results   CommitResult `json:"results,omitempty" form:"results" query:"results" validate:"required"`
	extraData []byte
}

type finalizedBlock struct {
	fieldsSet []bool
	baseNodeMessage
	results   BlockResults `json:"results,omitempty" form:"results" query:"results" validate:"required"`
	extraData []byte
}

type proposeBlock struct {
	fieldsSet []bool
	baseNodeMessage
	BlockProposal
	extraData []byte
}

type proposeLeader struct {
	fieldsSet []bool
	baseNodeMessage
	LeaderProposal
	extraData []byte
}

func (*EnvelopeSubmitted) Type() messageType { return messageTypeEnvelopeSubmitted }

func (*ExecutedBlock) Type() messageType { return messageTypeExecutedBlock }

func (*StartBlock) Type() messageType { return messageTypeStartBlock }

func (*SubmitEnvelope) Type() messageType { return messageTypeSubmitEnvelope }

func (*acceptBlockProposal) Type() messageType { return messageTypeAcceptBlockProposal }

func (*acceptedSubmission) Type() messageType { return messageTypeAcceptedSubmission }

func (*committedBlock) Type() messageType { return messageTypeCommittedBlock }

func (*finalizedBlock) Type() messageType { return messageTypeFinalizedBlock }

func (*proposeBlock) Type() messageType { return messageTypeProposeBlock }

func (*proposeLeader) Type() messageType { return messageTypeProposeLeader }

func (v *BlockProposal) Copy() *BlockProposal {
	u := new(BlockProposal)

	u.LeaderProposal = *v.LeaderProposal.Copy()
	u.Index = v.Index
	u.Time = v.Time
	u.Envelopes = make([]*messaging.Envelope, len(v.Envelopes))
	for i, v := range v.Envelopes {
		v := v
		if v != nil {
			u.Envelopes[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockProposal) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockResults) Copy() *BlockResults {
	u := new(BlockResults)

	u.MessageResults = make([]*protocol.TransactionStatus, len(v.MessageResults))
	for i, v := range v.MessageResults {
		v := v
		if v != nil {
			u.MessageResults[i] = (v).Copy()
		}
	}
	u.ValidatorUpdates = make([]*ValidatorUpdate, len(v.ValidatorUpdates))
	for i, v := range v.ValidatorUpdates {
		v := v
		if v != nil {
			u.ValidatorUpdates[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *BlockResults) CopyAsInterface() interface{} { return v.Copy() }

func (v *CommitResult) Copy() *CommitResult {
	u := new(CommitResult)

	u.Hash = v.Hash
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *CommitResult) CopyAsInterface() interface{} { return v.Copy() }

func (v *EnvelopeSubmitted) Copy() *EnvelopeSubmitted {
	u := new(EnvelopeSubmitted)

	u.Results = make([]*protocol.TransactionStatus, len(v.Results))
	for i, v := range v.Results {
		v := v
		if v != nil {
			u.Results[i] = (v).Copy()
		}
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *EnvelopeSubmitted) CopyAsInterface() interface{} { return v.Copy() }

func (v *ExecutedBlock) Copy() *ExecutedBlock {
	u := new(ExecutedBlock)

	u.Network = v.Network
	u.Node = v.Node
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ExecutedBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *LeaderProposal) Copy() *LeaderProposal {
	u := new(LeaderProposal)

	u.Leader = v.Leader
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *LeaderProposal) CopyAsInterface() interface{} { return v.Copy() }

func (v *StartBlock) Copy() *StartBlock {
	u := new(StartBlock)

	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *StartBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *SubmitEnvelope) Copy() *SubmitEnvelope {
	u := new(SubmitEnvelope)

	u.Network = v.Network
	if v.Envelope != nil {
		u.Envelope = (v.Envelope).Copy()
	}
	u.Pretend = v.Pretend
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *SubmitEnvelope) CopyAsInterface() interface{} { return v.Copy() }

func (v *ValidatorUpdate) Copy() *ValidatorUpdate {
	u := new(ValidatorUpdate)

	u.Type = v.Type
	u.PublicKey = encoding.BytesCopy(v.PublicKey)
	u.Power = v.Power
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *ValidatorUpdate) CopyAsInterface() interface{} { return v.Copy() }

func (v *acceptBlockProposal) Copy() *acceptBlockProposal {
	u := new(acceptBlockProposal)

	u.baseNodeMessage = *v.baseNodeMessage.Copy()
	u.p = *(&v.p).Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *acceptBlockProposal) CopyAsInterface() interface{} { return v.Copy() }

func (v *acceptedSubmission) Copy() *acceptedSubmission {
	u := new(acceptedSubmission)

	u.baseNodeMessage = *v.baseNodeMessage.Copy()
	u.result = *(&v.result).Copy()
	if v.env != nil {
		u.env = (v.env).Copy()
	}
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *acceptedSubmission) CopyAsInterface() interface{} { return v.Copy() }

func (v *baseNodeMessage) Copy() *baseNodeMessage {
	u := new(baseNodeMessage)

	u.PubKeyHash = v.PubKeyHash
	u.Network = v.Network
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *baseNodeMessage) CopyAsInterface() interface{} { return v.Copy() }

func (v *committedBlock) Copy() *committedBlock {
	u := new(committedBlock)

	u.baseNodeMessage = *v.baseNodeMessage.Copy()
	u.results = *(&v.results).Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *committedBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *finalizedBlock) Copy() *finalizedBlock {
	u := new(finalizedBlock)

	u.baseNodeMessage = *v.baseNodeMessage.Copy()
	u.results = *(&v.results).Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *finalizedBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *proposeBlock) Copy() *proposeBlock {
	u := new(proposeBlock)

	u.baseNodeMessage = *v.baseNodeMessage.Copy()
	u.BlockProposal = *v.BlockProposal.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *proposeBlock) CopyAsInterface() interface{} { return v.Copy() }

func (v *proposeLeader) Copy() *proposeLeader {
	u := new(proposeLeader)

	u.baseNodeMessage = *v.baseNodeMessage.Copy()
	u.LeaderProposal = *v.LeaderProposal.Copy()
	if len(v.extraData) > 0 {
		u.extraData = make([]byte, len(v.extraData))
		copy(u.extraData, v.extraData)
	}

	return u
}

func (v *proposeLeader) CopyAsInterface() interface{} { return v.Copy() }

func (v *BlockProposal) Equal(u *BlockProposal) bool {
	if !v.LeaderProposal.Equal(&u.LeaderProposal) {
		return false
	}
	if !(v.Index == u.Index) {
		return false
	}
	if !((v.Time).Equal(u.Time)) {
		return false
	}
	if len(v.Envelopes) != len(u.Envelopes) {
		return false
	}
	for i := range v.Envelopes {
		if !((v.Envelopes[i]).Equal(u.Envelopes[i])) {
			return false
		}
	}

	return true
}

func (v *BlockResults) Equal(u *BlockResults) bool {
	if len(v.MessageResults) != len(u.MessageResults) {
		return false
	}
	for i := range v.MessageResults {
		if !((v.MessageResults[i]).Equal(u.MessageResults[i])) {
			return false
		}
	}
	if len(v.ValidatorUpdates) != len(u.ValidatorUpdates) {
		return false
	}
	for i := range v.ValidatorUpdates {
		if !((v.ValidatorUpdates[i]).Equal(u.ValidatorUpdates[i])) {
			return false
		}
	}

	return true
}

func (v *CommitResult) Equal(u *CommitResult) bool {
	if !(v.Hash == u.Hash) {
		return false
	}

	return true
}

func (v *EnvelopeSubmitted) Equal(u *EnvelopeSubmitted) bool {
	if len(v.Results) != len(u.Results) {
		return false
	}
	for i := range v.Results {
		if !((v.Results[i]).Equal(u.Results[i])) {
			return false
		}
	}

	return true
}

func (v *ExecutedBlock) Equal(u *ExecutedBlock) bool {
	if !(v.Network == u.Network) {
		return false
	}
	if !(v.Node == u.Node) {
		return false
	}

	return true
}

func (v *LeaderProposal) Equal(u *LeaderProposal) bool {
	if !(v.Leader == u.Leader) {
		return false
	}

	return true
}

func (v *StartBlock) Equal(u *StartBlock) bool {

	return true
}

func (v *SubmitEnvelope) Equal(u *SubmitEnvelope) bool {
	if !(v.Network == u.Network) {
		return false
	}
	switch {
	case v.Envelope == u.Envelope:
		// equal
	case v.Envelope == nil || u.Envelope == nil:
		return false
	case !((v.Envelope).Equal(u.Envelope)):
		return false
	}
	if !(v.Pretend == u.Pretend) {
		return false
	}

	return true
}

func (v *ValidatorUpdate) Equal(u *ValidatorUpdate) bool {
	if !(v.Type == u.Type) {
		return false
	}
	if !(bytes.Equal(v.PublicKey, u.PublicKey)) {
		return false
	}
	if !(v.Power == u.Power) {
		return false
	}

	return true
}

func (v *acceptBlockProposal) Equal(u *acceptBlockProposal) bool {
	if !v.baseNodeMessage.Equal(&u.baseNodeMessage) {
		return false
	}
	if !((&v.p).Equal(&u.p)) {
		return false
	}

	return true
}

func (v *acceptedSubmission) Equal(u *acceptedSubmission) bool {
	if !v.baseNodeMessage.Equal(&u.baseNodeMessage) {
		return false
	}
	if !((&v.result).Equal(&u.result)) {
		return false
	}
	switch {
	case v.env == u.env:
		// equal
	case v.env == nil || u.env == nil:
		return false
	case !((v.env).Equal(u.env)):
		return false
	}

	return true
}

func (v *baseNodeMessage) Equal(u *baseNodeMessage) bool {
	if !(v.PubKeyHash == u.PubKeyHash) {
		return false
	}
	if !(v.Network == u.Network) {
		return false
	}

	return true
}

func (v *committedBlock) Equal(u *committedBlock) bool {
	if !v.baseNodeMessage.Equal(&u.baseNodeMessage) {
		return false
	}
	if !((&v.results).Equal(&u.results)) {
		return false
	}

	return true
}

func (v *finalizedBlock) Equal(u *finalizedBlock) bool {
	if !v.baseNodeMessage.Equal(&u.baseNodeMessage) {
		return false
	}
	if !((&v.results).Equal(&u.results)) {
		return false
	}

	return true
}

func (v *proposeBlock) Equal(u *proposeBlock) bool {
	if !v.baseNodeMessage.Equal(&u.baseNodeMessage) {
		return false
	}
	if !v.BlockProposal.Equal(&u.BlockProposal) {
		return false
	}

	return true
}

func (v *proposeLeader) Equal(u *proposeLeader) bool {
	if !v.baseNodeMessage.Equal(&u.baseNodeMessage) {
		return false
	}
	if !v.LeaderProposal.Equal(&u.LeaderProposal) {
		return false
	}

	return true
}

var fieldNames_BlockProposal = []string{
	1: "LeaderProposal",
	2: "Index",
	3: "Time",
	4: "Envelopes",
}

func (v *BlockProposal) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteValue(1, v.LeaderProposal.MarshalBinary)
	if !(v.Index == 0) {
		writer.WriteUint(2, v.Index)
	}
	if !(v.Time == (time.Time{})) {
		writer.WriteTime(3, v.Time)
	}
	if !(len(v.Envelopes) == 0) {
		for _, v := range v.Envelopes {
			writer.WriteValue(4, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_BlockProposal)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockProposal) IsValid() error {
	var errs []string

	if err := v.LeaderProposal.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Index is missing")
	} else if v.Index == 0 {
		errs = append(errs, "field Index is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Time is missing")
	} else if v.Time == (time.Time{}) {
		errs = append(errs, "field Time is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Envelopes is missing")
	} else if len(v.Envelopes) == 0 {
		errs = append(errs, "field Envelopes is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_BlockResults = []string{
	1: "MessageResults",
	2: "ValidatorUpdates",
}

func (v *BlockResults) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(len(v.MessageResults) == 0) {
		for _, v := range v.MessageResults {
			writer.WriteValue(1, v.MarshalBinary)
		}
	}
	if !(len(v.ValidatorUpdates) == 0) {
		for _, v := range v.ValidatorUpdates {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_BlockResults)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *BlockResults) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field MessageResults is missing")
	} else if len(v.MessageResults) == 0 {
		errs = append(errs, "field MessageResults is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field ValidatorUpdates is missing")
	} else if len(v.ValidatorUpdates) == 0 {
		errs = append(errs, "field ValidatorUpdates is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_CommitResult = []string{
	1: "Hash",
}

func (v *CommitResult) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Hash == ([32]byte{})) {
		writer.WriteHash(1, &v.Hash)
	}

	_, _, err := writer.Reset(fieldNames_CommitResult)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *CommitResult) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Hash is missing")
	} else if v.Hash == ([32]byte{}) {
		errs = append(errs, "field Hash is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_EnvelopeSubmitted = []string{
	1: "Type",
	2: "Results",
}

func (v *EnvelopeSubmitted) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Results) == 0) {
		for _, v := range v.Results {
			writer.WriteValue(2, v.MarshalBinary)
		}
	}

	_, _, err := writer.Reset(fieldNames_EnvelopeSubmitted)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *EnvelopeSubmitted) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Results is missing")
	} else if len(v.Results) == 0 {
		errs = append(errs, "field Results is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ExecutedBlock = []string{
	1: "Type",
	2: "Network",
	3: "Node",
}

func (v *ExecutedBlock) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Network) == 0) {
		writer.WriteString(2, v.Network)
	}
	if !(v.Node == ([32]byte{})) {
		writer.WriteHash(3, &v.Node)
	}

	_, _, err := writer.Reset(fieldNames_ExecutedBlock)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ExecutedBlock) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Network is missing")
	} else if len(v.Network) == 0 {
		errs = append(errs, "field Network is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Node is missing")
	} else if v.Node == ([32]byte{}) {
		errs = append(errs, "field Node is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_LeaderProposal = []string{
	1: "Leader",
}

func (v *LeaderProposal) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Leader == ([32]byte{})) {
		writer.WriteHash(1, &v.Leader)
	}

	_, _, err := writer.Reset(fieldNames_LeaderProposal)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *LeaderProposal) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Leader is missing")
	} else if v.Leader == ([32]byte{}) {
		errs = append(errs, "field Leader is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_StartBlock = []string{
	1: "Type",
}

func (v *StartBlock) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())

	_, _, err := writer.Reset(fieldNames_StartBlock)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *StartBlock) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_SubmitEnvelope = []string{
	1: "Type",
	2: "Network",
	3: "Envelope",
	4: "Pretend",
}

func (v *SubmitEnvelope) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	if !(len(v.Network) == 0) {
		writer.WriteString(2, v.Network)
	}
	if !(v.Envelope == nil) {
		writer.WriteValue(3, v.Envelope.MarshalBinary)
	}
	if !(!v.Pretend) {
		writer.WriteBool(4, v.Pretend)
	}

	_, _, err := writer.Reset(fieldNames_SubmitEnvelope)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *SubmitEnvelope) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Network is missing")
	} else if len(v.Network) == 0 {
		errs = append(errs, "field Network is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Envelope is missing")
	} else if v.Envelope == nil {
		errs = append(errs, "field Envelope is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field Pretend is missing")
	} else if !v.Pretend {
		errs = append(errs, "field Pretend is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_ValidatorUpdate = []string{
	1: "Type",
	2: "PublicKey",
	3: "Power",
}

func (v *ValidatorUpdate) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.Type == 0) {
		writer.WriteEnum(1, v.Type)
	}
	if !(len(v.PublicKey) == 0) {
		writer.WriteBytes(2, v.PublicKey)
	}
	if !(v.Power == 0) {
		writer.WriteInt(3, v.Power)
	}

	_, _, err := writer.Reset(fieldNames_ValidatorUpdate)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *ValidatorUpdate) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	} else if v.Type == 0 {
		errs = append(errs, "field Type is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field PublicKey is missing")
	} else if len(v.PublicKey) == 0 {
		errs = append(errs, "field PublicKey is not set")
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field Power is missing")
	} else if v.Power == 0 {
		errs = append(errs, "field Power is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_acceptBlockProposal = []string{
	1: "Type",
	2: "baseNodeMessage",
	3: "p",
}

func (v *acceptBlockProposal) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.baseNodeMessage.MarshalBinary)
	if !((v.p).Equal(new(proposeBlock))) {
		writer.WriteValue(3, v.p.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_acceptBlockProposal)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *acceptBlockProposal) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.baseNodeMessage.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field p is missing")
	} else if (v.p).Equal(new(proposeBlock)) {
		errs = append(errs, "field p is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_acceptedSubmission = []string{
	1: "Type",
	2: "baseNodeMessage",
	3: "result",
	4: "env",
}

func (v *acceptedSubmission) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.baseNodeMessage.MarshalBinary)
	if !((v.result).Equal(new(EnvelopeSubmitted))) {
		writer.WriteValue(3, v.result.MarshalBinary)
	}
	if !(v.env == nil) {
		writer.WriteValue(4, v.env.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_acceptedSubmission)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *acceptedSubmission) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.baseNodeMessage.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field result is missing")
	} else if (v.result).Equal(new(EnvelopeSubmitted)) {
		errs = append(errs, "field result is not set")
	}
	if len(v.fieldsSet) > 3 && !v.fieldsSet[3] {
		errs = append(errs, "field env is missing")
	} else if v.env == nil {
		errs = append(errs, "field env is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_baseNodeMessage = []string{
	1: "PubKeyHash",
	2: "Network",
}

func (v *baseNodeMessage) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	if !(v.PubKeyHash == ([32]byte{})) {
		writer.WriteHash(1, &v.PubKeyHash)
	}
	if !(len(v.Network) == 0) {
		writer.WriteString(2, v.Network)
	}

	_, _, err := writer.Reset(fieldNames_baseNodeMessage)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *baseNodeMessage) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field PubKeyHash is missing")
	} else if v.PubKeyHash == ([32]byte{}) {
		errs = append(errs, "field PubKeyHash is not set")
	}
	if len(v.fieldsSet) > 1 && !v.fieldsSet[1] {
		errs = append(errs, "field Network is missing")
	} else if len(v.Network) == 0 {
		errs = append(errs, "field Network is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_committedBlock = []string{
	1: "Type",
	2: "baseNodeMessage",
	3: "results",
}

func (v *committedBlock) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.baseNodeMessage.MarshalBinary)
	if !((v.results).Equal(new(CommitResult))) {
		writer.WriteValue(3, v.results.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_committedBlock)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *committedBlock) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.baseNodeMessage.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field results is missing")
	} else if (v.results).Equal(new(CommitResult)) {
		errs = append(errs, "field results is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_finalizedBlock = []string{
	1: "Type",
	2: "baseNodeMessage",
	3: "results",
}

func (v *finalizedBlock) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.baseNodeMessage.MarshalBinary)
	if !((v.results).Equal(new(BlockResults))) {
		writer.WriteValue(3, v.results.MarshalBinary)
	}

	_, _, err := writer.Reset(fieldNames_finalizedBlock)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *finalizedBlock) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.baseNodeMessage.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if len(v.fieldsSet) > 2 && !v.fieldsSet[2] {
		errs = append(errs, "field results is missing")
	} else if (v.results).Equal(new(BlockResults)) {
		errs = append(errs, "field results is not set")
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_proposeBlock = []string{
	1: "Type",
	2: "baseNodeMessage",
	3: "BlockProposal",
}

func (v *proposeBlock) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.baseNodeMessage.MarshalBinary)
	writer.WriteValue(3, v.BlockProposal.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_proposeBlock)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *proposeBlock) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.baseNodeMessage.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if err := v.BlockProposal.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

var fieldNames_proposeLeader = []string{
	1: "Type",
	2: "baseNodeMessage",
	3: "LeaderProposal",
}

func (v *proposeLeader) MarshalBinary() ([]byte, error) {
	if v == nil {
		return []byte{encoding.EmptyObject}, nil
	}

	buffer := new(bytes.Buffer)
	writer := encoding.NewWriter(buffer)

	writer.WriteEnum(1, v.Type())
	writer.WriteValue(2, v.baseNodeMessage.MarshalBinary)
	writer.WriteValue(3, v.LeaderProposal.MarshalBinary)

	_, _, err := writer.Reset(fieldNames_proposeLeader)
	if err != nil {
		return nil, encoding.Error{E: err}
	}
	buffer.Write(v.extraData)
	return buffer.Bytes(), nil
}

func (v *proposeLeader) IsValid() error {
	var errs []string

	if len(v.fieldsSet) > 0 && !v.fieldsSet[0] {
		errs = append(errs, "field Type is missing")
	}
	if err := v.baseNodeMessage.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}
	if err := v.LeaderProposal.IsValid(); err != nil {
		errs = append(errs, err.Error())
	}

	switch len(errs) {
	case 0:
		return nil
	case 1:
		return errors.New(errs[0])
	default:
		return errors.New(strings.Join(errs, "; "))
	}
}

func (v *BlockProposal) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockProposal) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	reader.ReadValue(1, v.LeaderProposal.UnmarshalBinaryFrom)
	if x, ok := reader.ReadUint(2); ok {
		v.Index = x
	}
	if x, ok := reader.ReadTime(3); ok {
		v.Time = x
	}
	for {
		if x := new(messaging.Envelope); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
			v.Envelopes = append(v.Envelopes, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_BlockProposal)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *BlockResults) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *BlockResults) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	for {
		if x := new(protocol.TransactionStatus); reader.ReadValue(1, x.UnmarshalBinaryFrom) {
			v.MessageResults = append(v.MessageResults, x)
		} else {
			break
		}
	}
	for {
		if x := new(ValidatorUpdate); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.ValidatorUpdates = append(v.ValidatorUpdates, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_BlockResults)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *CommitResult) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *CommitResult) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.Hash = *x
	}

	seen, err := reader.Reset(fieldNames_CommitResult)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *EnvelopeSubmitted) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *EnvelopeSubmitted) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *EnvelopeSubmitted) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	for {
		if x := new(protocol.TransactionStatus); reader.ReadValue(2, x.UnmarshalBinaryFrom) {
			v.Results = append(v.Results, x)
		} else {
			break
		}
	}

	seen, err := reader.Reset(fieldNames_EnvelopeSubmitted)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ExecutedBlock) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ExecutedBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *ExecutedBlock) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadString(2); ok {
		v.Network = x
	}
	if x, ok := reader.ReadHash(3); ok {
		v.Node = *x
	}

	seen, err := reader.Reset(fieldNames_ExecutedBlock)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *LeaderProposal) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *LeaderProposal) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.Leader = *x
	}

	seen, err := reader.Reset(fieldNames_LeaderProposal)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *StartBlock) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *StartBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *StartBlock) UnmarshalFieldsFrom(reader *encoding.Reader) error {

	seen, err := reader.Reset(fieldNames_StartBlock)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *SubmitEnvelope) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *SubmitEnvelope) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *SubmitEnvelope) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	if x, ok := reader.ReadString(2); ok {
		v.Network = x
	}
	if x := new(messaging.Envelope); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.Envelope = x
	}
	if x, ok := reader.ReadBool(4); ok {
		v.Pretend = x
	}

	seen, err := reader.Reset(fieldNames_SubmitEnvelope)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *ValidatorUpdate) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *ValidatorUpdate) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x := new(protocol.SignatureType); reader.ReadEnum(1, x) {
		v.Type = *x
	}
	if x, ok := reader.ReadBytes(2); ok {
		v.PublicKey = x
	}
	if x, ok := reader.ReadInt(3); ok {
		v.Power = x
	}

	seen, err := reader.Reset(fieldNames_ValidatorUpdate)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *acceptBlockProposal) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *acceptBlockProposal) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *acceptBlockProposal) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.baseNodeMessage.UnmarshalBinaryFrom)
	if x := new(proposeBlock); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.p = *x
	}

	seen, err := reader.Reset(fieldNames_acceptBlockProposal)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *acceptedSubmission) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *acceptedSubmission) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *acceptedSubmission) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.baseNodeMessage.UnmarshalBinaryFrom)
	if x := new(EnvelopeSubmitted); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.result = *x
	}
	if x := new(messaging.Envelope); reader.ReadValue(4, x.UnmarshalBinaryFrom) {
		v.env = x
	}

	seen, err := reader.Reset(fieldNames_acceptedSubmission)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *baseNodeMessage) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *baseNodeMessage) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	if x, ok := reader.ReadHash(1); ok {
		v.PubKeyHash = *x
	}
	if x, ok := reader.ReadString(2); ok {
		v.Network = x
	}

	seen, err := reader.Reset(fieldNames_baseNodeMessage)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *committedBlock) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *committedBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *committedBlock) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.baseNodeMessage.UnmarshalBinaryFrom)
	if x := new(CommitResult); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.results = *x
	}

	seen, err := reader.Reset(fieldNames_committedBlock)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *finalizedBlock) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *finalizedBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *finalizedBlock) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.baseNodeMessage.UnmarshalBinaryFrom)
	if x := new(BlockResults); reader.ReadValue(3, x.UnmarshalBinaryFrom) {
		v.results = *x
	}

	seen, err := reader.Reset(fieldNames_finalizedBlock)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *proposeBlock) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *proposeBlock) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *proposeBlock) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.baseNodeMessage.UnmarshalBinaryFrom)
	reader.ReadValue(3, v.BlockProposal.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_proposeBlock)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func (v *proposeLeader) UnmarshalBinary(data []byte) error {
	return v.UnmarshalBinaryFrom(bytes.NewReader(data))
}

func (v *proposeLeader) UnmarshalBinaryFrom(rd io.Reader) error {
	reader := encoding.NewReader(rd)

	var vType messageType
	if x := new(messageType); reader.ReadEnum(1, x) {
		vType = *x
	}
	if !(v.Type() == vType) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), vType)
	}

	return v.UnmarshalFieldsFrom(reader)
}

func (v *proposeLeader) UnmarshalFieldsFrom(reader *encoding.Reader) error {
	reader.ReadValue(2, v.baseNodeMessage.UnmarshalBinaryFrom)
	reader.ReadValue(3, v.LeaderProposal.UnmarshalBinaryFrom)

	seen, err := reader.Reset(fieldNames_proposeLeader)
	if err != nil {
		return encoding.Error{E: err}
	}
	v.fieldsSet = seen
	v.extraData, err = reader.ReadAll()
	if err != nil {
		return encoding.Error{E: err}
	}
	return nil
}

func init() {

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("leader", "bytes32"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("time", "string"),
		encoding.NewTypeField("envelopes", "messaging.Envelope[]"),
	}, "BlockProposal", "blockProposal")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("messageResults", "protocol.TransactionStatus[]"),
		encoding.NewTypeField("validatorUpdates", "ValidatorUpdate[]"),
	}, "BlockResults", "blockResults")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("hash", "bytes32"),
	}, "CommitResult", "commitResult")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("results", "protocol.TransactionStatus[]"),
	}, "EnvelopeSubmitted", "envelopeSubmitted")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("node", "bytes32"),
	}, "ExecutedBlock", "executedBlock")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("leader", "bytes32"),
	}, "LeaderProposal", "leaderProposal")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
	}, "StartBlock", "startBlock")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("envelope", "messaging.Envelope"),
		encoding.NewTypeField("pretend", "bool"),
	}, "SubmitEnvelope", "submitEnvelope")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("publicKey", "bytes"),
		encoding.NewTypeField("power", "int64"),
	}, "ValidatorUpdate", "validatorUpdate")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("pubKeyHash", "bytes32"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("p", "proposeBlock"),
	}, "acceptBlockProposal", "acceptBlockProposal")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("pubKeyHash", "bytes32"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("result", "EnvelopeSubmitted"),
		encoding.NewTypeField("env", "messaging.Envelope"),
	}, "acceptedSubmission", "acceptedSubmission")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("pubKeyHash", "bytes32"),
		encoding.NewTypeField("network", "string"),
	}, "baseNodeMessage", "baseNodeMessage")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("pubKeyHash", "bytes32"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("results", "CommitResult"),
	}, "committedBlock", "committedBlock")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("pubKeyHash", "bytes32"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("results", "BlockResults"),
	}, "finalizedBlock", "finalizedBlock")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("pubKeyHash", "bytes32"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("leaderProposal", "LeaderProposal"),
		encoding.NewTypeField("index", "uint64"),
		encoding.NewTypeField("time", "string"),
		encoding.NewTypeField("envelopes", "messaging.Envelope[]"),
	}, "proposeBlock", "proposeBlock")

	encoding.RegisterTypeDefinition(&[]*encoding.TypeField{
		encoding.NewTypeField("type", "string"),
		encoding.NewTypeField("pubKeyHash", "bytes32"),
		encoding.NewTypeField("network", "string"),
		encoding.NewTypeField("leader", "bytes32"),
	}, "proposeLeader", "proposeLeader")

}

func (v *BlockProposal) MarshalJSON() ([]byte, error) {
	u := struct {
		Leader    *string                                `json:"leader,omitempty"`
		Index     uint64                                 `json:"index,omitempty"`
		Time      time.Time                              `json:"time,omitempty"`
		Envelopes encoding.JsonList[*messaging.Envelope] `json:"envelopes,omitempty"`
		ExtraData *string                                `json:"$epilogue,omitempty"`
	}{}
	if !(v.LeaderProposal.Leader == ([32]byte{})) {
		u.Leader = encoding.ChainToJSON(&v.LeaderProposal.Leader)
	}
	if !(v.Index == 0) {
		u.Index = v.Index
	}
	if !(v.Time == (time.Time{})) {
		u.Time = v.Time
	}
	if !(len(v.Envelopes) == 0) {
		u.Envelopes = v.Envelopes
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *BlockResults) MarshalJSON() ([]byte, error) {
	u := struct {
		MessageResults   encoding.JsonList[*protocol.TransactionStatus] `json:"messageResults,omitempty"`
		ValidatorUpdates encoding.JsonList[*ValidatorUpdate]            `json:"validatorUpdates,omitempty"`
		ExtraData        *string                                        `json:"$epilogue,omitempty"`
	}{}
	if !(len(v.MessageResults) == 0) {
		u.MessageResults = v.MessageResults
	}
	if !(len(v.ValidatorUpdates) == 0) {
		u.ValidatorUpdates = v.ValidatorUpdates
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *CommitResult) MarshalJSON() ([]byte, error) {
	u := struct {
		Hash      *string `json:"hash,omitempty"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	if !(v.Hash == ([32]byte{})) {
		u.Hash = encoding.ChainToJSON(&v.Hash)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *EnvelopeSubmitted) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      messageType                                    `json:"type"`
		Results   encoding.JsonList[*protocol.TransactionStatus] `json:"results,omitempty"`
		ExtraData *string                                        `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Results) == 0) {
		u.Results = v.Results
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ExecutedBlock) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      messageType `json:"type"`
		Network   string      `json:"network,omitempty"`
		Node      *string     `json:"node,omitempty"`
		ExtraData *string     `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Network) == 0) {
		u.Network = v.Network
	}
	if !(v.Node == ([32]byte{})) {
		u.Node = encoding.ChainToJSON(&v.Node)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *LeaderProposal) MarshalJSON() ([]byte, error) {
	u := struct {
		Leader    *string `json:"leader,omitempty"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	if !(v.Leader == ([32]byte{})) {
		u.Leader = encoding.ChainToJSON(&v.Leader)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *StartBlock) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      messageType `json:"type"`
		ExtraData *string     `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *SubmitEnvelope) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      messageType         `json:"type"`
		Network   string              `json:"network,omitempty"`
		Envelope  *messaging.Envelope `json:"envelope,omitempty"`
		Pretend   bool                `json:"pretend,omitempty"`
		ExtraData *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(len(v.Network) == 0) {
		u.Network = v.Network
	}
	if !(v.Envelope == nil) {
		u.Envelope = v.Envelope
	}
	if !(!v.Pretend) {
		u.Pretend = v.Pretend
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *ValidatorUpdate) MarshalJSON() ([]byte, error) {
	u := struct {
		Type      protocol.SignatureType `json:"type,omitempty"`
		PublicKey *string                `json:"publicKey,omitempty"`
		Power     int64                  `json:"power,omitempty"`
		ExtraData *string                `json:"$epilogue,omitempty"`
	}{}
	if !(v.Type == 0) {
		u.Type = v.Type
	}
	if !(len(v.PublicKey) == 0) {
		u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	}
	if !(v.Power == 0) {
		u.Power = v.Power
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *acceptBlockProposal) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       messageType  `json:"type"`
		PubKeyHash *string      `json:"pubKeyHash,omitempty"`
		Network    string       `json:"network,omitempty"`
		p          proposeBlock `json:"p,omitempty"`
		ExtraData  *string      `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.baseNodeMessage.PubKeyHash == ([32]byte{})) {
		u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	}
	if !(len(v.baseNodeMessage.Network) == 0) {
		u.Network = v.baseNodeMessage.Network
	}
	if !((v.p).Equal(new(proposeBlock))) {
		u.p = v.p
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *acceptedSubmission) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       messageType         `json:"type"`
		PubKeyHash *string             `json:"pubKeyHash,omitempty"`
		Network    string              `json:"network,omitempty"`
		result     EnvelopeSubmitted   `json:"result,omitempty"`
		env        *messaging.Envelope `json:"env,omitempty"`
		ExtraData  *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.baseNodeMessage.PubKeyHash == ([32]byte{})) {
		u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	}
	if !(len(v.baseNodeMessage.Network) == 0) {
		u.Network = v.baseNodeMessage.Network
	}
	if !((v.result).Equal(new(EnvelopeSubmitted))) {
		u.result = v.result
	}
	if !(v.env == nil) {
		u.env = v.env
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *baseNodeMessage) MarshalJSON() ([]byte, error) {
	u := struct {
		PubKeyHash *string `json:"pubKeyHash,omitempty"`
		Network    string  `json:"network,omitempty"`
		ExtraData  *string `json:"$epilogue,omitempty"`
	}{}
	if !(v.PubKeyHash == ([32]byte{})) {
		u.PubKeyHash = encoding.ChainToJSON(&v.PubKeyHash)
	}
	if !(len(v.Network) == 0) {
		u.Network = v.Network
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *committedBlock) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       messageType  `json:"type"`
		PubKeyHash *string      `json:"pubKeyHash,omitempty"`
		Network    string       `json:"network,omitempty"`
		results    CommitResult `json:"results,omitempty"`
		ExtraData  *string      `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.baseNodeMessage.PubKeyHash == ([32]byte{})) {
		u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	}
	if !(len(v.baseNodeMessage.Network) == 0) {
		u.Network = v.baseNodeMessage.Network
	}
	if !((v.results).Equal(new(CommitResult))) {
		u.results = v.results
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *finalizedBlock) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       messageType  `json:"type"`
		PubKeyHash *string      `json:"pubKeyHash,omitempty"`
		Network    string       `json:"network,omitempty"`
		results    BlockResults `json:"results,omitempty"`
		ExtraData  *string      `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.baseNodeMessage.PubKeyHash == ([32]byte{})) {
		u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	}
	if !(len(v.baseNodeMessage.Network) == 0) {
		u.Network = v.baseNodeMessage.Network
	}
	if !((v.results).Equal(new(BlockResults))) {
		u.results = v.results
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *proposeBlock) MarshalJSON() ([]byte, error) {
	u := struct {
		Type           messageType                            `json:"type"`
		PubKeyHash     *string                                `json:"pubKeyHash,omitempty"`
		Network        string                                 `json:"network,omitempty"`
		LeaderProposal LeaderProposal                         `json:"leaderProposal,omitempty"`
		Index          uint64                                 `json:"index,omitempty"`
		Time           time.Time                              `json:"time,omitempty"`
		Envelopes      encoding.JsonList[*messaging.Envelope] `json:"envelopes,omitempty"`
		ExtraData      *string                                `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.baseNodeMessage.PubKeyHash == ([32]byte{})) {
		u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	}
	if !(len(v.baseNodeMessage.Network) == 0) {
		u.Network = v.baseNodeMessage.Network
	}
	if !((v.BlockProposal.LeaderProposal).Equal(new(LeaderProposal))) {
		u.LeaderProposal = v.BlockProposal.LeaderProposal
	}
	if !(v.BlockProposal.Index == 0) {
		u.Index = v.BlockProposal.Index
	}
	if !(v.BlockProposal.Time == (time.Time{})) {
		u.Time = v.BlockProposal.Time
	}
	if !(len(v.BlockProposal.Envelopes) == 0) {
		u.Envelopes = v.BlockProposal.Envelopes
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *proposeLeader) MarshalJSON() ([]byte, error) {
	u := struct {
		Type       messageType `json:"type"`
		PubKeyHash *string     `json:"pubKeyHash,omitempty"`
		Network    string      `json:"network,omitempty"`
		Leader     *string     `json:"leader,omitempty"`
		ExtraData  *string     `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	if !(v.baseNodeMessage.PubKeyHash == ([32]byte{})) {
		u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	}
	if !(len(v.baseNodeMessage.Network) == 0) {
		u.Network = v.baseNodeMessage.Network
	}
	if !(v.LeaderProposal.Leader == ([32]byte{})) {
		u.Leader = encoding.ChainToJSON(&v.LeaderProposal.Leader)
	}
	u.ExtraData = encoding.BytesToJSON(v.extraData)
	return json.Marshal(&u)
}

func (v *BlockProposal) UnmarshalJSON(data []byte) error {
	u := struct {
		Leader    *string                                `json:"leader,omitempty"`
		Index     uint64                                 `json:"index,omitempty"`
		Time      time.Time                              `json:"time,omitempty"`
		Envelopes encoding.JsonList[*messaging.Envelope] `json:"envelopes,omitempty"`
		ExtraData *string                                `json:"$epilogue,omitempty"`
	}{}
	u.Leader = encoding.ChainToJSON(&v.LeaderProposal.Leader)
	u.Index = v.Index
	u.Time = v.Time
	u.Envelopes = v.Envelopes
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Leader); err != nil {
		return fmt.Errorf("error decoding Leader: %w", err)
	} else {
		v.LeaderProposal.Leader = *x
	}
	v.Index = u.Index
	v.Time = u.Time
	v.Envelopes = u.Envelopes
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *BlockResults) UnmarshalJSON(data []byte) error {
	u := struct {
		MessageResults   encoding.JsonList[*protocol.TransactionStatus] `json:"messageResults,omitempty"`
		ValidatorUpdates encoding.JsonList[*ValidatorUpdate]            `json:"validatorUpdates,omitempty"`
		ExtraData        *string                                        `json:"$epilogue,omitempty"`
	}{}
	u.MessageResults = v.MessageResults
	u.ValidatorUpdates = v.ValidatorUpdates
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.MessageResults = u.MessageResults
	v.ValidatorUpdates = u.ValidatorUpdates
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *CommitResult) UnmarshalJSON(data []byte) error {
	u := struct {
		Hash      *string `json:"hash,omitempty"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	u.Hash = encoding.ChainToJSON(&v.Hash)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Hash); err != nil {
		return fmt.Errorf("error decoding Hash: %w", err)
	} else {
		v.Hash = *x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *EnvelopeSubmitted) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      messageType                                    `json:"type"`
		Results   encoding.JsonList[*protocol.TransactionStatus] `json:"results,omitempty"`
		ExtraData *string                                        `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Results = v.Results
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Results = u.Results
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ExecutedBlock) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      messageType `json:"type"`
		Network   string      `json:"network,omitempty"`
		Node      *string     `json:"node,omitempty"`
		ExtraData *string     `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Network = v.Network
	u.Node = encoding.ChainToJSON(&v.Node)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Network = u.Network
	if x, err := encoding.ChainFromJSON(u.Node); err != nil {
		return fmt.Errorf("error decoding Node: %w", err)
	} else {
		v.Node = *x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *LeaderProposal) UnmarshalJSON(data []byte) error {
	u := struct {
		Leader    *string `json:"leader,omitempty"`
		ExtraData *string `json:"$epilogue,omitempty"`
	}{}
	u.Leader = encoding.ChainToJSON(&v.Leader)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.Leader); err != nil {
		return fmt.Errorf("error decoding Leader: %w", err)
	} else {
		v.Leader = *x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *StartBlock) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      messageType `json:"type"`
		ExtraData *string     `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *SubmitEnvelope) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      messageType         `json:"type"`
		Network   string              `json:"network,omitempty"`
		Envelope  *messaging.Envelope `json:"envelope,omitempty"`
		Pretend   bool                `json:"pretend,omitempty"`
		ExtraData *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.Network = v.Network
	u.Envelope = v.Envelope
	u.Pretend = v.Pretend
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	v.Network = u.Network
	v.Envelope = u.Envelope
	v.Pretend = u.Pretend
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *ValidatorUpdate) UnmarshalJSON(data []byte) error {
	u := struct {
		Type      protocol.SignatureType `json:"type,omitempty"`
		PublicKey *string                `json:"publicKey,omitempty"`
		Power     int64                  `json:"power,omitempty"`
		ExtraData *string                `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type
	u.PublicKey = encoding.BytesToJSON(v.PublicKey)
	u.Power = v.Power
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	v.Type = u.Type
	if x, err := encoding.BytesFromJSON(u.PublicKey); err != nil {
		return fmt.Errorf("error decoding PublicKey: %w", err)
	} else {
		v.PublicKey = x
	}
	v.Power = u.Power
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *acceptBlockProposal) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       messageType  `json:"type"`
		PubKeyHash *string      `json:"pubKeyHash,omitempty"`
		Network    string       `json:"network,omitempty"`
		p          proposeBlock `json:"p,omitempty"`
		ExtraData  *string      `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	u.Network = v.baseNodeMessage.Network
	u.p = v.p
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.PubKeyHash); err != nil {
		return fmt.Errorf("error decoding PubKeyHash: %w", err)
	} else {
		v.baseNodeMessage.PubKeyHash = *x
	}
	v.baseNodeMessage.Network = u.Network
	v.p = u.p
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *acceptedSubmission) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       messageType         `json:"type"`
		PubKeyHash *string             `json:"pubKeyHash,omitempty"`
		Network    string              `json:"network,omitempty"`
		result     EnvelopeSubmitted   `json:"result,omitempty"`
		env        *messaging.Envelope `json:"env,omitempty"`
		ExtraData  *string             `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	u.Network = v.baseNodeMessage.Network
	u.result = v.result
	u.env = v.env
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.PubKeyHash); err != nil {
		return fmt.Errorf("error decoding PubKeyHash: %w", err)
	} else {
		v.baseNodeMessage.PubKeyHash = *x
	}
	v.baseNodeMessage.Network = u.Network
	v.result = u.result
	v.env = u.env
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *baseNodeMessage) UnmarshalJSON(data []byte) error {
	u := struct {
		PubKeyHash *string `json:"pubKeyHash,omitempty"`
		Network    string  `json:"network,omitempty"`
		ExtraData  *string `json:"$epilogue,omitempty"`
	}{}
	u.PubKeyHash = encoding.ChainToJSON(&v.PubKeyHash)
	u.Network = v.Network
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if x, err := encoding.ChainFromJSON(u.PubKeyHash); err != nil {
		return fmt.Errorf("error decoding PubKeyHash: %w", err)
	} else {
		v.PubKeyHash = *x
	}
	v.Network = u.Network
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *committedBlock) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       messageType  `json:"type"`
		PubKeyHash *string      `json:"pubKeyHash,omitempty"`
		Network    string       `json:"network,omitempty"`
		results    CommitResult `json:"results,omitempty"`
		ExtraData  *string      `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	u.Network = v.baseNodeMessage.Network
	u.results = v.results
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.PubKeyHash); err != nil {
		return fmt.Errorf("error decoding PubKeyHash: %w", err)
	} else {
		v.baseNodeMessage.PubKeyHash = *x
	}
	v.baseNodeMessage.Network = u.Network
	v.results = u.results
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *finalizedBlock) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       messageType  `json:"type"`
		PubKeyHash *string      `json:"pubKeyHash,omitempty"`
		Network    string       `json:"network,omitempty"`
		results    BlockResults `json:"results,omitempty"`
		ExtraData  *string      `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	u.Network = v.baseNodeMessage.Network
	u.results = v.results
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.PubKeyHash); err != nil {
		return fmt.Errorf("error decoding PubKeyHash: %w", err)
	} else {
		v.baseNodeMessage.PubKeyHash = *x
	}
	v.baseNodeMessage.Network = u.Network
	v.results = u.results
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *proposeBlock) UnmarshalJSON(data []byte) error {
	u := struct {
		Type           messageType                            `json:"type"`
		PubKeyHash     *string                                `json:"pubKeyHash,omitempty"`
		Network        string                                 `json:"network,omitempty"`
		LeaderProposal LeaderProposal                         `json:"leaderProposal,omitempty"`
		Index          uint64                                 `json:"index,omitempty"`
		Time           time.Time                              `json:"time,omitempty"`
		Envelopes      encoding.JsonList[*messaging.Envelope] `json:"envelopes,omitempty"`
		ExtraData      *string                                `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	u.Network = v.baseNodeMessage.Network
	u.LeaderProposal = v.BlockProposal.LeaderProposal
	u.Index = v.BlockProposal.Index
	u.Time = v.BlockProposal.Time
	u.Envelopes = v.BlockProposal.Envelopes
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.PubKeyHash); err != nil {
		return fmt.Errorf("error decoding PubKeyHash: %w", err)
	} else {
		v.baseNodeMessage.PubKeyHash = *x
	}
	v.baseNodeMessage.Network = u.Network
	v.BlockProposal.LeaderProposal = u.LeaderProposal
	v.BlockProposal.Index = u.Index
	v.BlockProposal.Time = u.Time
	v.BlockProposal.Envelopes = u.Envelopes
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}

func (v *proposeLeader) UnmarshalJSON(data []byte) error {
	u := struct {
		Type       messageType `json:"type"`
		PubKeyHash *string     `json:"pubKeyHash,omitempty"`
		Network    string      `json:"network,omitempty"`
		Leader     *string     `json:"leader,omitempty"`
		ExtraData  *string     `json:"$epilogue,omitempty"`
	}{}
	u.Type = v.Type()
	u.PubKeyHash = encoding.ChainToJSON(&v.baseNodeMessage.PubKeyHash)
	u.Network = v.baseNodeMessage.Network
	u.Leader = encoding.ChainToJSON(&v.LeaderProposal.Leader)
	err := json.Unmarshal(data, &u)
	if err != nil {
		return err
	}
	if !(v.Type() == u.Type) {
		return fmt.Errorf("field Type: not equal: want %v, got %v", v.Type(), u.Type)
	}
	if x, err := encoding.ChainFromJSON(u.PubKeyHash); err != nil {
		return fmt.Errorf("error decoding PubKeyHash: %w", err)
	} else {
		v.baseNodeMessage.PubKeyHash = *x
	}
	v.baseNodeMessage.Network = u.Network
	if x, err := encoding.ChainFromJSON(u.Leader); err != nil {
		return fmt.Errorf("error decoding Leader: %w", err)
	} else {
		v.LeaderProposal.Leader = *x
	}
	v.extraData, err = encoding.BytesFromJSON(u.ExtraData)
	if err != nil {
		return err
	}
	return nil
}
